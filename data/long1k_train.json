{
  "32": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/StoneCech.lean",
    "full_name": "ultrafilter_extend_extends",
    "start": [
      197,
      1
    ],
    "end": [
      200,
      77
    ],
    "traced_tactics": [
      {
        "tactic": "letI : TopologicalSpace \u03b1 := \u22a5",
        "annotated_tactic": [
          "letI : <a>TopologicalSpace</a> \u03b1 := \u22a5",
          [
            {
              "full_name": "TopologicalSpace",
              "def_path": "Mathlib/Topology/Defs/Basic.lean",
              "def_pos": [
                63,
                7
              ],
              "def_end_pos": [
                63,
                23
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b3 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b3\ninst\u271d : T2Space \u03b3\nf : \u03b1 \u2192 \u03b3\n\u22a2 Ultrafilter.extend f \u2218 pure = f",
        "state_after": "\u03b1 : Type u\n\u03b3 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b3\ninst\u271d : T2Space \u03b3\nf : \u03b1 \u2192 \u03b3\nthis : TopologicalSpace \u03b1 := \u22a5\n\u22a2 Ultrafilter.extend f \u2218 pure = f"
      },
      {
        "tactic": "haveI : DiscreteTopology \u03b1 := \u27e8rfl\u27e9",
        "annotated_tactic": [
          "haveI : <a>DiscreteTopology</a> \u03b1 := \u27e8<a>rfl</a>\u27e9",
          [
            {
              "full_name": "DiscreteTopology",
              "def_path": "Mathlib/Topology/Order.lean",
              "def_pos": [
                268,
                7
              ],
              "def_end_pos": [
                268,
                23
              ]
            },
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b3 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b3\ninst\u271d : T2Space \u03b3\nf : \u03b1 \u2192 \u03b3\nthis : TopologicalSpace \u03b1 := \u22a5\n\u22a2 Ultrafilter.extend f \u2218 pure = f",
        "state_after": "\u03b1 : Type u\n\u03b3 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b3\ninst\u271d : T2Space \u03b3\nf : \u03b1 \u2192 \u03b3\nthis\u271d : TopologicalSpace \u03b1 := \u22a5\nthis : DiscreteTopology \u03b1\n\u22a2 Ultrafilter.extend f \u2218 pure = f"
      },
      {
        "tactic": "exact funext (denseInducing_pure.extend_eq continuous_of_discreteTopology)",
        "annotated_tactic": [
          "exact <a>funext</a> (denseInducing_pure.extend_eq <a>continuous_of_discreteTopology</a>)",
          [
            {
              "full_name": "funext",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1817,
                9
              ],
              "def_end_pos": [
                1817,
                15
              ]
            },
            {
              "full_name": "continuous_of_discreteTopology",
              "def_path": "Mathlib/Topology/Order.lean",
              "def_pos": [
                297,
                9
              ],
              "def_end_pos": [
                297,
                39
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b3 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b3\ninst\u271d : T2Space \u03b3\nf : \u03b1 \u2192 \u03b3\nthis\u271d : TopologicalSpace \u03b1 := \u22a5\nthis : DiscreteTopology \u03b1\n\u22a2 Ultrafilter.extend f \u2218 pure = f",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8439859460340813,
    "entry_failed": false
  },
  "212": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Finset/Card.lean",
    "full_name": "Finset.card_insert_eq_ite",
    "start": [
      144,
      1
    ],
    "end": [
      147,
      44
    ],
    "traced_tactics": [
      {
        "tactic": "by_cases h : a \u2208 s",
        "annotated_tactic": [
          "by_cases h : a \u2208 s",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t : Finset \u03b1\na b : \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 (insert a s).card = if a \u2208 s then s.card else s.card + 1",
        "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t : Finset \u03b1\na b : \u03b1\ninst\u271d : DecidableEq \u03b1\nh : a \u2208 s\n\u22a2 (insert a s).card = if a \u2208 s then s.card else s.card + 1\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t : Finset \u03b1\na b : \u03b1\ninst\u271d : DecidableEq \u03b1\nh : a \u2209 s\n\u22a2 (insert a s).card = if a \u2208 s then s.card else s.card + 1"
      },
      {
        "tactic": "rw [card_insert_of_mem h, if_pos h]",
        "annotated_tactic": [
          "rw [<a>card_insert_of_mem</a> h, <a>if_pos</a> h]",
          [
            {
              "full_name": "Finset.card_insert_of_mem",
              "def_path": "Mathlib/Data/Finset/Card.lean",
              "def_pos": [
                112,
                9
              ],
              "def_end_pos": [
                112,
                27
              ]
            },
            {
              "full_name": "if_pos",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                932,
                9
              ],
              "def_end_pos": [
                932,
                15
              ]
            }
          ]
        ],
        "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t : Finset \u03b1\na b : \u03b1\ninst\u271d : DecidableEq \u03b1\nh : a \u2208 s\n\u22a2 (insert a s).card = if a \u2208 s then s.card else s.card + 1",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [card_insert_of_not_mem h, if_neg h]",
        "annotated_tactic": [
          "rw [<a>card_insert_of_not_mem</a> h, <a>if_neg</a> h]",
          [
            {
              "full_name": "Finset.card_insert_of_not_mem",
              "def_path": "Mathlib/Data/Finset/Card.lean",
              "def_pos": [
                108,
                9
              ],
              "def_end_pos": [
                108,
                31
              ]
            },
            {
              "full_name": "if_neg",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                937,
                9
              ],
              "def_end_pos": [
                937,
                15
              ]
            }
          ]
        ],
        "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t : Finset \u03b1\na b : \u03b1\ninst\u271d : DecidableEq \u03b1\nh : a \u2209 s\n\u22a2 (insert a s).card = if a \u2208 s then s.card else s.card + 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.555636952049099,
    "entry_failed": false
  },
  "236": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Perm/Cycle/Factors.lean",
    "full_name": "Equiv.Perm.cycleFactorsFinset_injective",
    "start": [
      575,
      1
    ],
    "end": [
      578,
      51
    ],
    "traced_tactics": [
      {
        "tactic": "intro f g h",
        "annotated_tactic": [
          "intro f g h",
          []
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\n\u22a2 Injective cycleFactorsFinset",
        "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d f g : Perm \u03b1\nh : f.cycleFactorsFinset = g.cycleFactorsFinset\n\u22a2 f = g"
      },
      {
        "tactic": "rw [\u2190 cycleFactorsFinset_noncommProd f]",
        "annotated_tactic": [
          "rw [\u2190 <a>cycleFactorsFinset_noncommProd</a> f]",
          [
            {
              "full_name": "Equiv.Perm.cycleFactorsFinset_noncommProd",
              "def_path": "Mathlib/GroupTheory/Perm/Cycle/Factors.lean",
              "def_pos": [
                504,
                9
              ],
              "def_end_pos": [
                504,
                39
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d f g : Perm \u03b1\nh : f.cycleFactorsFinset = g.cycleFactorsFinset\n\u22a2 f = g",
        "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d f g : Perm \u03b1\nh : f.cycleFactorsFinset = g.cycleFactorsFinset\n\u22a2 f.cycleFactorsFinset.noncommProd id \u22ef = g"
      },
      {
        "tactic": "simpa [h] using cycleFactorsFinset_noncommProd g",
        "annotated_tactic": [
          "simpa [h] using <a>cycleFactorsFinset_noncommProd</a> g",
          [
            {
              "full_name": "Equiv.Perm.cycleFactorsFinset_noncommProd",
              "def_path": "Mathlib/GroupTheory/Perm/Cycle/Factors.lean",
              "def_pos": [
                504,
                9
              ],
              "def_end_pos": [
                504,
                39
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d f g : Perm \u03b1\nh : f.cycleFactorsFinset = g.cycleFactorsFinset\n\u22a2 f.cycleFactorsFinset.noncommProd id \u22ef = g",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.705683167907409,
    "entry_failed": false
  },
  "308": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Factorial/Basic.lean",
    "full_name": "Nat.factorial_dvd_factorial",
    "start": [
      73,
      1
    ],
    "end": [
      76,
      50
    ],
    "traced_tactics": [
      {
        "tactic": "induction' h with n _ ih",
        "annotated_tactic": [
          "induction' h with n _ ih",
          []
        ],
        "state_before": "m\u271d n\u271d m n : \u2115\nh : m \u2264 n\n\u22a2 m ! \u2223 n !",
        "state_after": "case refl\nm\u271d n\u271d m n : \u2115\n\u22a2 m ! \u2223 m !\n\ncase step\nm\u271d n\u271d\u00b9 m n\u271d n : \u2115\na\u271d : m.le n\nih : m ! \u2223 n !\n\u22a2 m ! \u2223 n.succ !"
      },
      {
        "tactic": "exact Nat.dvd_refl _",
        "annotated_tactic": [
          "exact <a>Nat.dvd_refl</a> _",
          [
            {
              "full_name": "Nat.dvd_refl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Dvd.lean",
              "def_pos": [
                12,
                19
              ],
              "def_end_pos": [
                12,
                27
              ]
            }
          ]
        ],
        "state_before": "case refl\nm\u271d n\u271d m n : \u2115\n\u22a2 m ! \u2223 m !",
        "state_after": "no goals"
      },
      {
        "tactic": "exact Nat.dvd_trans ih (Nat.dvd_mul_left _ _)",
        "annotated_tactic": [
          "exact <a>Nat.dvd_trans</a> ih (<a>Nat.dvd_mul_left</a> _ _)",
          [
            {
              "full_name": "Nat.dvd_trans",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Dvd.lean",
              "def_pos": [
                19,
                19
              ],
              "def_end_pos": [
                19,
                28
              ]
            },
            {
              "full_name": "Nat.dvd_mul_left",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Dvd.lean",
              "def_pos": [
                16,
                19
              ],
              "def_end_pos": [
                16,
                31
              ]
            }
          ]
        ],
        "state_before": "case step\nm\u271d n\u271d\u00b9 m n\u271d n : \u2115\na\u271d : m.le n\nih : m ! \u2223 n !\n\u22a2 m ! \u2223 n.succ !",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.3445887819398195,
    "entry_failed": false
  },
  "367": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Exponent.lean",
    "full_name": "Monoid.exponent_min",
    "start": [
      183,
      1
    ],
    "end": [
      186,
      8
    ],
    "traced_tactics": [
      {
        "tactic": "by_contra! h",
        "annotated_tactic": [
          "by_contra! h",
          []
        ],
        "state_before": "G : Type u\ninst\u271d : Monoid G\nm : \u2115\nhpos : 0 < m\nhm : m < exponent G\n\u22a2 \u2203 g, g ^ m \u2260 1",
        "state_after": "G : Type u\ninst\u271d : Monoid G\nm : \u2115\nhpos : 0 < m\nhm : m < exponent G\nh : \u2200 (g : G), g ^ m = 1\n\u22a2 False"
      },
      {
        "tactic": "have hcon : exponent G \u2264 m := exponent_min' m hpos h",
        "annotated_tactic": [
          "have hcon : <a>exponent</a> G \u2264 m := <a>exponent_min'</a> m hpos h",
          [
            {
              "full_name": "Monoid.exponent",
              "def_path": "Mathlib/GroupTheory/Exponent.lean",
              "def_pos": [
                75,
                19
              ],
              "def_end_pos": [
                75,
                27
              ]
            },
            {
              "full_name": "Monoid.exponent_min'",
              "def_path": "Mathlib/GroupTheory/Exponent.lean",
              "def_pos": [
                174,
                9
              ],
              "def_end_pos": [
                174,
                22
              ]
            }
          ]
        ],
        "state_before": "G : Type u\ninst\u271d : Monoid G\nm : \u2115\nhpos : 0 < m\nhm : m < exponent G\nh : \u2200 (g : G), g ^ m = 1\n\u22a2 False",
        "state_after": "G : Type u\ninst\u271d : Monoid G\nm : \u2115\nhpos : 0 < m\nhm : m < exponent G\nh : \u2200 (g : G), g ^ m = 1\nhcon : exponent G \u2264 m\n\u22a2 False"
      },
      {
        "tactic": "omega",
        "annotated_tactic": [
          "omega",
          []
        ],
        "state_before": "G : Type u\ninst\u271d : Monoid G\nm : \u2115\nhpos : 0 < m\nhm : m < exponent G\nh : \u2200 (g : G), g ^ m = 1\nhcon : exponent G \u2264 m\n\u22a2 False",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.4242825229885057,
    "entry_failed": false
  },
  "401": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/GradedObject.lean",
    "full_name": "CategoryTheory.GradedObject.eqToHom_apply",
    "start": [
      189,
      1
    ],
    "end": [
      192,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "rw [h]",
        "annotated_tactic": [
          "rw [h]",
          []
        ],
        "state_before": "C : Type u\ninst\u271d : Category.{v, u} C\n\u03b2 : Type w\nX Y : \u03b2 \u2192 C\nh : X = Y\nb : \u03b2\n\u22a2 X b = Y b",
        "state_after": "no goals"
      },
      {
        "tactic": "subst h",
        "annotated_tactic": [
          "subst h",
          []
        ],
        "state_before": "C : Type u\ninst\u271d : Category.{v, u} C\n\u03b2 : Type w\nX Y : \u03b2 \u2192 C\nh : X = Y\nb : \u03b2\n\u22a2 eqToHom h b = eqToHom \u22ef",
        "state_after": "C : Type u\ninst\u271d : Category.{v, u} C\n\u03b2 : Type w\nX : \u03b2 \u2192 C\nb : \u03b2\n\u22a2 eqToHom \u22ef b = eqToHom \u22ef"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "C : Type u\ninst\u271d : Category.{v, u} C\n\u03b2 : Type w\nX : \u03b2 \u2192 C\nb : \u03b2\n\u22a2 eqToHom \u22ef b = eqToHom \u22ef",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.776674264925532,
    "entry_failed": false
  },
  "442": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Instances/EReal.lean",
    "full_name": "EReal.tendsto_toReal",
    "start": [
      86,
      1
    ],
    "end": [
      90,
      19
    ],
    "traced_tactics": [
      {
        "tactic": "lift a to \u211d using \u27e8ha, h'a\u27e9",
        "annotated_tactic": [
          "lift a to \u211d using \u27e8ha, h'a\u27e9",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : EReal\nha : a \u2260 \u22a4\nh'a : a \u2260 \u22a5\n\u22a2 Tendsto toReal (\ud835\udcdd a) (\ud835\udcdd a.toReal)",
        "state_after": "case intro\n\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u211d\nha : \u2191a \u2260 \u22a4\nh'a : \u2191a \u2260 \u22a5\n\u22a2 Tendsto toReal (\ud835\udcdd \u2191a) (\ud835\udcdd (\u2191a).toReal)"
      },
      {
        "tactic": "rw [nhds_coe, tendsto_map'_iff]",
        "annotated_tactic": [
          "rw [<a>nhds_coe</a>, <a>tendsto_map'_iff</a>]",
          [
            {
              "full_name": "EReal.nhds_coe",
              "def_path": "Mathlib/Topology/Instances/EReal.lean",
              "def_pos": [
                77,
                9
              ],
              "def_end_pos": [
                77,
                17
              ]
            },
            {
              "full_name": "Filter.tendsto_map'_iff",
              "def_path": "Mathlib/Order/Filter/Basic.lean",
              "def_pos": [
                3127,
                9
              ],
              "def_end_pos": [
                3127,
                25
              ]
            }
          ]
        ],
        "state_before": "case intro\n\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u211d\nha : \u2191a \u2260 \u22a4\nh'a : \u2191a \u2260 \u22a5\n\u22a2 Tendsto toReal (\ud835\udcdd \u2191a) (\ud835\udcdd (\u2191a).toReal)",
        "state_after": "case intro\n\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u211d\nha : \u2191a \u2260 \u22a4\nh'a : \u2191a \u2260 \u22a5\n\u22a2 Tendsto (toReal \u2218 Real.toEReal) (\ud835\udcdd a) (\ud835\udcdd (\u2191a).toReal)"
      },
      {
        "tactic": "exact tendsto_id",
        "annotated_tactic": [
          "exact <a>tendsto_id</a>",
          [
            {
              "full_name": "Filter.tendsto_id",
              "def_path": "Mathlib/Order/Filter/Basic.lean",
              "def_pos": [
                3094,
                9
              ],
              "def_end_pos": [
                3094,
                19
              ]
            }
          ]
        ],
        "state_before": "case intro\n\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u211d\nha : \u2191a \u2260 \u22a4\nh'a : \u2191a \u2260 \u22a5\n\u22a2 Tendsto (toReal \u2218 Real.toEReal) (\ud835\udcdd a) (\ud835\udcdd (\u2191a).toReal)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7763066519983113,
    "entry_failed": false
  },
  "448": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/SuccPred/CompleteLinearOrder.lean",
    "full_name": "csSup_mem_of_not_isSuccLimit'",
    "start": [
      67,
      1
    ],
    "end": [
      73,
      52
    ],
    "traced_tactics": [
      {
        "tactic": "obtain (rfl|hs) := s.eq_empty_or_nonempty",
        "annotated_tactic": [
          "obtain (rfl|hs) := s.eq_empty_or_nonempty",
          []
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d : ConditionallyCompleteLinearOrderBot \u03b1\nf : \u03b9 \u2192 \u03b1\ns : Set \u03b1\nx : \u03b1\nhbdd : BddAbove s\nhlim : \u00acIsSuccLimit (sSup s)\n\u22a2 sSup s \u2208 s",
        "state_after": "case inl\n\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d : ConditionallyCompleteLinearOrderBot \u03b1\nf : \u03b9 \u2192 \u03b1\nx : \u03b1\nhbdd : BddAbove \u2205\nhlim : \u00acIsSuccLimit (sSup \u2205)\n\u22a2 sSup \u2205 \u2208 \u2205\n\ncase inr\n\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d : ConditionallyCompleteLinearOrderBot \u03b1\nf : \u03b9 \u2192 \u03b1\ns : Set \u03b1\nx : \u03b1\nhbdd : BddAbove s\nhlim : \u00acIsSuccLimit (sSup s)\nhs : s.Nonempty\n\u22a2 sSup s \u2208 s"
      },
      {
        "tactic": "simp [isSuccLimit_bot] at hlim",
        "annotated_tactic": [
          "simp [<a>isSuccLimit_bot</a>] at hlim",
          [
            {
              "full_name": "Order.isSuccLimit_bot",
              "def_path": "Mathlib/Order/SuccPred/Limit.lean",
              "def_pos": [
                64,
                9
              ],
              "def_end_pos": [
                64,
                24
              ]
            }
          ]
        ],
        "state_before": "case inl\n\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d : ConditionallyCompleteLinearOrderBot \u03b1\nf : \u03b9 \u2192 \u03b1\nx : \u03b1\nhbdd : BddAbove \u2205\nhlim : \u00acIsSuccLimit (sSup \u2205)\n\u22a2 sSup \u2205 \u2208 \u2205",
        "state_after": "no goals"
      },
      {
        "tactic": "exact csSup_mem_of_not_isSuccLimit hs hbdd hlim",
        "annotated_tactic": [
          "exact <a>csSup_mem_of_not_isSuccLimit</a> hs hbdd hlim",
          [
            {
              "full_name": "csSup_mem_of_not_isSuccLimit",
              "def_path": "Mathlib/Order/SuccPred/CompleteLinearOrder.lean",
              "def_pos": [
                22,
                7
              ],
              "def_end_pos": [
                22,
                35
              ]
            }
          ]
        ],
        "state_before": "case inr\n\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d : ConditionallyCompleteLinearOrderBot \u03b1\nf : \u03b9 \u2192 \u03b1\ns : Set \u03b1\nx : \u03b1\nhbdd : BddAbove s\nhlim : \u00acIsSuccLimit (sSup s)\nhs : s.Nonempty\n\u22a2 sSup s \u2208 s",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.191722877905704,
    "entry_failed": false
  },
  "477": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Bits.lean",
    "full_name": "Nat.bit_val",
    "start": [
      151,
      1
    ],
    "end": [
      154,
      19
    ],
    "traced_tactics": [
      {
        "tactic": "cases b",
        "annotated_tactic": [
          "cases b",
          []
        ],
        "state_before": "m n\u271d : \u2115\nb : Bool\nn : \u2115\n\u22a2 bit b n = 2 * n + bif b then 1 else 0",
        "state_after": "case false\nm n\u271d n : \u2115\n\u22a2 bit false n = 2 * n + bif false then 1 else 0\n\ncase true\nm n\u271d n : \u2115\n\u22a2 bit true n = 2 * n + bif true then 1 else 0"
      },
      {
        "tactic": "apply bit0_val",
        "annotated_tactic": [
          "apply <a>bit0_val</a>",
          [
            {
              "full_name": "Nat.bit0_val",
              "def_path": "Mathlib/Data/Nat/Bits.lean",
              "def_pos": [
                141,
                7
              ],
              "def_end_pos": [
                141,
                15
              ]
            }
          ]
        ],
        "state_before": "case false\nm n\u271d n : \u2115\n\u22a2 bit false n = 2 * n + bif false then 1 else 0",
        "state_after": "no goals"
      },
      {
        "tactic": "apply bit1_val",
        "annotated_tactic": [
          "apply <a>bit1_val</a>",
          [
            {
              "full_name": "Nat.bit1_val",
              "def_path": "Mathlib/Data/Nat/Bits.lean",
              "def_pos": [
                148,
                7
              ],
              "def_end_pos": [
                148,
                15
              ]
            }
          ]
        ],
        "state_before": "case true\nm n\u271d n : \u2115\n\u22a2 bit true n = 2 * n + bif true then 1 else 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6776088019832969,
    "entry_failed": false
  },
  "551": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Finset/Grade.lean",
    "full_name": "CovBy.card_multiset",
    "start": [
      40,
      1
    ],
    "end": [
      41,
      80
    ],
    "traced_tactics": [
      {
        "tactic": "obtain \u27e8a, rfl\u27e9 := h.exists_multiset_cons",
        "annotated_tactic": [
          "obtain \u27e8a, rfl\u27e9 := h.exists_multiset_cons",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ns t : Multiset \u03b1\na : \u03b1\nh : s \u22d6 t\n\u22a2 card s \u22d6 card t",
        "state_after": "case intro\n\u03b1 : Type u_1\ns : Multiset \u03b1\na\u271d a : \u03b1\nh : s \u22d6 a ::\u2098 s\n\u22a2 card s \u22d6 card (a ::\u2098 s)"
      },
      {
        "tactic": "rw [card_cons]",
        "annotated_tactic": [
          "rw [<a>card_cons</a>]",
          [
            {
              "full_name": "Multiset.card_cons",
              "def_path": "Mathlib/Data/Multiset/Basic.lean",
              "def_pos": [
                788,
                9
              ],
              "def_end_pos": [
                788,
                18
              ]
            }
          ]
        ],
        "state_before": "case intro\n\u03b1 : Type u_1\ns : Multiset \u03b1\na\u271d a : \u03b1\nh : s \u22d6 a ::\u2098 s\n\u22a2 card s \u22d6 card (a ::\u2098 s)",
        "state_after": "case intro\n\u03b1 : Type u_1\ns : Multiset \u03b1\na\u271d a : \u03b1\nh : s \u22d6 a ::\u2098 s\n\u22a2 card s \u22d6 card s + 1"
      },
      {
        "tactic": "exact covBy_succ _",
        "annotated_tactic": [
          "exact <a>covBy_succ</a> _",
          [
            {
              "full_name": "Order.covBy_succ",
              "def_path": "Mathlib/Order/SuccPred/Basic.lean",
              "def_pos": [
                381,
                9
              ],
              "def_end_pos": [
                381,
                19
              ]
            }
          ]
        ],
        "state_before": "case intro\n\u03b1 : Type u_1\ns : Multiset \u03b1\na\u271d a : \u03b1\nh : s \u22d6 a ::\u2098 s\n\u22a2 card s \u22d6 card s + 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2676940360106528,
    "entry_failed": false
  },
  "610": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Polynomial/Quotient.lean",
    "full_name": "Ideal.quotient_map_C_eq_zero",
    "start": [
      87,
      1
    ],
    "end": [
      91,
      28
    ],
    "traced_tactics": [
      {
        "tactic": "intro a ha",
        "annotated_tactic": [
          "intro a ha",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d : CommRing R\nI : Ideal R\n\u22a2 \u2200 a \u2208 I, ((Quotient.mk (map C I)).comp C) a = 0",
        "state_after": "R : Type u_1\ninst\u271d : CommRing R\nI : Ideal R\na : R\nha : a \u2208 I\n\u22a2 ((Quotient.mk (map C I)).comp C) a = 0"
      },
      {
        "tactic": "rw [RingHom.comp_apply, Quotient.eq_zero_iff_mem]",
        "annotated_tactic": [
          "rw [<a>RingHom.comp_apply</a>, <a>Quotient.eq_zero_iff_mem</a>]",
          [
            {
              "full_name": "RingHom.comp_apply",
              "def_path": "Mathlib/Algebra/Ring/Hom/Defs.lean",
              "def_pos": [
                670,
                9
              ],
              "def_end_pos": [
                670,
                19
              ]
            },
            {
              "full_name": "Ideal.Quotient.eq_zero_iff_mem",
              "def_path": "Mathlib/RingTheory/Ideal/Quotient.lean",
              "def_pos": [
                125,
                9
              ],
              "def_end_pos": [
                125,
                24
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d : CommRing R\nI : Ideal R\na : R\nha : a \u2208 I\n\u22a2 ((Quotient.mk (map C I)).comp C) a = 0",
        "state_after": "R : Type u_1\ninst\u271d : CommRing R\nI : Ideal R\na : R\nha : a \u2208 I\n\u22a2 C a \u2208 map C I"
      },
      {
        "tactic": "exact mem_map_of_mem _ ha",
        "annotated_tactic": [
          "exact <a>mem_map_of_mem</a> _ ha",
          [
            {
              "full_name": "Ideal.mem_map_of_mem",
              "def_path": "Mathlib/RingTheory/Ideal/Maps.lean",
              "def_pos": [
                61,
                9
              ],
              "def_end_pos": [
                61,
                23
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d : CommRing R\nI : Ideal R\na : R\nha : a \u2208 I\n\u22a2 C a \u2208 map C I",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.748000207939185,
    "entry_failed": false
  },
  "615": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Infix.lean",
    "full_name": "List.suffix_insert",
    "start": [
      524,
      1
    ],
    "end": [
      527,
      57
    ],
    "traced_tactics": [
      {
        "tactic": "by_cases h : a \u2208 l",
        "annotated_tactic": [
          "by_cases h : a \u2208 l",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 l\u2083 : List \u03b1\na\u271d b : \u03b1\nm n : \u2115\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List \u03b1\n\u22a2 l <:+ List.insert a l",
        "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 l\u2083 : List \u03b1\na\u271d b : \u03b1\nm n : \u2115\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List \u03b1\nh : a \u2208 l\n\u22a2 l <:+ List.insert a l\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 l\u2083 : List \u03b1\na\u271d b : \u03b1\nm n : \u2115\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List \u03b1\nh : \u00aca \u2208 l\n\u22a2 l <:+ List.insert a l"
      },
      {
        "tactic": "simp only [insert_of_mem h, insert, suffix_refl]",
        "annotated_tactic": [
          "simp only [<a>insert_of_mem</a> h, <a>insert</a>, <a>suffix_refl</a>]",
          [
            {
              "full_name": "List.insert_of_mem",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean",
              "def_pos": [
                1926,
                17
              ],
              "def_end_pos": [
                1926,
                30
              ]
            },
            {
              "full_name": "Insert.insert",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                458,
                3
              ],
              "def_end_pos": [
                458,
                9
              ]
            },
            {
              "full_name": "List.suffix_refl",
              "def_path": ".lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
              "def_pos": [
                1075,
                9
              ],
              "def_end_pos": [
                1075,
                20
              ]
            }
          ]
        ],
        "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 l\u2083 : List \u03b1\na\u271d b : \u03b1\nm n : \u2115\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List \u03b1\nh : a \u2208 l\n\u22a2 l <:+ List.insert a l",
        "state_after": "no goals"
      },
      {
        "tactic": "simp only [insert_of_not_mem h, suffix_cons, insert]",
        "annotated_tactic": [
          "simp only [<a>insert_of_not_mem</a> h, <a>suffix_cons</a>, <a>insert</a>]",
          [
            {
              "full_name": "List.insert_of_not_mem",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean",
              "def_pos": [
                1929,
                17
              ],
              "def_end_pos": [
                1929,
                34
              ]
            },
            {
              "full_name": "List.suffix_cons",
              "def_path": ".lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
              "def_pos": [
                1079,
                17
              ],
              "def_end_pos": [
                1079,
                28
              ]
            },
            {
              "full_name": "Insert.insert",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                458,
                3
              ],
              "def_end_pos": [
                458,
                9
              ]
            }
          ]
        ],
        "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 l\u2083 : List \u03b1\na\u271d b : \u03b1\nm n : \u2115\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List \u03b1\nh : \u00aca \u2208 l\n\u22a2 l <:+ List.insert a l",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.6584519690368325,
    "entry_failed": false
  },
  "641": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean",
    "full_name": "Real.log_nonpos_iff'",
    "start": [
      210,
      1
    ],
    "end": [
      213,
      26
    ],
    "traced_tactics": [
      {
        "tactic": "rcases hx.eq_or_lt with (rfl | hx)",
        "annotated_tactic": [
          "rcases hx.eq_or_lt with (rfl | hx)",
          []
        ],
        "state_before": "x y : \u211d\nhx : 0 \u2264 x\n\u22a2 log x \u2264 0 \u2194 x \u2264 1",
        "state_after": "case inl\ny : \u211d\nhx : 0 \u2264 0\n\u22a2 log 0 \u2264 0 \u2194 0 \u2264 1\n\ncase inr\nx y : \u211d\nhx\u271d : 0 \u2264 x\nhx : 0 < x\n\u22a2 log x \u2264 0 \u2194 x \u2264 1"
      },
      {
        "tactic": "exact log_nonpos_iff hx",
        "annotated_tactic": [
          "exact <a>log_nonpos_iff</a> hx",
          [
            {
              "full_name": "Real.log_nonpos_iff",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean",
              "def_pos": [
                207,
                9
              ],
              "def_end_pos": [
                207,
                23
              ]
            }
          ]
        ],
        "state_before": "case inr\nx y : \u211d\nhx\u271d : 0 \u2264 x\nhx : 0 < x\n\u22a2 log x \u2264 0 \u2194 x \u2264 1",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [le_refl, zero_le_one]",
        "annotated_tactic": [
          "simp [<a>le_refl</a>, <a>zero_le_one</a>]",
          [
            {
              "full_name": "le_refl",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                45,
                9
              ],
              "def_end_pos": [
                45,
                16
              ]
            },
            {
              "full_name": "zero_le_one",
              "def_path": "Mathlib/Algebra/Order/ZeroLEOne.lean",
              "def_pos": [
                26,
                15
              ],
              "def_end_pos": [
                26,
                26
              ]
            }
          ]
        ],
        "state_before": "case inl\ny : \u211d\nhx : 0 \u2264 0\n\u22a2 log 0 \u2264 0 \u2194 0 \u2264 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.931302002980374,
    "entry_failed": false
  },
  "747": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Rel.lean",
    "full_name": "Rel.comp_left_id",
    "start": [
      119,
      1
    ],
    "end": [
      122,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "unfold comp",
        "annotated_tactic": [
          "unfold <a>comp</a>",
          [
            {
              "full_name": "Rel.comp",
              "def_path": "Mathlib/Data/Rel.lean",
              "def_pos": [
                97,
                5
              ],
              "def_end_pos": [
                97,
                9
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr\u271d r : Rel \u03b1 \u03b2\n\u22a2 Eq \u2022 r = r",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr\u271d r : Rel \u03b1 \u03b2\n\u22a2 (fun x z => \u2203 y, x = y \u2227 r y z) = r"
      },
      {
        "tactic": "ext x",
        "annotated_tactic": [
          "ext x",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr\u271d r : Rel \u03b1 \u03b2\n\u22a2 (fun x z => \u2203 y, x = y \u2227 r y z) = r",
        "state_after": "case a.h.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr\u271d r : Rel \u03b1 \u03b2\nx : \u03b1\nx\u271d : \u03b2\n\u22a2 (\u2203 y, x = y \u2227 r y x\u271d) \u2194 r x x\u271d"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case a.h.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr\u271d r : Rel \u03b1 \u03b2\nx : \u03b1\nx\u271d : \u03b2\n\u22a2 (\u2203 y, x = y \u2227 r y x\u271d) \u2194 r x x\u271d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.489458276075311,
    "entry_failed": false
  },
  "808": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Permutation.lean",
    "full_name": "List.mem_permutationsAux2'",
    "start": [
      167,
      1
    ],
    "end": [
      170,
      82
    ],
    "traced_tactics": [
      {
        "tactic": "apply mem_permutationsAux2",
        "annotated_tactic": [
          "apply <a>mem_permutationsAux2</a>",
          [
            {
              "full_name": "List.mem_permutationsAux2",
              "def_path": "Mathlib/Data/List/Permutation.lean",
              "def_pos": [
                149,
                9
              ],
              "def_end_pos": [
                149,
                29
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u03b1\nts ys l : List \u03b1\n\u22a2 l \u2208 (permutationsAux2 t ts [] ys fun x => [] ++ x).2 \u2194 \u2203 l\u2081 l\u2082, l\u2082 \u2260 [] \u2227 ys = l\u2081 ++ l\u2082 \u2227 l = l\u2081 ++ t :: l\u2082 ++ ts",
        "state_after": "no goals"
      },
      {
        "tactic": "funext _",
        "annotated_tactic": [
          "funext _",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u03b1\nts ys l : List \u03b1\n\u22a2 id = fun x => [] ++ x",
        "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u03b1\nts ys l x\u271d : List \u03b1\n\u22a2 id x\u271d = [] ++ x\u271d"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u03b1\nts ys l x\u271d : List \u03b1\n\u22a2 id x\u271d = [] ++ x\u271d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6647428680444136,
    "entry_failed": false
  },
  "820": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Tropical/BigOperators.lean",
    "full_name": "Finset.trop_inf",
    "start": [
      92,
      1
    ],
    "end": [
      96,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "convert Multiset.trop_inf (s.val.map f)",
        "annotated_tactic": [
          "convert <a>Multiset.trop_inf</a> (s.val.map f)",
          [
            {
              "full_name": "Multiset.trop_inf",
              "def_path": "Mathlib/Algebra/Tropical/BigOperators.lean",
              "def_pos": [
                85,
                9
              ],
              "def_end_pos": [
                85,
                26
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : Finset S\nf : S \u2192 R\n\u22a2 trop (s.inf f) = \u2211 i \u2208 s, trop (f i)",
        "state_after": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : Finset S\nf : S \u2192 R\n\u22a2 \u2211 i \u2208 s, trop (f i) = (Multiset.map trop (Multiset.map f s.val)).sum"
      },
      {
        "tactic": "simp only [Multiset.map_map, Function.comp_apply]",
        "annotated_tactic": [
          "simp only [<a>Multiset.map_map</a>, <a>Function.comp_apply</a>]",
          [
            {
              "full_name": "Multiset.map_map",
              "def_path": "Mathlib/Data/Multiset/Basic.lean",
              "def_pos": [
                1332,
                9
              ],
              "def_end_pos": [
                1332,
                16
              ]
            },
            {
              "full_name": "Function.comp_apply",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                35,
                17
              ],
              "def_end_pos": [
                35,
                36
              ]
            }
          ]
        ],
        "state_before": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : Finset S\nf : S \u2192 R\n\u22a2 \u2211 i \u2208 s, trop (f i) = (Multiset.map trop (Multiset.map f s.val)).sum",
        "state_after": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : Finset S\nf : S \u2192 R\n\u22a2 \u2211 i \u2208 s, trop (f i) = (Multiset.map (fun i => trop (f i)) s.val).sum"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : Finset S\nf : S \u2192 R\n\u22a2 \u2211 i \u2208 s, trop (f i) = (Multiset.map (fun i => trop (f i)) s.val).sum",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.064940336975269,
    "entry_failed": false
  },
  "921": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/AlgebraicGeometry/Morphisms/QuasiSeparated.lean",
    "full_name": "AlgebraicGeometry.quasi_compact_affineProperty_diagonal_eq",
    "start": [
      122,
      1
    ],
    "end": [
      124,
      73
    ],
    "traced_tactics": [
      {
        "tactic": "funext",
        "annotated_tactic": [
          "funext",
          []
        ],
        "state_before": "X Y : Scheme\nf : X \u27f6 Y\n\u22a2 QuasiCompact.affineProperty.diagonal = QuasiSeparated.affineProperty",
        "state_after": "case h.h.h.h\nX Y : Scheme\nf : X \u27f6 Y\nx\u271d\u00b3 x\u271d\u00b2 : Scheme\nx\u271d\u00b9 : x\u271d\u00b3 \u27f6 x\u271d\u00b2\nx\u271d : IsAffine x\u271d\u00b2\n\u22a2 QuasiCompact.affineProperty.diagonal x\u271d\u00b9 = QuasiSeparated.affineProperty x\u271d\u00b9"
      },
      {
        "tactic": "rw [quasi_compact_affineProperty_iff_quasiSeparatedSpace]",
        "annotated_tactic": [
          "rw [<a>quasi_compact_affineProperty_iff_quasiSeparatedSpace</a>]",
          [
            {
              "full_name": "AlgebraicGeometry.quasi_compact_affineProperty_iff_quasiSeparatedSpace",
              "def_path": "Mathlib/AlgebraicGeometry/Morphisms/QuasiSeparated.lean",
              "def_pos": [
                87,
                9
              ],
              "def_end_pos": [
                87,
                61
              ]
            }
          ]
        ],
        "state_before": "case h.h.h.h\nX Y : Scheme\nf : X \u27f6 Y\nx\u271d\u00b3 x\u271d\u00b2 : Scheme\nx\u271d\u00b9 : x\u271d\u00b3 \u27f6 x\u271d\u00b2\nx\u271d : IsAffine x\u271d\u00b2\n\u22a2 QuasiCompact.affineProperty.diagonal x\u271d\u00b9 = QuasiSeparated.affineProperty x\u271d\u00b9",
        "state_after": "case h.h.h.h\nX Y : Scheme\nf : X \u27f6 Y\nx\u271d\u00b3 x\u271d\u00b2 : Scheme\nx\u271d\u00b9 : x\u271d\u00b3 \u27f6 x\u271d\u00b2\nx\u271d : IsAffine x\u271d\u00b2\n\u22a2 QuasiSeparatedSpace \u2191\u2191x\u271d\u00b3.toPresheafedSpace = QuasiSeparated.affineProperty x\u271d\u00b9"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case h.h.h.h\nX Y : Scheme\nf : X \u27f6 Y\nx\u271d\u00b3 x\u271d\u00b2 : Scheme\nx\u271d\u00b9 : x\u271d\u00b3 \u27f6 x\u271d\u00b2\nx\u271d : IsAffine x\u271d\u00b2\n\u22a2 QuasiSeparatedSpace \u2191\u2191x\u271d\u00b3.toPresheafedSpace = QuasiSeparated.affineProperty x\u271d\u00b9",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.800467181019485,
    "entry_failed": false
  },
  "1001": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Log/NegMulLog.lean",
    "full_name": "Real.deriv_mul_log",
    "start": [
      45,
      1
    ],
    "end": [
      48,
      26
    ],
    "traced_tactics": [
      {
        "tactic": "rw [deriv_mul differentiableAt_id' (differentiableAt_log hx)]",
        "annotated_tactic": [
          "rw [<a>deriv_mul</a> <a>differentiableAt_id'</a> (<a>differentiableAt_log</a> hx)]",
          [
            {
              "full_name": "deriv_mul",
              "def_path": "Mathlib/Analysis/Calculus/Deriv/Mul.lean",
              "def_pos": [
                237,
                9
              ],
              "def_end_pos": [
                237,
                18
              ]
            },
            {
              "full_name": "differentiableAt_id'",
              "def_path": "Mathlib/Analysis/Calculus/FDeriv/Basic.lean",
              "def_pos": [
                1101,
                9
              ],
              "def_end_pos": [
                1101,
                29
              ]
            },
            {
              "full_name": "Real.differentiableAt_log",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Log/Deriv.lean",
              "def_pos": [
                54,
                9
              ],
              "def_end_pos": [
                54,
                29
              ]
            }
          ]
        ],
        "state_before": "x : \u211d\nhx : x \u2260 0\n\u22a2 deriv (fun x => x * log x) x = log x + 1",
        "state_after": "x : \u211d\nhx : x \u2260 0\n\u22a2 deriv (fun x => x) x * log x + x * deriv log x = log x + 1"
      },
      {
        "tactic": "simp only [deriv_id'', one_mul, deriv_log', ne_eq, add_right_inj]",
        "annotated_tactic": [
          "simp only [<a>deriv_id''</a>, <a>one_mul</a>, <a>deriv_log'</a>, <a>ne_eq</a>, <a>add_right_inj</a>]",
          [
            {
              "full_name": "deriv_id''",
              "def_path": "Mathlib/Analysis/Calculus/Deriv/Basic.lean",
              "def_pos": [
                698,
                9
              ],
              "def_end_pos": [
                698,
                19
              ]
            },
            {
              "full_name": "one_mul",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                477,
                9
              ],
              "def_end_pos": [
                477,
                16
              ]
            },
            {
              "full_name": "Real.deriv_log'",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Log/Deriv.lean",
              "def_pos": [
                74,
                9
              ],
              "def_end_pos": [
                74,
                19
              ]
            },
            {
              "full_name": "ne_eq",
              "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean",
              "def_pos": [
                89,
                17
              ],
              "def_end_pos": [
                89,
                22
              ]
            },
            {
              "full_name": "add_right_inj",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                67,
                3
              ],
              "def_end_pos": [
                67,
                14
              ]
            }
          ]
        ],
        "state_before": "x : \u211d\nhx : x \u2260 0\n\u22a2 deriv (fun x => x) x * log x + x * deriv log x = log x + 1",
        "state_after": "x : \u211d\nhx : x \u2260 0\n\u22a2 x * x\u207b\u00b9 = 1"
      },
      {
        "tactic": "exact mul_inv_cancel hx",
        "annotated_tactic": [
          "exact <a>mul_inv_cancel</a> hx",
          [
            {
              "full_name": "mul_inv_cancel",
              "def_path": "Mathlib/Algebra/GroupWithZero/Defs.lean",
              "def_pos": [
                223,
                15
              ],
              "def_end_pos": [
                223,
                29
              ]
            }
          ]
        ],
        "state_before": "x : \u211d\nhx : x \u2260 0\n\u22a2 x * x\u207b\u00b9 = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9154849060578272,
    "entry_failed": false
  },
  "1045": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Set/BoolIndicator.lean",
    "full_name": "Set.preimage_boolIndicator_eq_union",
    "start": [
      47,
      1
    ],
    "end": [
      51,
      25
    ],
    "traced_tactics": [
      {
        "tactic": "ext x",
        "annotated_tactic": [
          "ext x",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ns : Set \u03b1\nt : Set Bool\n\u22a2 s.boolIndicator \u207b\u00b9' t = (if true \u2208 t then s else \u2205) \u222a if false \u2208 t then s\u1d9c else \u2205",
        "state_after": "case h\n\u03b1 : Type u_1\ns : Set \u03b1\nt : Set Bool\nx : \u03b1\n\u22a2 x \u2208 s.boolIndicator \u207b\u00b9' t \u2194 x \u2208 (if true \u2208 t then s else \u2205) \u222a if false \u2208 t then s\u1d9c else \u2205"
      },
      {
        "tactic": "simp only [boolIndicator, mem_preimage]",
        "annotated_tactic": [
          "simp only [<a>boolIndicator</a>, <a>mem_preimage</a>]",
          [
            {
              "full_name": "Set.boolIndicator",
              "def_path": "Mathlib/Data/Set/BoolIndicator.lean",
              "def_pos": [
                23,
                19
              ],
              "def_end_pos": [
                23,
                32
              ]
            },
            {
              "full_name": "Set.mem_preimage",
              "def_path": "Mathlib/Data/Set/Defs.lean",
              "def_pos": [
                120,
                9
              ],
              "def_end_pos": [
                120,
                21
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u_1\ns : Set \u03b1\nt : Set Bool\nx : \u03b1\n\u22a2 x \u2208 s.boolIndicator \u207b\u00b9' t \u2194 x \u2208 (if true \u2208 t then s else \u2205) \u222a if false \u2208 t then s\u1d9c else \u2205",
        "state_after": "case h\n\u03b1 : Type u_1\ns : Set \u03b1\nt : Set Bool\nx : \u03b1\n\u22a2 (if x \u2208 s then true else false) \u2208 t \u2194 x \u2208 (if true \u2208 t then s else \u2205) \u222a if false \u2208 t then s\u1d9c else \u2205"
      },
      {
        "tactic": "split_ifs <;> simp [*]",
        "annotated_tactic": [
          "split_ifs <;> simp [*]",
          []
        ],
        "state_before": "case h\n\u03b1 : Type u_1\ns : Set \u03b1\nt : Set Bool\nx : \u03b1\n\u22a2 (if x \u2208 s then true else false) \u2208 t \u2194 x \u2208 (if true \u2208 t then s else \u2205) \u222a if false \u2208 t then s\u1d9c else \u2205",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.01880031300243,
    "entry_failed": false
  },
  "1050": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Lattice.lean",
    "full_name": "inf_eq_minDefault",
    "start": [
      862,
      1
    ],
    "end": [
      868,
      88
    ],
    "traced_tactics": [
      {
        "tactic": "ext x y",
        "annotated_tactic": [
          "ext x y",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : DecidableRel fun x x_1 => x \u2264 x_1\ninst\u271d : IsTotal \u03b1 fun x x_1 => x \u2264 x_1\n\u22a2 (fun x x_1 => x \u2293 x_1) = minDefault",
        "state_after": "case h.h\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : DecidableRel fun x x_1 => x \u2264 x_1\ninst\u271d : IsTotal \u03b1 fun x x_1 => x \u2264 x_1\nx y : \u03b1\n\u22a2 x \u2293 y = minDefault x y"
      },
      {
        "tactic": "unfold minDefault",
        "annotated_tactic": [
          "unfold <a>minDefault</a>",
          [
            {
              "full_name": "minDefault",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                252,
                5
              ],
              "def_end_pos": [
                252,
                15
              ]
            }
          ]
        ],
        "state_before": "case h.h\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : DecidableRel fun x x_1 => x \u2264 x_1\ninst\u271d : IsTotal \u03b1 fun x x_1 => x \u2264 x_1\nx y : \u03b1\n\u22a2 x \u2293 y = minDefault x y",
        "state_after": "case h.h\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : DecidableRel fun x x_1 => x \u2264 x_1\ninst\u271d : IsTotal \u03b1 fun x x_1 => x \u2264 x_1\nx y : \u03b1\n\u22a2 x \u2293 y = if x \u2264 y then x else y"
      },
      {
        "tactic": "split_ifs with h'",
        "annotated_tactic": [
          "split_ifs with h'",
          []
        ],
        "state_before": "case h.h\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : DecidableRel fun x x_1 => x \u2264 x_1\ninst\u271d : IsTotal \u03b1 fun x x_1 => x \u2264 x_1\nx y : \u03b1\n\u22a2 x \u2293 y = if x \u2264 y then x else y",
        "state_after": "case pos\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : DecidableRel fun x x_1 => x \u2264 x_1\ninst\u271d : IsTotal \u03b1 fun x x_1 => x \u2264 x_1\nx y : \u03b1\nh' : x \u2264 y\n\u22a2 x \u2293 y = x\n\ncase neg\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : DecidableRel fun x x_1 => x \u2264 x_1\ninst\u271d : IsTotal \u03b1 fun x x_1 => x \u2264 x_1\nx y : \u03b1\nh' : \u00acx \u2264 y\n\u22a2 x \u2293 y = y"
      }
    ],
    "entry_time": 4.453184037003666,
    "entry_failed": false
  },
  "1058": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean",
    "full_name": "Real.tendsto_log_nhdsWithin_zero",
    "start": [
      347,
      1
    ],
    "end": [
      350,
      52
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 show _ = log from funext log_abs]",
        "annotated_tactic": [
          "rw [\u2190 show _ = <a>log</a> from <a>funext</a> <a>log_abs</a>]",
          [
            {
              "full_name": "Real.log",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean",
              "def_pos": [
                41,
                19
              ],
              "def_end_pos": [
                41,
                22
              ]
            },
            {
              "full_name": "funext",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1817,
                9
              ],
              "def_end_pos": [
                1817,
                15
              ]
            },
            {
              "full_name": "Real.log_abs",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean",
              "def_pos": [
                104,
                9
              ],
              "def_end_pos": [
                104,
                16
              ]
            }
          ]
        ],
        "state_before": "x y : \u211d\n\u22a2 Tendsto log (\ud835\udcdd[\u2260] 0) atBot",
        "state_after": "x y : \u211d\n\u22a2 Tendsto (fun x => log |x|) (\ud835\udcdd[\u2260] 0) atBot"
      },
      {
        "tactic": "refine Tendsto.comp (g := log) ?_ tendsto_abs_nhdsWithin_zero",
        "annotated_tactic": [
          "refine <a>Tendsto.comp</a> (g := <a>log</a>) ?_ <a>tendsto_abs_nhdsWithin_zero</a>",
          [
            {
              "full_name": "Filter.Tendsto.comp",
              "def_path": "Mathlib/Order/Filter/Basic.lean",
              "def_pos": [
                3098,
                9
              ],
              "def_end_pos": [
                3098,
                21
              ]
            },
            {
              "full_name": "Real.log",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean",
              "def_pos": [
                41,
                19
              ],
              "def_end_pos": [
                41,
                22
              ]
            },
            {
              "full_name": "tendsto_abs_nhdsWithin_zero",
              "def_path": "Mathlib/Topology/Algebra/Order/Group.lean",
              "def_pos": [
                98,
                9
              ],
              "def_end_pos": [
                98,
                36
              ]
            }
          ]
        ],
        "state_before": "x y : \u211d\n\u22a2 Tendsto (fun x => log |x|) (\ud835\udcdd[\u2260] 0) atBot",
        "state_after": "x y : \u211d\n\u22a2 Tendsto log (\ud835\udcdd[>] 0) atBot"
      },
      {
        "tactic": "simpa [\u2190 tendsto_comp_exp_atBot] using tendsto_id",
        "annotated_tactic": [
          "simpa [\u2190 <a>tendsto_comp_exp_atBot</a>] using <a>tendsto_id</a>",
          [
            {
              "full_name": "Real.tendsto_comp_exp_atBot",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Exp.lean",
              "def_pos": [
                368,
                9
              ],
              "def_end_pos": [
                368,
                31
              ]
            },
            {
              "full_name": "Filter.tendsto_id",
              "def_path": "Mathlib/Order/Filter/Basic.lean",
              "def_pos": [
                3094,
                9
              ],
              "def_end_pos": [
                3094,
                19
              ]
            }
          ]
        ],
        "state_before": "x y : \u211d\n\u22a2 Tendsto log (\ud835\udcdd[>] 0) atBot",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.9032323859864846,
    "entry_failed": false
  },
  "1162": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Polynomial/Hermite/Basic.lean",
    "full_name": "Polynomial.hermite_eq_iterate",
    "start": [
      59,
      1
    ],
    "end": [
      62,
      58
    ],
    "traced_tactics": [
      {
        "tactic": "induction' n with n ih",
        "annotated_tactic": [
          "induction' n with n ih",
          []
        ],
        "state_before": "n : \u2115\n\u22a2 hermite n = (fun p => X * p - derivative p)^[n] 1",
        "state_after": "case zero\n\n\u22a2 hermite 0 = (fun p => X * p - derivative p)^[0] 1\n\ncase succ\nn : \u2115\nih : hermite n = (fun p => X * p - derivative p)^[n] 1\n\u22a2 hermite (n + 1) = (fun p => X * p - derivative p)^[n + 1] 1"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case zero\n\n\u22a2 hermite 0 = (fun p => X * p - derivative p)^[0] 1",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [Function.iterate_succ_apply', \u2190 ih, hermite_succ]",
        "annotated_tactic": [
          "rw [<a>Function.iterate_succ_apply'</a>, \u2190 ih, <a>hermite_succ</a>]",
          [
            {
              "full_name": "Function.iterate_succ_apply'",
              "def_path": "Mathlib/Logic/Function/Iterate.lean",
              "def_pos": [
                191,
                9
              ],
              "def_end_pos": [
                191,
                28
              ]
            },
            {
              "full_name": "Polynomial.hermite_succ",
              "def_path": "Mathlib/RingTheory/Polynomial/Hermite/Basic.lean",
              "def_pos": [
                55,
                9
              ],
              "def_end_pos": [
                55,
                21
              ]
            }
          ]
        ],
        "state_before": "case succ\nn : \u2115\nih : hermite n = (fun p => X * p - derivative p)^[n] 1\n\u22a2 hermite (n + 1) = (fun p => X * p - derivative p)^[n + 1] 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5003484999760985,
    "entry_failed": false
  },
  "1186": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/MulChar/Basic.lean",
    "full_name": "MulChar.pow_apply'",
    "start": [
      390,
      1
    ],
    "end": [
      393,
      63
    ],
    "traced_tactics": [
      {
        "tactic": "by_cases ha : IsUnit a",
        "annotated_tactic": [
          "by_cases ha : <a>IsUnit</a> a",
          [
            {
              "full_name": "IsUnit",
              "def_path": "Mathlib/Algebra/Group/Units.lean",
              "def_pos": [
                653,
                5
              ],
              "def_end_pos": [
                653,
                11
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d\u00b9 : CommMonoid R\nR' : Type u_2\ninst\u271d : CommMonoidWithZero R'\n\u03c7 : MulChar R R'\nn : \u2115\nhn : n \u2260 0\na : R\n\u22a2 (\u03c7 ^ n) a = \u03c7 a ^ n",
        "state_after": "case pos\nR : Type u_1\ninst\u271d\u00b9 : CommMonoid R\nR' : Type u_2\ninst\u271d : CommMonoidWithZero R'\n\u03c7 : MulChar R R'\nn : \u2115\nhn : n \u2260 0\na : R\nha : IsUnit a\n\u22a2 (\u03c7 ^ n) a = \u03c7 a ^ n\n\ncase neg\nR : Type u_1\ninst\u271d\u00b9 : CommMonoid R\nR' : Type u_2\ninst\u271d : CommMonoidWithZero R'\n\u03c7 : MulChar R R'\nn : \u2115\nhn : n \u2260 0\na : R\nha : \u00acIsUnit a\n\u22a2 (\u03c7 ^ n) a = \u03c7 a ^ n"
      },
      {
        "tactic": "exact pow_apply_coe \u03c7 n ha.unit",
        "annotated_tactic": [
          "exact <a>pow_apply_coe</a> \u03c7 n ha.unit",
          [
            {
              "full_name": "MulChar.pow_apply_coe",
              "def_path": "Mathlib/NumberTheory/MulChar/Basic.lean",
              "def_pos": [
                383,
                9
              ],
              "def_end_pos": [
                383,
                22
              ]
            }
          ]
        ],
        "state_before": "case pos\nR : Type u_1\ninst\u271d\u00b9 : CommMonoid R\nR' : Type u_2\ninst\u271d : CommMonoidWithZero R'\n\u03c7 : MulChar R R'\nn : \u2115\nhn : n \u2260 0\na : R\nha : IsUnit a\n\u22a2 (\u03c7 ^ n) a = \u03c7 a ^ n",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [map_nonunit (\u03c7 ^ n) ha, map_nonunit \u03c7 ha, zero_pow hn]",
        "annotated_tactic": [
          "rw [<a>map_nonunit</a> (\u03c7 ^ n) ha, <a>map_nonunit</a> \u03c7 ha, <a>zero_pow</a> hn]",
          [
            {
              "full_name": "MulChar.map_nonunit",
              "def_path": "Mathlib/NumberTheory/MulChar/Basic.lean",
              "def_pos": [
                131,
                9
              ],
              "def_end_pos": [
                131,
                20
              ]
            },
            {
              "full_name": "MulChar.map_nonunit",
              "def_path": "Mathlib/NumberTheory/MulChar/Basic.lean",
              "def_pos": [
                131,
                9
              ],
              "def_end_pos": [
                131,
                20
              ]
            },
            {
              "full_name": "zero_pow",
              "def_path": "Mathlib/Algebra/GroupWithZero/Basic.lean",
              "def_pos": [
                160,
                15
              ],
              "def_end_pos": [
                160,
                23
              ]
            }
          ]
        ],
        "state_before": "case neg\nR : Type u_1\ninst\u271d\u00b9 : CommMonoid R\nR' : Type u_2\ninst\u271d : CommMonoidWithZero R'\n\u03c7 : MulChar R R'\nn : \u2115\nhn : n \u2260 0\na : R\nha : \u00acIsUnit a\n\u22a2 (\u03c7 ^ n) a = \u03c7 a ^ n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.824806903954595,
    "entry_failed": false
  },
  "1210": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Finite.lean",
    "full_name": "SimpleGraph.maxDegree_lt_card_verts",
    "start": [
      442,
      1
    ],
    "end": [
      446,
      33
    ],
    "traced_tactics": [
      {
        "tactic": "cases' G.exists_maximal_degree_vertex with v hv",
        "annotated_tactic": [
          "cases' G.exists_maximal_degree_vertex with v hv",
          []
        ],
        "state_before": "V : Type u_1\nG : SimpleGraph V\ne : Sym2 V\ninst\u271d\u00b2 : Fintype V\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : Nonempty V\n\u22a2 G.maxDegree < Fintype.card V",
        "state_after": "case intro\nV : Type u_1\nG : SimpleGraph V\ne : Sym2 V\ninst\u271d\u00b2 : Fintype V\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : Nonempty V\nv : V\nhv : G.maxDegree = G.degree v\n\u22a2 G.maxDegree < Fintype.card V"
      },
      {
        "tactic": "rw [hv]",
        "annotated_tactic": [
          "rw [hv]",
          []
        ],
        "state_before": "case intro\nV : Type u_1\nG : SimpleGraph V\ne : Sym2 V\ninst\u271d\u00b2 : Fintype V\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : Nonempty V\nv : V\nhv : G.maxDegree = G.degree v\n\u22a2 G.maxDegree < Fintype.card V",
        "state_after": "case intro\nV : Type u_1\nG : SimpleGraph V\ne : Sym2 V\ninst\u271d\u00b2 : Fintype V\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : Nonempty V\nv : V\nhv : G.maxDegree = G.degree v\n\u22a2 G.degree v < Fintype.card V"
      },
      {
        "tactic": "apply G.degree_lt_card_verts v",
        "annotated_tactic": [
          "apply G.degree_lt_card_verts v",
          []
        ],
        "state_before": "case intro\nV : Type u_1\nG : SimpleGraph V\ne : Sym2 V\ninst\u271d\u00b2 : Fintype V\ninst\u271d\u00b9 : DecidableRel G.Adj\ninst\u271d : Nonempty V\nv : V\nhv : G.maxDegree = G.degree v\n\u22a2 G.degree v < Fintype.card V",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.195944459992461,
    "entry_failed": false
  },
  "1214": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Ordinal/Notation.lean",
    "full_name": "ONote.oadd_lt_oadd_3",
    "start": [
      320,
      1
    ],
    "end": [
      322,
      49
    ],
    "traced_tactics": [
      {
        "tactic": "rw [lt_def]",
        "annotated_tactic": [
          "rw [<a>lt_def</a>]",
          [
            {
              "full_name": "ONote.lt_def",
              "def_path": "Mathlib/SetTheory/Ordinal/Notation.lean",
              "def_pos": [
                115,
                9
              ],
              "def_end_pos": [
                115,
                15
              ]
            }
          ]
        ],
        "state_before": "e : ONote\nn : \u2115+\na\u2081 a\u2082 : ONote\nh : a\u2081 < a\u2082\n\u22a2 e.oadd n a\u2081 < e.oadd n a\u2082",
        "state_after": "e : ONote\nn : \u2115+\na\u2081 a\u2082 : ONote\nh : a\u2081 < a\u2082\n\u22a2 (e.oadd n a\u2081).repr < (e.oadd n a\u2082).repr"
      },
      {
        "tactic": "unfold repr",
        "annotated_tactic": [
          "unfold <a>repr</a>",
          [
            {
              "full_name": "ONote.repr",
              "def_path": "Mathlib/SetTheory/Ordinal/Notation.lean",
              "def_pos": [
                74,
                19
              ],
              "def_end_pos": [
                74,
                23
              ]
            }
          ]
        ],
        "state_before": "e : ONote\nn : \u2115+\na\u2081 a\u2082 : ONote\nh : a\u2081 < a\u2082\n\u22a2 (e.oadd n a\u2081).repr < (e.oadd n a\u2082).repr",
        "state_after": "e : ONote\nn : \u2115+\na\u2081 a\u2082 : ONote\nh : a\u2081 < a\u2082\n\u22a2 \u03c9 ^ e.repr * \u2191\u2191n + a\u2081.repr < \u03c9 ^ e.repr * \u2191\u2191n + a\u2082.repr"
      },
      {
        "tactic": "exact @add_lt_add_left _ _ _ _ (repr a\u2081) _ h _",
        "annotated_tactic": [
          "exact @<a>add_lt_add_left</a> _ _ _ _ (<a>repr</a> a\u2081) _ h _",
          [
            {
              "full_name": "add_lt_add_left",
              "def_path": "Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean",
              "def_pos": [
                120,
                32
              ],
              "def_end_pos": [
                120,
                47
              ]
            },
            {
              "full_name": "ONote.repr",
              "def_path": "Mathlib/SetTheory/Ordinal/Notation.lean",
              "def_pos": [
                74,
                19
              ],
              "def_end_pos": [
                74,
                23
              ]
            }
          ]
        ],
        "state_before": "e : ONote\nn : \u2115+\na\u2081 a\u2082 : ONote\nh : a\u2081 < a\u2082\n\u22a2 \u03c9 ^ e.repr * \u2191\u2191n + a\u2081.repr < \u03c9 ^ e.repr * \u2191\u2191n + a\u2082.repr",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.29932635196019,
    "entry_failed": false
  },
  "1231": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Homotopy/Contractible.lean",
    "full_name": "ContractibleSpace.hequiv",
    "start": [
      113,
      1
    ],
    "end": [
      117,
      26
    ],
    "traced_tactics": [
      {
        "tactic": "rcases ContractibleSpace.hequiv_unit' (X := X) with \u27e8h\u27e9",
        "annotated_tactic": [
          "rcases <a>ContractibleSpace.hequiv_unit'</a> (X := X) with \u27e8h\u27e9",
          [
            {
              "full_name": "ContractibleSpace.hequiv_unit'",
              "def_path": "Mathlib/Topology/Homotopy/Contractible.lean",
              "def_pos": [
                52,
                3
              ],
              "def_end_pos": [
                52,
                15
              ]
            }
          ]
        ],
        "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : ContractibleSpace X\ninst\u271d : ContractibleSpace Y\n\u22a2 Nonempty (X \u2243\u2095 Y)",
        "state_after": "case intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : ContractibleSpace X\ninst\u271d : ContractibleSpace Y\nh : X \u2243\u2095 Unit\n\u22a2 Nonempty (X \u2243\u2095 Y)"
      },
      {
        "tactic": "rcases ContractibleSpace.hequiv_unit' (X := Y) with \u27e8h'\u27e9",
        "annotated_tactic": [
          "rcases <a>ContractibleSpace.hequiv_unit'</a> (X := Y) with \u27e8h'\u27e9",
          [
            {
              "full_name": "ContractibleSpace.hequiv_unit'",
              "def_path": "Mathlib/Topology/Homotopy/Contractible.lean",
              "def_pos": [
                52,
                3
              ],
              "def_end_pos": [
                52,
                15
              ]
            }
          ]
        ],
        "state_before": "case intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : ContractibleSpace X\ninst\u271d : ContractibleSpace Y\nh : X \u2243\u2095 Unit\n\u22a2 Nonempty (X \u2243\u2095 Y)",
        "state_after": "case intro.intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : ContractibleSpace X\ninst\u271d : ContractibleSpace Y\nh : X \u2243\u2095 Unit\nh' : Y \u2243\u2095 Unit\n\u22a2 Nonempty (X \u2243\u2095 Y)"
      },
      {
        "tactic": "exact \u27e8h.trans h'.symm\u27e9",
        "annotated_tactic": [
          "exact \u27e8h.trans h'.symm\u27e9",
          []
        ],
        "state_before": "case intro.intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : ContractibleSpace X\ninst\u271d : ContractibleSpace Y\nh : X \u2243\u2095 Unit\nh' : Y \u2243\u2095 Unit\n\u22a2 Nonempty (X \u2243\u2095 Y)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7428567620227113,
    "entry_failed": false
  },
  "1248": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Range.lean",
    "full_name": "List.take_range",
    "start": [
      87,
      1
    ],
    "end": [
      90,
      73
    ],
    "traced_tactics": [
      {
        "tactic": "apply List.ext_getElem",
        "annotated_tactic": [
          "apply <a>List.ext_getElem</a>",
          [
            {
              "full_name": "List.ext_getElem",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean",
              "def_pos": [
                258,
                9
              ],
              "def_end_pos": [
                258,
                20
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\nm n : \u2115\n\u22a2 take m (range n) = range (min m n)",
        "state_after": "case hl\n\u03b1 : Type u\nm n : \u2115\n\u22a2 (take m (range n)).length = (range (min m n)).length\n\ncase h\n\u03b1 : Type u\nm n : \u2115\n\u22a2 \u2200 (n_1 : \u2115) (h\u2081 : n_1 < (take m (range n)).length) (h\u2082 : n_1 < (range (min m n)).length),\n    (take m (range n))[n_1] = (range (min m n))[n_1]"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case hl\n\u03b1 : Type u\nm n : \u2115\n\u22a2 (take m (range n)).length = (range (min m n)).length",
        "state_after": "no goals"
      },
      {
        "tactic": "simp (config := { contextual := true }) [\u2190 getElem_take, Nat.lt_min]",
        "annotated_tactic": [
          "simp (config := { contextual := <a>true</a> }) [\u2190 <a>getElem_take</a>, <a>Nat.lt_min</a>]",
          [
            {
              "full_name": "Bool.true",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                571,
                5
              ],
              "def_end_pos": [
                571,
                9
              ]
            },
            {
              "full_name": "List.getElem_take",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/TakeDrop.lean",
              "def_pos": [
                77,
                9
              ],
              "def_end_pos": [
                77,
                21
              ]
            },
            {
              "full_name": "Nat.lt_min",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/MinMax.lean",
              "def_pos": [
                40,
                19
              ],
              "def_end_pos": [
                40,
                25
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u\nm n : \u2115\n\u22a2 \u2200 (n_1 : \u2115) (h\u2081 : n_1 < (take m (range n)).length) (h\u2082 : n_1 < (range (min m n)).length),\n    (take m (range n))[n_1] = (range (min m n))[n_1]",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2449444219237193,
    "entry_failed": false
  },
  "1309": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Coxeter/Length.lean",
    "full_name": "CoxeterSystem.isLeftDescent_inv_iff",
    "start": [
      271,
      1
    ],
    "end": [
      275,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "unfold IsLeftDescent IsRightDescent",
        "annotated_tactic": [
          "unfold <a>IsLeftDescent</a> <a>IsRightDescent</a>",
          [
            {
              "full_name": "CoxeterSystem.IsLeftDescent",
              "def_path": "Mathlib/GroupTheory/Coxeter/Length.lean",
              "def_pos": [
                262,
                5
              ],
              "def_end_pos": [
                262,
                18
              ]
            },
            {
              "full_name": "CoxeterSystem.IsRightDescent",
              "def_path": "Mathlib/GroupTheory/Coxeter/Length.lean",
              "def_pos": [
                265,
                5
              ],
              "def_end_pos": [
                265,
                19
              ]
            }
          ]
        ],
        "state_before": "B : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\n\u22a2 cs.IsLeftDescent w\u207b\u00b9 i \u2194 cs.IsRightDescent w i",
        "state_after": "B : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\n\u22a2 cs.length (cs.simple i * w\u207b\u00b9) < cs.length w\u207b\u00b9 \u2194 cs.length (w * cs.simple i) < cs.length w"
      },
      {
        "tactic": "nth_rw 1 [\u2190 length_inv]",
        "annotated_tactic": [
          "nth_rw 1 [\u2190 <a>length_inv</a>]",
          [
            {
              "full_name": "CoxeterSystem.length_inv",
              "def_path": "Mathlib/GroupTheory/Coxeter/Length.lean",
              "def_pos": [
                91,
                9
              ],
              "def_end_pos": [
                91,
                19
              ]
            }
          ]
        ],
        "state_before": "B : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\n\u22a2 cs.length (cs.simple i * w\u207b\u00b9) < cs.length w\u207b\u00b9 \u2194 cs.length (w * cs.simple i) < cs.length w",
        "state_after": "B : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\n\u22a2 cs.length (cs.simple i * w\u207b\u00b9)\u207b\u00b9 < cs.length w\u207b\u00b9 \u2194 cs.length (w * cs.simple i) < cs.length w"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "B : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\n\u22a2 cs.length (cs.simple i * w\u207b\u00b9)\u207b\u00b9 < cs.length w\u207b\u00b9 \u2194 cs.length (w * cs.simple i) < cs.length w",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.701789161073975,
    "entry_failed": false
  },
  "1424": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Set/Defs.lean",
    "full_name": "Set.comp_rangeSplitting",
    "start": [
      182,
      1
    ],
    "end": [
      185,
      29
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nf : \u03b1 \u2192 \u03b2\n\u22a2 f \u2218 rangeSplitting f = Subtype.val",
        "state_after": "case h\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nf : \u03b1 \u2192 \u03b2\nx\u271d : \u2191(range f)\n\u22a2 (f \u2218 rangeSplitting f) x\u271d = \u2191x\u271d"
      },
      {
        "tactic": "simp only [Function.comp_apply]",
        "annotated_tactic": [
          "simp only [<a>Function.comp_apply</a>]",
          [
            {
              "full_name": "Function.comp_apply",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                35,
                17
              ],
              "def_end_pos": [
                35,
                36
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nf : \u03b1 \u2192 \u03b2\nx\u271d : \u2191(range f)\n\u22a2 (f \u2218 rangeSplitting f) x\u271d = \u2191x\u271d",
        "state_after": "case h\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nf : \u03b1 \u2192 \u03b2\nx\u271d : \u2191(range f)\n\u22a2 f (rangeSplitting f x\u271d) = \u2191x\u271d"
      },
      {
        "tactic": "apply apply_rangeSplitting",
        "annotated_tactic": [
          "apply <a>apply_rangeSplitting</a>",
          [
            {
              "full_name": "Set.apply_rangeSplitting",
              "def_path": "Mathlib/Data/Set/Defs.lean",
              "def_pos": [
                177,
                9
              ],
              "def_end_pos": [
                177,
                29
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nf : \u03b1 \u2192 \u03b2\nx\u271d : \u2191(range f)\n\u22a2 f (rangeSplitting f x\u271d) = \u2191x\u271d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2444620479363948,
    "entry_failed": false
  },
  "1456": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": ".lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "full_name": "List.inits_eq_initsTR",
    "start": [
      488,
      10
    ],
    "end": [
      489,
      68
    ],
    "traced_tactics": [
      {
        "tactic": "funext \u03b1 l",
        "annotated_tactic": [
          "funext \u03b1 l",
          []
        ],
        "state_before": "\u22a2 @inits = @initsTR",
        "state_after": "case h.h\n\u03b1 : Type u_1\nl : List \u03b1\n\u22a2 l.inits = l.initsTR"
      },
      {
        "tactic": "simp [initsTR]",
        "annotated_tactic": [
          "simp [<a>initsTR</a>]",
          [
            {
              "full_name": "List.initsTR",
              "def_path": ".lake/packages/batteries/Batteries/Data/List/Basic.lean",
              "def_pos": [
                485,
                5
              ],
              "def_end_pos": [
                485,
                12
              ]
            }
          ]
        ],
        "state_before": "case h.h\n\u03b1 : Type u_1\nl : List \u03b1\n\u22a2 l.inits = l.initsTR",
        "state_after": "case h.h\n\u03b1 : Type u_1\nl : List \u03b1\n\u22a2 l.inits = (foldr (fun a arrs => (Array.map (fun t => a :: t) arrs).push []) #[[]] l).data.reverse"
      },
      {
        "tactic": "induction l <;> simp [*, map_reverse]",
        "annotated_tactic": [
          "induction l <;> simp [*, <a>map_reverse</a>]",
          [
            {
              "full_name": "List.map_reverse",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean",
              "def_pos": [
                1480,
                17
              ],
              "def_end_pos": [
                1480,
                28
              ]
            }
          ]
        ],
        "state_before": "case h.h\n\u03b1 : Type u_1\nl : List \u03b1\n\u22a2 l.inits = (foldr (fun a arrs => (Array.map (fun t => a :: t) arrs).push []) #[[]] l).data.reverse",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.7843334310455248,
    "entry_failed": false
  },
  "1610": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/Enumerative/Composition.lean",
    "full_name": "Composition.sizeUpTo_ofLength_le",
    "start": [
      207,
      1
    ],
    "end": [
      210,
      25
    ],
    "traced_tactics": [
      {
        "tactic": "dsimp [sizeUpTo]",
        "annotated_tactic": [
          "dsimp [<a>sizeUpTo</a>]",
          [
            {
              "full_name": "Composition.sizeUpTo",
              "def_path": "Mathlib/Combinatorics/Enumerative/Composition.lean",
              "def_pos": [
                199,
                5
              ],
              "def_end_pos": [
                199,
                13
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\nc : Composition n\ni : \u2115\nh : c.length \u2264 i\n\u22a2 c.sizeUpTo i = n",
        "state_after": "n : \u2115\nc : Composition n\ni : \u2115\nh : c.length \u2264 i\n\u22a2 (take i c.blocks).sum = n"
      },
      {
        "tactic": "convert c.blocks_sum",
        "annotated_tactic": [
          "convert c.blocks_sum",
          []
        ],
        "state_before": "n : \u2115\nc : Composition n\ni : \u2115\nh : c.length \u2264 i\n\u22a2 (take i c.blocks).sum = n",
        "state_after": "case h.e'_2.h.e'_4\nn : \u2115\nc : Composition n\ni : \u2115\nh : c.length \u2264 i\n\u22a2 take i c.blocks = c.blocks"
      },
      {
        "tactic": "exact take_all_of_le h",
        "annotated_tactic": [
          "exact <a>take_all_of_le</a> h",
          [
            {
              "full_name": "List.take_all_of_le",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean",
              "def_pos": [
                1573,
                9
              ],
              "def_end_pos": [
                1573,
                23
              ]
            }
          ]
        ],
        "state_before": "case h.e'_2.h.e'_4\nn : \u2115\nc : Composition n\ni : \u2115\nh : c.length \u2264 i\n\u22a2 take i c.blocks = c.blocks",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.3253574250265956,
    "entry_failed": false
  },
  "1731": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/LinearAlgebra/Matrix/Circulant.lean",
    "full_name": "Matrix.circulant_injective",
    "start": [
      61,
      1
    ],
    "end": [
      64,
      63
    ],
    "traced_tactics": [
      {
        "tactic": "intro v w h",
        "annotated_tactic": [
          "intro v w h",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : Type u_3\nn : Type u_4\nR : Type u_5\ninst\u271d : AddGroup n\n\u22a2 Injective circulant",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : Type u_3\nn : Type u_4\nR : Type u_5\ninst\u271d : AddGroup n\nv w : n \u2192 \u03b1\nh : circulant v = circulant w\n\u22a2 v = w"
      },
      {
        "tactic": "ext k",
        "annotated_tactic": [
          "ext k",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : Type u_3\nn : Type u_4\nR : Type u_5\ninst\u271d : AddGroup n\nv w : n \u2192 \u03b1\nh : circulant v = circulant w\n\u22a2 v = w",
        "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : Type u_3\nn : Type u_4\nR : Type u_5\ninst\u271d : AddGroup n\nv w : n \u2192 \u03b1\nh : circulant v = circulant w\nk : n\n\u22a2 v k = w k"
      },
      {
        "tactic": "rw [\u2190 circulant_col_zero_eq v, \u2190 circulant_col_zero_eq w, h]",
        "annotated_tactic": [
          "rw [\u2190 <a>circulant_col_zero_eq</a> v, \u2190 <a>circulant_col_zero_eq</a> w, h]",
          [
            {
              "full_name": "Matrix.circulant_col_zero_eq",
              "def_path": "Mathlib/LinearAlgebra/Matrix/Circulant.lean",
              "def_pos": [
                57,
                9
              ],
              "def_end_pos": [
                57,
                30
              ]
            },
            {
              "full_name": "Matrix.circulant_col_zero_eq",
              "def_path": "Mathlib/LinearAlgebra/Matrix/Circulant.lean",
              "def_pos": [
                57,
                9
              ],
              "def_end_pos": [
                57,
                30
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : Type u_3\nn : Type u_4\nR : Type u_5\ninst\u271d : AddGroup n\nv w : n \u2192 \u03b1\nh : circulant v = circulant w\nk : n\n\u22a2 v k = w k",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.501274866051972,
    "entry_failed": false
  },
  "1773": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Category/CompHaus/Limits.lean",
    "full_name": "CompHaus.finiteCoproduct.\u03b9_desc_apply",
    "start": [
      223,
      1
    ],
    "end": [
      227,
      21
    ],
    "traced_tactics": [
      {
        "tactic": "intro x",
        "annotated_tactic": [
          "intro x",
          []
        ],
        "state_before": "\u03b1 : Type w\ninst\u271d : Finite \u03b1\nX : \u03b1 \u2192 CompHaus\nB : CompHaus\n\u03c0 : (a : \u03b1) \u2192 X a \u27f6 B\na : \u03b1\n\u22a2 \u2200 (x : (forget CompHaus).obj (X a)), (desc X \u03c0) ((\u03b9 X a) x) = (\u03c0 a) x",
        "state_after": "\u03b1 : Type w\ninst\u271d : Finite \u03b1\nX : \u03b1 \u2192 CompHaus\nB : CompHaus\n\u03c0 : (a : \u03b1) \u2192 X a \u27f6 B\na : \u03b1\nx : (forget CompHaus).obj (X a)\n\u22a2 (desc X \u03c0) ((\u03b9 X a) x) = (\u03c0 a) x"
      },
      {
        "tactic": "change (\u03b9 X a \u226b desc X \u03c0) _ = _",
        "annotated_tactic": [
          "change (<a>\u03b9</a> X a \u226b <a>desc</a> X \u03c0) _ = _",
          [
            {
              "full_name": "CompHaus.finiteCoproduct.\u03b9",
              "def_path": "Mathlib/Topology/Category/CompHaus/Limits.lean",
              "def_pos": [
                158,
                5
              ],
              "def_end_pos": [
                158,
                22
              ]
            },
            {
              "full_name": "CompHaus.finiteCoproduct.desc",
              "def_path": "Mathlib/Topology/Category/CompHaus/Limits.lean",
              "def_pos": [
                167,
                5
              ],
              "def_end_pos": [
                167,
                25
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type w\ninst\u271d : Finite \u03b1\nX : \u03b1 \u2192 CompHaus\nB : CompHaus\n\u03c0 : (a : \u03b1) \u2192 X a \u27f6 B\na : \u03b1\nx : (forget CompHaus).obj (X a)\n\u22a2 (desc X \u03c0) ((\u03b9 X a) x) = (\u03c0 a) x",
        "state_after": "\u03b1 : Type w\ninst\u271d : Finite \u03b1\nX : \u03b1 \u2192 CompHaus\nB : CompHaus\n\u03c0 : (a : \u03b1) \u2192 X a \u27f6 B\na : \u03b1\nx : (forget CompHaus).obj (X a)\n\u22a2 (\u03b9 X a \u226b desc X \u03c0) x = (\u03c0 a) x"
      },
      {
        "tactic": "simp only [\u03b9_desc]",
        "annotated_tactic": [
          "simp only [<a>\u03b9_desc</a>]",
          [
            {
              "full_name": "CompHaus.finiteCoproduct.\u03b9_desc",
              "def_path": "Mathlib/Topology/Category/CompHaus/Limits.lean",
              "def_pos": [
                175,
                7
              ],
              "def_end_pos": [
                175,
                29
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type w\ninst\u271d : Finite \u03b1\nX : \u03b1 \u2192 CompHaus\nB : CompHaus\n\u03c0 : (a : \u03b1) \u2192 X a \u27f6 B\na : \u03b1\nx : (forget CompHaus).obj (X a)\n\u22a2 (\u03b9 X a \u226b desc X \u03c0) x = (\u03c0 a) x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.2518723639659584,
    "entry_failed": false
  },
  "1780": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Seq/Computation.lean",
    "full_name": "Computation.Results.len_unique",
    "start": [
      524,
      1
    ],
    "end": [
      525,
      92
    ],
    "traced_tactics": [
      {
        "tactic": "haveI := h1.terminates",
        "annotated_tactic": [
          "haveI := h1.terminates",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns : Computation \u03b1\na b : \u03b1\nm n : \u2115\nh1 : s.Results a m\nh2 : s.Results b n\n\u22a2 m = n",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns : Computation \u03b1\na b : \u03b1\nm n : \u2115\nh1 : s.Results a m\nh2 : s.Results b n\nthis : s.Terminates\n\u22a2 m = n"
      },
      {
        "tactic": "haveI := h2.terminates",
        "annotated_tactic": [
          "haveI := h2.terminates",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns : Computation \u03b1\na b : \u03b1\nm n : \u2115\nh1 : s.Results a m\nh2 : s.Results b n\nthis : s.Terminates\n\u22a2 m = n",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns : Computation \u03b1\na b : \u03b1\nm n : \u2115\nh1 : s.Results a m\nh2 : s.Results b n\nthis\u271d this : s.Terminates\n\u22a2 m = n"
      },
      {
        "tactic": "rw [\u2190 h1.length, h2.length]",
        "annotated_tactic": [
          "rw [\u2190 h1.length, h2.length]",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns : Computation \u03b1\na b : \u03b1\nm n : \u2115\nh1 : s.Results a m\nh2 : s.Results b n\nthis\u271d this : s.Terminates\n\u22a2 m = n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.752456720918417,
    "entry_failed": false
  },
  "1875": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Finsupp/AList.lean",
    "full_name": "AList.empty_lookupFinsupp",
    "start": [
      102,
      1
    ],
    "end": [
      105,
      9
    ],
    "traced_tactics": [
      {
        "tactic": "classical\n  ext\n  simp",
        "annotated_tactic": [
          "classical\n    ext\n    simp",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nM : Type u_2\ninst\u271d : Zero M\n\u22a2 \u2205.lookupFinsupp = 0",
        "state_after": "no goals"
      },
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nM : Type u_2\ninst\u271d : Zero M\n\u22a2 \u2205.lookupFinsupp = 0",
        "state_after": "case h\n\u03b1 : Type u_1\nM : Type u_2\ninst\u271d : Zero M\na\u271d : \u03b1\n\u22a2 \u2205.lookupFinsupp a\u271d = 0 a\u271d"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case h\n\u03b1 : Type u_1\nM : Type u_2\ninst\u271d : Zero M\na\u271d : \u03b1\n\u22a2 \u2205.lookupFinsupp a\u271d = 0 a\u271d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9124170889845118,
    "entry_failed": false
  },
  "1900": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Finsupp/BigOperators.lean",
    "full_name": "Finset.support_sum_subset",
    "start": [
      55,
      1
    ],
    "end": [
      57,
      58
    ],
    "traced_tactics": [
      {
        "tactic": "classical convert Multiset.support_sum_subset s.1; simp",
        "annotated_tactic": [
          "classical convert <a>Multiset.support_sum_subset</a> s.1; simp",
          [
            {
              "full_name": "Multiset.support_sum_subset",
              "def_path": "Mathlib/Data/Finsupp/BigOperators.lean",
              "def_pos": [
                48,
                9
              ],
              "def_end_pos": [
                48,
                36
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : AddCommMonoid M\ns : Finset (\u03b9 \u2192\u2080 M)\n\u22a2 (s.sum id).support \u2286 s.sup Finsupp.support",
        "state_after": "no goals"
      },
      {
        "tactic": "convert Multiset.support_sum_subset s.1",
        "annotated_tactic": [
          "convert <a>Multiset.support_sum_subset</a> s.1",
          [
            {
              "full_name": "Multiset.support_sum_subset",
              "def_path": "Mathlib/Data/Finsupp/BigOperators.lean",
              "def_pos": [
                48,
                9
              ],
              "def_end_pos": [
                48,
                36
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : AddCommMonoid M\ns : Finset (\u03b9 \u2192\u2080 M)\n\u22a2 (s.sum id).support \u2286 s.sup Finsupp.support",
        "state_after": "case h.e'_3.h.e'_4\n\u03b9 : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : AddCommMonoid M\ns : Finset (\u03b9 \u2192\u2080 M)\n\u22a2 s.sum id = s.val.sum"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case h.e'_3.h.e'_4\n\u03b9 : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : AddCommMonoid M\ns : Finset (\u03b9 \u2192\u2080 M)\n\u22a2 s.sum id = s.val.sum",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2661058210069314,
    "entry_failed": false
  },
  "1954": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Coprime/Basic.lean",
    "full_name": "IsCoprime.ne_zero_or_ne_zero",
    "start": [
      89,
      1
    ],
    "end": [
      92,
      34
    ],
    "traced_tactics": [
      {
        "tactic": "apply not_or_of_imp",
        "annotated_tactic": [
          "apply <a>not_or_of_imp</a>",
          [
            {
              "full_name": "not_or_of_imp",
              "def_path": "Mathlib/Logic/Basic.lean",
              "def_pos": [
                375,
                9
              ],
              "def_end_pos": [
                375,
                22
              ]
            }
          ]
        ],
        "state_before": "R : Type u\ninst\u271d\u00b9 : CommSemiring R\nx y z : R\ninst\u271d : Nontrivial R\nh : IsCoprime x y\n\u22a2 x \u2260 0 \u2228 y \u2260 0",
        "state_after": "case a\nR : Type u\ninst\u271d\u00b9 : CommSemiring R\nx y z : R\ninst\u271d : Nontrivial R\nh : IsCoprime x y\n\u22a2 x = 0 \u2192 y \u2260 0"
      },
      {
        "tactic": "rintro rfl rfl",
        "annotated_tactic": [
          "rintro rfl rfl",
          []
        ],
        "state_before": "case a\nR : Type u\ninst\u271d\u00b9 : CommSemiring R\nx y z : R\ninst\u271d : Nontrivial R\nh : IsCoprime x y\n\u22a2 x = 0 \u2192 y \u2260 0",
        "state_after": "case a\nR : Type u\ninst\u271d\u00b9 : CommSemiring R\nz : R\ninst\u271d : Nontrivial R\nh : IsCoprime 0 0\n\u22a2 False"
      },
      {
        "tactic": "exact not_isCoprime_zero_zero h",
        "annotated_tactic": [
          "exact <a>not_isCoprime_zero_zero</a> h",
          [
            {
              "full_name": "not_isCoprime_zero_zero",
              "def_path": "Mathlib/RingTheory/Coprime/Basic.lean",
              "def_pos": [
                72,
                9
              ],
              "def_end_pos": [
                72,
                32
              ]
            }
          ]
        ],
        "state_before": "case a\nR : Type u\ninst\u271d\u00b9 : CommSemiring R\nz : R\ninst\u271d : Nontrivial R\nh : IsCoprime 0 0\n\u22a2 False",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9753371340921149,
    "entry_failed": false
  },
  "2066": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Homotopy/Contractible.lean",
    "full_name": "id_nullhomotopic",
    "start": [
      61,
      1
    ],
    "end": [
      65,
      27
    ],
    "traced_tactics": [
      {
        "tactic": "obtain \u27e8hv\u27e9 := ContractibleSpace.hequiv_unit X",
        "annotated_tactic": [
          "obtain \u27e8hv\u27e9 := <a>ContractibleSpace.hequiv_unit</a> X",
          [
            {
              "full_name": "ContractibleSpace.hequiv_unit",
              "def_path": "Mathlib/Topology/Homotopy/Contractible.lean",
              "def_pos": [
                56,
                9
              ],
              "def_end_pos": [
                56,
                38
              ]
            }
          ]
        ],
        "state_before": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : ContractibleSpace X\n\u22a2 (ContinuousMap.id X).Nullhomotopic",
        "state_after": "case intro\nX : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : ContractibleSpace X\nhv : X \u2243\u2095 Unit\n\u22a2 (ContinuousMap.id X).Nullhomotopic"
      },
      {
        "tactic": "use hv.invFun ()",
        "annotated_tactic": [
          "use hv.invFun ()",
          []
        ],
        "state_before": "case intro\nX : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : ContractibleSpace X\nhv : X \u2243\u2095 Unit\n\u22a2 (ContinuousMap.id X).Nullhomotopic",
        "state_after": "case h\nX : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : ContractibleSpace X\nhv : X \u2243\u2095 Unit\n\u22a2 (ContinuousMap.id X).Homotopic (const X (hv.invFun ()))"
      },
      {
        "tactic": "convert hv.left_inv.symm",
        "annotated_tactic": [
          "convert hv.left_inv.symm",
          []
        ],
        "state_before": "case h\nX : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : ContractibleSpace X\nhv : X \u2243\u2095 Unit\n\u22a2 (ContinuousMap.id X).Homotopic (const X (hv.invFun ()))",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5824234370375052,
    "entry_failed": false
  },
  "2135": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Matching.lean",
    "full_name": "SimpleGraph.Subgraph.IsMatching.toEdge_eq_of_adj",
    "start": [
      63,
      1
    ],
    "end": [
      67,
      57
    ],
    "traced_tactics": [
      {
        "tactic": "simp only [IsMatching.toEdge, Subtype.mk_eq_mk]",
        "annotated_tactic": [
          "simp only [<a>IsMatching.toEdge</a>, <a>Subtype.mk_eq_mk</a>]",
          [
            {
              "full_name": "SimpleGraph.Subgraph.IsMatching.toEdge",
              "def_path": "Mathlib/Combinatorics/SimpleGraph/Matching.lean",
              "def_pos": [
                59,
                19
              ],
              "def_end_pos": [
                59,
                36
              ]
            },
            {
              "full_name": "Subtype.mk_eq_mk",
              "def_path": "Mathlib/Data/Subtype.lean",
              "def_pos": [
                116,
                9
              ],
              "def_end_pos": [
                116,
                17
              ]
            }
          ]
        ],
        "state_before": "V : Type u\nG : SimpleGraph V\nM\u271d M : G.Subgraph\nh : M.IsMatching\nv w : V\nhv : v \u2208 M.verts\nhvw : M.Adj v w\n\u22a2 h.toEdge \u27e8v, hv\u27e9 = \u27e8s(v, w), hvw\u27e9",
        "state_after": "V : Type u\nG : SimpleGraph V\nM\u271d M : G.Subgraph\nh : M.IsMatching\nv w : V\nhv : v \u2208 M.verts\nhvw : M.Adj v w\n\u22a2 s(v, Exists.choose \u22ef) = s(v, w)"
      },
      {
        "tactic": "congr",
        "annotated_tactic": [
          "congr",
          []
        ],
        "state_before": "V : Type u\nG : SimpleGraph V\nM\u271d M : G.Subgraph\nh : M.IsMatching\nv w : V\nhv : v \u2208 M.verts\nhvw : M.Adj v w\n\u22a2 s(v, Exists.choose \u22ef) = s(v, w)",
        "state_after": "case e_p.e_snd\nV : Type u\nG : SimpleGraph V\nM\u271d M : G.Subgraph\nh : M.IsMatching\nv w : V\nhv : v \u2208 M.verts\nhvw : M.Adj v w\n\u22a2 Exists.choose \u22ef = w"
      },
      {
        "tactic": "exact ((h (M.edge_vert hvw)).choose_spec.2 w hvw).symm",
        "annotated_tactic": [
          "exact ((h (M.edge_vert hvw)).<a>choose_spec</a>.2 w hvw).<a>symm</a>",
          [
            {
              "full_name": "Exists.choose_spec",
              "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean",
              "def_pos": [
                177,
                9
              ],
              "def_end_pos": [
                177,
                27
              ]
            },
            {
              "full_name": "Eq.symm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                323,
                9
              ],
              "def_end_pos": [
                323,
                16
              ]
            }
          ]
        ],
        "state_before": "case e_p.e_snd\nV : Type u\nG : SimpleGraph V\nM\u271d M : G.Subgraph\nh : M.IsMatching\nv w : V\nhv : v \u2208 M.verts\nhvw : M.Adj v w\n\u22a2 Exists.choose \u22ef = w",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.3988688450772315,
    "entry_failed": false
  },
  "2151": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Matroid/Restrict.lean",
    "full_name": "Matroid.basis_restrict_iff",
    "start": [
      192,
      1
    ],
    "end": [
      196,
      57
    ],
    "traced_tactics": [
      {
        "tactic": "rw [basis_restrict_iff', and_congr_left_iff]",
        "annotated_tactic": [
          "rw [<a>basis_restrict_iff'</a>, <a>and_congr_left_iff</a>]",
          [
            {
              "full_name": "Matroid.basis_restrict_iff'",
              "def_path": "Mathlib/Data/Matroid/Restrict.lean",
              "def_pos": [
                185,
                9
              ],
              "def_end_pos": [
                185,
                28
              ]
            },
            {
              "full_name": "and_congr_left_iff",
              "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean",
              "def_pos": [
                158,
                17
              ],
              "def_end_pos": [
                158,
                35
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nM : Matroid \u03b1\nR I J X Y : Set \u03b1\nhR : autoParam (R \u2286 M.E) _auto\u271d\n\u22a2 (M \u21be R).Basis I X \u2194 M.Basis I X \u2227 X \u2286 R",
        "state_after": "\u03b1 : Type u_1\nM : Matroid \u03b1\nR I J X Y : Set \u03b1\nhR : autoParam (R \u2286 M.E) _auto\u271d\n\u22a2 X \u2286 R \u2192 (M.Basis I (X \u2229 M.E) \u2194 M.Basis I X)"
      },
      {
        "tactic": "intro hXR",
        "annotated_tactic": [
          "intro hXR",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nM : Matroid \u03b1\nR I J X Y : Set \u03b1\nhR : autoParam (R \u2286 M.E) _auto\u271d\n\u22a2 X \u2286 R \u2192 (M.Basis I (X \u2229 M.E) \u2194 M.Basis I X)",
        "state_after": "\u03b1 : Type u_1\nM : Matroid \u03b1\nR I J X Y : Set \u03b1\nhR : autoParam (R \u2286 M.E) _auto\u271d\nhXR : X \u2286 R\n\u22a2 M.Basis I (X \u2229 M.E) \u2194 M.Basis I X"
      },
      {
        "tactic": "rw [\u2190 basis'_iff_basis_inter_ground, basis'_iff_basis]",
        "annotated_tactic": [
          "rw [\u2190 <a>basis'_iff_basis_inter_ground</a>, <a>basis'_iff_basis</a>]",
          [
            {
              "full_name": "Matroid.basis'_iff_basis_inter_ground",
              "def_path": "Mathlib/Data/Matroid/Basic.lean",
              "def_pos": [
                755,
                9
              ],
              "def_end_pos": [
                755,
                38
              ]
            },
            {
              "full_name": "Bool.true",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                571,
                5
              ],
              "def_end_pos": [
                571,
                9
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nM : Matroid \u03b1\nR I J X Y : Set \u03b1\nhR : autoParam (R \u2286 M.E) _auto\u271d\nhXR : X \u2286 R\n\u22a2 M.Basis I (X \u2229 M.E) \u2194 M.Basis I X",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.924704186967574,
    "entry_failed": false
  },
  "2153": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": ".lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "full_name": "List.singleton_sublist",
    "start": [
      198,
      9
    ],
    "end": [
      201,
      66
    ],
    "traced_tactics": [
      {
        "tactic": "refine \u27e8fun h => h.subset (mem_singleton_self _), fun h => ?_\u27e9",
        "annotated_tactic": [
          "refine \u27e8fun h => h.subset (<a>mem_singleton_self</a> _), fun h => ?_\u27e9",
          [
            {
              "full_name": "List.mem_singleton_self",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean",
              "def_pos": [
                322,
                9
              ],
              "def_end_pos": [
                322,
                27
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\na : \u03b1\nl : List \u03b1\n\u22a2 [a] <+ l \u2194 a \u2208 l",
        "state_after": "\u03b1 : Type u_1\na : \u03b1\nl : List \u03b1\nh : a \u2208 l\n\u22a2 [a] <+ l"
      },
      {
        "tactic": "obtain \u27e8_, _, rfl\u27e9 := append_of_mem h",
        "annotated_tactic": [
          "obtain \u27e8_, _, rfl\u27e9 := <a>append_of_mem</a> h",
          [
            {
              "full_name": "List.append_of_mem",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean",
              "def_pos": [
                1065,
                9
              ],
              "def_end_pos": [
                1065,
                22
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\na : \u03b1\nl : List \u03b1\nh : a \u2208 l\n\u22a2 [a] <+ l",
        "state_after": "case intro.intro\n\u03b1 : Type u_1\na : \u03b1\nw\u271d\u00b9 w\u271d : List \u03b1\nh : a \u2208 w\u271d\u00b9 ++ a :: w\u271d\n\u22a2 [a] <+ w\u271d\u00b9 ++ a :: w\u271d"
      },
      {
        "tactic": "exact ((nil_sublist _).cons\u2082 _).trans (sublist_append_right ..)",
        "annotated_tactic": [
          "exact ((<a>nil_sublist</a> _).<a>cons\u2082</a> _).<a>trans</a> (<a>sublist_append_right</a> ..)",
          [
            {
              "full_name": "List.nil_sublist",
              "def_path": ".lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
              "def_pos": [
                83,
                17
              ],
              "def_end_pos": [
                83,
                28
              ]
            },
            {
              "full_name": "List.Sublist.cons\u2082",
              "def_path": ".lake/packages/batteries/Batteries/Data/List/Basic.lean",
              "def_pos": [
                149,
                5
              ],
              "def_end_pos": [
                149,
                10
              ]
            },
            {
              "full_name": "List.Sublist.trans",
              "def_path": ".lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
              "def_pos": [
                91,
                9
              ],
              "def_end_pos": [
                91,
                22
              ]
            },
            {
              "full_name": "List.sublist_append_right",
              "def_path": ".lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
              "def_pos": [
                113,
                17
              ],
              "def_end_pos": [
                113,
                37
              ]
            }
          ]
        ],
        "state_before": "case intro.intro\n\u03b1 : Type u_1\na : \u03b1\nw\u271d\u00b9 w\u271d : List \u03b1\nh : a \u2208 w\u271d\u00b9 ++ a :: w\u271d\n\u22a2 [a] <+ w\u271d\u00b9 ++ a :: w\u271d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.574492905987427,
    "entry_failed": false
  },
  "2203": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Sort.lean",
    "full_name": "List.sublist_orderedInsert",
    "start": [
      333,
      1
    ],
    "end": [
      336,
      34
    ],
    "traced_tactics": [
      {
        "tactic": "rw [orderedInsert_eq_take_drop]",
        "annotated_tactic": [
          "rw [<a>orderedInsert_eq_take_drop</a>]",
          [
            {
              "full_name": "List.orderedInsert_eq_take_drop",
              "def_path": "Mathlib/Data/List/Sort.lean",
              "def_pos": [
                234,
                9
              ],
              "def_end_pos": [
                234,
                35
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : DecidableRel r\nx : \u03b1\nxs : List \u03b1\n\u22a2 xs <+ orderedInsert r x xs",
        "state_after": "\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : DecidableRel r\nx : \u03b1\nxs : List \u03b1\n\u22a2 xs <+ takeWhile (fun b => decide \u00acr x b) xs ++ x :: dropWhile (fun b => decide \u00acr x b) xs"
      },
      {
        "tactic": "refine Sublist.trans ?_ (.append_left (.cons _ (.refl _)) _)",
        "annotated_tactic": [
          "refine <a>Sublist.trans</a> ?_ (.append_left (.cons _ (.refl _)) _)",
          [
            {
              "full_name": "List.Sublist.trans",
              "def_path": ".lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
              "def_pos": [
                91,
                9
              ],
              "def_end_pos": [
                91,
                22
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : DecidableRel r\nx : \u03b1\nxs : List \u03b1\n\u22a2 xs <+ takeWhile (fun b => decide \u00acr x b) xs ++ x :: dropWhile (fun b => decide \u00acr x b) xs",
        "state_after": "\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : DecidableRel r\nx : \u03b1\nxs : List \u03b1\n\u22a2 xs <+ takeWhile (fun b => decide \u00acr x b) xs ++ dropWhile (fun b => decide \u00acr x b) xs"
      },
      {
        "tactic": "rw [takeWhile_append_dropWhile]",
        "annotated_tactic": [
          "rw [<a>takeWhile_append_dropWhile</a>]",
          [
            {
              "full_name": "List.takeWhile_append_dropWhile",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean",
              "def_pos": [
                1743,
                17
              ],
              "def_end_pos": [
                1743,
                43
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : DecidableRel r\nx : \u03b1\nxs : List \u03b1\n\u22a2 xs <+ takeWhile (fun b => decide \u00acr x b) xs ++ dropWhile (fun b => decide \u00acr x b) xs",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.223141054972075,
    "entry_failed": false
  },
  "2236": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/SuccPred/LinearLocallyFinite.lean",
    "full_name": "LinearLocallyFiniteOrder.succFn_le_of_lt",
    "start": [
      103,
      1
    ],
    "end": [
      106,
      18
    ],
    "traced_tactics": [
      {
        "tactic": "have h := succFn_spec i",
        "annotated_tactic": [
          "have h := <a>succFn_spec</a> i",
          [
            {
              "full_name": "LinearLocallyFiniteOrder.succFn_spec",
              "def_path": "Mathlib/Order/SuccPred/LinearLocallyFinite.lean",
              "def_pos": [
                69,
                9
              ],
              "def_end_pos": [
                69,
                20
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\ninst\u271d : LinearOrder \u03b9\ni j : \u03b9\nhij : i < j\n\u22a2 succFn i \u2264 j",
        "state_after": "\u03b9 : Type u_1\ninst\u271d : LinearOrder \u03b9\ni j : \u03b9\nhij : i < j\nh : IsGLB (Set.Ioi i) (succFn i)\n\u22a2 succFn i \u2264 j"
      },
      {
        "tactic": "rw [IsGLB, IsGreatest, mem_lowerBounds] at h",
        "annotated_tactic": [
          "rw [<a>IsGLB</a>, <a>IsGreatest</a>, <a>mem_lowerBounds</a>] at h",
          [
            {
              "full_name": "IsGLB",
              "def_path": "Mathlib/Order/Bounds/Basic.lean",
              "def_pos": [
                81,
                5
              ],
              "def_end_pos": [
                81,
                10
              ]
            },
            {
              "full_name": "IsGreatest",
              "def_path": "Mathlib/Order/Bounds/Basic.lean",
              "def_pos": [
                71,
                5
              ],
              "def_end_pos": [
                71,
                15
              ]
            },
            {
              "full_name": "mem_lowerBounds",
              "def_path": "Mathlib/Order/Bounds/Basic.lean",
              "def_pos": [
                89,
                9
              ],
              "def_end_pos": [
                89,
                24
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\ninst\u271d : LinearOrder \u03b9\ni j : \u03b9\nhij : i < j\nh : IsGLB (Set.Ioi i) (succFn i)\n\u22a2 succFn i \u2264 j",
        "state_after": "\u03b9 : Type u_1\ninst\u271d : LinearOrder \u03b9\ni j : \u03b9\nhij : i < j\nh : (\u2200 x \u2208 Set.Ioi i, succFn i \u2264 x) \u2227 succFn i \u2208 upperBounds (lowerBounds (Set.Ioi i))\n\u22a2 succFn i \u2264 j"
      },
      {
        "tactic": "exact h.1 j hij",
        "annotated_tactic": [
          "exact h.1 j hij",
          []
        ],
        "state_before": "\u03b9 : Type u_1\ninst\u271d : LinearOrder \u03b9\ni j : \u03b9\nhij : i < j\nh : (\u2200 x \u2208 Set.Ioi i, succFn i \u2264 x) \u2227 succFn i \u2208 upperBounds (lowerBounds (Set.Ioi i))\n\u22a2 succFn i \u2264 j",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6991523909382522,
    "entry_failed": false
  },
  "2290": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Game/Domineering.lean",
    "full_name": "SetTheory.PGame.Domineering.snd_pred_mem_erase_of_mem_left",
    "start": [
      86,
      1
    ],
    "end": [
      90,
      51
    ],
    "traced_tactics": [
      {
        "tactic": "rw [mem_left] at h",
        "annotated_tactic": [
          "rw [<a>mem_left</a>] at h",
          [
            {
              "full_name": "SetTheory.PGame.Domineering.mem_left",
              "def_path": "Mathlib/SetTheory/Game/Domineering.lean",
              "def_pos": [
                61,
                9
              ],
              "def_end_pos": [
                61,
                17
              ]
            }
          ]
        ],
        "state_before": "b : Board\nm : \u2124 \u00d7 \u2124\nh : m \u2208 left b\n\u22a2 (m.1, m.2 - 1) \u2208 Finset.erase b m",
        "state_after": "b : Board\nm : \u2124 \u00d7 \u2124\nh : m \u2208 b \u2227 (m.1, m.2 - 1) \u2208 b\n\u22a2 (m.1, m.2 - 1) \u2208 Finset.erase b m"
      },
      {
        "tactic": "apply Finset.mem_erase_of_ne_of_mem _ h.2",
        "annotated_tactic": [
          "apply <a>Finset.mem_erase_of_ne_of_mem</a> _ h.2",
          [
            {
              "full_name": "Finset.mem_erase_of_ne_of_mem",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                1931,
                9
              ],
              "def_end_pos": [
                1931,
                31
              ]
            }
          ]
        ],
        "state_before": "b : Board\nm : \u2124 \u00d7 \u2124\nh : m \u2208 b \u2227 (m.1, m.2 - 1) \u2208 b\n\u22a2 (m.1, m.2 - 1) \u2208 Finset.erase b m",
        "state_after": "b : Board\nm : \u2124 \u00d7 \u2124\nh : m \u2208 b \u2227 (m.1, m.2 - 1) \u2208 b\n\u22a2 (m.1, m.2 - 1) \u2260 m"
      },
      {
        "tactic": "exact ne_of_apply_ne Prod.snd (pred_ne_self m.2)",
        "annotated_tactic": [
          "exact <a>ne_of_apply_ne</a> <a>Prod.snd</a> (<a>pred_ne_self</a> m.2)",
          [
            {
              "full_name": "ne_of_apply_ne",
              "def_path": ".lake/packages/batteries/Batteries/Logic.lean",
              "def_pos": [
                66,
                9
              ],
              "def_end_pos": [
                66,
                23
              ]
            },
            {
              "full_name": "Prod.snd",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                485,
                3
              ],
              "def_end_pos": [
                485,
                6
              ]
            },
            {
              "full_name": "pred_ne_self",
              "def_path": "Mathlib/Algebra/Ring/Basic.lean",
              "def_pos": [
                144,
                9
              ],
              "def_end_pos": [
                144,
                21
              ]
            }
          ]
        ],
        "state_before": "b : Board\nm : \u2124 \u00d7 \u2124\nh : m \u2208 b \u2227 (m.1, m.2 - 1) \u2208 b\n\u22a2 (m.1, m.2 - 1) \u2260 m",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5207657929277048,
    "entry_failed": false
  },
  "2330": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Real/Archimedean.lean",
    "full_name": "Real.ciInf_const_zero",
    "start": [
      223,
      1
    ],
    "end": [
      226,
      22
    ],
    "traced_tactics": [
      {
        "tactic": "cases isEmpty_or_nonempty \u03b1",
        "annotated_tactic": [
          "cases <a>isEmpty_or_nonempty</a> \u03b1",
          [
            {
              "full_name": "isEmpty_or_nonempty",
              "def_path": "Mathlib/Logic/IsEmpty.lean",
              "def_pos": [
                221,
                9
              ],
              "def_end_pos": [
                221,
                28
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Sort u_1\n\u22a2 \u2a05 x, 0 = 0",
        "state_after": "case inl\n\u03b1 : Sort u_1\nh\u271d : IsEmpty \u03b1\n\u22a2 \u2a05 x, 0 = 0\n\ncase inr\n\u03b1 : Sort u_1\nh\u271d : Nonempty \u03b1\n\u22a2 \u2a05 x, 0 = 0"
      },
      {
        "tactic": "exact Real.iInf_of_isEmpty _",
        "annotated_tactic": [
          "exact <a>Real.iInf_of_isEmpty</a> _",
          [
            {
              "full_name": "Real.iInf_of_isEmpty",
              "def_path": "Mathlib/Data/Real/Archimedean.lean",
              "def_pos": [
                218,
                22
              ],
              "def_end_pos": [
                218,
                37
              ]
            }
          ]
        ],
        "state_before": "case inl\n\u03b1 : Sort u_1\nh\u271d : IsEmpty \u03b1\n\u22a2 \u2a05 x, 0 = 0",
        "state_after": "no goals"
      },
      {
        "tactic": "exact ciInf_const",
        "annotated_tactic": [
          "exact <a>ciInf_const</a>",
          [
            {
              "full_name": "ciInf_const",
              "def_path": "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean",
              "def_pos": [
                853,
                9
              ],
              "def_end_pos": [
                853,
                20
              ]
            }
          ]
        ],
        "state_before": "case inr\n\u03b1 : Sort u_1\nh\u271d : Nonempty \u03b1\n\u22a2 \u2a05 x, 0 = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.0282570710405707,
    "entry_failed": false
  },
  "2346": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Infix.lean",
    "full_name": "List.length_tails",
    "start": [
      451,
      1
    ],
    "end": [
      454,
      19
    ],
    "traced_tactics": [
      {
        "tactic": "induction' l with x l IH",
        "annotated_tactic": [
          "induction' l with x l IH",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 l\u2083 : List \u03b1\na b : \u03b1\nm n : \u2115\nl : List \u03b1\n\u22a2 l.tails.length = l.length + 1",
        "state_after": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081 l\u2082 l\u2083 : List \u03b1\na b : \u03b1\nm n : \u2115\n\u22a2 [].tails.length = [].length + 1\n\ncase cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 l\u2083 : List \u03b1\na b : \u03b1\nm n : \u2115\nx : \u03b1\nl : List \u03b1\nIH : l.tails.length = l.length + 1\n\u22a2 (x :: l).tails.length = (x :: l).length + 1"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081 l\u2082 l\u2083 : List \u03b1\na b : \u03b1\nm n : \u2115\n\u22a2 [].tails.length = [].length + 1",
        "state_after": "no goals"
      },
      {
        "tactic": "simpa using IH",
        "annotated_tactic": [
          "simpa using IH",
          []
        ],
        "state_before": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl\u271d l\u2081 l\u2082 l\u2083 : List \u03b1\na b : \u03b1\nm n : \u2115\nx : \u03b1\nl : List \u03b1\nIH : l.tails.length = l.length + 1\n\u22a2 (x :: l).tails.length = (x :: l).length + 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.5906553380191326,
    "entry_failed": false
  },
  "2390": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/MetricSpace/PiNat.lean",
    "full_name": "PiNat.eq_of_dist_eq_zero",
    "start": [
      309,
      11
    ],
    "end": [
      311,
      32
    ],
    "traced_tactics": [
      {
        "tactic": "rcases eq_or_ne x y with (rfl | h)",
        "annotated_tactic": [
          "rcases <a>eq_or_ne</a> x y with (rfl | h)",
          [
            {
              "full_name": "eq_or_ne",
              "def_path": "Mathlib/Logic/Basic.lean",
              "def_pos": [
                212,
                9
              ],
              "def_end_pos": [
                212,
                17
              ]
            }
          ]
        ],
        "state_before": "E : \u2115 \u2192 Type u_1\nx y : (n : \u2115) \u2192 E n\nhxy : dist x y = 0\n\u22a2 x = y",
        "state_after": "case inl\nE : \u2115 \u2192 Type u_1\nx : (n : \u2115) \u2192 E n\nhxy : dist x x = 0\n\u22a2 x = x\n\ncase inr\nE : \u2115 \u2192 Type u_1\nx y : (n : \u2115) \u2192 E n\nhxy : dist x y = 0\nh : x \u2260 y\n\u22a2 x = y"
      },
      {
        "tactic": "simp [dist_eq_of_ne h] at hxy",
        "annotated_tactic": [
          "simp [<a>dist_eq_of_ne</a> h] at hxy",
          [
            {
              "full_name": "PiNat.dist_eq_of_ne",
              "def_path": "Mathlib/Topology/MetricSpace/PiNat.lean",
              "def_pos": [
                274,
                9
              ],
              "def_end_pos": [
                274,
                22
              ]
            }
          ]
        ],
        "state_before": "case inr\nE : \u2115 \u2192 Type u_1\nx y : (n : \u2115) \u2192 E n\nhxy : dist x y = 0\nh : x \u2260 y\n\u22a2 x = y",
        "state_after": "no goals"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case inl\nE : \u2115 \u2192 Type u_1\nx : (n : \u2115) \u2192 E n\nhxy : dist x x = 0\n\u22a2 x = x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.8555205350276083,
    "entry_failed": false
  },
  "2428": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Polynomial/Opposites.lean",
    "full_name": "Polynomial.support_opRingEquiv",
    "start": [
      103,
      1
    ],
    "end": [
      106,
      74
    ],
    "traced_tactics": [
      {
        "tactic": "induction' p with p",
        "annotated_tactic": [
          "induction' p with p",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d : Semiring R\np : R[X]\u1d50\u1d52\u1d56\n\u22a2 ((opRingEquiv R) p).support = (unop p).support",
        "state_after": "case h\nR : Type u_1\ninst\u271d : Semiring R\np : R[X]\n\u22a2 ((opRingEquiv R) (op p)).support = (unop (op p)).support"
      },
      {
        "tactic": "cases p",
        "annotated_tactic": [
          "cases p",
          []
        ],
        "state_before": "case h\nR : Type u_1\ninst\u271d : Semiring R\np : R[X]\n\u22a2 ((opRingEquiv R) (op p)).support = (unop (op p)).support",
        "state_after": "case h.ofFinsupp\nR : Type u_1\ninst\u271d : Semiring R\ntoFinsupp\u271d : AddMonoidAlgebra R \u2115\n\u22a2 ((opRingEquiv R) (op { toFinsupp := toFinsupp\u271d })).support = (unop (op { toFinsupp := toFinsupp\u271d })).support"
      },
      {
        "tactic": "exact Finsupp.support_mapRange_of_injective (map_zero _) _ op_injective",
        "annotated_tactic": [
          "exact <a>Finsupp.support_mapRange_of_injective</a> (<a>map_zero</a> _) _ <a>op_injective</a>",
          [
            {
              "full_name": "Finsupp.support_mapRange_of_injective",
              "def_path": "Mathlib/Data/Finsupp/Defs.lean",
              "def_pos": [
                833,
                9
              ],
              "def_end_pos": [
                833,
                38
              ]
            },
            {
              "full_name": "map_zero",
              "def_path": "Mathlib/Algebra/Group/Hom/Defs.lean",
              "def_pos": [
                203,
                3
              ],
              "def_end_pos": [
                203,
                14
              ]
            },
            {
              "full_name": "MulOpposite.op_injective",
              "def_path": "Mathlib/Algebra/Opposites.lean",
              "def_pos": [
                143,
                9
              ],
              "def_end_pos": [
                143,
                21
              ]
            }
          ]
        ],
        "state_before": "case h.ofFinsupp\nR : Type u_1\ninst\u271d : Semiring R\ntoFinsupp\u271d : AddMonoidAlgebra R \u2115\n\u22a2 ((opRingEquiv R) (op { toFinsupp := toFinsupp\u271d })).support = (unop (op { toFinsupp := toFinsupp\u271d })).support",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8031454219017178,
    "entry_failed": false
  },
  "2615": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Surreal/Dyadic.lean",
    "full_name": "Surreal.zsmul_pow_two_powHalf",
    "start": [
      205,
      1
    ],
    "end": [
      209,
      35
    ],
    "traced_tactics": [
      {
        "tactic": "rw [mul_assoc]",
        "annotated_tactic": [
          "rw [<a>mul_assoc</a>]",
          [
            {
              "full_name": "mul_assoc",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                289,
                9
              ],
              "def_end_pos": [
                289,
                18
              ]
            }
          ]
        ],
        "state_before": "m : \u2124\nn k : \u2115\n\u22a2 \u2191m * 2 ^ n * powHalf (n + k) = \u2191m * powHalf k",
        "state_after": "m : \u2124\nn k : \u2115\n\u22a2 \u2191m * (2 ^ n * powHalf (n + k)) = \u2191m * powHalf k"
      },
      {
        "tactic": "congr",
        "annotated_tactic": [
          "congr",
          []
        ],
        "state_before": "m : \u2124\nn k : \u2115\n\u22a2 \u2191m * (2 ^ n * powHalf (n + k)) = \u2191m * powHalf k",
        "state_after": "case e_a\nm : \u2124\nn k : \u2115\n\u22a2 2 ^ n * powHalf (n + k) = powHalf k"
      },
      {
        "tactic": "exact nsmul_pow_two_powHalf' n k",
        "annotated_tactic": [
          "exact <a>nsmul_pow_two_powHalf'</a> n k",
          [
            {
              "full_name": "Surreal.nsmul_pow_two_powHalf'",
              "def_path": "Mathlib/SetTheory/Surreal/Dyadic.lean",
              "def_pos": [
                195,
                9
              ],
              "def_end_pos": [
                195,
                31
              ]
            }
          ]
        ],
        "state_before": "case e_a\nm : \u2124\nn k : \u2115\n\u22a2 2 ^ n * powHalf (n + k) = powHalf k",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.247888998943381,
    "entry_failed": false
  },
  "2616": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Star/Unitary.lean",
    "full_name": "IsUnit.mem_unitary_of_star_mul_self",
    "start": [
      142,
      1
    ],
    "end": [
      146,
      58
    ],
    "traced_tactics": [
      {
        "tactic": "refine unitary.mem_iff.mpr \u27e8h_mul, ?_\u27e9",
        "annotated_tactic": [
          "refine unitary.mem_iff.mpr \u27e8h_mul, ?_\u27e9",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d\u00b9 : Monoid R\ninst\u271d : StarMul R\nu : R\nhu : IsUnit u\nh_mul : star u * u = 1\n\u22a2 u \u2208 unitary R",
        "state_after": "R : Type u_1\ninst\u271d\u00b9 : Monoid R\ninst\u271d : StarMul R\nu : R\nhu : IsUnit u\nh_mul : star u * u = 1\n\u22a2 u * star u = 1"
      },
      {
        "tactic": "lift u to R\u02e3 using hu",
        "annotated_tactic": [
          "lift u to R\u02e3 using hu",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d\u00b9 : Monoid R\ninst\u271d : StarMul R\nu : R\nhu : IsUnit u\nh_mul : star u * u = 1\n\u22a2 u * star u = 1",
        "state_after": "case intro\nR : Type u_1\ninst\u271d\u00b9 : Monoid R\ninst\u271d : StarMul R\nu : R\u02e3\nh_mul : star \u2191u * \u2191u = 1\n\u22a2 \u2191u * star \u2191u = 1"
      },
      {
        "tactic": "exact left_inv_eq_right_inv h_mul u.mul_inv \u25b8 u.mul_inv",
        "annotated_tactic": [
          "exact <a>left_inv_eq_right_inv</a> h_mul u.mul_inv \u25b8 u.mul_inv",
          [
            {
              "full_name": "left_inv_eq_right_inv",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                644,
                22
              ],
              "def_end_pos": [
                644,
                43
              ]
            }
          ]
        ],
        "state_before": "case intro\nR : Type u_1\ninst\u271d\u00b9 : Monoid R\ninst\u271d : StarMul R\nu : R\u02e3\nh_mul : star \u2191u * \u2191u = 1\n\u22a2 \u2191u * star \u2191u = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.4053939770674333,
    "entry_failed": false
  },
  "2668": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/RingHom/Finite.lean",
    "full_name": "RingHom.finite_respectsIso",
    "start": [
      28,
      1
    ],
    "end": [
      31,
      64
    ],
    "traced_tactics": [
      {
        "tactic": "apply finite_stableUnderComposition.respectsIso",
        "annotated_tactic": [
          "apply finite_stableUnderComposition.respectsIso",
          []
        ],
        "state_before": "\u22a2 RespectsIso @Finite",
        "state_after": "\u22a2 \u2200 {R S : Type u_1} [inst : CommRing R] [inst_1 : CommRing S] (e : R \u2243+* S), e.toRingHom.Finite"
      },
      {
        "tactic": "intros",
        "annotated_tactic": [
          "intros",
          []
        ],
        "state_before": "\u22a2 \u2200 {R S : Type u_1} [inst : CommRing R] [inst_1 : CommRing S] (e : R \u2243+* S), e.toRingHom.Finite",
        "state_after": "R\u271d S\u271d : Type u_1\ninst\u271d\u00b9 : CommRing R\u271d\ninst\u271d : CommRing S\u271d\ne\u271d : R\u271d \u2243+* S\u271d\n\u22a2 e\u271d.toRingHom.Finite"
      },
      {
        "tactic": "exact Finite.of_surjective _ (RingEquiv.toEquiv _).surjective",
        "annotated_tactic": [
          "exact <a>Finite.of_surjective</a> _ (<a>RingEquiv.toEquiv</a> _).<a>surjective</a>",
          [
            {
              "full_name": "RingHom.Finite.of_surjective",
              "def_path": "Mathlib/RingTheory/Finiteness.lean",
              "def_pos": [
                829,
                9
              ],
              "def_end_pos": [
                829,
                22
              ]
            },
            {
              "full_name": "RingEquiv.toEquiv",
              "def_path": "Mathlib/Algebra/Ring/Equiv.lean",
              "def_pos": [
                70,
                14
              ],
              "def_end_pos": [
                70,
                31
              ]
            },
            {
              "full_name": "Equiv.surjective",
              "def_path": "Mathlib/Logic/Equiv/Defs.lean",
              "def_pos": [
                199,
                19
              ],
              "def_end_pos": [
                199,
                29
              ]
            }
          ]
        ],
        "state_before": "R\u271d S\u271d : Type u_1\ninst\u271d\u00b9 : CommRing R\u271d\ninst\u271d : CommRing S\u271d\ne\u271d : R\u271d \u2243+* S\u271d\n\u22a2 e\u271d.toRingHom.Finite",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5887010449077934,
    "entry_failed": false
  },
  "2701": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Perm/Support.lean",
    "full_name": "Equiv.Perm.Disjoint.inv_left",
    "start": [
      93,
      1
    ],
    "end": [
      96,
      12
    ],
    "traced_tactics": [
      {
        "tactic": "intro x",
        "annotated_tactic": [
          "intro x",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nf g h\u271d : Perm \u03b1\nh : f.Disjoint g\n\u22a2 f\u207b\u00b9.Disjoint g",
        "state_after": "\u03b1 : Type u_1\nf g h\u271d : Perm \u03b1\nh : f.Disjoint g\nx : \u03b1\n\u22a2 f\u207b\u00b9 x = x \u2228 g x = x"
      },
      {
        "tactic": "rw [inv_eq_iff_eq, eq_comm]",
        "annotated_tactic": [
          "rw [<a>inv_eq_iff_eq</a>, <a>eq_comm</a>]",
          [
            {
              "full_name": "Equiv.Perm.inv_eq_iff_eq",
              "def_path": "Mathlib/GroupTheory/Perm/Basic.lean",
              "def_pos": [
                121,
                9
              ],
              "def_end_pos": [
                121,
                22
              ]
            },
            {
              "full_name": "eq_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                811,
                9
              ],
              "def_end_pos": [
                811,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nf g h\u271d : Perm \u03b1\nh : f.Disjoint g\nx : \u03b1\n\u22a2 f\u207b\u00b9 x = x \u2228 g x = x",
        "state_after": "\u03b1 : Type u_1\nf g h\u271d : Perm \u03b1\nh : f.Disjoint g\nx : \u03b1\n\u22a2 f x = x \u2228 g x = x"
      },
      {
        "tactic": "exact h x",
        "annotated_tactic": [
          "exact h x",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nf g h\u271d : Perm \u03b1\nh : f.Disjoint g\nx : \u03b1\n\u22a2 f x = x \u2228 g x = x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7126737160142511,
    "entry_failed": false
  },
  "2724": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Intervals.lean",
    "full_name": "List.Ico.filter_le",
    "start": [
      207,
      1
    ],
    "end": [
      210,
      50
    ],
    "traced_tactics": [
      {
        "tactic": "rcases le_total n l with hnl | hln",
        "annotated_tactic": [
          "rcases <a>le_total</a> n l with hnl | hln",
          [
            {
              "full_name": "le_total",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                297,
                9
              ],
              "def_end_pos": [
                297,
                17
              ]
            }
          ]
        ],
        "state_before": "n m l : \u2115\n\u22a2 filter (fun x => decide (l \u2264 x)) (Ico n m) = Ico (max n l) m",
        "state_after": "case inl\nn m l : \u2115\nhnl : n \u2264 l\n\u22a2 filter (fun x => decide (l \u2264 x)) (Ico n m) = Ico (max n l) m\n\ncase inr\nn m l : \u2115\nhln : l \u2264 n\n\u22a2 filter (fun x => decide (l \u2264 x)) (Ico n m) = Ico (max n l) m"
      },
      {
        "tactic": "rw [max_eq_right hnl, filter_le_of_le hnl]",
        "annotated_tactic": [
          "rw [<a>max_eq_right</a> hnl, <a>filter_le_of_le</a> hnl]",
          [
            {
              "full_name": "max_eq_right",
              "def_path": "Mathlib/Init/Order/LinearOrder.lean",
              "def_pos": [
                137,
                9
              ],
              "def_end_pos": [
                137,
                21
              ]
            },
            {
              "full_name": "List.Ico.filter_le_of_le",
              "def_path": "Mathlib/Data/List/Intervals.lean",
              "def_pos": [
                198,
                9
              ],
              "def_end_pos": [
                198,
                24
              ]
            }
          ]
        ],
        "state_before": "case inl\nn m l : \u2115\nhnl : n \u2264 l\n\u22a2 filter (fun x => decide (l \u2264 x)) (Ico n m) = Ico (max n l) m",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [max_eq_left hln, filter_le_of_le_bot hln]",
        "annotated_tactic": [
          "rw [<a>max_eq_left</a> hln, <a>filter_le_of_le_bot</a> hln]",
          [
            {
              "full_name": "max_eq_left",
              "def_path": "Mathlib/Init/Order/LinearOrder.lean",
              "def_pos": [
                133,
                9
              ],
              "def_end_pos": [
                133,
                20
              ]
            },
            {
              "full_name": "List.Ico.filter_le_of_le_bot",
              "def_path": "Mathlib/Data/List/Intervals.lean",
              "def_pos": [
                185,
                9
              ],
              "def_end_pos": [
                185,
                28
              ]
            }
          ]
        ],
        "state_before": "case inr\nn m l : \u2115\nhln : l \u2264 n\n\u22a2 filter (fun x => decide (l \u2264 x)) (Ico n m) = Ico (max n l) m",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5970939790131524,
    "entry_failed": false
  },
  "2757": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Tactic/Congr!.lean",
    "full_name": "implies_congr'",
    "start": [
      414,
      9
    ],
    "end": [
      418,
      17
    ],
    "traced_tactics": [
      {
        "tactic": "cases h",
        "annotated_tactic": [
          "cases h",
          []
        ],
        "state_before": "\u03b1 \u03b1' : Sort u\n\u03b2 \u03b2' : Sort v\nh : \u03b1 = \u03b1'\nh' : \u03b1' \u2192 \u03b2 = \u03b2'\n\u22a2 (\u03b1 \u2192 \u03b2) = (\u03b1' \u2192 \u03b2')",
        "state_after": "case refl\n\u03b1 : Sort u\n\u03b2 \u03b2' : Sort v\nh' : \u03b1 \u2192 \u03b2 = \u03b2'\n\u22a2 (\u03b1 \u2192 \u03b2) = (\u03b1 \u2192 \u03b2')"
      },
      {
        "tactic": "show (\u2200 (x : \u03b1), (fun _ => \u03b2) x) = _",
        "annotated_tactic": [
          "show (\u2200 (x : \u03b1), (fun _ => \u03b2) x) = _",
          []
        ],
        "state_before": "case refl\n\u03b1 : Sort u\n\u03b2 \u03b2' : Sort v\nh' : \u03b1 \u2192 \u03b2 = \u03b2'\n\u22a2 (\u03b1 \u2192 \u03b2) = (\u03b1 \u2192 \u03b2')",
        "state_after": "case refl\n\u03b1 : Sort u\n\u03b2 \u03b2' : Sort v\nh' : \u03b1 \u2192 \u03b2 = \u03b2'\n\u22a2 ((x : \u03b1) \u2192 (fun x => \u03b2) x) = (\u03b1 \u2192 \u03b2')"
      },
      {
        "tactic": "rw [funext h']",
        "annotated_tactic": [
          "rw [<a>funext</a> h']",
          [
            {
              "full_name": "funext",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1817,
                9
              ],
              "def_end_pos": [
                1817,
                15
              ]
            }
          ]
        ],
        "state_before": "case refl\n\u03b1 : Sort u\n\u03b2 \u03b2' : Sort v\nh' : \u03b1 \u2192 \u03b2 = \u03b2'\n\u22a2 ((x : \u03b1) \u2192 (fun x => \u03b2) x) = (\u03b1 \u2192 \u03b2')",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.7149112089537084,
    "entry_failed": false
  },
  "2772": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Cast/Defs.lean",
    "full_name": "one_add_one_eq_two",
    "start": [
      231,
      1
    ],
    "end": [
      234,
      9
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 Nat.cast_one, \u2190 Nat.cast_add]",
        "annotated_tactic": [
          "rw [\u2190 <a>Nat.cast_one</a>, \u2190 <a>Nat.cast_add</a>]",
          [
            {
              "full_name": "Nat.cast_one",
              "def_path": "Mathlib/Data/Nat/Cast/Defs.lean",
              "def_pos": [
                154,
                9
              ],
              "def_end_pos": [
                154,
                17
              ]
            },
            {
              "full_name": "Nat.cast_add",
              "def_path": "Mathlib/Data/Nat/Cast/Defs.lean",
              "def_pos": [
                159,
                9
              ],
              "def_end_pos": [
                159,
                17
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d : AddMonoidWithOne R\n\u22a2 1 + 1 = 2",
        "state_after": "R : Type u_1\ninst\u271d : AddMonoidWithOne R\n\u22a2 \u2191(1 + 1) = 2"
      },
      {
        "tactic": "apply congrArg",
        "annotated_tactic": [
          "apply <a>congrArg</a>",
          [
            {
              "full_name": "congrArg",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                362,
                9
              ],
              "def_end_pos": [
                362,
                17
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d : AddMonoidWithOne R\n\u22a2 \u2191(1 + 1) = 2",
        "state_after": "case h\nR : Type u_1\ninst\u271d : AddMonoidWithOne R\n\u22a2 1 + 1 = 2"
      },
      {
        "tactic": "decide",
        "annotated_tactic": [
          "decide",
          []
        ],
        "state_before": "case h\nR : Type u_1\ninst\u271d : AddMonoidWithOne R\n\u22a2 1 + 1 = 2",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.472874380997382,
    "entry_failed": false
  },
  "2816": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Order/UpperLowerSetTopology.lean",
    "full_name": "Topology.isUpperSet_orderDual",
    "start": [
      353,
      1
    ],
    "end": [
      357,
      35
    ],
    "traced_tactics": [
      {
        "tactic": "constructor",
        "annotated_tactic": [
          "constructor",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 Topology.IsUpperSet \u03b1\u1d52\u1d48 \u2194 Topology.IsLowerSet \u03b1",
        "state_after": "case mp\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 Topology.IsUpperSet \u03b1\u1d52\u1d48 \u2192 Topology.IsLowerSet \u03b1\n\ncase mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 Topology.IsLowerSet \u03b1 \u2192 Topology.IsUpperSet \u03b1\u1d52\u1d48"
      },
      {
        "tactic": "apply OrderDual.instIsLowerSet",
        "annotated_tactic": [
          "apply <a>OrderDual.instIsLowerSet</a>",
          [
            {
              "full_name": "OrderDual.instIsLowerSet",
              "def_path": "Mathlib/Topology/Order/UpperLowerSetTopology.lean",
              "def_pos": [
                216,
                10
              ],
              "def_end_pos": [
                216,
                41
              ]
            }
          ]
        ],
        "state_before": "case mp\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 Topology.IsUpperSet \u03b1\u1d52\u1d48 \u2192 Topology.IsLowerSet \u03b1",
        "state_after": "no goals"
      },
      {
        "tactic": "apply OrderDual.instIsUpperSet",
        "annotated_tactic": [
          "apply <a>OrderDual.instIsUpperSet</a>",
          [
            {
              "full_name": "OrderDual.instIsUpperSet",
              "def_path": "Mathlib/Topology/Order/UpperLowerSetTopology.lean",
              "def_pos": [
                299,
                10
              ],
              "def_end_pos": [
                299,
                41
              ]
            }
          ]
        ],
        "state_before": "case mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 Topology.IsLowerSet \u03b1 \u2192 Topology.IsUpperSet \u03b1\u1d52\u1d48",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.0206004730425775,
    "entry_failed": false
  },
  "2861": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/Padics/PadicNorm.lean",
    "full_name": "padicNorm.padicNorm_of_prime_of_ne",
    "start": [
      94,
      1
    ],
    "end": [
      98,
      27
    ],
    "traced_tactics": [
      {
        "tactic": "have p : padicValRat p q = 0 := mod_cast padicValNat_primes neq",
        "annotated_tactic": [
          "have p : <a>padicValRat</a> p q = 0 := mod_cast <a>padicValNat_primes</a> neq",
          [
            {
              "full_name": "padicValRat",
              "def_path": "Mathlib/NumberTheory/Padics/PadicVal.lean",
              "def_pos": [
                200,
                5
              ],
              "def_end_pos": [
                200,
                16
              ]
            },
            {
              "full_name": "padicValNat_primes",
              "def_path": "Mathlib/NumberTheory/Padics/PadicVal.lean",
              "def_pos": [
                594,
                9
              ],
              "def_end_pos": [
                594,
                27
              ]
            }
          ]
        ],
        "state_before": "p q : \u2115\np_prime : Fact (Nat.Prime p)\nq_prime : Fact (Nat.Prime q)\nneq : p \u2260 q\n\u22a2 padicNorm p \u2191q = 1",
        "state_after": "p\u271d q : \u2115\np_prime : Fact (Nat.Prime p\u271d)\nq_prime : Fact (Nat.Prime q)\nneq : p\u271d \u2260 q\np : padicValRat p\u271d \u2191q = 0\n\u22a2 padicNorm p\u271d \u2191q = 1"
      },
      {
        "tactic": "rw [padicNorm, p]",
        "annotated_tactic": [
          "rw [<a>padicNorm</a>, p]",
          [
            {
              "full_name": "padicNorm",
              "def_path": "Mathlib/NumberTheory/Padics/PadicNorm.lean",
              "def_pos": [
                42,
                5
              ],
              "def_end_pos": [
                42,
                14
              ]
            }
          ]
        ],
        "state_before": "p\u271d q : \u2115\np_prime : Fact (Nat.Prime p\u271d)\nq_prime : Fact (Nat.Prime q)\nneq : p\u271d \u2260 q\np : padicValRat p\u271d \u2191q = 0\n\u22a2 padicNorm p\u271d \u2191q = 1",
        "state_after": "p\u271d q : \u2115\np_prime : Fact (Nat.Prime p\u271d)\nq_prime : Fact (Nat.Prime q)\nneq : p\u271d \u2260 q\np : padicValRat p\u271d \u2191q = 0\n\u22a2 (if \u2191q = 0 then 0 else \u2191p\u271d ^ (-0)) = 1"
      },
      {
        "tactic": "simp [q_prime.1.ne_zero]",
        "annotated_tactic": [
          "simp [q_prime.1.<a>ne_zero</a>]",
          [
            {
              "full_name": "Nat.Prime.ne_zero",
              "def_path": "Mathlib/Data/Nat/Prime.lean",
              "def_pos": [
                61,
                9
              ],
              "def_end_pos": [
                61,
                22
              ]
            }
          ]
        ],
        "state_before": "p\u271d q : \u2115\np_prime : Fact (Nat.Prime p\u271d)\nq_prime : Fact (Nat.Prime q)\nneq : p\u271d \u2260 q\np : padicValRat p\u271d \u2191q = 0\n\u22a2 (if \u2191q = 0 then 0 else \u2191p\u271d ^ (-0)) = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6263818939914927,
    "entry_failed": false
  },
  "2909": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/LSeries/HurwitzZeta.lean",
    "full_name": "HurwitzZeta.sinZeta_eq",
    "start": [
      119,
      1
    ],
    "end": [
      123,
      10
    ],
    "traced_tactics": [
      {
        "tactic": "rw [expZeta, expZeta, cosZeta_neg, sinZeta_neg]",
        "annotated_tactic": [
          "rw [<a>expZeta</a>, <a>expZeta</a>, <a>cosZeta_neg</a>, <a>sinZeta_neg</a>]",
          [
            {
              "full_name": "HurwitzZeta.expZeta",
              "def_path": "Mathlib/NumberTheory/LSeries/HurwitzZeta.lean",
              "def_pos": [
                111,
                19
              ],
              "def_end_pos": [
                111,
                26
              ]
            },
            {
              "full_name": "HurwitzZeta.expZeta",
              "def_path": "Mathlib/NumberTheory/LSeries/HurwitzZeta.lean",
              "def_pos": [
                111,
                19
              ],
              "def_end_pos": [
                111,
                26
              ]
            },
            {
              "full_name": "HurwitzZeta.cosZeta_neg",
              "def_path": "Mathlib/NumberTheory/LSeries/HurwitzZetaEven.lean",
              "def_pos": [
                723,
                7
              ],
              "def_end_pos": [
                723,
                18
              ]
            },
            {
              "full_name": "HurwitzZeta.sinZeta_neg",
              "def_path": "Mathlib/NumberTheory/LSeries/HurwitzZetaOdd.lean",
              "def_pos": [
                482,
                7
              ],
              "def_end_pos": [
                482,
                18
              ]
            }
          ]
        ],
        "state_before": "a : UnitAddCircle\ns : \u2102\n\u22a2 sinZeta a s = (expZeta a s - expZeta (-a) s) / (2 * I)",
        "state_after": "a : UnitAddCircle\ns : \u2102\n\u22a2 sinZeta a s = (cosZeta a s + I * sinZeta a s - (cosZeta a s + I * -sinZeta a s)) / (2 * I)"
      },
      {
        "tactic": "field_simp",
        "annotated_tactic": [
          "field_simp",
          []
        ],
        "state_before": "a : UnitAddCircle\ns : \u2102\n\u22a2 sinZeta a s = (cosZeta a s + I * sinZeta a s - (cosZeta a s + I * -sinZeta a s)) / (2 * I)",
        "state_after": "a : UnitAddCircle\ns : \u2102\n\u22a2 sinZeta a s * (2 * I) = I * sinZeta a s + I * sinZeta a s"
      },
      {
        "tactic": "ring_nf",
        "annotated_tactic": [
          "ring_nf",
          []
        ],
        "state_before": "a : UnitAddCircle\ns : \u2102\n\u22a2 sinZeta a s * (2 * I) = I * sinZeta a s + I * sinZeta a s",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.437774076941423,
    "entry_failed": false
  },
  "2946": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Group/Submonoid/Membership.lean",
    "full_name": "list_prod_mem",
    "start": [
      73,
      1
    ],
    "end": [
      76,
      24
    ],
    "traced_tactics": [
      {
        "tactic": "lift l to List S using hl",
        "annotated_tactic": [
          "lift l to <a>List</a> S using hl",
          [
            {
              "full_name": "List",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                2284,
                11
              ],
              "def_end_pos": [
                2284,
                15
              ]
            }
          ]
        ],
        "state_before": "M : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : SetLike B M\ninst\u271d : SubmonoidClass B M\nS : B\nl : List M\nhl : \u2200 x \u2208 l, x \u2208 S\n\u22a2 l.prod \u2208 S",
        "state_after": "case intro\nM : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : SetLike B M\ninst\u271d : SubmonoidClass B M\nS : B\nl : List \u21a5S\n\u22a2 (List.map Subtype.val l).prod \u2208 S"
      },
      {
        "tactic": "rw [\u2190 coe_list_prod]",
        "annotated_tactic": [
          "rw [\u2190 <a>coe_list_prod</a>]",
          [
            {
              "full_name": "SubmonoidClass.coe_list_prod",
              "def_path": "Mathlib/Algebra/Group/Submonoid/Membership.lean",
              "def_pos": [
                48,
                9
              ],
              "def_end_pos": [
                48,
                22
              ]
            }
          ]
        ],
        "state_before": "case intro\nM : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : SetLike B M\ninst\u271d : SubmonoidClass B M\nS : B\nl : List \u21a5S\n\u22a2 (List.map Subtype.val l).prod \u2208 S",
        "state_after": "case intro\nM : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : SetLike B M\ninst\u271d : SubmonoidClass B M\nS : B\nl : List \u21a5S\n\u22a2 \u2191l.prod \u2208 S"
      },
      {
        "tactic": "exact l.prod.coe_prop",
        "annotated_tactic": [
          "exact l.prod.coe_prop",
          []
        ],
        "state_before": "case intro\nM : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : SetLike B M\ninst\u271d : SubmonoidClass B M\nS : B\nl : List \u21a5S\n\u22a2 \u2191l.prod \u2208 S",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.099626387003809,
    "entry_failed": false
  },
  "2988": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Disjoint.lean",
    "full_name": "Codisjoint.ne_bot_of_ne_top",
    "start": [
      313,
      1
    ],
    "end": [
      314,
      43
    ],
    "traced_tactics": [
      {
        "tactic": "rintro rfl",
        "annotated_tactic": [
          "rintro rfl",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : BoundedOrder \u03b1\na b : \u03b1\nh : Codisjoint a b\nha : a \u2260 \u22a4\n\u22a2 b \u2260 \u22a5",
        "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : BoundedOrder \u03b1\na : \u03b1\nha : a \u2260 \u22a4\nh : Codisjoint a \u22a5\n\u22a2 False"
      },
      {
        "tactic": "exact ha <| by simpa using h",
        "annotated_tactic": [
          "exact ha <| by simpa using h",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : BoundedOrder \u03b1\na : \u03b1\nha : a \u2260 \u22a4\nh : Codisjoint a \u22a5\n\u22a2 False",
        "state_after": "no goals"
      },
      {
        "tactic": "simpa using h",
        "annotated_tactic": [
          "simpa using h",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : BoundedOrder \u03b1\na : \u03b1\nha : a \u2260 \u22a4\nh : Codisjoint a \u22a5\n\u22a2 a = \u22a4",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9869772909441963,
    "entry_failed": false
  },
  "2993": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Logic/Equiv/Fin.lean",
    "full_name": "finRotate_of_lt",
    "start": [
      394,
      1
    ],
    "end": [
      398,
      50
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "m n k : \u2115\nh : k < n\n\u22a2 (finRotate (n + 1)) \u27e8k, \u22ef\u27e9 = \u27e8k + 1, \u22ef\u27e9",
        "state_after": "case h\nm n k : \u2115\nh : k < n\n\u22a2 \u2191((finRotate (n + 1)) \u27e8k, \u22ef\u27e9) = \u2191\u27e8k + 1, \u22ef\u27e9"
      },
      {
        "tactic": "dsimp [finRotate_succ]",
        "annotated_tactic": [
          "dsimp [<a>finRotate_succ</a>]",
          [
            {
              "full_name": "finRotate_succ",
              "def_path": "Mathlib/Logic/Equiv/Fin.lean",
              "def_pos": [
                391,
                7
              ],
              "def_end_pos": [
                391,
                21
              ]
            }
          ]
        ],
        "state_before": "case h\nm n k : \u2115\nh : k < n\n\u22a2 \u2191((finRotate (n + 1)) \u27e8k, \u22ef\u27e9) = \u2191\u27e8k + 1, \u22ef\u27e9",
        "state_after": "case h\nm n k : \u2115\nh : k < n\n\u22a2 \u2191(finAddFlip \u27e8k, \u22ef\u27e9) = k + 1"
      },
      {
        "tactic": "simp [finAddFlip_apply_mk_left h, Nat.add_comm]",
        "annotated_tactic": [
          "simp [<a>finAddFlip_apply_mk_left</a> h, <a>Nat.add_comm</a>]",
          [
            {
              "full_name": "finAddFlip_apply_mk_left",
              "def_path": "Mathlib/Logic/Equiv/Fin.lean",
              "def_pos": [
                369,
                9
              ],
              "def_end_pos": [
                369,
                33
              ]
            },
            {
              "full_name": "Nat.add_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean",
              "def_pos": [
                160,
                19
              ],
              "def_end_pos": [
                160,
                27
              ]
            }
          ]
        ],
        "state_before": "case h\nm n k : \u2115\nh : k < n\n\u22a2 \u2191(finAddFlip \u27e8k, \u22ef\u27e9) = k + 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.9617184899980202,
    "entry_failed": false
  },
  "3000": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/AlgebraicGeometry/AffineScheme.lean",
    "full_name": "AlgebraicGeometry.isAffineOpen_top",
    "start": [
      201,
      1
    ],
    "end": [
      204,
      26
    ],
    "traced_tactics": [
      {
        "tactic": "convert isAffineOpen_opensRange (\ud835\udfd9 X)",
        "annotated_tactic": [
          "convert <a>isAffineOpen_opensRange</a> (\ud835\udfd9 X)",
          [
            {
              "full_name": "AlgebraicGeometry.isAffineOpen_opensRange",
              "def_path": "Mathlib/AlgebraicGeometry/AffineScheme.lean",
              "def_pos": [
                195,
                9
              ],
              "def_end_pos": [
                195,
                32
              ]
            }
          ]
        ],
        "state_before": "X : Scheme\ninst\u271d : IsAffine X\n\u22a2 IsAffineOpen \u22a4",
        "state_after": "case h.e'_2\nX : Scheme\ninst\u271d : IsAffine X\n\u22a2 \u22a4 = Scheme.Hom.opensRange (\ud835\udfd9 X)"
      },
      {
        "tactic": "ext1",
        "annotated_tactic": [
          "ext1",
          []
        ],
        "state_before": "case h.e'_2\nX : Scheme\ninst\u271d : IsAffine X\n\u22a2 \u22a4 = Scheme.Hom.opensRange (\ud835\udfd9 X)",
        "state_after": "case h.e'_2.h\nX : Scheme\ninst\u271d : IsAffine X\n\u22a2 \u2191\u22a4 = \u2191(Scheme.Hom.opensRange (\ud835\udfd9 X))"
      },
      {
        "tactic": "exact Set.range_id.symm",
        "annotated_tactic": [
          "exact Set.range_id.symm",
          []
        ],
        "state_before": "case h.e'_2.h\nX : Scheme\ninst\u271d : IsAffine X\n\u22a2 \u2191\u22a4 = \u2191(Scheme.Hom.opensRange (\ud835\udfd9 X))",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.022345341043547,
    "entry_failed": false
  },
  "3038": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Vector/Mem.lean",
    "full_name": "Vector.not_mem_nil",
    "start": [
      38,
      1
    ],
    "end": [
      41,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "unfold Vector.nil",
        "annotated_tactic": [
          "unfold <a>Vector.nil</a>",
          [
            {
              "full_name": "Vector.nil",
              "def_path": "Mathlib/Data/Vector/Defs.lean",
              "def_pos": [
                33,
                5
              ],
              "def_end_pos": [
                33,
                8
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : \u2115\na a' : \u03b1\n\u22a2 a \u2209 nil.toList",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : \u2115\na a' : \u03b1\n\u22a2 a \u2209 toList \u27e8[], \u22ef\u27e9"
      },
      {
        "tactic": "dsimp",
        "annotated_tactic": [
          "dsimp",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : \u2115\na a' : \u03b1\n\u22a2 a \u2209 toList \u27e8[], \u22ef\u27e9",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : \u2115\na a' : \u03b1\n\u22a2 a \u2209 []"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : \u2115\na a' : \u03b1\n\u22a2 a \u2209 []",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.1442817019997165,
    "entry_failed": false
  },
  "3158": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Category/MonCat/Colimits.lean",
    "full_name": "MonCat.Colimits.cocone_naturality",
    "start": [
      179,
      1
    ],
    "end": [
      183,
      21
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "J : Type v\ninst\u271d : SmallCategory J\nF : J \u2964 MonCat\nj j' : J\nf : j \u27f6 j'\n\u22a2 F.map f \u226b coconeMorphism F j' = coconeMorphism F j",
        "state_after": "case w\nJ : Type v\ninst\u271d : SmallCategory J\nF : J \u2964 MonCat\nj j' : J\nf : j \u27f6 j'\nx\u271d : \u2191(F.obj j)\n\u22a2 (F.map f \u226b coconeMorphism F j') x\u271d = (coconeMorphism F j) x\u271d"
      },
      {
        "tactic": "apply Quot.sound",
        "annotated_tactic": [
          "apply <a>Quot.sound</a>",
          [
            {
              "full_name": "Quot.sound",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1471,
                7
              ],
              "def_end_pos": [
                1471,
                12
              ]
            }
          ]
        ],
        "state_before": "case w\nJ : Type v\ninst\u271d : SmallCategory J\nF : J \u2964 MonCat\nj j' : J\nf : j \u27f6 j'\nx\u271d : \u2191(F.obj j)\n\u22a2 (F.map f \u226b coconeMorphism F j') x\u271d = (coconeMorphism F j) x\u271d",
        "state_after": "case w.a\nJ : Type v\ninst\u271d : SmallCategory J\nF : J \u2964 MonCat\nj j' : J\nf : j \u27f6 j'\nx\u271d : \u2191(F.obj j)\n\u22a2 Setoid.r (Prequotient.of j' ((F.map f) x\u271d)) (Prequotient.of j x\u271d)"
      },
      {
        "tactic": "apply Relation.map",
        "annotated_tactic": [
          "apply <a>Relation.map</a>",
          [
            {
              "full_name": "MonCat.Colimits.Relation.map",
              "def_path": "Mathlib/Algebra/Category/MonCat/Colimits.lean",
              "def_pos": [
                96,
                5
              ],
              "def_end_pos": [
                96,
                8
              ]
            }
          ]
        ],
        "state_before": "case w.a\nJ : Type v\ninst\u271d : SmallCategory J\nF : J \u2964 MonCat\nj j' : J\nf : j \u27f6 j'\nx\u271d : \u2191(F.obj j)\n\u22a2 Setoid.r (Prequotient.of j' ((F.map f) x\u271d)) (Prequotient.of j x\u271d)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5971424980089068,
    "entry_failed": false
  },
  "3185": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Bits.lean",
    "full_name": "Nat.bodd_succ",
    "start": [
      67,
      1
    ],
    "end": [
      71,
      18
    ],
    "traced_tactics": [
      {
        "tactic": "simp only [bodd, boddDiv2]",
        "annotated_tactic": [
          "simp only [<a>bodd</a>, <a>boddDiv2</a>]",
          [
            {
              "full_name": "Nat.bodd",
              "def_path": "Mathlib/Data/Nat/Bits.lean",
              "def_pos": [
                55,
                5
              ],
              "def_end_pos": [
                55,
                9
              ]
            },
            {
              "full_name": "Nat.boddDiv2",
              "def_path": "Mathlib/Data/Nat/Bits.lean",
              "def_pos": [
                42,
                5
              ],
              "def_end_pos": [
                42,
                13
              ]
            }
          ]
        ],
        "state_before": "m n\u271d n : \u2115\n\u22a2 n.succ.bodd = !n.bodd",
        "state_after": "m n\u271d n : \u2115\n\u22a2 (match n.boddDiv2 with\n      | (false, m) => (true, m)\n      | (true, m) => (false, m.succ)).1 =\n    !n.boddDiv2.1"
      },
      {
        "tactic": "let \u27e8b,m\u27e9 := boddDiv2 n",
        "annotated_tactic": [
          "let \u27e8b,m\u27e9 := <a>boddDiv2</a> n",
          [
            {
              "full_name": "Nat.boddDiv2",
              "def_path": "Mathlib/Data/Nat/Bits.lean",
              "def_pos": [
                42,
                5
              ],
              "def_end_pos": [
                42,
                13
              ]
            }
          ]
        ],
        "state_before": "m n\u271d n : \u2115\n\u22a2 (match n.boddDiv2 with\n      | (false, m) => (true, m)\n      | (true, m) => (false, m.succ)).1 =\n    !n.boddDiv2.1",
        "state_after": "m\u271d n\u271d n : \u2115\nb : Bool\nm : \u2115\n\u22a2 (match (b, m) with\n      | (false, m) => (true, m)\n      | (true, m) => (false, m.succ)).1 =\n    !(b, m).1"
      },
      {
        "tactic": "cases b <;> rfl",
        "annotated_tactic": [
          "cases b <;> rfl",
          []
        ],
        "state_before": "m\u271d n\u271d n : \u2115\nb : Bool\nm : \u2115\n\u22a2 (match (b, m) with\n      | (false, m) => (true, m)\n      | (true, m) => (false, m.succ)).1 =\n    !(b, m).1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4215162369655445,
    "entry_failed": false
  },
  "3191": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Finset/Sym.lean",
    "full_name": "Finset.sym2_mono",
    "start": [
      69,
      1
    ],
    "end": [
      72,
      19
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 val_le_iff, sym2_val, sym2_val]",
        "annotated_tactic": [
          "rw [\u2190 <a>val_le_iff</a>, <a>sym2_val</a>, <a>sym2_val</a>]",
          [
            {
              "full_name": "Finset.val_le_iff",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                381,
                9
              ],
              "def_end_pos": [
                381,
                19
              ]
            },
            {
              "full_name": "Finset.sym2_val",
              "def_path": "Mathlib/Data/Finset/Sym.lean",
              "def_pos": [
                39,
                3
              ],
              "def_end_pos": [
                39,
                8
              ]
            },
            {
              "full_name": "Finset.sym2_val",
              "def_path": "Mathlib/Data/Finset/Sym.lean",
              "def_pos": [
                39,
                3
              ],
              "def_end_pos": [
                39,
                8
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ns t : Finset \u03b1\na b : \u03b1\nh : s \u2286 t\n\u22a2 s.sym2 \u2286 t.sym2",
        "state_after": "\u03b1 : Type u_1\ns t : Finset \u03b1\na b : \u03b1\nh : s \u2286 t\n\u22a2 s.val.sym2 \u2264 t.val.sym2"
      },
      {
        "tactic": "apply Multiset.sym2_mono",
        "annotated_tactic": [
          "apply <a>Multiset.sym2_mono</a>",
          [
            {
              "full_name": "Multiset.sym2_mono",
              "def_path": "Mathlib/Data/Multiset/Sym.lean",
              "def_pos": [
                63,
                9
              ],
              "def_end_pos": [
                63,
                18
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ns t : Finset \u03b1\na b : \u03b1\nh : s \u2286 t\n\u22a2 s.val.sym2 \u2264 t.val.sym2",
        "state_after": "case h\n\u03b1 : Type u_1\ns t : Finset \u03b1\na b : \u03b1\nh : s \u2286 t\n\u22a2 s.val \u2264 t.val"
      },
      {
        "tactic": "rwa [val_le_iff]",
        "annotated_tactic": [
          "rwa [<a>val_le_iff</a>]",
          [
            {
              "full_name": "Finset.val_le_iff",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                381,
                9
              ],
              "def_end_pos": [
                381,
                19
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u_1\ns t : Finset \u03b1\na b : \u03b1\nh : s \u2286 t\n\u22a2 s.val \u2264 t.val",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.3260271130129695,
    "entry_failed": false
  },
  "3193": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Join.lean",
    "full_name": "List.reverse_join",
    "start": [
      205,
      1
    ],
    "end": [
      209,
      72
    ],
    "traced_tactics": [
      {
        "tactic": "induction' L with _ _ ih",
        "annotated_tactic": [
          "induction' L with _ _ ih",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nL : List (List \u03b1)\n\u22a2 L.join.reverse = (map reverse L).reverse.join",
        "state_after": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u22a2 [].join.reverse = (map reverse []).reverse.join\n\ncase cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nhead\u271d : List \u03b1\ntail\u271d : List (List \u03b1)\nih : tail\u271d.join.reverse = (map reverse tail\u271d).reverse.join\n\u22a2 (head\u271d :: tail\u271d).join.reverse = (map reverse (head\u271d :: tail\u271d)).reverse.join"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u22a2 [].join.reverse = (map reverse []).reverse.join",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [join, reverse_append, ih, map_cons, reverse_cons', join_concat]",
        "annotated_tactic": [
          "rw [<a>join</a>, <a>reverse_append</a>, ih, <a>map_cons</a>, <a>reverse_cons'</a>, <a>join_concat</a>]",
          [
            {
              "full_name": "List.join",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean",
              "def_pos": [
                532,
                5
              ],
              "def_end_pos": [
                532,
                9
              ]
            },
            {
              "full_name": "List.reverse_append",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean",
              "def_pos": [
                1477,
                17
              ],
              "def_end_pos": [
                1477,
                31
              ]
            },
            {
              "full_name": "List.map_cons",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean",
              "def_pos": [
                366,
                17
              ],
              "def_end_pos": [
                366,
                25
              ]
            },
            {
              "full_name": "List.reverse_cons'",
              "def_path": "Mathlib/Data/List/Basic.lean",
              "def_pos": [
                517,
                9
              ],
              "def_end_pos": [
                517,
                22
              ]
            },
            {
              "full_name": "List.join_concat",
              "def_path": "Mathlib/Data/List/Join.lean",
              "def_pos": [
                42,
                9
              ],
              "def_end_pos": [
                42,
                20
              ]
            }
          ]
        ],
        "state_before": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nhead\u271d : List \u03b1\ntail\u271d : List (List \u03b1)\nih : tail\u271d.join.reverse = (map reverse tail\u271d).reverse.join\n\u22a2 (head\u271d :: tail\u271d).join.reverse = (map reverse (head\u271d :: tail\u271d)).reverse.join",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4921908240066841,
    "entry_failed": false
  },
  "3278": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Archimedean.lean",
    "full_name": "exists_nat_ge",
    "start": [
      120,
      1
    ],
    "end": [
      122,
      73
    ],
    "traced_tactics": [
      {
        "tactic": "nontriviality \u03b1",
        "annotated_tactic": [
          "nontriviality \u03b1",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : OrderedSemiring \u03b1\ninst\u271d : Archimedean \u03b1\nx : \u03b1\n\u22a2 \u2203 n, x \u2264 \u2191n",
        "state_after": "\u03b1 : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : OrderedSemiring \u03b1\ninst\u271d : Archimedean \u03b1\nx : \u03b1\na\u271d : Nontrivial \u03b1\n\u22a2 \u2203 n, x \u2264 \u2191n"
      },
      {
        "tactic": "exact (Archimedean.arch x one_pos).imp fun n h => by rwa [\u2190 nsmul_one]",
        "annotated_tactic": [
          "exact (<a>Archimedean.arch</a> x <a>one_pos</a>).<a>imp</a> fun n h => by rwa [\u2190 <a>nsmul_one</a>]",
          [
            {
              "full_name": "Archimedean.arch",
              "def_path": "Mathlib/Algebra/Order/Archimedean.lean",
              "def_pos": [
                41,
                3
              ],
              "def_end_pos": [
                41,
                7
              ]
            },
            {
              "full_name": "one_pos",
              "def_path": "Mathlib/Algebra/Order/ZeroLEOne.lean",
              "def_pos": [
                50,
                7
              ],
              "def_end_pos": [
                50,
                14
              ]
            },
            {
              "full_name": "Exists.imp",
              "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean",
              "def_pos": [
                193,
                9
              ],
              "def_end_pos": [
                193,
                19
              ]
            },
            {
              "full_name": "nsmul_one",
              "def_path": "Mathlib/Data/Nat/Cast/Basic.lean",
              "def_pos": [
                144,
                15
              ],
              "def_end_pos": [
                144,
                24
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : OrderedSemiring \u03b1\ninst\u271d : Archimedean \u03b1\nx : \u03b1\na\u271d : Nontrivial \u03b1\n\u22a2 \u2203 n, x \u2264 \u2191n",
        "state_after": "no goals"
      },
      {
        "tactic": "rwa [\u2190 nsmul_one]",
        "annotated_tactic": [
          "rwa [\u2190 <a>nsmul_one</a>]",
          [
            {
              "full_name": "nsmul_one",
              "def_path": "Mathlib/Data/Nat/Cast/Basic.lean",
              "def_pos": [
                144,
                15
              ],
              "def_end_pos": [
                144,
                24
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : OrderedSemiring \u03b1\ninst\u271d : Archimedean \u03b1\nx : \u03b1\na\u271d : Nontrivial \u03b1\nn : \u2115\nh : x \u2264 n \u2022 1\n\u22a2 x \u2264 \u2191n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.9380808549467474,
    "entry_failed": false
  },
  "3347": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Group/Even.lean",
    "full_name": "IsSquare.map",
    "start": [
      100,
      1
    ],
    "end": [
      105,
      23
    ],
    "traced_tactics": [
      {
        "tactic": "rintro \u27e8m, rfl\u27e9",
        "annotated_tactic": [
          "rintro \u27e8m, rfl\u27e9",
          []
        ],
        "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : MulOneClass \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : MonoidHomClass F \u03b1 \u03b2\nm : \u03b1\nf : F\n\u22a2 IsSquare m \u2192 IsSquare (f m)",
        "state_after": "case intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : MulOneClass \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : MonoidHomClass F \u03b1 \u03b2\nf : F\nm : \u03b1\n\u22a2 IsSquare (f (m * m))"
      },
      {
        "tactic": "exact \u27e8f m, by simp\u27e9",
        "annotated_tactic": [
          "exact \u27e8f m, by simp\u27e9",
          []
        ],
        "state_before": "case intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : MulOneClass \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : MonoidHomClass F \u03b1 \u03b2\nf : F\nm : \u03b1\n\u22a2 IsSquare (f (m * m))",
        "state_after": "no goals"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : MulOneClass \u03b2\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : MonoidHomClass F \u03b1 \u03b2\nf : F\nm : \u03b1\n\u22a2 f (m * m) = f m * f m",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.170788182062097,
    "entry_failed": false
  },
  "3410": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Nilpotent/Defs.lean",
    "full_name": "IsNilpotent.pow_of_pos",
    "start": [
      70,
      1
    ],
    "end": [
      74,
      45
    ],
    "traced_tactics": [
      {
        "tactic": "cases n with\n| zero => contradiction\n| succ => exact  IsNilpotent.pow_succ _ hx",
        "annotated_tactic": [
          "cases n with\n  | zero => contradiction\n  | succ => exact  <a>IsNilpotent.pow_succ</a> _ hx",
          [
            {
              "full_name": "IsNilpotent.pow_succ",
              "def_path": "Mathlib/RingTheory/Nilpotent/Defs.lean",
              "def_pos": [
                58,
                7
              ],
              "def_end_pos": [
                58,
                27
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\nS\u271d : Type u_2\nx\u271d y : R\nn : \u2115\nS : Type u_3\ninst\u271d : MonoidWithZero S\nx : S\nhx : IsNilpotent x\nhn : n \u2260 0\n\u22a2 IsNilpotent (x ^ n)",
        "state_after": "no goals"
      },
      {
        "tactic": "contradiction",
        "annotated_tactic": [
          "contradiction",
          []
        ],
        "state_before": "case zero\nR : Type u_1\nS\u271d : Type u_2\nx\u271d y : R\nS : Type u_3\ninst\u271d : MonoidWithZero S\nx : S\nhx : IsNilpotent x\nhn : 0 \u2260 0\n\u22a2 IsNilpotent (x ^ 0)",
        "state_after": "no goals"
      },
      {
        "tactic": "exact  IsNilpotent.pow_succ _ hx",
        "annotated_tactic": [
          "exact  <a>IsNilpotent.pow_succ</a> _ hx",
          [
            {
              "full_name": "IsNilpotent.pow_succ",
              "def_path": "Mathlib/RingTheory/Nilpotent/Defs.lean",
              "def_pos": [
                58,
                7
              ],
              "def_end_pos": [
                58,
                27
              ]
            }
          ]
        ],
        "state_before": "case succ\nR : Type u_1\nS\u271d : Type u_2\nx\u271d y : R\nS : Type u_3\ninst\u271d : MonoidWithZero S\nx : S\nhx : IsNilpotent x\nn\u271d : \u2115\nhn : n\u271d + 1 \u2260 0\n\u22a2 IsNilpotent (x ^ (n\u271d + 1))",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.3865663490723819,
    "entry_failed": false
  },
  "3463": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Dynamics/Flow.lean",
    "full_name": "Flow.continuous_toFun",
    "start": [
      178,
      1
    ],
    "end": [
      181,
      16
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 curry_uncurry \u03d5.toFun]",
        "annotated_tactic": [
          "rw [\u2190 <a>curry_uncurry</a> \u03d5.toFun]",
          [
            {
              "full_name": "Function.curry_uncurry",
              "def_path": "Mathlib/Init/Function.lean",
              "def_pos": [
                235,
                9
              ],
              "def_end_pos": [
                235,
                22
              ]
            }
          ]
        ],
        "state_before": "\u03c4 : Type u_1\ninst\u271d\u00b3 : AddCommGroup \u03c4\ninst\u271d\u00b2 : TopologicalSpace \u03c4\ninst\u271d\u00b9 : TopologicalAddGroup \u03c4\n\u03b1 : Type u_2\ninst\u271d : TopologicalSpace \u03b1\n\u03d5 : Flow \u03c4 \u03b1\nt : \u03c4\n\u22a2 Continuous (\u03d5.toFun t)",
        "state_after": "\u03c4 : Type u_1\ninst\u271d\u00b3 : AddCommGroup \u03c4\ninst\u271d\u00b2 : TopologicalSpace \u03c4\ninst\u271d\u00b9 : TopologicalAddGroup \u03c4\n\u03b1 : Type u_2\ninst\u271d : TopologicalSpace \u03b1\n\u03d5 : Flow \u03c4 \u03b1\nt : \u03c4\n\u22a2 Continuous (Function.curry (uncurry \u03d5.toFun) t)"
      },
      {
        "tactic": "apply continuous_curry",
        "annotated_tactic": [
          "apply <a>continuous_curry</a>",
          [
            {
              "full_name": "continuous_curry",
              "def_path": "Mathlib/Topology/Constructions.lean",
              "def_pos": [
                540,
                9
              ],
              "def_end_pos": [
                540,
                25
              ]
            }
          ]
        ],
        "state_before": "\u03c4 : Type u_1\ninst\u271d\u00b3 : AddCommGroup \u03c4\ninst\u271d\u00b2 : TopologicalSpace \u03c4\ninst\u271d\u00b9 : TopologicalAddGroup \u03c4\n\u03b1 : Type u_2\ninst\u271d : TopologicalSpace \u03b1\n\u03d5 : Flow \u03c4 \u03b1\nt : \u03c4\n\u22a2 Continuous (Function.curry (uncurry \u03d5.toFun) t)",
        "state_after": "case h\n\u03c4 : Type u_1\ninst\u271d\u00b3 : AddCommGroup \u03c4\ninst\u271d\u00b2 : TopologicalSpace \u03c4\ninst\u271d\u00b9 : TopologicalAddGroup \u03c4\n\u03b1 : Type u_2\ninst\u271d : TopologicalSpace \u03b1\n\u03d5 : Flow \u03c4 \u03b1\nt : \u03c4\n\u22a2 Continuous (uncurry \u03d5.toFun)"
      },
      {
        "tactic": "exact \u03d5.cont'",
        "annotated_tactic": [
          "exact \u03d5.cont'",
          []
        ],
        "state_before": "case h\n\u03c4 : Type u_1\ninst\u271d\u00b3 : AddCommGroup \u03c4\ninst\u271d\u00b2 : TopologicalSpace \u03c4\ninst\u271d\u00b9 : TopologicalAddGroup \u03c4\n\u03b1 : Type u_2\ninst\u271d : TopologicalSpace \u03b1\n\u03d5 : Flow \u03c4 \u03b1\nt : \u03c4\n\u22a2 Continuous (uncurry \u03d5.toFun)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.1357855019159615,
    "entry_failed": false
  },
  "3478": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/Quiver/Cast.lean",
    "full_name": "Quiver.Path.cast_eq_cast",
    "start": [
      87,
      1
    ],
    "end": [
      90,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "rw [hu, hv]",
        "annotated_tactic": [
          "rw [hu, hv]",
          []
        ],
        "state_before": "U : Type u_1\ninst\u271d : Quiver U\nu v u' v' : U\nhu : u = u'\nhv : v = v'\np : Path u v\n\u22a2 Path u v = Path u' v'",
        "state_after": "no goals"
      },
      {
        "tactic": "subst_vars",
        "annotated_tactic": [
          "subst_vars",
          []
        ],
        "state_before": "U : Type u_1\ninst\u271d : Quiver U\nu v u' v' : U\nhu : u = u'\nhv : v = v'\np : Path u v\n\u22a2 cast hu hv p = _root_.cast \u22ef p",
        "state_after": "U : Type u_1\ninst\u271d : Quiver U\nu' v' : U\np : Path u' v'\n\u22a2 cast \u22ef \u22ef p = _root_.cast \u22ef p"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "U : Type u_1\ninst\u271d : Quiver U\nu' v' : U\np : Path u' v'\n\u22a2 cast \u22ef \u22ef p = _root_.cast \u22ef p",
        "state_after": "no goals"
      }
    ],
    "entry_time": 0.937281341990456,
    "entry_failed": false
  },
  "3501": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/ContinuousOn.lean",
    "full_name": "nhdsWithin_le_nhds",
    "start": [
      196,
      1
    ],
    "end": [
      199,
      17
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 nhdsWithin_univ]",
        "annotated_tactic": [
          "rw [\u2190 <a>nhdsWithin_univ</a>]",
          [
            {
              "full_name": "nhdsWithin_univ",
              "def_path": "Mathlib/Topology/ContinuousOn.lean",
              "def_pos": [
                75,
                9
              ],
              "def_end_pos": [
                75,
                24
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\ns : Set \u03b1\n\u22a2 \ud835\udcdd[s] a \u2264 \ud835\udcdd a",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\ns : Set \u03b1\n\u22a2 \ud835\udcdd[s] a \u2264 \ud835\udcdd[univ] a"
      },
      {
        "tactic": "apply nhdsWithin_le_of_mem",
        "annotated_tactic": [
          "apply <a>nhdsWithin_le_of_mem</a>",
          [
            {
              "full_name": "nhdsWithin_le_of_mem",
              "def_path": "Mathlib/Topology/ContinuousOn.lean",
              "def_pos": [
                192,
                9
              ],
              "def_end_pos": [
                192,
                29
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\ns : Set \u03b1\n\u22a2 \ud835\udcdd[s] a \u2264 \ud835\udcdd[univ] a",
        "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\ns : Set \u03b1\n\u22a2 univ \u2208 \ud835\udcdd[s] a"
      },
      {
        "tactic": "exact univ_mem",
        "annotated_tactic": [
          "exact <a>univ_mem</a>",
          [
            {
              "full_name": "Filter.univ_mem",
              "def_path": "Mathlib/Order/Filter/Basic.lean",
              "def_pos": [
                147,
                9
              ],
              "def_end_pos": [
                147,
                17
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\ns : Set \u03b1\n\u22a2 univ \u2208 \ud835\udcdd[s] a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.9940590849146247,
    "entry_failed": false
  },
  "3626": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Intervals.lean",
    "full_name": "List.Ico.filter_le_of_bot",
    "start": [
      220,
      1
    ],
    "end": [
      223,
      37
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 filter_lt_of_succ_bot hnm]",
        "annotated_tactic": [
          "rw [\u2190 <a>filter_lt_of_succ_bot</a> hnm]",
          [
            {
              "full_name": "List.Ico.filter_lt_of_succ_bot",
              "def_path": "Mathlib/Data/List/Intervals.lean",
              "def_pos": [
                213,
                9
              ],
              "def_end_pos": [
                213,
                30
              ]
            }
          ]
        ],
        "state_before": "n m : \u2115\nhnm : n < m\n\u22a2 filter (fun x => decide (x \u2264 n)) (Ico n m) = [n]",
        "state_after": "n m : \u2115\nhnm : n < m\n\u22a2 filter (fun x => decide (x \u2264 n)) (Ico n m) = filter (fun x => decide (x < n + 1)) (Ico n m)"
      },
      {
        "tactic": "exact filter_congr fun _ _ => by\n  simpa using Nat.lt_succ_iff.symm",
        "annotated_tactic": [
          "exact <a>filter_congr</a> fun _ _ => by\n    simpa using Nat.lt_succ_iff.symm",
          [
            {
              "full_name": "List.filter_congr",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean",
              "def_pos": [
                925,
                9
              ],
              "def_end_pos": [
                925,
                21
              ]
            }
          ]
        ],
        "state_before": "n m : \u2115\nhnm : n < m\n\u22a2 filter (fun x => decide (x \u2264 n)) (Ico n m) = filter (fun x => decide (x < n + 1)) (Ico n m)",
        "state_after": "no goals"
      },
      {
        "tactic": "simpa using Nat.lt_succ_iff.symm",
        "annotated_tactic": [
          "simpa using Nat.lt_succ_iff.symm",
          []
        ],
        "state_before": "n m : \u2115\nhnm : n < m\nx\u271d\u00b9 : \u2115\nx\u271d : x\u271d\u00b9 \u2208 Ico n m\n\u22a2 decide (x\u271d\u00b9 \u2264 n) = decide (x\u271d\u00b9 < n + 1)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7208396960049868,
    "entry_failed": false
  },
  "3642": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/Complex/Isometry.lean",
    "full_name": "LinearIsometry.re_apply_eq_re",
    "start": [
      119,
      1
    ],
    "end": [
      122,
      40
    ],
    "traced_tactics": [
      {
        "tactic": "apply LinearIsometry.re_apply_eq_re_of_add_conj_eq",
        "annotated_tactic": [
          "apply <a>LinearIsometry.re_apply_eq_re_of_add_conj_eq</a>",
          [
            {
              "full_name": "LinearIsometry.re_apply_eq_re_of_add_conj_eq",
              "def_path": "Mathlib/Analysis/Complex/Isometry.lean",
              "def_pos": [
                90,
                9
              ],
              "def_end_pos": [
                90,
                53
              ]
            }
          ]
        ],
        "state_before": "f : \u2102 \u2192\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\nz : \u2102\n\u22a2 (f z).re = z.re",
        "state_after": "case h\u2083\nf : \u2102 \u2192\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\nz : \u2102\n\u22a2 \u2200 (z : \u2102), z + (starRingEnd \u2102) z = f z + (starRingEnd \u2102) (f z)"
      },
      {
        "tactic": "intro z",
        "annotated_tactic": [
          "intro z",
          []
        ],
        "state_before": "case h\u2083\nf : \u2102 \u2192\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\nz : \u2102\n\u22a2 \u2200 (z : \u2102), z + (starRingEnd \u2102) z = f z + (starRingEnd \u2102) (f z)",
        "state_after": "case h\u2083\nf : \u2102 \u2192\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\nz\u271d z : \u2102\n\u22a2 z + (starRingEnd \u2102) z = f z + (starRingEnd \u2102) (f z)"
      },
      {
        "tactic": "apply LinearIsometry.im_apply_eq_im h",
        "annotated_tactic": [
          "apply <a>LinearIsometry.im_apply_eq_im</a> h",
          [
            {
              "full_name": "LinearIsometry.im_apply_eq_im",
              "def_path": "Mathlib/Analysis/Complex/Isometry.lean",
              "def_pos": [
                104,
                9
              ],
              "def_end_pos": [
                104,
                38
              ]
            }
          ]
        ],
        "state_before": "case h\u2083\nf : \u2102 \u2192\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\nz\u271d z : \u2102\n\u22a2 z + (starRingEnd \u2102) z = f z + (starRingEnd \u2102) (f z)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.419917234103195,
    "entry_failed": false
  },
  "3673": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Probability/Distributions/Geometric.lean",
    "full_name": "ProbabilityTheory.geometricPMFReal_pos",
    "start": [
      47,
      1
    ],
    "end": [
      52,
      13
    ],
    "traced_tactics": [
      {
        "tactic": "rw [geometricPMFReal]",
        "annotated_tactic": [
          "rw [<a>geometricPMFReal</a>]",
          [
            {
              "full_name": "ProbabilityTheory.geometricPMFReal",
              "def_path": "Mathlib/Probability/Distributions/Geometric.lean",
              "def_pos": [
                36,
                5
              ],
              "def_end_pos": [
                36,
                21
              ]
            }
          ]
        ],
        "state_before": "p : \u211d\nn : \u2115\nhp_pos : 0 < p\nhp_lt_one : p < 1\n\u22a2 0 < geometricPMFReal p n",
        "state_after": "p : \u211d\nn : \u2115\nhp_pos : 0 < p\nhp_lt_one : p < 1\n\u22a2 0 < (1 - p) ^ n * p"
      },
      {
        "tactic": "have : 0 < 1 - p := sub_pos.mpr hp_lt_one",
        "annotated_tactic": [
          "have : 0 < 1 - p := sub_pos.mpr hp_lt_one",
          []
        ],
        "state_before": "p : \u211d\nn : \u2115\nhp_pos : 0 < p\nhp_lt_one : p < 1\n\u22a2 0 < (1 - p) ^ n * p",
        "state_after": "p : \u211d\nn : \u2115\nhp_pos : 0 < p\nhp_lt_one : p < 1\nthis : 0 < 1 - p\n\u22a2 0 < (1 - p) ^ n * p"
      },
      {
        "tactic": "positivity",
        "annotated_tactic": [
          "positivity",
          []
        ],
        "state_before": "p : \u211d\nn : \u2115\nhp_pos : 0 < p\nhp_lt_one : p < 1\nthis : 0 < 1 - p\n\u22a2 0 < (1 - p) ^ n * p",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.755306249950081,
    "entry_failed": false
  },
  "3711": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/PNat/Factors.lean",
    "full_name": "PrimeMultiset.prod_add",
    "start": [
      219,
      1
    ],
    "end": [
      222,
      30
    ],
    "traced_tactics": [
      {
        "tactic": "change (coePNatMonoidHom (u + v)).prod = _",
        "annotated_tactic": [
          "change (<a>coePNatMonoidHom</a> (u + v)).<a>prod</a> = _",
          [
            {
              "full_name": "PrimeMultiset.coePNatMonoidHom",
              "def_path": "Mathlib/Data/PNat/Factors.lean",
              "def_pos": [
                104,
                5
              ],
              "def_end_pos": [
                104,
                21
              ]
            },
            {
              "full_name": "Multiset.prod",
              "def_path": "Mathlib/Algebra/BigOperators/Group/Multiset.lean",
              "def_pos": [
                40,
                5
              ],
              "def_end_pos": [
                40,
                9
              ]
            }
          ]
        ],
        "state_before": "u v : PrimeMultiset\n\u22a2 (u + v).prod = u.prod * v.prod",
        "state_after": "u v : PrimeMultiset\n\u22a2 (coePNatMonoidHom (u + v)).prod = u.prod * v.prod"
      },
      {
        "tactic": "rw [coePNatMonoidHom.map_add]",
        "annotated_tactic": [
          "rw [coePNatMonoidHom.map_add]",
          []
        ],
        "state_before": "u v : PrimeMultiset\n\u22a2 (coePNatMonoidHom (u + v)).prod = u.prod * v.prod",
        "state_after": "u v : PrimeMultiset\n\u22a2 (coePNatMonoidHom u + coePNatMonoidHom v).prod = u.prod * v.prod"
      },
      {
        "tactic": "exact Multiset.prod_add _ _",
        "annotated_tactic": [
          "exact <a>Multiset.prod_add</a> _ _",
          [
            {
              "full_name": "Multiset.prod_add",
              "def_path": "Mathlib/Algebra/BigOperators/Group/Multiset.lean",
              "def_pos": [
                111,
                9
              ],
              "def_end_pos": [
                111,
                17
              ]
            }
          ]
        ],
        "state_before": "u v : PrimeMultiset\n\u22a2 (coePNatMonoidHom u + coePNatMonoidHom v).prod = u.prod * v.prod",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8720142400125042,
    "entry_failed": false
  },
  "3875": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Option/Basic.lean",
    "full_name": "Option.orElse_eq_none",
    "start": [
      414,
      1
    ],
    "end": [
      417,
      39
    ],
    "traced_tactics": [
      {
        "tactic": "cases o",
        "annotated_tactic": [
          "cases o",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\no o' : Option \u03b1\n\u22a2 (HOrElse.hOrElse o fun x => o') = none \u2194 o = none \u2227 o' = none",
        "state_after": "case none\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\no' : Option \u03b1\n\u22a2 (HOrElse.hOrElse none fun x => o') = none \u2194 none = none \u2227 o' = none\n\ncase some\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\no' : Option \u03b1\nval\u271d : \u03b1\n\u22a2 (HOrElse.hOrElse (some val\u271d) fun x => o') = none \u2194 some val\u271d = none \u2227 o' = none"
      },
      {
        "tactic": "simp only [true_and, none_orElse, eq_self_iff_true]",
        "annotated_tactic": [
          "simp only [<a>true_and</a>, <a>none_orElse</a>, <a>eq_self_iff_true</a>]",
          [
            {
              "full_name": "true_and",
              "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean",
              "def_pos": [
                105,
                17
              ],
              "def_end_pos": [
                105,
                25
              ]
            },
            {
              "full_name": "Option.none_orElse",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Option/Lemmas.lean",
              "def_pos": [
                185,
                17
              ],
              "def_end_pos": [
                185,
                28
              ]
            },
            {
              "full_name": "eq_self_iff_true",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1380,
                9
              ],
              "def_end_pos": [
                1380,
                25
              ]
            }
          ]
        ],
        "state_before": "case none\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\no' : Option \u03b1\n\u22a2 (HOrElse.hOrElse none fun x => o') = none \u2194 none = none \u2227 o' = none",
        "state_after": "no goals"
      },
      {
        "tactic": "simp only [some_orElse, false_and]",
        "annotated_tactic": [
          "simp only [<a>some_orElse</a>, <a>false_and</a>]",
          [
            {
              "full_name": "Option.some_orElse",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Option/Lemmas.lean",
              "def_pos": [
                183,
                17
              ],
              "def_end_pos": [
                183,
                28
              ]
            },
            {
              "full_name": "false_and",
              "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean",
              "def_pos": [
                110,
                17
              ],
              "def_end_pos": [
                110,
                26
              ]
            }
          ]
        ],
        "state_before": "case some\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\no' : Option \u03b1\nval\u271d : \u03b1\n\u22a2 (HOrElse.hOrElse (some val\u271d) fun x => o') = none \u2194 some val\u271d = none \u2227 o' = none",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.003016841947101,
    "entry_failed": false
  },
  "3906": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Duplicate.lean",
    "full_name": "List.Duplicate.mem",
    "start": [
      46,
      1
    ],
    "end": [
      49,
      31
    ],
    "traced_tactics": [
      {
        "tactic": "induction' h with l' _ y l' _ hm",
        "annotated_tactic": [
          "induction' h with l' _ y l' _ hm",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nl : List \u03b1\nx : \u03b1\nh : x \u2208+ l\n\u22a2 x \u2208 l",
        "state_after": "case cons_mem\n\u03b1 : Type u_1\nl : List \u03b1\nx : \u03b1\nl' : List \u03b1\na\u271d : x \u2208 l'\n\u22a2 x \u2208 x :: l'\n\ncase cons_duplicate\n\u03b1 : Type u_1\nl : List \u03b1\nx y : \u03b1\nl' : List \u03b1\na\u271d : x \u2208+ l'\nhm : x \u2208 l'\n\u22a2 x \u2208 y :: l'"
      },
      {
        "tactic": "exact mem_cons_self _ _",
        "annotated_tactic": [
          "exact <a>mem_cons_self</a> _ _",
          [
            {
              "full_name": "List.mem_cons_self",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean",
              "def_pos": [
                289,
                9
              ],
              "def_end_pos": [
                289,
                22
              ]
            }
          ]
        ],
        "state_before": "case cons_mem\n\u03b1 : Type u_1\nl : List \u03b1\nx : \u03b1\nl' : List \u03b1\na\u271d : x \u2208 l'\n\u22a2 x \u2208 x :: l'",
        "state_after": "no goals"
      },
      {
        "tactic": "exact mem_cons_of_mem _ hm",
        "annotated_tactic": [
          "exact <a>mem_cons_of_mem</a> _ hm",
          [
            {
              "full_name": "List.mem_cons_of_mem",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean",
              "def_pos": [
                291,
                9
              ],
              "def_end_pos": [
                291,
                24
              ]
            }
          ]
        ],
        "state_before": "case cons_duplicate\n\u03b1 : Type u_1\nl : List \u03b1\nx y : \u03b1\nl' : List \u03b1\na\u271d : x \u2208+ l'\nhm : x \u2208 l'\n\u22a2 x \u2208 y :: l'",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2152194899972528,
    "entry_failed": false
  },
  "3921": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/WittVector/Truncated.lean",
    "full_name": "TruncatedWittVector.truncate_surjective",
    "start": [
      406,
      1
    ],
    "end": [
      409,
      68
    ],
    "traced_tactics": [
      {
        "tactic": "intro x",
        "annotated_tactic": [
          "intro x",
          []
        ],
        "state_before": "p : \u2115\nhp : Fact (Nat.Prime p)\nn : \u2115\nR : Type u_1\ninst\u271d : CommRing R\nm : \u2115\nhm : n \u2264 m\n\u22a2 Surjective \u21d1(truncate hm)",
        "state_after": "p : \u2115\nhp : Fact (Nat.Prime p)\nn : \u2115\nR : Type u_1\ninst\u271d : CommRing R\nm : \u2115\nhm : n \u2264 m\nx : TruncatedWittVector p n R\n\u22a2 \u2203 a, (truncate hm) a = x"
      },
      {
        "tactic": "obtain \u27e8x, rfl\u27e9 := @WittVector.truncate_surjective p _ _ R _ x",
        "annotated_tactic": [
          "obtain \u27e8x, rfl\u27e9 := @<a>WittVector.truncate_surjective</a> p _ _ R _ x",
          [
            {
              "full_name": "WittVector.truncate_surjective",
              "def_path": "Mathlib/RingTheory/WittVector/Truncated.lean",
              "def_pos": [
                333,
                9
              ],
              "def_end_pos": [
                333,
                28
              ]
            }
          ]
        ],
        "state_before": "p : \u2115\nhp : Fact (Nat.Prime p)\nn : \u2115\nR : Type u_1\ninst\u271d : CommRing R\nm : \u2115\nhm : n \u2264 m\nx : TruncatedWittVector p n R\n\u22a2 \u2203 a, (truncate hm) a = x",
        "state_after": "case intro\np : \u2115\nhp : Fact (Nat.Prime p)\nn : \u2115\nR : Type u_1\ninst\u271d : CommRing R\nm : \u2115\nhm : n \u2264 m\nx : \ud835\udd4e R\n\u22a2 \u2203 a, (truncate hm) a = (WittVector.truncate n) x"
      },
      {
        "tactic": "exact \u27e8WittVector.truncate _ x, truncate_wittVector_truncate _ _\u27e9",
        "annotated_tactic": [
          "exact \u27e8<a>WittVector.truncate</a> _ x, <a>truncate_wittVector_truncate</a> _ _\u27e9",
          [
            {
              "full_name": "WittVector.truncate",
              "def_path": "Mathlib/RingTheory/WittVector/Truncated.lean",
              "def_pos": [
                323,
                19
              ],
              "def_end_pos": [
                323,
                27
              ]
            },
            {
              "full_name": "TruncatedWittVector.truncate_wittVector_truncate",
              "def_path": "Mathlib/RingTheory/WittVector/Truncated.lean",
              "def_pos": [
                387,
                9
              ],
              "def_end_pos": [
                387,
                37
              ]
            }
          ]
        ],
        "state_before": "case intro\np : \u2115\nhp : Fact (Nat.Prime p)\nn : \u2115\nR : Type u_1\ninst\u271d : CommRing R\nm : \u2115\nhm : n \u2264 m\nx : \ud835\udd4e R\n\u22a2 \u2203 a, (truncate hm) a = (WittVector.truncate n) x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.2538066010456532,
    "entry_failed": false
  },
  "3933": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Logic/Relation.lean",
    "full_name": "Reflexive.rel_of_ne_imp",
    "start": [
      61,
      1
    ],
    "end": [
      64,
      17
    ],
    "traced_tactics": [
      {
        "tactic": "by_cases hxy : x = y",
        "annotated_tactic": [
          "by_cases hxy : x = y",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b5 : Type u_5\n\u03b6 : Type u_6\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : Reflexive r\nx y : \u03b1\nhr : x \u2260 y \u2192 r x y\n\u22a2 r x y",
        "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b5 : Type u_5\n\u03b6 : Type u_6\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : Reflexive r\nx y : \u03b1\nhr : x \u2260 y \u2192 r x y\nhxy : x = y\n\u22a2 r x y\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b5 : Type u_5\n\u03b6 : Type u_6\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : Reflexive r\nx y : \u03b1\nhr : x \u2260 y \u2192 r x y\nhxy : \u00acx = y\n\u22a2 r x y"
      },
      {
        "tactic": "exact hxy \u25b8 h x",
        "annotated_tactic": [
          "exact hxy \u25b8 h x",
          []
        ],
        "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b5 : Type u_5\n\u03b6 : Type u_6\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : Reflexive r\nx y : \u03b1\nhr : x \u2260 y \u2192 r x y\nhxy : x = y\n\u22a2 r x y",
        "state_after": "no goals"
      },
      {
        "tactic": "exact hr hxy",
        "annotated_tactic": [
          "exact hr hxy",
          []
        ],
        "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b5 : Type u_5\n\u03b6 : Type u_6\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : Reflexive r\nx y : \u03b1\nhr : x \u2260 y \u2192 r x y\nhxy : \u00acx = y\n\u22a2 r x y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.460355800925754,
    "entry_failed": false
  },
  "4029": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/ModularLattice.lean",
    "full_name": "eq_of_le_of_inf_le_of_le_sup",
    "start": [
      233,
      1
    ],
    "end": [
      237,
      59
    ],
    "traced_tactics": [
      {
        "tactic": "refine hxy.antisymm ?_",
        "annotated_tactic": [
          "refine hxy.antisymm ?_",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : IsModularLattice \u03b1\nx y z : \u03b1\nhxy : x \u2264 y\nhinf : y \u2293 z \u2264 x\nhsup : y \u2264 x \u2294 z\n\u22a2 x = y",
        "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : IsModularLattice \u03b1\nx y z : \u03b1\nhxy : x \u2264 y\nhinf : y \u2293 z \u2264 x\nhsup : y \u2264 x \u2294 z\n\u22a2 y \u2264 x"
      },
      {
        "tactic": "rw [\u2190 inf_eq_right, sup_inf_assoc_of_le _ hxy] at hsup",
        "annotated_tactic": [
          "rw [\u2190 <a>inf_eq_right</a>, <a>sup_inf_assoc_of_le</a> _ hxy] at hsup",
          [
            {
              "full_name": "inf_eq_right",
              "def_path": "Mathlib/Order/Lattice.lean",
              "def_pos": [
                404,
                9
              ],
              "def_end_pos": [
                404,
                21
              ]
            },
            {
              "full_name": "sup_inf_assoc_of_le",
              "def_path": "Mathlib/Order/ModularLattice.lean",
              "def_pos": [
                207,
                9
              ],
              "def_end_pos": [
                207,
                28
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : IsModularLattice \u03b1\nx y z : \u03b1\nhxy : x \u2264 y\nhinf : y \u2293 z \u2264 x\nhsup : y \u2264 x \u2294 z\n\u22a2 y \u2264 x",
        "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : IsModularLattice \u03b1\nx y z : \u03b1\nhxy : x \u2264 y\nhinf : y \u2293 z \u2264 x\nhsup : x \u2294 z \u2293 y = y\n\u22a2 y \u2264 x"
      },
      {
        "tactic": "rwa [\u2190 hsup, sup_le_iff, and_iff_right rfl.le, inf_comm]",
        "annotated_tactic": [
          "rwa [\u2190 hsup, <a>sup_le_iff</a>, <a>and_iff_right</a> rfl.le, <a>inf_comm</a>]",
          [
            {
              "full_name": "sup_le_iff",
              "def_path": "Mathlib/Order/Lattice.lean",
              "def_pos": [
                148,
                9
              ],
              "def_end_pos": [
                148,
                19
              ]
            },
            {
              "full_name": "and_iff_right",
              "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean",
              "def_pos": [
                70,
                9
              ],
              "def_end_pos": [
                70,
                22
              ]
            },
            {
              "full_name": "inf_comm",
              "def_path": "Mathlib/Order/Lattice.lean",
              "def_pos": [
                461,
                9
              ],
              "def_end_pos": [
                461,
                17
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : IsModularLattice \u03b1\nx y z : \u03b1\nhxy : x \u2264 y\nhinf : y \u2293 z \u2264 x\nhsup : x \u2294 z \u2293 y = y\n\u22a2 y \u2264 x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5983301589731127,
    "entry_failed": false
  },
  "4067": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/IsWellOrderLimitElement.lean",
    "full_name": "IsWellOrderLimitElement.bot_lt",
    "start": [
      60,
      1
    ],
    "end": [
      63,
      12
    ],
    "traced_tactics": [
      {
        "tactic": "obtain h|h := eq_or_lt_of_le (@bot_le _ _ _ a)",
        "annotated_tactic": [
          "obtain h|h := <a>eq_or_lt_of_le</a> (@<a>bot_le</a> _ _ _ a)",
          [
            {
              "full_name": "eq_or_lt_of_le",
              "def_path": "Mathlib/Order/Basic.lean",
              "def_pos": [
                381,
                9
              ],
              "def_end_pos": [
                381,
                23
              ]
            },
            {
              "full_name": "bot_le",
              "def_path": "Mathlib/Order/BoundedOrder.lean",
              "def_pos": [
                224,
                9
              ],
              "def_end_pos": [
                224,
                15
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsWellOrder \u03b1 fun x x_1 => x < x_1\na : \u03b1\nha : IsWellOrderLimitElement a\ninst\u271d : OrderBot \u03b1\n\u22a2 \u22a5 < a",
        "state_after": "case inl\n\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsWellOrder \u03b1 fun x x_1 => x < x_1\na : \u03b1\nha : IsWellOrderLimitElement a\ninst\u271d : OrderBot \u03b1\nh : \u22a5 = a\n\u22a2 \u22a5 < a\n\ncase inr\n\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsWellOrder \u03b1 fun x x_1 => x < x_1\na : \u03b1\nha : IsWellOrderLimitElement a\ninst\u271d : OrderBot \u03b1\nh : \u22a5 < a\n\u22a2 \u22a5 < a"
      },
      {
        "tactic": "exact (IsWellOrderLimitElement.neq_bot a h.symm).elim",
        "annotated_tactic": [
          "exact (<a>IsWellOrderLimitElement.neq_bot</a> a h.symm).<a>elim</a>",
          [
            {
              "full_name": "IsWellOrderLimitElement.neq_bot",
              "def_path": "Mathlib/Order/IsWellOrderLimitElement.lean",
              "def_pos": [
                55,
                7
              ],
              "def_end_pos": [
                55,
                38
              ]
            },
            {
              "full_name": "False.elim",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                236,
                21
              ],
              "def_end_pos": [
                236,
                31
              ]
            }
          ]
        ],
        "state_before": "case inl\n\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsWellOrder \u03b1 fun x x_1 => x < x_1\na : \u03b1\nha : IsWellOrderLimitElement a\ninst\u271d : OrderBot \u03b1\nh : \u22a5 = a\n\u22a2 \u22a5 < a",
        "state_after": "no goals"
      },
      {
        "tactic": "exact h",
        "annotated_tactic": [
          "exact h",
          []
        ],
        "state_before": "case inr\n\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsWellOrder \u03b1 fun x x_1 => x < x_1\na : \u03b1\nha : IsWellOrderLimitElement a\ninst\u271d : OrderBot \u03b1\nh : \u22a5 < a\n\u22a2 \u22a5 < a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.369945873040706,
    "entry_failed": false
  },
  "4088": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/MorphismProperty/Limits.lean",
    "full_name": "CategoryTheory.MorphismProperty.StableUnderBaseChange.respectsIso",
    "start": [
      58,
      1
    ],
    "end": [
      62,
      59
    ],
    "traced_tactics": [
      {
        "tactic": "apply RespectsIso.of_respects_arrow_iso",
        "annotated_tactic": [
          "apply <a>RespectsIso.of_respects_arrow_iso</a>",
          [
            {
              "full_name": "CategoryTheory.MorphismProperty.RespectsIso.of_respects_arrow_iso",
              "def_path": "Mathlib/CategoryTheory/MorphismProperty/Basic.lean",
              "def_pos": [
                158,
                9
              ],
              "def_end_pos": [
                158,
                42
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d : Category.{v, u} C\nP : MorphismProperty C\nhP : P.StableUnderBaseChange\n\u22a2 P.RespectsIso",
        "state_after": "case hP\nC : Type u\ninst\u271d : Category.{v, u} C\nP : MorphismProperty C\nhP : P.StableUnderBaseChange\n\u22a2 \u2200 (f g : Arrow C), (f \u2245 g) \u2192 P f.hom \u2192 P g.hom"
      },
      {
        "tactic": "intro f g e",
        "annotated_tactic": [
          "intro f g e",
          []
        ],
        "state_before": "case hP\nC : Type u\ninst\u271d : Category.{v, u} C\nP : MorphismProperty C\nhP : P.StableUnderBaseChange\n\u22a2 \u2200 (f g : Arrow C), (f \u2245 g) \u2192 P f.hom \u2192 P g.hom",
        "state_after": "case hP\nC : Type u\ninst\u271d : Category.{v, u} C\nP : MorphismProperty C\nhP : P.StableUnderBaseChange\nf g : Arrow C\ne : f \u2245 g\n\u22a2 P f.hom \u2192 P g.hom"
      },
      {
        "tactic": "exact hP (IsPullback.of_horiz_isIso (CommSq.mk e.inv.w))",
        "annotated_tactic": [
          "exact hP (<a>IsPullback.of_horiz_isIso</a> (<a>CommSq.mk</a> e.inv.w))",
          [
            {
              "full_name": "CategoryTheory.IsPullback.of_horiz_isIso",
              "def_path": "Mathlib/CategoryTheory/Limits/Shapes/CommSq.lean",
              "def_pos": [
                316,
                9
              ],
              "def_end_pos": [
                316,
                23
              ]
            },
            {
              "full_name": "CategoryTheory.CommSq.mk",
              "def_path": "Mathlib/CategoryTheory/CommSq.lean",
              "def_pos": [
                44,
                11
              ],
              "def_end_pos": [
                44,
                17
              ]
            }
          ]
        ],
        "state_before": "case hP\nC : Type u\ninst\u271d : Category.{v, u} C\nP : MorphismProperty C\nhP : P.StableUnderBaseChange\nf g : Arrow C\ne : f \u2245 g\n\u22a2 P f.hom \u2192 P g.hom",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4481033200863749,
    "entry_failed": false
  },
  "4120": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/MetricSpace/Infsep.lean",
    "full_name": "Set.einfsep_pair",
    "start": [
      209,
      1
    ],
    "end": [
      212,
      18
    ],
    "traced_tactics": [
      {
        "tactic": "nth_rw 1 [\u2190 min_self (edist x y)]",
        "annotated_tactic": [
          "nth_rw 1 [\u2190 <a>min_self</a> (<a>edist</a> x y)]",
          [
            {
              "full_name": "min_self",
              "def_path": "Mathlib/Init/Order/LinearOrder.lean",
              "def_pos": [
                97,
                9
              ],
              "def_end_pos": [
                97,
                17
              ]
            },
            {
              "full_name": "EDist.edist",
              "def_path": "Mathlib/Topology/EMetricSpace/Basic.lean",
              "def_pos": [
                52,
                3
              ],
              "def_end_pos": [
                52,
                8
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PseudoEMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nhxy : x \u2260 y\n\u22a2 {x, y}.einfsep = edist x y",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PseudoEMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nhxy : x \u2260 y\n\u22a2 {x, y}.einfsep = min (edist x y) (edist x y)"
      },
      {
        "tactic": "convert einfsep_pair_eq_inf hxy using 2",
        "annotated_tactic": [
          "convert <a>einfsep_pair_eq_inf</a> hxy using 2",
          [
            {
              "full_name": "Set.einfsep_pair_eq_inf",
              "def_path": "Mathlib/Topology/MetricSpace/Infsep.lean",
              "def_pos": [
                159,
                9
              ],
              "def_end_pos": [
                159,
                28
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PseudoEMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nhxy : x \u2260 y\n\u22a2 {x, y}.einfsep = min (edist x y) (edist x y)",
        "state_after": "case h.e'_3.h.e'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PseudoEMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nhxy : x \u2260 y\n\u22a2 edist x y = edist y x"
      },
      {
        "tactic": "rw [edist_comm]",
        "annotated_tactic": [
          "rw [<a>edist_comm</a>]",
          [
            {
              "full_name": "PseudoEMetricSpace.edist_comm",
              "def_path": "Mathlib/Topology/EMetricSpace/Basic.lean",
              "def_pos": [
                83,
                3
              ],
              "def_end_pos": [
                83,
                13
              ]
            }
          ]
        ],
        "state_before": "case h.e'_3.h.e'_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PseudoEMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nhxy : x \u2260 y\n\u22a2 edist x y = edist y x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.276847930974327,
    "entry_failed": false
  },
  "4166": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Matroid/Basic.lean",
    "full_name": "Matroid.Dep.nonempty",
    "start": [
      535,
      1
    ],
    "end": [
      536,
      75
    ],
    "traced_tactics": [
      {
        "tactic": "rw [nonempty_iff_ne_empty]",
        "annotated_tactic": [
          "rw [<a>nonempty_iff_ne_empty</a>]",
          [
            {
              "full_name": "Set.nonempty_iff_ne_empty",
              "def_path": "Mathlib/Data/Set/Basic.lean",
              "def_pos": [
                580,
                9
              ],
              "def_end_pos": [
                580,
                30
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nM : Matroid \u03b1\nD : Set \u03b1\nhD : M.Dep D\n\u22a2 D.Nonempty",
        "state_after": "\u03b1 : Type u_1\nM : Matroid \u03b1\nD : Set \u03b1\nhD : M.Dep D\n\u22a2 D \u2260 \u2205"
      },
      {
        "tactic": "rintro rfl",
        "annotated_tactic": [
          "rintro rfl",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nM : Matroid \u03b1\nD : Set \u03b1\nhD : M.Dep D\n\u22a2 D \u2260 \u2205",
        "state_after": "\u03b1 : Type u_1\nM : Matroid \u03b1\nhD : M.Dep \u2205\n\u22a2 False"
      },
      {
        "tactic": "exact hD.not_indep M.empty_indep",
        "annotated_tactic": [
          "exact hD.not_indep M.empty_indep",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nM : Matroid \u03b1\nhD : M.Dep \u2205\n\u22a2 False",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.4341598519822583,
    "entry_failed": false
  },
  "4179": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean",
    "full_name": "Real.list_prod_map_rpow'",
    "start": [
      193,
      1
    ],
    "end": [
      198,
      17
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 Real.list_prod_map_rpow (l.map f) _ r, List.map_map]",
        "annotated_tactic": [
          "rw [\u2190 <a>Real.list_prod_map_rpow</a> (l.map f) _ r, <a>List.map_map</a>]",
          [
            {
              "full_name": "Real.list_prod_map_rpow",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean",
              "def_pos": [
                185,
                9
              ],
              "def_end_pos": [
                185,
                39
              ]
            },
            {
              "full_name": "List.map_map",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean",
              "def_pos": [
                842,
                17
              ],
              "def_end_pos": [
                842,
                24
              ]
            }
          ]
        ],
        "state_before": "w x y z : \u211d\n\u03b9 : Type u_1\nl : List \u03b9\nf : \u03b9 \u2192 \u211d\nhl : \u2200 i \u2208 l, 0 \u2264 f i\nr : \u211d\n\u22a2 (List.map (fun x => f x ^ r) l).prod = (List.map f l).prod ^ r",
        "state_after": "w x y z : \u211d\n\u03b9 : Type u_1\nl : List \u03b9\nf : \u03b9 \u2192 \u211d\nhl : \u2200 i \u2208 l, 0 \u2264 f i\nr : \u211d\n\u22a2 (List.map (fun x => f x ^ r) l).prod = (List.map ((fun x => x ^ r) \u2218 f) l).prod\n\nw x y z : \u211d\n\u03b9 : Type u_1\nl : List \u03b9\nf : \u03b9 \u2192 \u211d\nhl : \u2200 i \u2208 l, 0 \u2264 f i\nr : \u211d\n\u22a2 \u2200 x \u2208 List.map f l, 0 \u2264 x"
      },
      {
        "tactic": "simpa using hl",
        "annotated_tactic": [
          "simpa using hl",
          []
        ],
        "state_before": "w x y z : \u211d\n\u03b9 : Type u_1\nl : List \u03b9\nf : \u03b9 \u2192 \u211d\nhl : \u2200 i \u2208 l, 0 \u2264 f i\nr : \u211d\n\u22a2 \u2200 x \u2208 List.map f l, 0 \u2264 x",
        "state_after": "no goals"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "w x y z : \u211d\n\u03b9 : Type u_1\nl : List \u03b9\nf : \u03b9 \u2192 \u211d\nhl : \u2200 i \u2208 l, 0 \u2264 f i\nr : \u211d\n\u22a2 (List.map (fun x => f x ^ r) l).prod = (List.map ((fun x => x ^ r) \u2218 f) l).prod",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.7994394280249253,
    "entry_failed": false
  },
  "4186": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/MetricSpace/Infsep.lean",
    "full_name": "Set.Nontrivial.einfsep_ne_top",
    "start": [
      257,
      1
    ],
    "end": [
      260,
      42
    ],
    "traced_tactics": [
      {
        "tactic": "contrapose! hs",
        "annotated_tactic": [
          "contrapose! hs",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nhs : s.Nontrivial\n\u22a2 s.einfsep \u2260 \u22a4",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nhs : s.einfsep = \u22a4\n\u22a2 \u00acs.Nontrivial"
      },
      {
        "tactic": "rw [not_nontrivial_iff]",
        "annotated_tactic": [
          "rw [<a>not_nontrivial_iff</a>]",
          [
            {
              "full_name": "Set.not_nontrivial_iff",
              "def_path": "Mathlib/Data/Set/Subsingleton.lean",
              "def_pos": [
                305,
                9
              ],
              "def_end_pos": [
                305,
                27
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nhs : s.einfsep = \u22a4\n\u22a2 \u00acs.Nontrivial",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nhs : s.einfsep = \u22a4\n\u22a2 s.Subsingleton"
      },
      {
        "tactic": "exact subsingleton_of_einfsep_eq_top hs",
        "annotated_tactic": [
          "exact <a>subsingleton_of_einfsep_eq_top</a> hs",
          [
            {
              "full_name": "Set.subsingleton_of_einfsep_eq_top",
              "def_path": "Mathlib/Topology/MetricSpace/Infsep.lean",
              "def_pos": [
                248,
                9
              ],
              "def_end_pos": [
                248,
                39
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nhs : s.einfsep = \u22a4\n\u22a2 s.Subsingleton",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.68381540896371,
    "entry_failed": false
  },
  "4219": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/GroupWithZero/Divisibility.lean",
    "full_name": "dvd_antisymm",
    "start": [
      145,
      1
    ],
    "end": [
      148,
      40
    ],
    "traced_tactics": [
      {
        "tactic": "rintro \u27e8c, rfl\u27e9 \u27e8d, hcd\u27e9",
        "annotated_tactic": [
          "rintro \u27e8c, rfl\u27e9 \u27e8d, hcd\u27e9",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : Subsingleton \u03b1\u02e3\na b : \u03b1\nm n : \u2115\n\u22a2 a \u2223 b \u2192 b \u2223 a \u2192 a = b",
        "state_after": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : Subsingleton \u03b1\u02e3\na : \u03b1\nm n : \u2115\nc d : \u03b1\nhcd : a = a * c * d\n\u22a2 a = a * c"
      },
      {
        "tactic": "rw [mul_assoc, eq_comm, mul_right_eq_self\u2080, mul_eq_one] at hcd",
        "annotated_tactic": [
          "rw [<a>mul_assoc</a>, <a>eq_comm</a>, <a>mul_right_eq_self\u2080</a>, <a>mul_eq_one</a>] at hcd",
          [
            {
              "full_name": "mul_assoc",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                289,
                9
              ],
              "def_end_pos": [
                289,
                18
              ]
            },
            {
              "full_name": "eq_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                811,
                9
              ],
              "def_end_pos": [
                811,
                16
              ]
            },
            {
              "full_name": "mul_right_eq_self\u2080",
              "def_path": "Mathlib/Algebra/GroupWithZero/Basic.lean",
              "def_pos": [
                235,
                9
              ],
              "def_end_pos": [
                235,
                27
              ]
            },
            {
              "full_name": "mul_eq_one",
              "def_path": "Mathlib/Algebra/Group/Units.lean",
              "def_pos": [
                628,
                9
              ],
              "def_end_pos": [
                628,
                19
              ]
            }
          ]
        ],
        "state_before": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : Subsingleton \u03b1\u02e3\na : \u03b1\nm n : \u2115\nc d : \u03b1\nhcd : a = a * c * d\n\u22a2 a = a * c",
        "state_after": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : Subsingleton \u03b1\u02e3\na : \u03b1\nm n : \u2115\nc d : \u03b1\nhcd : c = 1 \u2227 d = 1 \u2228 a = 0\n\u22a2 a = a * c"
      },
      {
        "tactic": "obtain \u27e8rfl, -\u27e9 | rfl := hcd <;> simp",
        "annotated_tactic": [
          "obtain \u27e8rfl, -\u27e9 | rfl := hcd <;> simp",
          []
        ],
        "state_before": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : Subsingleton \u03b1\u02e3\na : \u03b1\nm n : \u2115\nc d : \u03b1\nhcd : c = 1 \u2227 d = 1 \u2228 a = 0\n\u22a2 a = a * c",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4144142030272633,
    "entry_failed": false
  },
  "4281": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/PNat/Prime.lean",
    "full_name": "PNat.coprime_coe",
    "start": [
      186,
      1
    ],
    "end": [
      189,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "unfold Nat.Coprime Coprime",
        "annotated_tactic": [
          "unfold <a>Nat.Coprime</a> <a>Coprime</a>",
          [
            {
              "full_name": "Nat.Coprime",
              "def_path": ".lake/packages/batteries/Batteries/Data/Nat/Gcd.lean",
              "def_pos": [
                20,
                18
              ],
              "def_end_pos": [
                20,
                25
              ]
            },
            {
              "full_name": "PNat.Coprime",
              "def_path": "Mathlib/Data/PNat/Prime.lean",
              "def_pos": [
                181,
                5
              ],
              "def_end_pos": [
                181,
                12
              ]
            }
          ]
        ],
        "state_before": "m n : \u2115+\n\u22a2 (\u2191m).Coprime \u2191n \u2194 m.Coprime n",
        "state_after": "m n : \u2115+\n\u22a2 (\u2191m).gcd \u2191n = 1 \u2194 m.gcd n = 1"
      },
      {
        "tactic": "rw [\u2190 coe_inj]",
        "annotated_tactic": [
          "rw [\u2190 <a>coe_inj</a>]",
          [
            {
              "full_name": "PNat.coe_inj",
              "def_path": "Mathlib/Data/PNat/Basic.lean",
              "def_pos": [
                124,
                9
              ],
              "def_end_pos": [
                124,
                16
              ]
            }
          ]
        ],
        "state_before": "m n : \u2115+\n\u22a2 (\u2191m).gcd \u2191n = 1 \u2194 m.gcd n = 1",
        "state_after": "m n : \u2115+\n\u22a2 (\u2191m).gcd \u2191n = 1 \u2194 \u2191(m.gcd n) = \u21911"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "m n : \u2115+\n\u22a2 (\u2191m).gcd \u2191n = 1 \u2194 \u2191(m.gcd n) = \u21911",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6308081310708076,
    "entry_failed": false
  },
  "4346": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/Measure/FiniteMeasureProd.lean",
    "full_name": "MeasureTheory.FiniteMeasure.mass_prod",
    "start": [
      59,
      1
    ],
    "end": [
      62,
      65
    ],
    "traced_tactics": [
      {
        "tactic": "simp only [coeFn_def, mass, univ_prod_univ.symm, toMeasure_prod]",
        "annotated_tactic": [
          "simp only [<a>coeFn_def</a>, <a>mass</a>, univ_prod_univ.symm, <a>toMeasure_prod</a>]",
          [
            {
              "full_name": "MeasureTheory.FiniteMeasure.coeFn_def",
              "def_path": "Mathlib/MeasureTheory/Measure/FiniteMeasure.lean",
              "def_pos": [
                152,
                7
              ],
              "def_end_pos": [
                152,
                16
              ]
            },
            {
              "full_name": "MeasureTheory.FiniteMeasure.mass",
              "def_path": "Mathlib/MeasureTheory/Measure/FiniteMeasure.lean",
              "def_pos": [
                176,
                5
              ],
              "def_end_pos": [
                176,
                9
              ]
            },
            {
              "full_name": "MeasureTheory.FiniteMeasure.toMeasure_prod",
              "def_path": "Mathlib/MeasureTheory/Measure/FiniteMeasureProd.lean",
              "def_pos": [
                47,
                15
              ],
              "def_end_pos": [
                47,
                29
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d : MeasurableSpace \u03b2\n\u03bc : FiniteMeasure \u03b1\n\u03bd : FiniteMeasure \u03b2\n\u22a2 (\u03bc.prod \u03bd).mass = \u03bc.mass * \u03bd.mass",
        "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d : MeasurableSpace \u03b2\n\u03bc : FiniteMeasure \u03b1\n\u03bd : FiniteMeasure \u03b2\n\u22a2 (((\u2191\u03bc).prod \u2191\u03bd) (univ \u00d7\u02e2 univ)).toNNReal = (\u2191\u03bc univ).toNNReal * (\u2191\u03bd univ).toNNReal"
      },
      {
        "tactic": "rw [\u2190 ENNReal.toNNReal_mul]",
        "annotated_tactic": [
          "rw [\u2190 <a>ENNReal.toNNReal_mul</a>]",
          [
            {
              "full_name": "ENNReal.toNNReal_mul",
              "def_path": "Mathlib/Data/ENNReal/Real.lean",
              "def_pos": [
                383,
                9
              ],
              "def_end_pos": [
                383,
                21
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d : MeasurableSpace \u03b2\n\u03bc : FiniteMeasure \u03b1\n\u03bd : FiniteMeasure \u03b2\n\u22a2 (((\u2191\u03bc).prod \u2191\u03bd) (univ \u00d7\u02e2 univ)).toNNReal = (\u2191\u03bc univ).toNNReal * (\u2191\u03bd univ).toNNReal",
        "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d : MeasurableSpace \u03b2\n\u03bc : FiniteMeasure \u03b1\n\u03bd : FiniteMeasure \u03b2\n\u22a2 (((\u2191\u03bc).prod \u2191\u03bd) (univ \u00d7\u02e2 univ)).toNNReal = (\u2191\u03bc univ * \u2191\u03bd univ).toNNReal"
      },
      {
        "tactic": "exact congr_arg ENNReal.toNNReal (Measure.prod_prod univ univ)",
        "annotated_tactic": [
          "exact <a>congr_arg</a> <a>ENNReal.toNNReal</a> (<a>Measure.prod_prod</a> <a>univ</a> <a>univ</a>)",
          [
            {
              "full_name": "congr_arg",
              "def_path": ".lake/packages/batteries/Batteries/Logic.lean",
              "def_pos": [
                76,
                7
              ],
              "def_end_pos": [
                76,
                16
              ]
            },
            {
              "full_name": "ENNReal.toNNReal",
              "def_path": "Mathlib/Data/ENNReal/Basic.lean",
              "def_pos": [
                190,
                15
              ],
              "def_end_pos": [
                190,
                23
              ]
            },
            {
              "full_name": "MeasureTheory.Measure.prod_prod",
              "def_path": "Mathlib/MeasureTheory/Constructions/Prod/Basic.lean",
              "def_pos": [
                350,
                9
              ],
              "def_end_pos": [
                350,
                18
              ]
            },
            {
              "full_name": "Set.univ",
              "def_path": "Mathlib/Init/Set.lean",
              "def_pos": [
                153,
                5
              ],
              "def_end_pos": [
                153,
                9
              ]
            },
            {
              "full_name": "Set.univ",
              "def_path": "Mathlib/Init/Set.lean",
              "def_pos": [
                153,
                5
              ],
              "def_end_pos": [
                153,
                9
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\n\u03b2 : Type u_2\ninst\u271d : MeasurableSpace \u03b2\n\u03bc : FiniteMeasure \u03b1\n\u03bd : FiniteMeasure \u03b2\n\u22a2 (((\u2191\u03bc).prod \u2191\u03bd) (univ \u00d7\u02e2 univ)).toNNReal = (\u2191\u03bc univ * \u2191\u03bd univ).toNNReal",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.567469767993316,
    "entry_failed": false
  },
  "4349": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Game/Ordinal.lean",
    "full_name": "Ordinal.toPGame_le",
    "start": [
      134,
      1
    ],
    "end": [
      137,
      63
    ],
    "traced_tactics": [
      {
        "tactic": "refine le_iff_forall_lf.2 \u27e8fun i => ?_, isEmptyElim\u27e9",
        "annotated_tactic": [
          "refine <a>le_iff_forall_lf</a>.2 \u27e8fun i => ?_, <a>isEmptyElim</a>\u27e9",
          [
            {
              "full_name": "SetTheory.PGame.le_iff_forall_lf",
              "def_path": "Mathlib/SetTheory/Game/PGame.lean",
              "def_pos": [
                427,
                9
              ],
              "def_end_pos": [
                427,
                25
              ]
            },
            {
              "full_name": "isEmptyElim",
              "def_path": "Mathlib/Logic/IsEmpty.lean",
              "def_pos": [
                96,
                5
              ],
              "def_end_pos": [
                96,
                16
              ]
            }
          ]
        ],
        "state_before": "a b : Ordinal.{u_1}\nh : a \u2264 b\n\u22a2 a.toPGame \u2264 b.toPGame",
        "state_after": "a b : Ordinal.{u_1}\nh : a \u2264 b\ni : a.toPGame.LeftMoves\n\u22a2 a.toPGame.moveLeft i \u29cf b.toPGame"
      },
      {
        "tactic": "rw [toPGame_moveLeft']",
        "annotated_tactic": [
          "rw [<a>toPGame_moveLeft'</a>]",
          [
            {
              "full_name": "Ordinal.toPGame_moveLeft'",
              "def_path": "Mathlib/SetTheory/Game/Ordinal.lean",
              "def_pos": [
                91,
                9
              ],
              "def_end_pos": [
                91,
                26
              ]
            }
          ]
        ],
        "state_before": "a b : Ordinal.{u_1}\nh : a \u2264 b\ni : a.toPGame.LeftMoves\n\u22a2 a.toPGame.moveLeft i \u29cf b.toPGame",
        "state_after": "a b : Ordinal.{u_1}\nh : a \u2264 b\ni : a.toPGame.LeftMoves\n\u22a2 (\u2191(toLeftMovesToPGame.symm i)).toPGame \u29cf b.toPGame"
      },
      {
        "tactic": "exact toPGame_lf ((toLeftMovesToPGame_symm_lt i).trans_le h)",
        "annotated_tactic": [
          "exact <a>toPGame_lf</a> ((<a>toLeftMovesToPGame_symm_lt</a> i).<a>trans_le</a> h)",
          [
            {
              "full_name": "Ordinal.toPGame_lf",
              "def_path": "Mathlib/SetTheory/Game/Ordinal.lean",
              "def_pos": [
                130,
                9
              ],
              "def_end_pos": [
                130,
                19
              ]
            },
            {
              "full_name": "Ordinal.toLeftMovesToPGame_symm_lt",
              "def_path": "Mathlib/SetTheory/Game/Ordinal.lean",
              "def_pos": [
                77,
                9
              ],
              "def_end_pos": [
                77,
                35
              ]
            },
            {
              "full_name": "LT.lt.trans_le",
              "def_path": "Mathlib/Order/Basic.lean",
              "def_pos": [
                143,
                7
              ],
              "def_end_pos": [
                143,
                21
              ]
            }
          ]
        ],
        "state_before": "a b : Ordinal.{u_1}\nh : a \u2264 b\ni : a.toPGame.LeftMoves\n\u22a2 (\u2191(toLeftMovesToPGame.symm i)).toPGame \u29cf b.toPGame",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7286550159333274,
    "entry_failed": false
  },
  "4413": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/PNat/Prime.lean",
    "full_name": "PNat.Coprime.pow",
    "start": [
      316,
      1
    ],
    "end": [
      317,
      58
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 coprime_coe] at *",
        "annotated_tactic": [
          "rw [\u2190 <a>coprime_coe</a>] at *",
          [
            {
              "full_name": "PNat.coprime_coe",
              "def_path": "Mathlib/Data/PNat/Prime.lean",
              "def_pos": [
                186,
                9
              ],
              "def_end_pos": [
                186,
                20
              ]
            }
          ]
        ],
        "state_before": "m n : \u2115+\nk l : \u2115\nh : m.Coprime n\n\u22a2 (\u2191m ^ k).Coprime (\u2191n ^ l)",
        "state_after": "m n : \u2115+\nk l : \u2115\nh : (\u2191m).Coprime \u2191n\n\u22a2 (\u2191m ^ k).Coprime (\u2191n ^ l)"
      },
      {
        "tactic": "apply Nat.Coprime.pow",
        "annotated_tactic": [
          "apply <a>Nat.Coprime.pow</a>",
          [
            {
              "full_name": "Nat.Coprime.pow",
              "def_path": ".lake/packages/batteries/Batteries/Data/Nat/Gcd.lean",
              "def_pos": [
                165,
                9
              ],
              "def_end_pos": [
                165,
                20
              ]
            }
          ]
        ],
        "state_before": "m n : \u2115+\nk l : \u2115\nh : (\u2191m).Coprime \u2191n\n\u22a2 (\u2191m ^ k).Coprime (\u2191n ^ l)",
        "state_after": "case H1\nm n : \u2115+\nk l : \u2115\nh : (\u2191m).Coprime \u2191n\n\u22a2 (\u2191m).Coprime \u2191n"
      },
      {
        "tactic": "apply h",
        "annotated_tactic": [
          "apply h",
          []
        ],
        "state_before": "case H1\nm n : \u2115+\nk l : \u2115\nh : (\u2191m).Coprime \u2191n\n\u22a2 (\u2191m).Coprime \u2191n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.1170222110813484,
    "entry_failed": false
  },
  "4420": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Homology/Embedding/Basic.lean",
    "full_name": "ComplexShape.Embedding.rel_iff",
    "start": [
      72,
      1
    ],
    "end": [
      75,
      16
    ],
    "traced_tactics": [
      {
        "tactic": "constructor",
        "annotated_tactic": [
          "constructor",
          []
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b9' : Type u_2\nc : ComplexShape \u03b9\nc' : ComplexShape \u03b9'\ne : c.Embedding c'\ninst\u271d : e.IsRelIff\ni\u2081 i\u2082 : \u03b9\n\u22a2 c'.Rel (e.f i\u2081) (e.f i\u2082) \u2194 c.Rel i\u2081 i\u2082",
        "state_after": "case mp\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nc : ComplexShape \u03b9\nc' : ComplexShape \u03b9'\ne : c.Embedding c'\ninst\u271d : e.IsRelIff\ni\u2081 i\u2082 : \u03b9\n\u22a2 c'.Rel (e.f i\u2081) (e.f i\u2082) \u2192 c.Rel i\u2081 i\u2082\n\ncase mpr\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nc : ComplexShape \u03b9\nc' : ComplexShape \u03b9'\ne : c.Embedding c'\ninst\u271d : e.IsRelIff\ni\u2081 i\u2082 : \u03b9\n\u22a2 c.Rel i\u2081 i\u2082 \u2192 c'.Rel (e.f i\u2081) (e.f i\u2082)"
      },
      {
        "tactic": "apply IsRelIff.rel'",
        "annotated_tactic": [
          "apply <a>IsRelIff.rel'</a>",
          [
            {
              "full_name": "ComplexShape.Embedding.IsRelIff.rel'",
              "def_path": "Mathlib/Algebra/Homology/Embedding/Basic.lean",
              "def_pos": [
                70,
                3
              ],
              "def_end_pos": [
                70,
                7
              ]
            }
          ]
        ],
        "state_before": "case mp\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nc : ComplexShape \u03b9\nc' : ComplexShape \u03b9'\ne : c.Embedding c'\ninst\u271d : e.IsRelIff\ni\u2081 i\u2082 : \u03b9\n\u22a2 c'.Rel (e.f i\u2081) (e.f i\u2082) \u2192 c.Rel i\u2081 i\u2082",
        "state_after": "no goals"
      },
      {
        "tactic": "exact e.rel",
        "annotated_tactic": [
          "exact e.rel",
          []
        ],
        "state_before": "case mpr\n\u03b9 : Type u_1\n\u03b9' : Type u_2\nc : ComplexShape \u03b9\nc' : ComplexShape \u03b9'\ne : c.Embedding c'\ninst\u271d : e.IsRelIff\ni\u2081 i\u2082 : \u03b9\n\u22a2 c.Rel i\u2081 i\u2082 \u2192 c'.Rel (e.f i\u2081) (e.f i\u2082)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.0765668379608542,
    "entry_failed": false
  },
  "4422": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/Quiver/Cast.lean",
    "full_name": "Quiver.eq_nil_of_length_zero",
    "start": [
      148,
      1
    ],
    "end": [
      152,
      55
    ],
    "traced_tactics": [
      {
        "tactic": "cases p",
        "annotated_tactic": [
          "cases p",
          []
        ],
        "state_before": "U : Type u_1\ninst\u271d : Quiver U\nu v : U\np : Path u v\nhzero : p.length = 0\n\u22a2 Path.cast \u22ef \u22ef p = nil",
        "state_after": "case nil\nU : Type u_1\ninst\u271d : Quiver U\nu : U\nhzero : nil.length = 0\n\u22a2 Path.cast \u22ef \u22ef nil = nil\n\ncase cons\nU : Type u_1\ninst\u271d : Quiver U\nu v b\u271d : U\na\u271d\u00b9 : Path u b\u271d\na\u271d : b\u271d \u27f6 v\nhzero : (a\u271d\u00b9.cons a\u271d).length = 0\n\u22a2 Path.cast \u22ef \u22ef (a\u271d\u00b9.cons a\u271d) = nil"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case nil\nU : Type u_1\ninst\u271d : Quiver U\nu : U\nhzero : nil.length = 0\n\u22a2 Path.cast \u22ef \u22ef nil = nil",
        "state_after": "no goals"
      },
      {
        "tactic": "simp only [Nat.succ_ne_zero, length_cons] at hzero",
        "annotated_tactic": [
          "simp only [<a>Nat.succ_ne_zero</a>, <a>length_cons</a>] at hzero",
          [
            {
              "full_name": "Nat.succ_ne_zero",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean",
              "def_pos": [
                708,
                17
              ],
              "def_end_pos": [
                708,
                29
              ]
            },
            {
              "full_name": "Quiver.Path.length_cons",
              "def_path": "Mathlib/Combinatorics/Quiver/Path.lean",
              "def_pos": [
                77,
                9
              ],
              "def_end_pos": [
                77,
                20
              ]
            }
          ]
        ],
        "state_before": "case cons\nU : Type u_1\ninst\u271d : Quiver U\nu v b\u271d : U\na\u271d\u00b9 : Path u b\u271d\na\u271d : b\u271d \u27f6 v\nhzero : (a\u271d\u00b9.cons a\u271d).length = 0\n\u22a2 Path.cast \u22ef \u22ef (a\u271d\u00b9.cons a\u271d) = nil",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.147067220066674,
    "entry_failed": false
  },
  "4426": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Seq/Computation.lean",
    "full_name": "Computation.of_results_think",
    "start": [
      566,
      1
    ],
    "end": [
      570,
      61
    ],
    "traced_tactics": [
      {
        "tactic": "haveI := of_think_terminates h.terminates",
        "annotated_tactic": [
          "haveI := <a>of_think_terminates</a> h.terminates",
          [
            {
              "full_name": "Computation.of_think_terminates",
              "def_path": "Mathlib/Data/Seq/Computation.lean",
              "def_pos": [
                390,
                9
              ],
              "def_end_pos": [
                390,
                28
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns : Computation \u03b1\na : \u03b1\nn : \u2115\nh : s.think.Results a n\n\u22a2 \u2203 m, s.Results a m \u2227 n = m + 1",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns : Computation \u03b1\na : \u03b1\nn : \u2115\nh : s.think.Results a n\nthis : s.Terminates\n\u22a2 \u2203 m, s.Results a m \u2227 n = m + 1"
      },
      {
        "tactic": "have := results_of_terminates' _ (of_think_mem h.mem)",
        "annotated_tactic": [
          "have := <a>results_of_terminates'</a> _ (<a>of_think_mem</a> h.mem)",
          [
            {
              "full_name": "Computation.results_of_terminates'",
              "def_path": "Mathlib/Data/Seq/Computation.lean",
              "def_pos": [
                503,
                9
              ],
              "def_end_pos": [
                503,
                31
              ]
            },
            {
              "full_name": "Computation.of_think_mem",
              "def_path": "Mathlib/Data/Seq/Computation.lean",
              "def_pos": [
                383,
                9
              ],
              "def_end_pos": [
                383,
                21
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns : Computation \u03b1\na : \u03b1\nn : \u2115\nh : s.think.Results a n\nthis : s.Terminates\n\u22a2 \u2203 m, s.Results a m \u2227 n = m + 1",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns : Computation \u03b1\na : \u03b1\nn : \u2115\nh : s.think.Results a n\nthis\u271d : s.Terminates\nthis : s.Results a s.length\n\u22a2 \u2203 m, s.Results a m \u2227 n = m + 1"
      },
      {
        "tactic": "exact \u27e8_, this, Results.len_unique h (results_think this)\u27e9",
        "annotated_tactic": [
          "exact \u27e8_, this, <a>Results.len_unique</a> h (<a>results_think</a> this)\u27e9",
          [
            {
              "full_name": "Computation.Results.len_unique",
              "def_path": "Mathlib/Data/Seq/Computation.lean",
              "def_pos": [
                524,
                9
              ],
              "def_end_pos": [
                524,
                27
              ]
            },
            {
              "full_name": "Computation.results_think",
              "def_path": "Mathlib/Data/Seq/Computation.lean",
              "def_pos": [
                561,
                9
              ],
              "def_end_pos": [
                561,
                22
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns : Computation \u03b1\na : \u03b1\nn : \u2115\nh : s.think.Results a n\nthis\u271d : s.Terminates\nthis : s.Results a s.length\n\u22a2 \u2203 m, s.Results a m \u2227 n = m + 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.965861549018882,
    "entry_failed": false
  },
  "4494": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Category/TopCat/Limits/Products.lean",
    "full_name": "TopCat.piIsoPi_hom_apply",
    "start": [
      81,
      1
    ],
    "end": [
      85,
      42
    ],
    "traced_tactics": [
      {
        "tactic": "have := piIsoPi_inv_\u03c0 \u03b1 i",
        "annotated_tactic": [
          "have := <a>piIsoPi_inv_\u03c0</a> \u03b1 i",
          [
            {
              "full_name": "TopCat.piIsoPi_inv_\u03c0",
              "def_path": "Mathlib/Topology/Category/TopCat/Limits/Products.lean",
              "def_pos": [
                71,
                9
              ],
              "def_end_pos": [
                71,
                22
              ]
            }
          ]
        ],
        "state_before": "J : Type v\ninst\u271d : SmallCategory J\n\u03b9 : Type v\n\u03b1 : \u03b9 \u2192 TopCat\ni : \u03b9\nx : \u2191(\u220f\u1d9c \u03b1)\n\u22a2 (piIsoPi \u03b1).hom x i = (Pi.\u03c0 \u03b1 i) x",
        "state_after": "J : Type v\ninst\u271d : SmallCategory J\n\u03b9 : Type v\n\u03b1 : \u03b9 \u2192 TopCat\ni : \u03b9\nx : \u2191(\u220f\u1d9c \u03b1)\nthis : (piIsoPi \u03b1).inv \u226b Pi.\u03c0 \u03b1 i = pi\u03c0 \u03b1 i\n\u22a2 (piIsoPi \u03b1).hom x i = (Pi.\u03c0 \u03b1 i) x"
      },
      {
        "tactic": "rw [Iso.inv_comp_eq] at this",
        "annotated_tactic": [
          "rw [<a>Iso.inv_comp_eq</a>] at this",
          [
            {
              "full_name": "CategoryTheory.Iso.inv_comp_eq",
              "def_path": "Mathlib/CategoryTheory/Iso.lean",
              "def_pos": [
                211,
                9
              ],
              "def_end_pos": [
                211,
                20
              ]
            }
          ]
        ],
        "state_before": "J : Type v\ninst\u271d : SmallCategory J\n\u03b9 : Type v\n\u03b1 : \u03b9 \u2192 TopCat\ni : \u03b9\nx : \u2191(\u220f\u1d9c \u03b1)\nthis : (piIsoPi \u03b1).inv \u226b Pi.\u03c0 \u03b1 i = pi\u03c0 \u03b1 i\n\u22a2 (piIsoPi \u03b1).hom x i = (Pi.\u03c0 \u03b1 i) x",
        "state_after": "J : Type v\ninst\u271d : SmallCategory J\n\u03b9 : Type v\n\u03b1 : \u03b9 \u2192 TopCat\ni : \u03b9\nx : \u2191(\u220f\u1d9c \u03b1)\nthis : Pi.\u03c0 \u03b1 i = (piIsoPi \u03b1).hom \u226b pi\u03c0 \u03b1 i\n\u22a2 (piIsoPi \u03b1).hom x i = (Pi.\u03c0 \u03b1 i) x"
      },
      {
        "tactic": "exact ConcreteCategory.congr_hom this x",
        "annotated_tactic": [
          "exact <a>ConcreteCategory.congr_hom</a> this x",
          [
            {
              "full_name": "CategoryTheory.ConcreteCategory.congr_hom",
              "def_path": "Mathlib/CategoryTheory/ConcreteCategory/Basic.lean",
              "def_pos": [
                141,
                9
              ],
              "def_end_pos": [
                141,
                35
              ]
            }
          ]
        ],
        "state_before": "J : Type v\ninst\u271d : SmallCategory J\n\u03b9 : Type v\n\u03b1 : \u03b9 \u2192 TopCat\ni : \u03b9\nx : \u2191(\u220f\u1d9c \u03b1)\nthis : Pi.\u03c0 \u03b1 i = (piIsoPi \u03b1).hom \u226b pi\u03c0 \u03b1 i\n\u22a2 (piIsoPi \u03b1).hom x i = (Pi.\u03c0 \u03b1 i) x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.904082246008329,
    "entry_failed": false
  },
  "4501": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Real/Hyperreal.lean",
    "full_name": "Hyperreal.IsSt.st_eq",
    "start": [
      282,
      1
    ],
    "end": [
      285,
      45
    ],
    "traced_tactics": [
      {
        "tactic": "have h : \u2203 r, IsSt x r := \u27e8r, hxr\u27e9",
        "annotated_tactic": [
          "have h : \u2203 r, <a>IsSt</a> x r := \u27e8r, hxr\u27e9",
          [
            {
              "full_name": "Hyperreal.IsSt",
              "def_path": "Mathlib/Data/Real/Hyperreal.lean",
              "def_pos": [
                222,
                5
              ],
              "def_end_pos": [
                222,
                9
              ]
            }
          ]
        ],
        "state_before": "x : \u211d*\nr : \u211d\nhxr : x.IsSt r\n\u22a2 x.st = r",
        "state_after": "x : \u211d*\nr : \u211d\nhxr : x.IsSt r\nh : \u2203 r, x.IsSt r\n\u22a2 x.st = r"
      },
      {
        "tactic": "rw [st, dif_pos h]",
        "annotated_tactic": [
          "rw [<a>st</a>, <a>dif_pos</a> h]",
          [
            {
              "full_name": "Hyperreal.st",
              "def_path": "Mathlib/Data/Real/Hyperreal.lean",
              "def_pos": [
                227,
                19
              ],
              "def_end_pos": [
                227,
                21
              ]
            },
            {
              "full_name": "dif_pos",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                949,
                9
              ],
              "def_end_pos": [
                949,
                16
              ]
            }
          ]
        ],
        "state_before": "x : \u211d*\nr : \u211d\nhxr : x.IsSt r\nh : \u2203 r, x.IsSt r\n\u22a2 x.st = r",
        "state_after": "x : \u211d*\nr : \u211d\nhxr : x.IsSt r\nh : \u2203 r, x.IsSt r\n\u22a2 Classical.choose h = r"
      },
      {
        "tactic": "exact (Classical.choose_spec h).unique hxr",
        "annotated_tactic": [
          "exact (<a>Classical.choose_spec</a> h).<a>unique</a> hxr",
          [
            {
              "full_name": "Classical.choose_spec",
              "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean",
              "def_pos": [
                28,
                9
              ],
              "def_end_pos": [
                28,
                20
              ]
            },
            {
              "full_name": "Hyperreal.IsSt.unique",
              "def_path": "Mathlib/Data/Real/Hyperreal.lean",
              "def_pos": [
                276,
                9
              ],
              "def_end_pos": [
                276,
                20
              ]
            }
          ]
        ],
        "state_before": "x : \u211d*\nr : \u211d\nhxr : x.IsSt r\nh : \u2203 r, x.IsSt r\n\u22a2 Classical.choose h = r",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.361277475953102,
    "entry_failed": false
  },
  "4572": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Perm/Support.lean",
    "full_name": "Equiv.Perm.set_support_inv_eq",
    "start": [
      264,
      1
    ],
    "end": [
      267,
      39
    ],
    "traced_tactics": [
      {
        "tactic": "ext x",
        "annotated_tactic": [
          "ext x",
          []
        ],
        "state_before": "\u03b1 : Type u_1\np q : Perm \u03b1\n\u22a2 {x | p\u207b\u00b9 x \u2260 x} = {x | p x \u2260 x}",
        "state_after": "case h\n\u03b1 : Type u_1\np q : Perm \u03b1\nx : \u03b1\n\u22a2 x \u2208 {x | p\u207b\u00b9 x \u2260 x} \u2194 x \u2208 {x | p x \u2260 x}"
      },
      {
        "tactic": "simp only [Set.mem_setOf_eq, Ne]",
        "annotated_tactic": [
          "simp only [<a>Set.mem_setOf_eq</a>, <a>Ne</a>]",
          [
            {
              "full_name": "Set.mem_setOf_eq",
              "def_path": "Mathlib/Data/Set/Defs.lean",
              "def_pos": [
                79,
                29
              ],
              "def_end_pos": [
                79,
                41
              ]
            },
            {
              "full_name": "Ne",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                689,
                18
              ],
              "def_end_pos": [
                689,
                20
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u_1\np q : Perm \u03b1\nx : \u03b1\n\u22a2 x \u2208 {x | p\u207b\u00b9 x \u2260 x} \u2194 x \u2208 {x | p x \u2260 x}",
        "state_after": "case h\n\u03b1 : Type u_1\np q : Perm \u03b1\nx : \u03b1\n\u22a2 \u00acp\u207b\u00b9 x = x \u2194 \u00acp x = x"
      },
      {
        "tactic": "rw [inv_def, symm_apply_eq, eq_comm]",
        "annotated_tactic": [
          "rw [<a>inv_def</a>, <a>symm_apply_eq</a>, <a>eq_comm</a>]",
          [
            {
              "full_name": "Equiv.Perm.inv_def",
              "def_path": "Mathlib/GroupTheory/Perm/Basic.lean",
              "def_pos": [
                101,
                9
              ],
              "def_end_pos": [
                101,
                16
              ]
            },
            {
              "full_name": "Equiv.symm_apply_eq",
              "def_path": "Mathlib/Logic/Equiv/Defs.lean",
              "def_pos": [
                342,
                9
              ],
              "def_end_pos": [
                342,
                22
              ]
            },
            {
              "full_name": "eq_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                811,
                9
              ],
              "def_end_pos": [
                811,
                16
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u_1\np q : Perm \u03b1\nx : \u03b1\n\u22a2 \u00acp\u207b\u00b9 x = x \u2194 \u00acp x = x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.3988211719552055,
    "entry_failed": false
  },
  "4637": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Matroid/Restrict.lean",
    "full_name": "Matroid.restriction_iff_exists",
    "start": [
      293,
      1
    ],
    "end": [
      294,
      93
    ],
    "traced_tactics": [
      {
        "tactic": "use Restriction.exists_eq_restrict",
        "annotated_tactic": [
          "use <a>Restriction.exists_eq_restrict</a>",
          [
            {
              "full_name": "Matroid.Restriction.exists_eq_restrict",
              "def_path": "Mathlib/Data/Matroid/Restrict.lean",
              "def_pos": [
                287,
                9
              ],
              "def_end_pos": [
                287,
                39
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nM : Matroid \u03b1\nR I J X Y : Set \u03b1\nN : Matroid \u03b1\n\u22a2 N \u2264r M \u2194 \u2203 R \u2286 M.E, N = M \u21be R",
        "state_after": "case mpr\n\u03b1 : Type u_1\nM : Matroid \u03b1\nR I J X Y : Set \u03b1\nN : Matroid \u03b1\n\u22a2 (\u2203 R \u2286 M.E, N = M \u21be R) \u2192 N \u2264r M"
      },
      {
        "tactic": "rintro \u27e8R, hR, rfl\u27e9",
        "annotated_tactic": [
          "rintro \u27e8R, hR, rfl\u27e9",
          []
        ],
        "state_before": "case mpr\n\u03b1 : Type u_1\nM : Matroid \u03b1\nR I J X Y : Set \u03b1\nN : Matroid \u03b1\n\u22a2 (\u2203 R \u2286 M.E, N = M \u21be R) \u2192 N \u2264r M",
        "state_after": "case mpr.intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nR\u271d I J X Y R : Set \u03b1\nhR : R \u2286 M.E\n\u22a2 M \u21be R \u2264r M"
      },
      {
        "tactic": "exact restrict_restriction M R hR",
        "annotated_tactic": [
          "exact <a>restrict_restriction</a> M R hR",
          [
            {
              "full_name": "Matroid.restrict_restriction",
              "def_path": "Mathlib/Data/Matroid/Restrict.lean",
              "def_pos": [
                277,
                9
              ],
              "def_end_pos": [
                277,
                29
              ]
            }
          ]
        ],
        "state_before": "case mpr.intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nR\u271d I J X Y R : Set \u03b1\nhR : R \u2286 M.E\n\u22a2 M \u21be R \u2264r M",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.6490447809919715,
    "entry_failed": false
  },
  "4666": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Cardinal/ToNat.lean",
    "full_name": "Cardinal.toNat_add",
    "start": [
      183,
      1
    ],
    "end": [
      186,
      12
    ],
    "traced_tactics": [
      {
        "tactic": "lift c to \u2115 using hc",
        "annotated_tactic": [
          "lift c to \u2115 using hc",
          []
        ],
        "state_before": "\u03b1 : Type u\nc d : Cardinal.{u}\nhc : c < \u2135\u2080\nhd : d < \u2135\u2080\n\u22a2 toNat (c + d) = toNat c + toNat d",
        "state_after": "case intro\n\u03b1 : Type u\nd : Cardinal.{u}\nhd : d < \u2135\u2080\nc : \u2115\n\u22a2 toNat (\u2191c + d) = toNat \u2191c + toNat d"
      },
      {
        "tactic": "lift d to \u2115 using hd",
        "annotated_tactic": [
          "lift d to \u2115 using hd",
          []
        ],
        "state_before": "case intro\n\u03b1 : Type u\nd : Cardinal.{u}\nhd : d < \u2135\u2080\nc : \u2115\n\u22a2 toNat (\u2191c + d) = toNat \u2191c + toNat d",
        "state_after": "case intro.intro\n\u03b1 : Type u\nc d : \u2115\n\u22a2 toNat (\u2191c + \u2191d) = toNat \u2191c + toNat \u2191d"
      },
      {
        "tactic": "norm_cast",
        "annotated_tactic": [
          "norm_cast",
          []
        ],
        "state_before": "case intro.intro\n\u03b1 : Type u\nc d : \u2115\n\u22a2 toNat (\u2191c + \u2191d) = toNat \u2191c + toNat \u2191d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.1386367439990863,
    "entry_failed": false
  },
  "4701": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Sub/Canonical.lean",
    "full_name": "tsub_add_eq_max",
    "start": [
      503,
      1
    ],
    "end": [
      506,
      48
    ],
    "traced_tactics": [
      {
        "tactic": "rcases le_total a b with h | h",
        "annotated_tactic": [
          "rcases <a>le_total</a> a b with h | h",
          [
            {
              "full_name": "le_total",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                297,
                9
              ],
              "def_end_pos": [
                297,
                17
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CanonicallyLinearOrderedAddCommMonoid \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\n\u22a2 a - b + b = max a b",
        "state_after": "case inl\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CanonicallyLinearOrderedAddCommMonoid \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\nh : a \u2264 b\n\u22a2 a - b + b = max a b\n\ncase inr\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CanonicallyLinearOrderedAddCommMonoid \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\nh : b \u2264 a\n\u22a2 a - b + b = max a b"
      },
      {
        "tactic": "rw [max_eq_right h, tsub_eq_zero_of_le h, zero_add]",
        "annotated_tactic": [
          "rw [<a>max_eq_right</a> h, <a>tsub_eq_zero_of_le</a> h, <a>zero_add</a>]",
          [
            {
              "full_name": "max_eq_right",
              "def_path": "Mathlib/Init/Order/LinearOrder.lean",
              "def_pos": [
                137,
                9
              ],
              "def_end_pos": [
                137,
                21
              ]
            },
            {
              "full_name": "tsub_eq_zero_of_le",
              "def_path": "Mathlib/Algebra/Order/Sub/Canonical.lean",
              "def_pos": [
                337,
                11
              ],
              "def_end_pos": [
                337,
                29
              ]
            },
            {
              "full_name": "zero_add",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                476,
                3
              ],
              "def_end_pos": [
                476,
                14
              ]
            }
          ]
        ],
        "state_before": "case inl\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CanonicallyLinearOrderedAddCommMonoid \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\nh : a \u2264 b\n\u22a2 a - b + b = max a b",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [max_eq_left h, tsub_add_cancel_of_le h]",
        "annotated_tactic": [
          "rw [<a>max_eq_left</a> h, <a>tsub_add_cancel_of_le</a> h]",
          [
            {
              "full_name": "max_eq_left",
              "def_path": "Mathlib/Init/Order/LinearOrder.lean",
              "def_pos": [
                133,
                9
              ],
              "def_end_pos": [
                133,
                20
              ]
            },
            {
              "full_name": "tsub_add_cancel_of_le",
              "def_path": "Mathlib/Algebra/Order/Sub/Canonical.lean",
              "def_pos": [
                31,
                9
              ],
              "def_end_pos": [
                31,
                30
              ]
            }
          ]
        ],
        "state_before": "case inr\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CanonicallyLinearOrderedAddCommMonoid \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\nh : b \u2264 a\n\u22a2 a - b + b = max a b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.493538800976239,
    "entry_failed": false
  },
  "4710": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/Additive/ETransform.lean",
    "full_name": "Finset.mulDysonETransform.smul_finset_snd_subset_fst",
    "start": [
      88,
      1
    ],
    "end": [
      92,
      27
    ],
    "traced_tactics": [
      {
        "tactic": "dsimp",
        "annotated_tactic": [
          "dsimp",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : CommGroup \u03b1\ne : \u03b1\nx : Finset \u03b1 \u00d7 Finset \u03b1\n\u22a2 e \u2022 (mulDysonETransform e x).2 \u2286 (mulDysonETransform e x).1",
        "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : CommGroup \u03b1\ne : \u03b1\nx : Finset \u03b1 \u00d7 Finset \u03b1\n\u22a2 e \u2022 (x.2 \u2229 e\u207b\u00b9 \u2022 x.1) \u2286 x.1 \u222a e \u2022 x.2"
      },
      {
        "tactic": "rw [smul_finset_inter, smul_inv_smul, inter_comm]",
        "annotated_tactic": [
          "rw [<a>smul_finset_inter</a>, <a>smul_inv_smul</a>, <a>inter_comm</a>]",
          [
            {
              "full_name": "Finset.smul_finset_inter",
              "def_path": "Mathlib/Data/Finset/Pointwise.lean",
              "def_pos": [
                2131,
                9
              ],
              "def_end_pos": [
                2131,
                26
              ]
            },
            {
              "full_name": "smul_inv_smul",
              "def_path": "Mathlib/GroupTheory/GroupAction/Group.lean",
              "def_pos": [
                35,
                9
              ],
              "def_end_pos": [
                35,
                22
              ]
            },
            {
              "full_name": "Finset.inter_comm",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                1647,
                9
              ],
              "def_end_pos": [
                1647,
                19
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : CommGroup \u03b1\ne : \u03b1\nx : Finset \u03b1 \u00d7 Finset \u03b1\n\u22a2 e \u2022 (x.2 \u2229 e\u207b\u00b9 \u2022 x.1) \u2286 x.1 \u222a e \u2022 x.2",
        "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : CommGroup \u03b1\ne : \u03b1\nx : Finset \u03b1 \u00d7 Finset \u03b1\n\u22a2 x.1 \u2229 e \u2022 x.2 \u2286 x.1 \u222a e \u2022 x.2"
      },
      {
        "tactic": "exact inter_subset_union",
        "annotated_tactic": [
          "exact <a>inter_subset_union</a>",
          [
            {
              "full_name": "Finset.inter_subset_union",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                1748,
                9
              ],
              "def_end_pos": [
                1748,
                27
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : CommGroup \u03b1\ne : \u03b1\nx : Finset \u03b1 \u00d7 Finset \u03b1\n\u22a2 x.1 \u2229 e \u2022 x.2 \u2286 x.1 \u222a e \u2022 x.2",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.0866272730054334,
    "entry_failed": false
  },
  "4729": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/Simple.lean",
    "full_name": "CategoryTheory.mono_to_simple_zero_of_not_iso",
    "start": [
      103,
      1
    ],
    "end": [
      107,
      41
    ],
    "traced_tactics": [
      {
        "tactic": "classical\n  by_contra h\n  exact w (isIso_of_mono_of_nonzero h)",
        "annotated_tactic": [
          "classical\n    by_contra h\n    exact w (<a>isIso_of_mono_of_nonzero</a> h)",
          [
            {
              "full_name": "CategoryTheory.isIso_of_mono_of_nonzero",
              "def_path": "Mathlib/CategoryTheory/Simple.lean",
              "def_pos": [
                57,
                9
              ],
              "def_end_pos": [
                57,
                33
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : HasZeroMorphisms C\nX Y : C\ninst\u271d\u00b9 : Simple Y\nf : X \u27f6 Y\ninst\u271d : Mono f\nw : IsIso f \u2192 False\n\u22a2 f = 0",
        "state_after": "no goals"
      },
      {
        "tactic": "by_contra h",
        "annotated_tactic": [
          "by_contra h",
          []
        ],
        "state_before": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : HasZeroMorphisms C\nX Y : C\ninst\u271d\u00b9 : Simple Y\nf : X \u27f6 Y\ninst\u271d : Mono f\nw : IsIso f \u2192 False\n\u22a2 f = 0",
        "state_after": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : HasZeroMorphisms C\nX Y : C\ninst\u271d\u00b9 : Simple Y\nf : X \u27f6 Y\ninst\u271d : Mono f\nw : IsIso f \u2192 False\nh : \u00acf = 0\n\u22a2 False"
      },
      {
        "tactic": "exact w (isIso_of_mono_of_nonzero h)",
        "annotated_tactic": [
          "exact w (<a>isIso_of_mono_of_nonzero</a> h)",
          [
            {
              "full_name": "CategoryTheory.isIso_of_mono_of_nonzero",
              "def_path": "Mathlib/CategoryTheory/Simple.lean",
              "def_pos": [
                57,
                9
              ],
              "def_end_pos": [
                57,
                33
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : HasZeroMorphisms C\nX Y : C\ninst\u271d\u00b9 : Simple Y\nf : X \u27f6 Y\ninst\u271d : Mono f\nw : IsIso f \u2192 False\nh : \u00acf = 0\n\u22a2 False",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5224550620187074,
    "entry_failed": false
  },
  "4740": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/PowerSeries/Basic.lean",
    "full_name": "PowerSeries.C_injective",
    "start": [
      267,
      1
    ],
    "end": [
      270,
      43
    ],
    "traced_tactics": [
      {
        "tactic": "intro a b H",
        "annotated_tactic": [
          "intro a b H",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d : Semiring R\n\u22a2 Function.Injective \u21d1(C R)",
        "state_after": "R : Type u_1\ninst\u271d : Semiring R\na b : R\nH : (C R) a = (C R) b\n\u22a2 a = b"
      },
      {
        "tactic": "have := (ext_iff (\u03c6 := C R a) (\u03c8 := C R b)).mp H 0",
        "annotated_tactic": [
          "have := (<a>ext_iff</a> (\u03c6 := <a>C</a> R a) (\u03c8 := <a>C</a> R b)).<a>mp</a> H 0",
          [
            {
              "full_name": "PowerSeries.ext_iff",
              "def_path": "Mathlib/RingTheory/PowerSeries/Basic.lean",
              "def_pos": [
                164,
                9
              ],
              "def_end_pos": [
                164,
                16
              ]
            },
            {
              "full_name": "PowerSeries.C",
              "def_path": "Mathlib/RingTheory/PowerSeries/Basic.lean",
              "def_pos": [
                210,
                5
              ],
              "def_end_pos": [
                210,
                6
              ]
            },
            {
              "full_name": "PowerSeries.C",
              "def_path": "Mathlib/RingTheory/PowerSeries/Basic.lean",
              "def_pos": [
                210,
                5
              ],
              "def_end_pos": [
                210,
                6
              ]
            },
            {
              "full_name": "Iff.mp",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                118,
                3
              ],
              "def_end_pos": [
                118,
                5
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d : Semiring R\na b : R\nH : (C R) a = (C R) b\n\u22a2 a = b",
        "state_after": "R : Type u_1\ninst\u271d : Semiring R\na b : R\nH : (C R) a = (C R) b\nthis : (coeff R 0) ((C R) a) = (coeff R 0) ((C R) b)\n\u22a2 a = b"
      },
      {
        "tactic": "rwa [coeff_zero_C, coeff_zero_C] at this",
        "annotated_tactic": [
          "rwa [<a>coeff_zero_C</a>, <a>coeff_zero_C</a>] at this",
          [
            {
              "full_name": "PowerSeries.coeff_zero_C",
              "def_path": "Mathlib/RingTheory/PowerSeries/Basic.lean",
              "def_pos": [
                255,
                9
              ],
              "def_end_pos": [
                255,
                21
              ]
            },
            {
              "full_name": "PowerSeries.coeff_zero_C",
              "def_path": "Mathlib/RingTheory/PowerSeries/Basic.lean",
              "def_pos": [
                255,
                9
              ],
              "def_end_pos": [
                255,
                21
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d : Semiring R\na b : R\nH : (C R) a = (C R) b\nthis : (coeff R 0) ((C R) a) = (coeff R 0) ((C R) b)\n\u22a2 a = b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.1293796480167657,
    "entry_failed": false
  },
  "4816": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Prod.lean",
    "full_name": "SimpleGraph.Connected.boxProd",
    "start": [
      198,
      11
    ],
    "end": [
      201,
      50
    ],
    "traced_tactics": [
      {
        "tactic": "haveI := hG.nonempty",
        "annotated_tactic": [
          "haveI := hG.nonempty",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nhG : G.Connected\nhH : H.Connected\n\u22a2 (G \u25a1 H).Connected",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nhG : G.Connected\nhH : H.Connected\nthis : Nonempty \u03b1\n\u22a2 (G \u25a1 H).Connected"
      },
      {
        "tactic": "haveI := hH.nonempty",
        "annotated_tactic": [
          "haveI := hH.nonempty",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nhG : G.Connected\nhH : H.Connected\nthis : Nonempty \u03b1\n\u22a2 (G \u25a1 H).Connected",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nhG : G.Connected\nhH : H.Connected\nthis\u271d : Nonempty \u03b1\nthis : Nonempty \u03b2\n\u22a2 (G \u25a1 H).Connected"
      },
      {
        "tactic": "exact \u27e8hG.preconnected.boxProd hH.preconnected\u27e9",
        "annotated_tactic": [
          "exact \u27e8hG.preconnected.boxProd hH.preconnected\u27e9",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nhG : G.Connected\nhH : H.Connected\nthis\u271d : Nonempty \u03b1\nthis : Nonempty \u03b2\n\u22a2 (G \u25a1 H).Connected",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.96464617701713,
    "entry_failed": false
  },
  "4912": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/UnionFind.lean",
    "full_name": "UnionFind.model'",
    "start": [
      163,
      1
    ],
    "end": [
      164,
      64
    ],
    "traced_tactics": [
      {
        "tactic": "let \u27e8n, m, hm\u27e9 := self.model",
        "annotated_tactic": [
          "let \u27e8n, m, hm\u27e9 := self.model",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nself : UnionFind \u03b1\n\u22a2 \u2203 m, UFModel.Models self.arr m",
        "state_after": "\u03b1 : Type u_1\nself : UnionFind \u03b1\nn : \u2115\nm : UFModel n\nhm : UFModel.Models self.arr m\n\u22a2 \u2203 m, UFModel.Models self.arr m"
      },
      {
        "tactic": "cases hm.size_eq",
        "annotated_tactic": [
          "cases hm.size_eq",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nself : UnionFind \u03b1\nn : \u2115\nm : UFModel n\nhm : UFModel.Models self.arr m\n\u22a2 \u2203 m, UFModel.Models self.arr m",
        "state_after": "case refl\n\u03b1 : Type u_1\nself : UnionFind \u03b1\nm : UFModel self.arr.size\nhm : UFModel.Models self.arr m\n\u22a2 \u2203 m, UFModel.Models self.arr m"
      },
      {
        "tactic": "exact \u27e8m, hm\u27e9",
        "annotated_tactic": [
          "exact \u27e8m, hm\u27e9",
          []
        ],
        "state_before": "case refl\n\u03b1 : Type u_1\nself : UnionFind \u03b1\nm : UFModel self.arr.size\nhm : UFModel.Models self.arr m\n\u22a2 \u2203 m, UFModel.Models self.arr m",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.783218183903955,
    "entry_failed": false
  },
  "4921": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/PowerSeries/Order.lean",
    "full_name": "PowerSeries.exists_coeff_ne_zero_iff_ne_zero",
    "start": [
      47,
      1
    ],
    "end": [
      51,
      51
    ],
    "traced_tactics": [
      {
        "tactic": "refine not_iff_not.mp ?_",
        "annotated_tactic": [
          "refine not_iff_not.mp ?_",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d : Semiring R\n\u03c6 : R\u27e6X\u27e7\n\u22a2 (\u2203 n, (coeff R n) \u03c6 \u2260 0) \u2194 \u03c6 \u2260 0",
        "state_after": "R : Type u_1\ninst\u271d : Semiring R\n\u03c6 : R\u27e6X\u27e7\n\u22a2 (\u00ac\u2203 n, (coeff R n) \u03c6 \u2260 0) \u2194 \u00ac\u03c6 \u2260 0"
      },
      {
        "tactic": "push_neg",
        "annotated_tactic": [
          "push_neg",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d : Semiring R\n\u03c6 : R\u27e6X\u27e7\n\u22a2 (\u00ac\u2203 n, (coeff R n) \u03c6 \u2260 0) \u2194 \u00ac\u03c6 \u2260 0",
        "state_after": "R : Type u_1\ninst\u271d : Semiring R\n\u03c6 : R\u27e6X\u27e7\n\u22a2 (\u2200 (n : \u2115), (coeff R n) \u03c6 = 0) \u2194 \u03c6 = 0"
      },
      {
        "tactic": "simp [PowerSeries.ext_iff, (coeff R _).map_zero]",
        "annotated_tactic": [
          "simp [<a>PowerSeries.ext_iff</a>, (<a>coeff</a> R _).<a>map_zero</a>]",
          [
            {
              "full_name": "PowerSeries.ext_iff",
              "def_path": "Mathlib/RingTheory/PowerSeries/Basic.lean",
              "def_pos": [
                164,
                9
              ],
              "def_end_pos": [
                164,
                16
              ]
            },
            {
              "full_name": "PowerSeries.coeff",
              "def_path": "Mathlib/RingTheory/PowerSeries/Basic.lean",
              "def_pos": [
                139,
                5
              ],
              "def_end_pos": [
                139,
                10
              ]
            },
            {
              "full_name": "LinearMap.map_zero",
              "def_path": "Mathlib/Algebra/Module/LinearMap/Defs.lean",
              "def_pos": [
                363,
                19
              ],
              "def_end_pos": [
                363,
                27
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d : Semiring R\n\u03c6 : R\u27e6X\u27e7\n\u22a2 (\u2200 (n : \u2115), (coeff R n) \u03c6 = 0) \u2194 \u03c6 = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.493489927961491,
    "entry_failed": false
  },
  "4974": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/OuterMeasure/OfFunction.lean",
    "full_name": "MeasureTheory.OuterMeasure.iSup_sInfGen_nonempty",
    "start": [
      356,
      1
    ],
    "end": [
      360,
      27
    ],
    "traced_tactics": [
      {
        "tactic": "rcases t.eq_empty_or_nonempty with (rfl | ht)",
        "annotated_tactic": [
          "rcases t.eq_empty_or_nonempty with (rfl | ht)",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nm : Set (OuterMeasure \u03b1)\nh : m.Nonempty\nt : Set \u03b1\n\u22a2 \u2a06 (_ : t.Nonempty), sInfGen m t = \u2a05 \u03bc \u2208 m, \u03bc t",
        "state_after": "case inl\n\u03b1 : Type u_1\nm : Set (OuterMeasure \u03b1)\nh : m.Nonempty\n\u22a2 \u2a06 (_ : \u2205.Nonempty), sInfGen m \u2205 = \u2a05 \u03bc \u2208 m, \u03bc \u2205\n\ncase inr\n\u03b1 : Type u_1\nm : Set (OuterMeasure \u03b1)\nh : m.Nonempty\nt : Set \u03b1\nht : t.Nonempty\n\u22a2 \u2a06 (_ : t.Nonempty), sInfGen m t = \u2a05 \u03bc \u2208 m, \u03bc t"
      },
      {
        "tactic": "simp [biInf_const h]",
        "annotated_tactic": [
          "simp [<a>biInf_const</a> h]",
          [
            {
              "full_name": "biInf_const",
              "def_path": "Mathlib/Order/CompleteLattice.lean",
              "def_pos": [
                1172,
                9
              ],
              "def_end_pos": [
                1172,
                20
              ]
            }
          ]
        ],
        "state_before": "case inl\n\u03b1 : Type u_1\nm : Set (OuterMeasure \u03b1)\nh : m.Nonempty\n\u22a2 \u2a06 (_ : \u2205.Nonempty), sInfGen m \u2205 = \u2a05 \u03bc \u2208 m, \u03bc \u2205",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [ht, sInfGen_def]",
        "annotated_tactic": [
          "simp [ht, <a>sInfGen_def</a>]",
          [
            {
              "full_name": "MeasureTheory.OuterMeasure.sInfGen_def",
              "def_path": "Mathlib/MeasureTheory/OuterMeasure/OfFunction.lean",
              "def_pos": [
                341,
                9
              ],
              "def_end_pos": [
                341,
                20
              ]
            }
          ]
        ],
        "state_before": "case inr\n\u03b1 : Type u_1\nm : Set (OuterMeasure \u03b1)\nh : m.Nonempty\nt : Set \u03b1\nht : t.Nonempty\n\u22a2 \u2a06 (_ : t.Nonempty), sInfGen m t = \u2a05 \u03bc \u2208 m, \u03bc t",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.801672406028956,
    "entry_failed": false
  },
  "5013": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean",
    "full_name": "CategoryTheory.Limits.IsZero.of_epi",
    "start": [
      241,
      1
    ],
    "end": [
      244,
      31
    ],
    "traced_tactics": [
      {
        "tactic": "have hf := i.eq_zero_of_src f",
        "annotated_tactic": [
          "have hf := i.eq_zero_of_src f",
          []
        ],
        "state_before": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nD : Type u'\ninst\u271d\u00b2 : Category.{v', u'} D\ninst\u271d\u00b9 : HasZeroMorphisms C\nX Y : C\nf : X \u27f6 Y\ninst\u271d : Epi f\ni : IsZero X\n\u22a2 IsZero Y",
        "state_after": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nD : Type u'\ninst\u271d\u00b2 : Category.{v', u'} D\ninst\u271d\u00b9 : HasZeroMorphisms C\nX Y : C\nf : X \u27f6 Y\ninst\u271d : Epi f\ni : IsZero X\nhf : f = 0\n\u22a2 IsZero Y"
      },
      {
        "tactic": "subst hf",
        "annotated_tactic": [
          "subst hf",
          []
        ],
        "state_before": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nD : Type u'\ninst\u271d\u00b2 : Category.{v', u'} D\ninst\u271d\u00b9 : HasZeroMorphisms C\nX Y : C\nf : X \u27f6 Y\ninst\u271d : Epi f\ni : IsZero X\nhf : f = 0\n\u22a2 IsZero Y",
        "state_after": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nD : Type u'\ninst\u271d\u00b2 : Category.{v', u'} D\ninst\u271d\u00b9 : HasZeroMorphisms C\nX Y : C\ni : IsZero X\ninst\u271d : Epi 0\n\u22a2 IsZero Y"
      },
      {
        "tactic": "exact IsZero.of_epi_zero X Y",
        "annotated_tactic": [
          "exact <a>IsZero.of_epi_zero</a> X Y",
          [
            {
              "full_name": "CategoryTheory.Limits.IsZero.of_epi_zero",
              "def_path": "Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean",
              "def_pos": [
                201,
                9
              ],
              "def_end_pos": [
                201,
                20
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nD : Type u'\ninst\u271d\u00b2 : Category.{v', u'} D\ninst\u271d\u00b9 : HasZeroMorphisms C\nX Y : C\ni : IsZero X\ninst\u271d : Epi 0\n\u22a2 IsZero Y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.1673520079348236,
    "entry_failed": false
  },
  "5045": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Polynomial/Monic.lean",
    "full_name": "Polynomial.Monic.natDegree_mul",
    "start": [
      175,
      1
    ],
    "end": [
      179,
      42
    ],
    "traced_tactics": [
      {
        "tactic": "nontriviality R",
        "annotated_tactic": [
          "nontriviality R",
          []
        ],
        "state_before": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : p.Monic\nhq : q.Monic\n\u22a2 (p * q).natDegree = p.natDegree + q.natDegree",
        "state_after": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : p.Monic\nhq : q.Monic\na\u271d : Nontrivial R\n\u22a2 (p * q).natDegree = p.natDegree + q.natDegree"
      },
      {
        "tactic": "apply natDegree_mul'",
        "annotated_tactic": [
          "apply <a>natDegree_mul'</a>",
          [
            {
              "full_name": "Polynomial.natDegree_mul'",
              "def_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
              "def_pos": [
                1012,
                9
              ],
              "def_end_pos": [
                1012,
                23
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : p.Monic\nhq : q.Monic\na\u271d : Nontrivial R\n\u22a2 (p * q).natDegree = p.natDegree + q.natDegree",
        "state_after": "case h\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : p.Monic\nhq : q.Monic\na\u271d : Nontrivial R\n\u22a2 p.leadingCoeff * q.leadingCoeff \u2260 0"
      },
      {
        "tactic": "simp [hp.leadingCoeff, hq.leadingCoeff]",
        "annotated_tactic": [
          "simp [hp.leadingCoeff, hq.leadingCoeff]",
          []
        ],
        "state_before": "case h\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : p.Monic\nhq : q.Monic\na\u271d : Nontrivial R\n\u22a2 p.leadingCoeff * q.leadingCoeff \u2260 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.8401274220086634,
    "entry_failed": false
  },
  "5186": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/Asymptotics/SpecificAsymptotics.lean",
    "full_name": "pow_div_pow_eventuallyEq_atBot",
    "start": [
      49,
      1
    ],
    "end": [
      53,
      25
    ],
    "traced_tactics": [
      {
        "tactic": "apply (eventually_lt_atBot (0 : \ud835\udd5c)).mono fun x hx => _",
        "annotated_tactic": [
          "apply (<a>eventually_lt_atBot</a> (0 : \ud835\udd5c)).<a>mono</a> fun x hx => _",
          [
            {
              "full_name": "Filter.eventually_lt_atBot",
              "def_path": "Mathlib/Order/Filter/AtTopBot.lean",
              "def_pos": [
                229,
                9
              ],
              "def_end_pos": [
                229,
                28
              ]
            },
            {
              "full_name": "Filter.Eventually.mono",
              "def_path": "Mathlib/Order/Filter/Basic.lean",
              "def_pos": [
                1158,
                9
              ],
              "def_end_pos": [
                1158,
                24
              ]
            }
          ]
        ],
        "state_before": "\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\np q : \u2115\n\u22a2 (fun x => x ^ p / x ^ q) =\u1da0[atBot] fun x => x ^ (\u2191p - \u2191q)",
        "state_after": "\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\np q : \u2115\n\u22a2 \u2200 x < 0, (fun x => x ^ p / x ^ q) x = (fun x => x ^ (\u2191p - \u2191q)) x"
      },
      {
        "tactic": "intro x hx",
        "annotated_tactic": [
          "intro x hx",
          []
        ],
        "state_before": "\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\np q : \u2115\n\u22a2 \u2200 x < 0, (fun x => x ^ p / x ^ q) x = (fun x => x ^ (\u2191p - \u2191q)) x",
        "state_after": "\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\np q : \u2115\nx : \ud835\udd5c\nhx : x < 0\n\u22a2 (fun x => x ^ p / x ^ q) x = (fun x => x ^ (\u2191p - \u2191q)) x"
      },
      {
        "tactic": "simp [zpow_sub\u2080 hx.ne]",
        "annotated_tactic": [
          "simp [<a>zpow_sub\u2080</a> hx.ne]",
          [
            {
              "full_name": "zpow_sub\u2080",
              "def_path": "Mathlib/Algebra/GroupWithZero/Units/Basic.lean",
              "def_pos": [
                431,
                7
              ],
              "def_end_pos": [
                431,
                16
              ]
            }
          ]
        ],
        "state_before": "\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\np q : \u2115\nx : \ud835\udd5c\nhx : x < 0\n\u22a2 (fun x => x ^ p / x ^ q) x = (fun x => x ^ (\u2191p - \u2191q)) x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7600779790664092,
    "entry_failed": false
  },
  "5241": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Factorial/Basic.lean",
    "full_name": "Nat.factorial_inj'",
    "start": [
      132,
      1
    ],
    "end": [
      135,
      44
    ],
    "traced_tactics": [
      {
        "tactic": "obtain hn|hm := h",
        "annotated_tactic": [
          "obtain hn|hm := h",
          []
        ],
        "state_before": "m n : \u2115\nh : 1 < n \u2228 1 < m\n\u22a2 n ! = m ! \u2194 n = m",
        "state_after": "case inl\nm n : \u2115\nhn : 1 < n\n\u22a2 n ! = m ! \u2194 n = m\n\ncase inr\nm n : \u2115\nhm : 1 < m\n\u22a2 n ! = m ! \u2194 n = m"
      },
      {
        "tactic": "exact factorial_inj hn",
        "annotated_tactic": [
          "exact <a>factorial_inj</a> hn",
          [
            {
              "full_name": "Nat.factorial_inj",
              "def_path": "Mathlib/Data/Nat/Factorial/Basic.lean",
              "def_pos": [
                121,
                9
              ],
              "def_end_pos": [
                121,
                22
              ]
            }
          ]
        ],
        "state_before": "case inl\nm n : \u2115\nhn : 1 < n\n\u22a2 n ! = m ! \u2194 n = m",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [eq_comm, factorial_inj hm, eq_comm]",
        "annotated_tactic": [
          "rw [<a>eq_comm</a>, <a>factorial_inj</a> hm, <a>eq_comm</a>]",
          [
            {
              "full_name": "eq_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                811,
                9
              ],
              "def_end_pos": [
                811,
                16
              ]
            },
            {
              "full_name": "Nat.factorial_inj",
              "def_path": "Mathlib/Data/Nat/Factorial/Basic.lean",
              "def_pos": [
                121,
                9
              ],
              "def_end_pos": [
                121,
                22
              ]
            },
            {
              "full_name": "eq_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                811,
                9
              ],
              "def_end_pos": [
                811,
                16
              ]
            }
          ]
        ],
        "state_before": "case inr\nm n : \u2115\nhm : 1 < m\n\u22a2 n ! = m ! \u2194 n = m",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.549295658012852,
    "entry_failed": false
  },
  "5243": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/UniformSpace/Cauchy.lean",
    "full_name": "Cauchy.prod",
    "start": [
      131,
      1
    ],
    "end": [
      134,
      47
    ],
    "traced_tactics": [
      {
        "tactic": "have := hf.1",
        "annotated_tactic": [
          "have := hf.1",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nf : Filter \u03b1\ng : Filter \u03b2\nhf : Cauchy f\nhg : Cauchy g\n\u22a2 Cauchy (f \u00d7\u02e2 g)",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nf : Filter \u03b1\ng : Filter \u03b2\nhf : Cauchy f\nhg : Cauchy g\nthis : f.NeBot\n\u22a2 Cauchy (f \u00d7\u02e2 g)"
      },
      {
        "tactic": "have := hg.1",
        "annotated_tactic": [
          "have := hg.1",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nf : Filter \u03b1\ng : Filter \u03b2\nhf : Cauchy f\nhg : Cauchy g\nthis : f.NeBot\n\u22a2 Cauchy (f \u00d7\u02e2 g)",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nf : Filter \u03b1\ng : Filter \u03b2\nhf : Cauchy f\nhg : Cauchy g\nthis\u271d : f.NeBot\nthis : g.NeBot\n\u22a2 Cauchy (f \u00d7\u02e2 g)"
      },
      {
        "tactic": "simpa [cauchy_prod_iff, hf.1] using \u27e8hf, hg\u27e9",
        "annotated_tactic": [
          "simpa [<a>cauchy_prod_iff</a>, hf.1] using \u27e8hf, hg\u27e9",
          [
            {
              "full_name": "cauchy_prod_iff",
              "def_path": "Mathlib/Topology/UniformSpace/Cauchy.lean",
              "def_pos": [
                127,
                7
              ],
              "def_end_pos": [
                127,
                22
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\ninst\u271d : UniformSpace \u03b2\nf : Filter \u03b1\ng : Filter \u03b2\nhf : Cauchy f\nhg : Cauchy g\nthis\u271d : f.NeBot\nthis : g.NeBot\n\u22a2 Cauchy (f \u00d7\u02e2 g)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.6882878589676693,
    "entry_failed": false
  },
  "5334": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/FLT/Four.lean",
    "full_name": "Fermat42.comm",
    "start": [
      32,
      1
    ],
    "end": [
      35,
      8
    ],
    "traced_tactics": [
      {
        "tactic": "delta Fermat42",
        "annotated_tactic": [
          "delta <a>Fermat42</a>",
          [
            {
              "full_name": "Fermat42",
              "def_path": "Mathlib/NumberTheory/FLT/Four.lean",
              "def_pos": [
                26,
                5
              ],
              "def_end_pos": [
                26,
                13
              ]
            }
          ]
        ],
        "state_before": "a b c : \u2124\n\u22a2 Fermat42 a b c \u2194 Fermat42 b a c",
        "state_after": "a b c : \u2124\n\u22a2 a \u2260 0 \u2227 b \u2260 0 \u2227 a ^ 4 + b ^ 4 = c ^ 2 \u2194 b \u2260 0 \u2227 a \u2260 0 \u2227 b ^ 4 + a ^ 4 = c ^ 2"
      },
      {
        "tactic": "rw [add_comm]",
        "annotated_tactic": [
          "rw [<a>add_comm</a>]",
          [
            {
              "full_name": "add_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                331,
                3
              ],
              "def_end_pos": [
                331,
                14
              ]
            }
          ]
        ],
        "state_before": "a b c : \u2124\n\u22a2 a \u2260 0 \u2227 b \u2260 0 \u2227 a ^ 4 + b ^ 4 = c ^ 2 \u2194 b \u2260 0 \u2227 a \u2260 0 \u2227 b ^ 4 + a ^ 4 = c ^ 2",
        "state_after": "a b c : \u2124\n\u22a2 a \u2260 0 \u2227 b \u2260 0 \u2227 b ^ 4 + a ^ 4 = c ^ 2 \u2194 b \u2260 0 \u2227 a \u2260 0 \u2227 b ^ 4 + a ^ 4 = c ^ 2"
      },
      {
        "tactic": "tauto",
        "annotated_tactic": [
          "tauto",
          []
        ],
        "state_before": "a b c : \u2124\n\u22a2 a \u2260 0 \u2227 b \u2260 0 \u2227 b ^ 4 + a ^ 4 = c ^ 2 \u2194 b \u2260 0 \u2227 a \u2260 0 \u2227 b ^ 4 + a ^ 4 = c ^ 2",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.599261463037692,
    "entry_failed": false
  },
  "5354": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Clique.lean",
    "full_name": "SimpleGraph.isNClique_one",
    "start": [
      240,
      1
    ],
    "end": [
      241,
      87
    ],
    "traced_tactics": [
      {
        "tactic": "simp only [isNClique_iff, card_eq_one, and_iff_right_iff_imp]",
        "annotated_tactic": [
          "simp only [<a>isNClique_iff</a>, <a>card_eq_one</a>, <a>and_iff_right_iff_imp</a>]",
          [
            {
              "full_name": "SimpleGraph.isNClique_iff",
              "def_path": "Mathlib/Combinatorics/SimpleGraph/Clique.lean",
              "def_pos": [
                189,
                9
              ],
              "def_end_pos": [
                189,
                22
              ]
            },
            {
              "full_name": "Finset.card_eq_one",
              "def_path": "Mathlib/Data/Finset/Card.lean",
              "def_pos": [
                672,
                9
              ],
              "def_end_pos": [
                672,
                20
              ]
            },
            {
              "full_name": "and_iff_right_iff_imp",
              "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean",
              "def_pos": [
                165,
                17
              ],
              "def_end_pos": [
                165,
                38
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG H : SimpleGraph \u03b1\nn : \u2115\ns : Finset \u03b1\na b c : \u03b1\n\u22a2 G.IsNClique 1 s \u2194 \u2203 a, s = {a}",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG H : SimpleGraph \u03b1\nn : \u2115\ns : Finset \u03b1\na b c : \u03b1\n\u22a2 (\u2203 a, s = {a}) \u2192 G.IsClique \u2191s"
      },
      {
        "tactic": "rintro \u27e8a, rfl\u27e9",
        "annotated_tactic": [
          "rintro \u27e8a, rfl\u27e9",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG H : SimpleGraph \u03b1\nn : \u2115\ns : Finset \u03b1\na b c : \u03b1\n\u22a2 (\u2203 a, s = {a}) \u2192 G.IsClique \u2191s",
        "state_after": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nG H : SimpleGraph \u03b1\nn : \u2115\na\u271d b c a : \u03b1\n\u22a2 G.IsClique \u2191{a}"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nG H : SimpleGraph \u03b1\nn : \u2115\na\u271d b c a : \u03b1\n\u22a2 G.IsClique \u2191{a}",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.180814997991547,
    "entry_failed": false
  },
  "5413": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Coloring.lean",
    "full_name": "SimpleGraph.isEmpty_of_chromaticNumber_eq_zero",
    "start": [
      335,
      1
    ],
    "end": [
      339,
      39
    ],
    "traced_tactics": [
      {
        "tactic": "have h' := G.colorable_chromaticNumber_of_fintype",
        "annotated_tactic": [
          "have h' := G.colorable_chromaticNumber_of_fintype",
          []
        ],
        "state_before": "V : Type u\nG\u271d : SimpleGraph V\nn : \u2115\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nC : G\u271d.Coloring \u03b1\nG : SimpleGraph V\ninst\u271d : Finite V\nh : G.chromaticNumber = 0\n\u22a2 IsEmpty V",
        "state_after": "V : Type u\nG\u271d : SimpleGraph V\nn : \u2115\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nC : G\u271d.Coloring \u03b1\nG : SimpleGraph V\ninst\u271d : Finite V\nh : G.chromaticNumber = 0\nh' : G.Colorable G.chromaticNumber.toNat\n\u22a2 IsEmpty V"
      },
      {
        "tactic": "rw [h] at h'",
        "annotated_tactic": [
          "rw [h] at h'",
          []
        ],
        "state_before": "V : Type u\nG\u271d : SimpleGraph V\nn : \u2115\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nC : G\u271d.Coloring \u03b1\nG : SimpleGraph V\ninst\u271d : Finite V\nh : G.chromaticNumber = 0\nh' : G.Colorable G.chromaticNumber.toNat\n\u22a2 IsEmpty V",
        "state_after": "V : Type u\nG\u271d : SimpleGraph V\nn : \u2115\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nC : G\u271d.Coloring \u03b1\nG : SimpleGraph V\ninst\u271d : Finite V\nh : G.chromaticNumber = 0\nh' : G.Colorable (ENat.toNat 0)\n\u22a2 IsEmpty V"
      },
      {
        "tactic": "exact G.isEmpty_of_colorable_zero h'",
        "annotated_tactic": [
          "exact G.isEmpty_of_colorable_zero h'",
          []
        ],
        "state_before": "V : Type u\nG\u271d : SimpleGraph V\nn : \u2115\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nC : G\u271d.Coloring \u03b1\nG : SimpleGraph V\ninst\u271d : Finite V\nh : G.chromaticNumber = 0\nh' : G.Colorable (ENat.toNat 0)\n\u22a2 IsEmpty V",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.8503330280072987,
    "entry_failed": false
  },
  "5419": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/MetricSpace/Infsep.lean",
    "full_name": "Set.Finite.infsep_of_nontrivial",
    "start": [
      484,
      1
    ],
    "end": [
      486,
      45
    ],
    "traced_tactics": [
      {
        "tactic": "simpa",
        "annotated_tactic": [
          "simpa",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nhsf : s.Finite\nhs : s.Nontrivial\n\u22a2 \u22ef.toFinset.Nonempty",
        "state_after": "no goals"
      },
      {
        "tactic": "classical simp_rw [hsf.infsep, dif_pos hs]",
        "annotated_tactic": [
          "classical simp_rw [hsf.infsep, <a>dif_pos</a> hs]",
          [
            {
              "full_name": "dif_pos",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                949,
                9
              ],
              "def_end_pos": [
                949,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nhsf : s.Finite\nhs : s.Nontrivial\n\u22a2 s.infsep = \u22ef.toFinset.inf' \u22ef (uncurry dist)",
        "state_after": "no goals"
      },
      {
        "tactic": "simp_rw [hsf.infsep, dif_pos hs]",
        "annotated_tactic": [
          "simp_rw [hsf.infsep, <a>dif_pos</a> hs]",
          [
            {
              "full_name": "dif_pos",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                949,
                9
              ],
              "def_end_pos": [
                949,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nhsf : s.Finite\nhs : s.Nontrivial\n\u22a2 s.infsep = \u22ef.toFinset.inf' \u22ef (uncurry dist)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.406034471001476,
    "entry_failed": false
  },
  "5462": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/RootsOfUnity/Complex.lean",
    "full_name": "Complex.card_primitiveRoots",
    "start": [
      96,
      1
    ],
    "end": [
      99,
      54
    ],
    "traced_tactics": [
      {
        "tactic": "by_cases h : k = 0",
        "annotated_tactic": [
          "by_cases h : k = 0",
          []
        ],
        "state_before": "k : \u2115\n\u22a2 (primitiveRoots k \u2102).card = \u03c6 k",
        "state_after": "case pos\nk : \u2115\nh : k = 0\n\u22a2 (primitiveRoots k \u2102).card = \u03c6 k\n\ncase neg\nk : \u2115\nh : \u00ack = 0\n\u22a2 (primitiveRoots k \u2102).card = \u03c6 k"
      },
      {
        "tactic": "exact (isPrimitiveRoot_exp k h).card_primitiveRoots",
        "annotated_tactic": [
          "exact (<a>isPrimitiveRoot_exp</a> k h).<a>card_primitiveRoots</a>",
          [
            {
              "full_name": "Complex.isPrimitiveRoot_exp",
              "def_path": "Mathlib/RingTheory/RootsOfUnity/Complex.lean",
              "def_pos": [
                53,
                9
              ],
              "def_end_pos": [
                53,
                28
              ]
            },
            {
              "full_name": "IsPrimitiveRoot.card_primitiveRoots",
              "def_path": "Mathlib/RingTheory/RootsOfUnity/Basic.lean",
              "def_pos": [
                958,
                9
              ],
              "def_end_pos": [
                958,
                28
              ]
            }
          ]
        ],
        "state_before": "case neg\nk : \u2115\nh : \u00ack = 0\n\u22a2 (primitiveRoots k \u2102).card = \u03c6 k",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [h]",
        "annotated_tactic": [
          "simp [h]",
          []
        ],
        "state_before": "case pos\nk : \u2115\nh : k = 0\n\u22a2 (primitiveRoots k \u2102).card = \u03c6 k",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.052811122965068,
    "entry_failed": false
  },
  "5536": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Digits.lean",
    "full_name": "Nat.digitsAux_def",
    "start": [
      63,
      1
    ],
    "end": [
      67,
      19
    ],
    "traced_tactics": [
      {
        "tactic": "cases n",
        "annotated_tactic": [
          "cases n",
          []
        ],
        "state_before": "n\u271d b : \u2115\nh : 2 \u2264 b\nn : \u2115\nw : 0 < n\n\u22a2 b.digitsAux h n = n % b :: b.digitsAux h (n / b)",
        "state_after": "case zero\nn b : \u2115\nh : 2 \u2264 b\nw : 0 < 0\n\u22a2 b.digitsAux h 0 = 0 % b :: b.digitsAux h (0 / b)\n\ncase succ\nn b : \u2115\nh : 2 \u2264 b\nn\u271d : \u2115\nw : 0 < n\u271d + 1\n\u22a2 b.digitsAux h (n\u271d + 1) = (n\u271d + 1) % b :: b.digitsAux h ((n\u271d + 1) / b)"
      },
      {
        "tactic": "cases w",
        "annotated_tactic": [
          "cases w",
          []
        ],
        "state_before": "case zero\nn b : \u2115\nh : 2 \u2264 b\nw : 0 < 0\n\u22a2 b.digitsAux h 0 = 0 % b :: b.digitsAux h (0 / b)",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [digitsAux]",
        "annotated_tactic": [
          "rw [<a>digitsAux</a>]",
          [
            {
              "full_name": "Nat.digitsAux",
              "def_path": "Mathlib/Data/Nat/Digits.lean",
              "def_pos": [
                52,
                5
              ],
              "def_end_pos": [
                52,
                14
              ]
            }
          ]
        ],
        "state_before": "case succ\nn b : \u2115\nh : 2 \u2264 b\nn\u271d : \u2115\nw : 0 < n\u271d + 1\n\u22a2 b.digitsAux h (n\u271d + 1) = (n\u271d + 1) % b :: b.digitsAux h ((n\u271d + 1) / b)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.2647334010107443,
    "entry_failed": false
  },
  "5569": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Intervals.lean",
    "full_name": "List.Ico.filter_lt",
    "start": [
      178,
      1
    ],
    "end": [
      182,
      47
    ],
    "traced_tactics": [
      {
        "tactic": "rcases le_total m l with hml | hlm",
        "annotated_tactic": [
          "rcases <a>le_total</a> m l with hml | hlm",
          [
            {
              "full_name": "le_total",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                297,
                9
              ],
              "def_end_pos": [
                297,
                17
              ]
            }
          ]
        ],
        "state_before": "n m l : \u2115\n\u22a2 filter (fun x => decide (x < l)) (Ico n m) = Ico n (min m l)",
        "state_after": "case inl\nn m l : \u2115\nhml : m \u2264 l\n\u22a2 filter (fun x => decide (x < l)) (Ico n m) = Ico n (min m l)\n\ncase inr\nn m l : \u2115\nhlm : l \u2264 m\n\u22a2 filter (fun x => decide (x < l)) (Ico n m) = Ico n (min m l)"
      },
      {
        "tactic": "rw [min_eq_left hml, filter_lt_of_top_le hml]",
        "annotated_tactic": [
          "rw [<a>min_eq_left</a> hml, <a>filter_lt_of_top_le</a> hml]",
          [
            {
              "full_name": "min_eq_left",
              "def_path": "Mathlib/Init/Order/LinearOrder.lean",
              "def_pos": [
                100,
                9
              ],
              "def_end_pos": [
                100,
                20
              ]
            },
            {
              "full_name": "List.Ico.filter_lt_of_top_le",
              "def_path": "Mathlib/Data/List/Intervals.lean",
              "def_pos": [
                156,
                9
              ],
              "def_end_pos": [
                156,
                28
              ]
            }
          ]
        ],
        "state_before": "case inl\nn m l : \u2115\nhml : m \u2264 l\n\u22a2 filter (fun x => decide (x < l)) (Ico n m) = Ico n (min m l)",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [min_eq_right hlm, filter_lt_of_ge hlm]",
        "annotated_tactic": [
          "rw [<a>min_eq_right</a> hlm, <a>filter_lt_of_ge</a> hlm]",
          [
            {
              "full_name": "min_eq_right",
              "def_path": "Mathlib/Init/Order/LinearOrder.lean",
              "def_pos": [
                104,
                9
              ],
              "def_end_pos": [
                104,
                21
              ]
            },
            {
              "full_name": "List.Ico.filter_lt_of_ge",
              "def_path": "Mathlib/Data/List/Intervals.lean",
              "def_pos": [
                169,
                9
              ],
              "def_end_pos": [
                169,
                24
              ]
            }
          ]
        ],
        "state_before": "case inr\nn m l : \u2115\nhlm : l \u2264 m\n\u22a2 filter (fun x => decide (x < l)) (Ico n m) = Ico n (min m l)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5431728629628196,
    "entry_failed": false
  },
  "5606": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Stream/Init.lean",
    "full_name": "Stream'.tails_eq",
    "start": [
      669,
      1
    ],
    "end": [
      670,
      35
    ],
    "traced_tactics": [
      {
        "tactic": "unfold tails",
        "annotated_tactic": [
          "unfold <a>tails</a>",
          [
            {
              "full_name": "Stream'.tails",
              "def_path": "Mathlib/Data/Stream/Defs.lean",
              "def_pos": [
                161,
                5
              ],
              "def_end_pos": [
                161,
                10
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\ns : Stream' \u03b1\n\u22a2 s.tails = s.tail :: s.tail.tails",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\ns : Stream' \u03b1\n\u22a2 corec id tail s.tail = s.tail :: corec id tail s.tail.tail"
      },
      {
        "tactic": "rw [corec_eq]",
        "annotated_tactic": [
          "rw [<a>corec_eq</a>]",
          [
            {
              "full_name": "Stream'.corec_eq",
              "def_path": "Mathlib/Data/Stream/Init.lean",
              "def_pos": [
                377,
                9
              ],
              "def_end_pos": [
                377,
                17
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\ns : Stream' \u03b1\n\u22a2 corec id tail s.tail = s.tail :: corec id tail s.tail.tail",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\ns : Stream' \u03b1\n\u22a2 id s.tail :: corec id tail s.tail.tail = s.tail :: corec id tail s.tail.tail"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\ns : Stream' \u03b1\n\u22a2 id s.tail :: corec id tail s.tail.tail = s.tail :: corec id tail s.tail.tail",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.193378929980099,
    "entry_failed": false
  },
  "5676": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/EuclideanDomain/Basic.lean",
    "full_name": "EuclideanDomain.dvd_lcm_left",
    "start": [
      248,
      1
    ],
    "end": [
      255,
      89
    ],
    "traced_tactics": [
      {
        "tactic": "rw [lcm, hxy, div_zero]",
        "annotated_tactic": [
          "rw [<a>lcm</a>, hxy, <a>div_zero</a>]",
          [
            {
              "full_name": "EuclideanDomain.lcm",
              "def_path": "Mathlib/Algebra/EuclideanDomain/Defs.lean",
              "def_pos": [
                286,
                5
              ],
              "def_end_pos": [
                286,
                8
              ]
            },
            {
              "full_name": "EuclideanDomain.div_zero",
              "def_path": "Mathlib/Algebra/EuclideanDomain/Defs.lean",
              "def_pos": [
                170,
                9
              ],
              "def_end_pos": [
                170,
                17
              ]
            }
          ]
        ],
        "state_before": "R : Type u\ninst\u271d\u00b9 : EuclideanDomain R\ninst\u271d : DecidableEq R\nx y : R\nhxy : gcd x y = 0\n\u22a2 x \u2223 lcm x y",
        "state_after": "R : Type u\ninst\u271d\u00b9 : EuclideanDomain R\ninst\u271d : DecidableEq R\nx y : R\nhxy : gcd x y = 0\n\u22a2 x \u2223 0"
      },
      {
        "tactic": "exact dvd_zero _",
        "annotated_tactic": [
          "exact <a>dvd_zero</a> _",
          [
            {
              "full_name": "dvd_zero",
              "def_path": "Mathlib/Algebra/GroupWithZero/Divisibility.lean",
              "def_pos": [
                41,
                9
              ],
              "def_end_pos": [
                41,
                17
              ]
            }
          ]
        ],
        "state_before": "R : Type u\ninst\u271d\u00b9 : EuclideanDomain R\ninst\u271d : DecidableEq R\nx y : R\nhxy : gcd x y = 0\n\u22a2 x \u2223 0",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [mul_right_comm, mul_assoc, \u2190 hz]",
        "annotated_tactic": [
          "rw [<a>mul_right_comm</a>, <a>mul_assoc</a>, \u2190 hz]",
          [
            {
              "full_name": "mul_right_comm",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                190,
                9
              ],
              "def_end_pos": [
                190,
                23
              ]
            },
            {
              "full_name": "mul_assoc",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                289,
                9
              ],
              "def_end_pos": [
                289,
                18
              ]
            }
          ]
        ],
        "state_before": "R : Type u\ninst\u271d\u00b9 : EuclideanDomain R\ninst\u271d : DecidableEq R\nx y : R\nhxy : \u00acgcd x y = 0\nz : R\nhz : y = gcd x y * z\n\u22a2 x * z * gcd x y = x * y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.246598200988956,
    "entry_failed": false
  },
  "5835": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/Measure/ProbabilityMeasure.lean",
    "full_name": "MeasureTheory.ProbabilityMeasure.eq_of_forall_toMeasure_apply_eq",
    "start": [
      216,
      1
    ],
    "end": [
      220,
      19
    ],
    "traced_tactics": [
      {
        "tactic": "apply toMeasure_injective",
        "annotated_tactic": [
          "apply <a>toMeasure_injective</a>",
          [
            {
              "full_name": "MeasureTheory.ProbabilityMeasure.toMeasure_injective",
              "def_path": "Mathlib/MeasureTheory/Measure/ProbabilityMeasure.lean",
              "def_pos": [
                139,
                9
              ],
              "def_end_pos": [
                139,
                28
              ]
            }
          ]
        ],
        "state_before": "\u03a9 : Type u_1\ninst\u271d : MeasurableSpace \u03a9\n\u03bc \u03bd : ProbabilityMeasure \u03a9\nh : \u2200 (s : Set \u03a9), MeasurableSet s \u2192 \u2191\u03bc s = \u2191\u03bd s\n\u22a2 \u03bc = \u03bd",
        "state_after": "case a\n\u03a9 : Type u_1\ninst\u271d : MeasurableSpace \u03a9\n\u03bc \u03bd : ProbabilityMeasure \u03a9\nh : \u2200 (s : Set \u03a9), MeasurableSet s \u2192 \u2191\u03bc s = \u2191\u03bd s\n\u22a2 \u2191\u03bc = \u2191\u03bd"
      },
      {
        "tactic": "ext1 s s_mble",
        "annotated_tactic": [
          "ext1 s s_mble",
          []
        ],
        "state_before": "case a\n\u03a9 : Type u_1\ninst\u271d : MeasurableSpace \u03a9\n\u03bc \u03bd : ProbabilityMeasure \u03a9\nh : \u2200 (s : Set \u03a9), MeasurableSet s \u2192 \u2191\u03bc s = \u2191\u03bd s\n\u22a2 \u2191\u03bc = \u2191\u03bd",
        "state_after": "case a.h\n\u03a9 : Type u_1\ninst\u271d : MeasurableSpace \u03a9\n\u03bc \u03bd : ProbabilityMeasure \u03a9\nh : \u2200 (s : Set \u03a9), MeasurableSet s \u2192 \u2191\u03bc s = \u2191\u03bd s\ns : Set \u03a9\ns_mble : MeasurableSet s\n\u22a2 \u2191\u03bc s = \u2191\u03bd s"
      },
      {
        "tactic": "exact h s s_mble",
        "annotated_tactic": [
          "exact h s s_mble",
          []
        ],
        "state_before": "case a.h\n\u03a9 : Type u_1\ninst\u271d : MeasurableSpace \u03a9\n\u03bc \u03bd : ProbabilityMeasure \u03a9\nh : \u2200 (s : Set \u03a9), MeasurableSet s \u2192 \u2191\u03bc s = \u2191\u03bd s\ns : Set \u03a9\ns_mble : MeasurableSet s\n\u22a2 \u2191\u03bc s = \u2191\u03bd s",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.7905176209751517,
    "entry_failed": false
  },
  "5852": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/LinearAlgebra/SymplecticGroup.lean",
    "full_name": "Matrix.J_inv",
    "start": [
      59,
      1
    ],
    "end": [
      62,
      18
    ],
    "traced_tactics": [
      {
        "tactic": "refine Matrix.inv_eq_right_inv ?_",
        "annotated_tactic": [
          "refine <a>Matrix.inv_eq_right_inv</a> ?_",
          [
            {
              "full_name": "Matrix.inv_eq_right_inv",
              "def_path": "Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean",
              "def_pos": [
                537,
                9
              ],
              "def_end_pos": [
                537,
                25
              ]
            }
          ]
        ],
        "state_before": "l : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : DecidableEq l\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Fintype l\n\u22a2 (J l R)\u207b\u00b9 = -J l R",
        "state_after": "l : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : DecidableEq l\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Fintype l\n\u22a2 J l R * -J l R = 1"
      },
      {
        "tactic": "rw [Matrix.mul_neg, J_squared]",
        "annotated_tactic": [
          "rw [<a>Matrix.mul_neg</a>, <a>J_squared</a>]",
          [
            {
              "full_name": "Matrix.mul_neg",
              "def_path": "Mathlib/Data/Matrix/Basic.lean",
              "def_pos": [
                1232,
                19
              ],
              "def_end_pos": [
                1232,
                26
              ]
            },
            {
              "full_name": "Matrix.J_squared",
              "def_path": "Mathlib/LinearAlgebra/SymplecticGroup.lean",
              "def_pos": [
                52,
                9
              ],
              "def_end_pos": [
                52,
                18
              ]
            }
          ]
        ],
        "state_before": "l : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : DecidableEq l\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Fintype l\n\u22a2 J l R * -J l R = 1",
        "state_after": "l : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : DecidableEq l\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Fintype l\n\u22a2 - -1 = 1"
      },
      {
        "tactic": "exact neg_neg 1",
        "annotated_tactic": [
          "exact <a>neg_neg</a> 1",
          [
            {
              "full_name": "neg_neg",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                869,
                3
              ],
              "def_end_pos": [
                869,
                14
              ]
            }
          ]
        ],
        "state_before": "l : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : DecidableEq l\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Fintype l\n\u22a2 - -1 = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.1649750450160354,
    "entry_failed": false
  },
  "5873": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Set/Functor.lean",
    "full_name": "Set.coe_eq_image_val",
    "start": [
      114,
      1
    ],
    "end": [
      118,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "change \u22c3 (x \u2208 t), {x.1} = _",
        "annotated_tactic": [
          "change \u22c3 (x \u2208 t), {x.1} = _",
          []
        ],
        "state_before": "\u03b1 \u03b2 : Type u\ns : Set \u03b1\nf : \u03b1 \u2192 Set \u03b2\ng : Set (\u03b1 \u2192 \u03b2)\nt : Set \u2191s\n\u22a2 Lean.Internal.coeM t = \u2191t",
        "state_after": "\u03b1 \u03b2 : Type u\ns : Set \u03b1\nf : \u03b1 \u2192 Set \u03b2\ng : Set (\u03b1 \u2192 \u03b2)\nt : Set \u2191s\n\u22a2 \u22c3 x \u2208 t, {\u2191x} = \u2191t"
      },
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "\u03b1 \u03b2 : Type u\ns : Set \u03b1\nf : \u03b1 \u2192 Set \u03b2\ng : Set (\u03b1 \u2192 \u03b2)\nt : Set \u2191s\n\u22a2 \u22c3 x \u2208 t, {\u2191x} = \u2191t",
        "state_after": "case h\n\u03b1 \u03b2 : Type u\ns : Set \u03b1\nf : \u03b1 \u2192 Set \u03b2\ng : Set (\u03b1 \u2192 \u03b2)\nt : Set \u2191s\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 \u22c3 x \u2208 t, {\u2191x} \u2194 x\u271d \u2208 \u2191t"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case h\n\u03b1 \u03b2 : Type u\ns : Set \u03b1\nf : \u03b1 \u2192 Set \u03b2\ng : Set (\u03b1 \u2192 \u03b2)\nt : Set \u2191s\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 \u22c3 x \u2208 t, {\u2191x} \u2194 x\u271d \u2208 \u2191t",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5361944569740444,
    "entry_failed": false
  },
  "6012": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/LSeries/HurwitzZeta.lean",
    "full_name": "HurwitzZeta.differentiableAt_expZeta",
    "start": [
      132,
      1
    ],
    "end": [
      136,
      72
    ],
    "traced_tactics": [
      {
        "tactic": "apply DifferentiableAt.add",
        "annotated_tactic": [
          "apply <a>DifferentiableAt.add</a>",
          [
            {
              "full_name": "DifferentiableAt.add",
              "def_path": "Mathlib/Analysis/Calculus/FDeriv/Add.lean",
              "def_pos": [
                150,
                9
              ],
              "def_end_pos": [
                150,
                29
              ]
            }
          ]
        ],
        "state_before": "a : UnitAddCircle\ns : \u2102\nhs : s \u2260 1 \u2228 a \u2260 0\n\u22a2 DifferentiableAt \u2102 (expZeta a) s",
        "state_after": "case hf\na : UnitAddCircle\ns : \u2102\nhs : s \u2260 1 \u2228 a \u2260 0\n\u22a2 DifferentiableAt \u2102 (cosZeta a) s\n\ncase hg\na : UnitAddCircle\ns : \u2102\nhs : s \u2260 1 \u2228 a \u2260 0\n\u22a2 DifferentiableAt \u2102 (fun y => I * sinZeta a y) s"
      },
      {
        "tactic": "exact differentiableAt_cosZeta a hs",
        "annotated_tactic": [
          "exact <a>differentiableAt_cosZeta</a> a hs",
          [
            {
              "full_name": "HurwitzZeta.differentiableAt_cosZeta",
              "def_path": "Mathlib/NumberTheory/LSeries/HurwitzZetaEven.lean",
              "def_pos": [
                736,
                7
              ],
              "def_end_pos": [
                736,
                31
              ]
            }
          ]
        ],
        "state_before": "case hf\na : UnitAddCircle\ns : \u2102\nhs : s \u2260 1 \u2228 a \u2260 0\n\u22a2 DifferentiableAt \u2102 (cosZeta a) s",
        "state_after": "no goals"
      },
      {
        "tactic": "apply (differentiableAt_const _).mul (differentiableAt_sinZeta a s)",
        "annotated_tactic": [
          "apply (<a>differentiableAt_const</a> _).<a>mul</a> (<a>differentiableAt_sinZeta</a> a s)",
          [
            {
              "full_name": "differentiableAt_const",
              "def_path": "Mathlib/Analysis/Calculus/FDeriv/Basic.lean",
              "def_pos": [
                1172,
                9
              ],
              "def_end_pos": [
                1172,
                31
              ]
            },
            {
              "full_name": "DifferentiableAt.mul",
              "def_path": "Mathlib/Analysis/Calculus/FDeriv/Mul.lean",
              "def_pos": [
                419,
                9
              ],
              "def_end_pos": [
                419,
                29
              ]
            },
            {
              "full_name": "HurwitzZeta.differentiableAt_sinZeta",
              "def_path": "Mathlib/NumberTheory/LSeries/HurwitzZetaOdd.lean",
              "def_pos": [
                487,
                7
              ],
              "def_end_pos": [
                487,
                31
              ]
            }
          ]
        ],
        "state_before": "case hg\na : UnitAddCircle\ns : \u2102\nhs : s \u2260 1 \u2228 a \u2260 0\n\u22a2 DifferentiableAt \u2102 (fun y => I * sinZeta a y) s",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.9925610300851986,
    "entry_failed": false
  },
  "6058": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Cardinal/Cofinality.lean",
    "full_name": "Ordinal.cof_sup_le_lift",
    "start": [
      340,
      1
    ],
    "end": [
      344,
      27
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 sup_eq_lsub_iff_lt_sup.{u, v}] at H",
        "annotated_tactic": [
          "rw [\u2190 <a>sup_eq_lsub_iff_lt_sup</a>.{u, v}] at H",
          [
            {
              "full_name": "Ordinal.sup_eq_lsub_iff_lt_sup",
              "def_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean",
              "def_pos": [
                1651,
                9
              ],
              "def_end_pos": [
                1651,
                31
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v}\nH : \u2200 (i : \u03b9), f i < sup f\n\u22a2 (sup f).cof \u2264 Cardinal.lift.{v, u} #\u03b9",
        "state_after": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v}\nH : sup f = lsub f\n\u22a2 (sup f).cof \u2264 Cardinal.lift.{v, u} #\u03b9"
      },
      {
        "tactic": "rw [H]",
        "annotated_tactic": [
          "rw [H]",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v}\nH : sup f = lsub f\n\u22a2 (sup f).cof \u2264 Cardinal.lift.{v, u} #\u03b9",
        "state_after": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v}\nH : sup f = lsub f\n\u22a2 (lsub f).cof \u2264 Cardinal.lift.{v, u} #\u03b9"
      },
      {
        "tactic": "exact cof_lsub_le_lift f",
        "annotated_tactic": [
          "exact <a>cof_lsub_le_lift</a> f",
          [
            {
              "full_name": "Ordinal.cof_lsub_le_lift",
              "def_path": "Mathlib/SetTheory/Cardinal/Cofinality.lean",
              "def_pos": [
                308,
                9
              ],
              "def_end_pos": [
                308,
                25
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v}\nH : sup f = lsub f\n\u22a2 (lsub f).cof \u2264 Cardinal.lift.{v, u} #\u03b9",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.418341739918105,
    "entry_failed": false
  },
  "6326": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/IsWellOrderLimitElement.lean",
    "full_name": "wellOrderSucc_le",
    "start": [
      35,
      1
    ],
    "end": [
      38,
      32
    ],
    "traced_tactics": [
      {
        "tactic": "dsimp [wellOrderSucc, WellFounded.succ]",
        "annotated_tactic": [
          "dsimp [<a>wellOrderSucc</a>, <a>WellFounded.succ</a>]",
          [
            {
              "full_name": "wellOrderSucc",
              "def_path": "Mathlib/Order/IsWellOrderLimitElement.lean",
              "def_pos": [
                26,
                19
              ],
              "def_end_pos": [
                26,
                32
              ]
            },
            {
              "full_name": "WellFounded.succ",
              "def_path": "Mathlib/Order/WellFounded.lean",
              "def_pos": [
                111,
                29
              ],
              "def_end_pos": [
                111,
                33
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsWellOrder \u03b1 fun x x_1 => x < x_1\na b : \u03b1\nha : a < b\n\u22a2 wellOrderSucc a \u2264 b",
        "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsWellOrder \u03b1 fun x x_1 => x < x_1\na b : \u03b1\nha : a < b\n\u22a2 (if h : \u2203 y, a < y then \u22ef.min {y | a < y} h else a) \u2264 b"
      },
      {
        "tactic": "rw [dif_pos \u27e8_, ha\u27e9]",
        "annotated_tactic": [
          "rw [<a>dif_pos</a> \u27e8_, ha\u27e9]",
          [
            {
              "full_name": "dif_pos",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                949,
                9
              ],
              "def_end_pos": [
                949,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsWellOrder \u03b1 fun x x_1 => x < x_1\na b : \u03b1\nha : a < b\n\u22a2 (if h : \u2203 y, a < y then \u22ef.min {y | a < y} h else a) \u2264 b",
        "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsWellOrder \u03b1 fun x x_1 => x < x_1\na b : \u03b1\nha : a < b\n\u22a2 \u22ef.min {y | a < y} \u22ef \u2264 b"
      },
      {
        "tactic": "exact WellFounded.min_le _ ha",
        "annotated_tactic": [
          "exact <a>WellFounded.min_le</a> _ ha",
          [
            {
              "full_name": "WellFounded.min_le",
              "def_path": "Mathlib/Order/WellFounded.lean",
              "def_pos": [
                145,
                9
              ],
              "def_end_pos": [
                145,
                15
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsWellOrder \u03b1 fun x x_1 => x < x_1\na b : \u03b1\nha : a < b\n\u22a2 \u22ef.min {y | a < y} \u22ef \u2264 b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.1187859069323167,
    "entry_failed": false
  },
  "6425": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Polynomial/Roots.lean",
    "full_name": "Polynomial.roots_X_sub_C",
    "start": [
      184,
      1
    ],
    "end": [
      187,
      62
    ],
    "traced_tactics": [
      {
        "tactic": "classical\next s\nrw [count_roots, rootMultiplicity_X_sub_C, count_singleton]",
        "annotated_tactic": [
          "classical\n  ext s\n  rw [<a>count_roots</a>, <a>rootMultiplicity_X_sub_C</a>, <a>count_singleton</a>]",
          [
            {
              "full_name": "Polynomial.count_roots",
              "def_path": "Mathlib/Algebra/Polynomial/Roots.lean",
              "def_pos": [
                100,
                9
              ],
              "def_end_pos": [
                100,
                20
              ]
            },
            {
              "full_name": "Polynomial.rootMultiplicity_X_sub_C",
              "def_path": "Mathlib/Algebra/Polynomial/RingDivision.lean",
              "def_pos": [
                542,
                9
              ],
              "def_end_pos": [
                542,
                33
              ]
            },
            {
              "full_name": "Multiset.count_singleton",
              "def_path": "Mathlib/Data/Multiset/Basic.lean",
              "def_pos": [
                2485,
                9
              ],
              "def_end_pos": [
                2485,
                24
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np q : R[X]\nr : R\n\u22a2 (X - C r).roots = {r}",
        "state_after": "no goals"
      },
      {
        "tactic": "ext s",
        "annotated_tactic": [
          "ext s",
          []
        ],
        "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np q : R[X]\nr : R\n\u22a2 (X - C r).roots = {r}",
        "state_after": "case a\nR : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np q : R[X]\nr s : R\n\u22a2 count s (X - C r).roots = count s {r}"
      },
      {
        "tactic": "rw [count_roots, rootMultiplicity_X_sub_C, count_singleton]",
        "annotated_tactic": [
          "rw [<a>count_roots</a>, <a>rootMultiplicity_X_sub_C</a>, <a>count_singleton</a>]",
          [
            {
              "full_name": "Polynomial.count_roots",
              "def_path": "Mathlib/Algebra/Polynomial/Roots.lean",
              "def_pos": [
                100,
                9
              ],
              "def_end_pos": [
                100,
                20
              ]
            },
            {
              "full_name": "Polynomial.rootMultiplicity_X_sub_C",
              "def_path": "Mathlib/Algebra/Polynomial/RingDivision.lean",
              "def_pos": [
                542,
                9
              ],
              "def_end_pos": [
                542,
                33
              ]
            },
            {
              "full_name": "Multiset.count_singleton",
              "def_path": "Mathlib/Data/Multiset/Basic.lean",
              "def_pos": [
                2485,
                9
              ],
              "def_end_pos": [
                2485,
                24
              ]
            }
          ]
        ],
        "state_before": "case a\nR : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np q : R[X]\nr s : R\n\u22a2 count s (X - C r).roots = count s {r}",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.2917360110441223,
    "entry_failed": false
  },
  "6492": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/Young/SemistandardTableau.lean",
    "full_name": "SemistandardYoungTableau.row_weak_of_le",
    "start": [
      129,
      1
    ],
    "end": [
      133,
      28
    ],
    "traced_tactics": [
      {
        "tactic": "cases' eq_or_lt_of_le hj with h h",
        "annotated_tactic": [
          "cases' <a>eq_or_lt_of_le</a> hj with h h",
          [
            {
              "full_name": "eq_or_lt_of_le",
              "def_path": "Mathlib/Order/Basic.lean",
              "def_pos": [
                381,
                9
              ],
              "def_end_pos": [
                381,
                23
              ]
            }
          ]
        ],
        "state_before": "\u03bc : YoungDiagram\nT : SemistandardYoungTableau \u03bc\ni j1 j2 : \u2115\nhj : j1 \u2264 j2\ncell : (i, j2) \u2208 \u03bc\n\u22a2 T i j1 \u2264 T i j2",
        "state_after": "case inl\n\u03bc : YoungDiagram\nT : SemistandardYoungTableau \u03bc\ni j1 j2 : \u2115\nhj : j1 \u2264 j2\ncell : (i, j2) \u2208 \u03bc\nh : j1 = j2\n\u22a2 T i j1 \u2264 T i j2\n\ncase inr\n\u03bc : YoungDiagram\nT : SemistandardYoungTableau \u03bc\ni j1 j2 : \u2115\nhj : j1 \u2264 j2\ncell : (i, j2) \u2208 \u03bc\nh : j1 < j2\n\u22a2 T i j1 \u2264 T i j2"
      },
      {
        "tactic": "rw [h]",
        "annotated_tactic": [
          "rw [h]",
          []
        ],
        "state_before": "case inl\n\u03bc : YoungDiagram\nT : SemistandardYoungTableau \u03bc\ni j1 j2 : \u2115\nhj : j1 \u2264 j2\ncell : (i, j2) \u2208 \u03bc\nh : j1 = j2\n\u22a2 T i j1 \u2264 T i j2",
        "state_after": "no goals"
      },
      {
        "tactic": "exact T.row_weak h cell",
        "annotated_tactic": [
          "exact T.row_weak h cell",
          []
        ],
        "state_before": "case inr\n\u03bc : YoungDiagram\nT : SemistandardYoungTableau \u03bc\ni j1 j2 : \u2115\nhj : j1 \u2264 j2\ncell : (i, j2) \u2208 \u03bc\nh : j1 < j2\n\u22a2 T i j1 \u2264 T i j2",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.328142891987227,
    "entry_failed": false
  },
  "6493": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Logic/Equiv/Fin.lean",
    "full_name": "coe_finRotate_of_ne_last",
    "start": [
      445,
      1
    ],
    "end": [
      449,
      35
    ],
    "traced_tactics": [
      {
        "tactic": "rw [finRotate_succ_apply]",
        "annotated_tactic": [
          "rw [<a>finRotate_succ_apply</a>]",
          [
            {
              "full_name": "finRotate_succ_apply",
              "def_path": "Mathlib/Logic/Equiv/Fin.lean",
              "def_pos": [
                430,
                17
              ],
              "def_end_pos": [
                430,
                37
              ]
            }
          ]
        ],
        "state_before": "m n : \u2115\ni : Fin n.succ\nh : i \u2260 Fin.last n\n\u22a2 \u2191((finRotate (n + 1)) i) = \u2191i + 1",
        "state_after": "m n : \u2115\ni : Fin n.succ\nh : i \u2260 Fin.last n\n\u22a2 \u2191(i + 1) = \u2191i + 1"
      },
      {
        "tactic": "have : (i : \u2115) < n := Fin.val_lt_last h",
        "annotated_tactic": [
          "have : (i : \u2115) < n := <a>Fin.val_lt_last</a> h",
          [
            {
              "full_name": "Fin.val_lt_last",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Fin/Lemmas.lean",
              "def_pos": [
                176,
                9
              ],
              "def_end_pos": [
                176,
                20
              ]
            }
          ]
        ],
        "state_before": "m n : \u2115\ni : Fin n.succ\nh : i \u2260 Fin.last n\n\u22a2 \u2191(i + 1) = \u2191i + 1",
        "state_after": "m n : \u2115\ni : Fin n.succ\nh : i \u2260 Fin.last n\nthis : \u2191i < n\n\u22a2 \u2191(i + 1) = \u2191i + 1"
      },
      {
        "tactic": "exact Fin.val_add_one_of_lt this",
        "annotated_tactic": [
          "exact <a>Fin.val_add_one_of_lt</a> this",
          [
            {
              "full_name": "Fin.val_add_one_of_lt",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Fin/Lemmas.lean",
              "def_pos": [
                206,
                9
              ],
              "def_end_pos": [
                206,
                26
              ]
            }
          ]
        ],
        "state_before": "m n : \u2115\ni : Fin n.succ\nh : i \u2260 Fin.last n\nthis : \u2191i < n\n\u22a2 \u2191(i + 1) = \u2191i + 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.089338577934541,
    "entry_failed": false
  },
  "6543": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/PNat/Prime.lean",
    "full_name": "PNat.gcd_comm",
    "start": [
      204,
      1
    ],
    "end": [
      207,
      21
    ],
    "traced_tactics": [
      {
        "tactic": "apply eq",
        "annotated_tactic": [
          "apply <a>eq</a>",
          [
            {
              "full_name": "PNat.eq",
              "def_path": "Mathlib/Data/PNat/Defs.lean",
              "def_pos": [
                151,
                9
              ],
              "def_end_pos": [
                151,
                11
              ]
            }
          ]
        ],
        "state_before": "m n : \u2115+\n\u22a2 m.gcd n = n.gcd m",
        "state_after": "case a\nm n : \u2115+\n\u22a2 \u2191(m.gcd n) = \u2191(n.gcd m)"
      },
      {
        "tactic": "simp only [gcd_coe]",
        "annotated_tactic": [
          "simp only [<a>gcd_coe</a>]",
          [
            {
              "full_name": "PNat.gcd_coe",
              "def_path": "Mathlib/Data/PNat/Prime.lean",
              "def_pos": [
                66,
                9
              ],
              "def_end_pos": [
                66,
                16
              ]
            }
          ]
        ],
        "state_before": "case a\nm n : \u2115+\n\u22a2 \u2191(m.gcd n) = \u2191(n.gcd m)",
        "state_after": "case a\nm n : \u2115+\n\u22a2 (\u2191m).gcd \u2191n = (\u2191n).gcd \u2191m"
      },
      {
        "tactic": "apply Nat.gcd_comm",
        "annotated_tactic": [
          "apply <a>Nat.gcd_comm</a>",
          [
            {
              "full_name": "Nat.gcd_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Gcd.lean",
              "def_pos": [
                103,
                9
              ],
              "def_end_pos": [
                103,
                17
              ]
            }
          ]
        ],
        "state_before": "case a\nm n : \u2115+\n\u22a2 (\u2191m).gcd \u2191n = (\u2191n).gcd \u2191m",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.730957171996124,
    "entry_failed": false
  },
  "6561": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/MaxPowDiv.lean",
    "full_name": "Nat.maxPowDiv.zero",
    "start": [
      63,
      1
    ],
    "end": [
      66,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "dsimp [maxPowDiv]",
        "annotated_tactic": [
          "dsimp [<a>maxPowDiv</a>]",
          [
            {
              "full_name": "Nat.maxPowDiv",
              "def_path": "Mathlib/Data/Nat/MaxPowDiv.lean",
              "def_pos": [
                30,
                5
              ],
              "def_end_pos": [
                30,
                14
              ]
            }
          ]
        ],
        "state_before": "p : \u2115\n\u22a2 p.maxPowDiv 0 = 0",
        "state_after": "p : \u2115\n\u22a2 go 0 p 0 = 0"
      },
      {
        "tactic": "rw [maxPowDiv.go]",
        "annotated_tactic": [
          "rw [<a>maxPowDiv.go</a>]",
          [
            {
              "full_name": "Nat.maxPowDiv.go",
              "def_path": "Mathlib/Data/Nat/MaxPowDiv.lean",
              "def_pos": [
                32,
                7
              ],
              "def_end_pos": [
                32,
                9
              ]
            }
          ]
        ],
        "state_before": "p : \u2115\n\u22a2 go 0 p 0 = 0",
        "state_after": "p : \u2115\n\u22a2 (if 1 < p \u2227 0 < 0 \u2227 0 % p = 0 then go (0 + 1) p (0 / p) else 0) = 0"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "p : \u2115\n\u22a2 (if 1 < p \u2227 0 < 0 \u2227 0 % p = 0 then go (0 + 1) p (0 / p) else 0) = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2022333769127727,
    "entry_failed": false
  },
  "6600": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Polynomial/RingDivision.lean",
    "full_name": "Polynomial.degree_le_of_dvd",
    "start": [
      161,
      1
    ],
    "end": [
      163,
      34
    ],
    "traced_tactics": [
      {
        "tactic": "rcases h1 with \u27e8q, rfl\u27e9",
        "annotated_tactic": [
          "rcases h1 with \u27e8q, rfl\u27e9",
          []
        ],
        "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np\u271d q\u271d p q : R[X]\nh1 : p \u2223 q\nh2 : q \u2260 0\n\u22a2 p.degree \u2264 q.degree",
        "state_after": "case intro\nR : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np\u271d q\u271d p q : R[X]\nh2 : p * q \u2260 0\n\u22a2 p.degree \u2264 (p * q).degree"
      },
      {
        "tactic": "rw [mul_ne_zero_iff] at h2",
        "annotated_tactic": [
          "rw [<a>mul_ne_zero_iff</a>] at h2",
          [
            {
              "full_name": "mul_ne_zero_iff",
              "def_path": "Mathlib/Algebra/GroupWithZero/Defs.lean",
              "def_pos": [
                295,
                9
              ],
              "def_end_pos": [
                295,
                24
              ]
            }
          ]
        ],
        "state_before": "case intro\nR : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np\u271d q\u271d p q : R[X]\nh2 : p * q \u2260 0\n\u22a2 p.degree \u2264 (p * q).degree",
        "state_after": "case intro\nR : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np\u271d q\u271d p q : R[X]\nh2 : p \u2260 0 \u2227 q \u2260 0\n\u22a2 p.degree \u2264 (p * q).degree"
      },
      {
        "tactic": "exact degree_le_mul_left p h2.2",
        "annotated_tactic": [
          "exact <a>degree_le_mul_left</a> p h2.2",
          [
            {
              "full_name": "Polynomial.degree_le_mul_left",
              "def_path": "Mathlib/Algebra/Polynomial/RingDivision.lean",
              "def_pos": [
                148,
                9
              ],
              "def_end_pos": [
                148,
                27
              ]
            }
          ]
        ],
        "state_before": "case intro\nR : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NoZeroDivisors R\np\u271d q\u271d p q : R[X]\nh2 : p \u2260 0 \u2227 q \u2260 0\n\u22a2 p.degree \u2264 (p * q).degree",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.850071519962512,
    "entry_failed": false
  },
  "6618": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/WittVector/Identities.lean",
    "full_name": "WittVector.coeff_p",
    "start": [
      74,
      1
    ],
    "end": [
      77,
      58
    ],
    "traced_tactics": [
      {
        "tactic": "split_ifs with hi",
        "annotated_tactic": [
          "split_ifs with hi",
          []
        ],
        "state_before": "p : \u2115\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CharP R p\ni : \u2115\n\u22a2 (\u2191p).coeff i = if i = 1 then 1 else 0",
        "state_after": "case pos\np : \u2115\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CharP R p\ni : \u2115\nhi : i = 1\n\u22a2 (\u2191p).coeff i = 1\n\ncase neg\np : \u2115\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CharP R p\ni : \u2115\nhi : \u00aci = 1\n\u22a2 (\u2191p).coeff i = 0"
      },
      {
        "tactic": "simpa only [hi, pow_one] using coeff_p_pow p R 1",
        "annotated_tactic": [
          "simpa only [hi, <a>pow_one</a>] using <a>coeff_p_pow</a> p R 1",
          [
            {
              "full_name": "pow_one",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                663,
                7
              ],
              "def_end_pos": [
                663,
                14
              ]
            },
            {
              "full_name": "WittVector.coeff_p_pow",
              "def_path": "Mathlib/RingTheory/WittVector/Identities.lean",
              "def_pos": [
                57,
                9
              ],
              "def_end_pos": [
                57,
                20
              ]
            }
          ]
        ],
        "state_before": "case pos\np : \u2115\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CharP R p\ni : \u2115\nhi : i = 1\n\u22a2 (\u2191p).coeff i = 1",
        "state_after": "no goals"
      },
      {
        "tactic": "simpa only [pow_one] using coeff_p_pow_eq_zero p R hi",
        "annotated_tactic": [
          "simpa only [<a>pow_one</a>] using <a>coeff_p_pow_eq_zero</a> p R hi",
          [
            {
              "full_name": "pow_one",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                663,
                7
              ],
              "def_end_pos": [
                663,
                14
              ]
            },
            {
              "full_name": "WittVector.coeff_p_pow_eq_zero",
              "def_path": "Mathlib/RingTheory/WittVector/Identities.lean",
              "def_pos": [
                64,
                9
              ],
              "def_end_pos": [
                64,
                28
              ]
            }
          ]
        ],
        "state_before": "case neg\np : \u2115\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CharP R p\ni : \u2115\nhi : \u00aci = 1\n\u22a2 (\u2191p).coeff i = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9628483299165964,
    "entry_failed": false
  },
  "6641": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Polynomial/Monic.lean",
    "full_name": "Polynomial.Monic.of_mul_monic_left",
    "start": [
      143,
      1
    ],
    "end": [
      146,
      34
    ],
    "traced_tactics": [
      {
        "tactic": "contrapose! hpq",
        "annotated_tactic": [
          "contrapose! hpq",
          []
        ],
        "state_before": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : p.Monic\nhpq : (p * q).Monic\n\u22a2 q.Monic",
        "state_after": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : p.Monic\nhpq : \u00acq.Monic\n\u22a2 \u00ac(p * q).Monic"
      },
      {
        "tactic": "rw [Monic.def] at hpq \u22a2",
        "annotated_tactic": [
          "rw [<a>Monic.def</a>] at hpq \u22a2",
          [
            {
              "full_name": "Polynomial.Monic.def",
              "def_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
              "def_pos": [
                86,
                9
              ],
              "def_end_pos": [
                86,
                18
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : p.Monic\nhpq : \u00acq.Monic\n\u22a2 \u00ac(p * q).Monic",
        "state_after": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : p.Monic\nhpq : \u00acq.leadingCoeff = 1\n\u22a2 \u00ac(p * q).leadingCoeff = 1"
      },
      {
        "tactic": "rwa [leadingCoeff_monic_mul hp]",
        "annotated_tactic": [
          "rwa [<a>leadingCoeff_monic_mul</a> hp]",
          [
            {
              "full_name": "Polynomial.leadingCoeff_monic_mul",
              "def_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
              "def_pos": [
                1067,
                9
              ],
              "def_end_pos": [
                1067,
                31
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : p.Monic\nhpq : \u00acq.leadingCoeff = 1\n\u22a2 \u00ac(p * q).leadingCoeff = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.728671781020239,
    "entry_failed": false
  },
  "6753": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/PEquiv.lean",
    "full_name": "PEquiv.bot_trans",
    "start": [
      318,
      1
    ],
    "end": [
      319,
      34
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type x\nf : \u03b2 \u2243. \u03b3\n\u22a2 \u22a5.trans f = \u22a5",
        "state_after": "case h.a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type x\nf : \u03b2 \u2243. \u03b3\nx\u271d : \u03b1\na\u271d : \u03b3\n\u22a2 a\u271d \u2208 (\u22a5.trans f) x\u271d \u2194 a\u271d \u2208 \u22a5 x\u271d"
      },
      {
        "tactic": "dsimp [PEquiv.trans]",
        "annotated_tactic": [
          "dsimp [<a>PEquiv.trans</a>]",
          [
            {
              "full_name": "PEquiv.trans",
              "def_path": "Mathlib/Data/PEquiv.lean",
              "def_pos": [
                118,
                15
              ],
              "def_end_pos": [
                118,
                20
              ]
            }
          ]
        ],
        "state_before": "case h.a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type x\nf : \u03b2 \u2243. \u03b3\nx\u271d : \u03b1\na\u271d : \u03b3\n\u22a2 a\u271d \u2208 (\u22a5.trans f) x\u271d \u2194 a\u271d \u2208 \u22a5 x\u271d",
        "state_after": "case h.a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type x\nf : \u03b2 \u2243. \u03b3\nx\u271d : \u03b1\na\u271d : \u03b3\n\u22a2 a\u271d \u2208 none \u2194 a\u271d \u2208 none"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case h.a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type x\nf : \u03b2 \u2243. \u03b3\nx\u271d : \u03b1\na\u271d : \u03b3\n\u22a2 a\u271d \u2208 none \u2194 a\u271d \u2208 none",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.0907234370242804,
    "entry_failed": false
  },
  "6765": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Filter/Subsingleton.lean",
    "full_name": "Filter.Subsingleton.isCountablyGenerated",
    "start": [
      76,
      1
    ],
    "end": [
      79,
      38
    ],
    "traced_tactics": [
      {
        "tactic": "rcases subsingleton_iff_bot_or_pure.1 hl with rfl|\u27e8x, rfl\u27e9",
        "annotated_tactic": [
          "rcases <a>subsingleton_iff_bot_or_pure</a>.1 hl with rfl|\u27e8x, rfl\u27e9",
          [
            {
              "full_name": "Filter.subsingleton_iff_bot_or_pure",
              "def_path": "Mathlib/Order/Filter/Subsingleton.lean",
              "def_pos": [
                58,
                9
              ],
              "def_end_pos": [
                58,
                37
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : Filter \u03b1\nhl : l.Subsingleton\n\u22a2 l.IsCountablyGenerated",
        "state_after": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nhl : \u22a5.Subsingleton\n\u22a2 \u22a5.IsCountablyGenerated\n\ncase inr.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx : \u03b1\nhl : (pure x).Subsingleton\n\u22a2 (pure x).IsCountablyGenerated"
      },
      {
        "tactic": "exact isCountablyGenerated_bot",
        "annotated_tactic": [
          "exact <a>isCountablyGenerated_bot</a>",
          [
            {
              "full_name": "Filter.isCountablyGenerated_bot",
              "def_path": "Mathlib/Order/Filter/Bases.lean",
              "def_pos": [
                1207,
                9
              ],
              "def_end_pos": [
                1207,
                33
              ]
            }
          ]
        ],
        "state_before": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nhl : \u22a5.Subsingleton\n\u22a2 \u22a5.IsCountablyGenerated",
        "state_after": "no goals"
      },
      {
        "tactic": "exact isCountablyGenerated_pure x",
        "annotated_tactic": [
          "exact <a>isCountablyGenerated_pure</a> x",
          [
            {
              "full_name": "Filter.isCountablyGenerated_pure",
              "def_path": "Mathlib/Order/Filter/Bases.lean",
              "def_pos": [
                1201,
                9
              ],
              "def_end_pos": [
                1201,
                34
              ]
            }
          ]
        ],
        "state_before": "case inr.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx : \u03b1\nhl : (pure x).Subsingleton\n\u22a2 (pure x).IsCountablyGenerated",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2517796979518607,
    "entry_failed": false
  },
  "6788": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/OfFn.lean",
    "full_name": "List.get_ofFn_go",
    "start": [
      56,
      1
    ],
    "end": [
      58,
      25
    ],
    "traced_tactics": [
      {
        "tactic": "simp at hk",
        "annotated_tactic": [
          "simp at hk",
          []
        ],
        "state_before": "\u03b1 : Type u\nn : \u2115\nf : Fin n \u2192 \u03b1\ni j : \u2115\nh : i + j = n\nk : \u2115\nhk : k < (ofFn.go f i j h).length\n\u22a2 j + k < n",
        "state_after": "\u03b1 : Type u\nn : \u2115\nf : Fin n \u2192 \u03b1\ni j : \u2115\nh : i + j = n\nk : \u2115\nhk : k < i\n\u22a2 j + k < n"
      },
      {
        "tactic": "omega",
        "annotated_tactic": [
          "omega",
          []
        ],
        "state_before": "\u03b1 : Type u\nn : \u2115\nf : Fin n \u2192 \u03b1\ni j : \u2115\nh : i + j = n\nk : \u2115\nhk : k < i\n\u22a2 j + k < n",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [getElem_ofFn_go]",
        "annotated_tactic": [
          "simp [<a>getElem_ofFn_go</a>]",
          [
            {
              "full_name": "List.getElem_ofFn_go",
              "def_path": "Mathlib/Data/List/OfFn.lean",
              "def_pos": [
                50,
                9
              ],
              "def_end_pos": [
                50,
                24
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\nn : \u2115\nf : Fin n \u2192 \u03b1\ni j : \u2115\nh : i + j = n\nk : \u2115\nhk : k < (ofFn.go f i j h).length\n\u22a2 (ofFn.go f i j h).get \u27e8k, hk\u27e9 = f \u27e8j + k, \u22ef\u27e9",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6436052870703861,
    "entry_failed": false
  },
  "6799": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Perm/Support.lean",
    "full_name": "Equiv.Perm.card_support_ne_one",
    "start": [
      583,
      1
    ],
    "end": [
      586,
      53
    ],
    "traced_tactics": [
      {
        "tactic": "by_cases h : f = 1",
        "annotated_tactic": [
          "by_cases h : f = 1",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d g f : Perm \u03b1\n\u22a2 f.support.card \u2260 1",
        "state_after": "case pos\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d g f : Perm \u03b1\nh : f = 1\n\u22a2 f.support.card \u2260 1\n\ncase neg\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d g f : Perm \u03b1\nh : \u00acf = 1\n\u22a2 f.support.card \u2260 1"
      },
      {
        "tactic": "exact ne_of_eq_of_ne (card_support_eq_zero.mpr h) zero_ne_one",
        "annotated_tactic": [
          "exact <a>ne_of_eq_of_ne</a> (card_support_eq_zero.mpr h) <a>zero_ne_one</a>",
          [
            {
              "full_name": "ne_of_eq_of_ne",
              "def_path": "Mathlib/Logic/Basic.lean",
              "def_pos": [
                533,
                7
              ],
              "def_end_pos": [
                533,
                21
              ]
            },
            {
              "full_name": "zero_ne_one",
              "def_path": "Mathlib/Algebra/NeZero.lean",
              "def_pos": [
                55,
                15
              ],
              "def_end_pos": [
                55,
                26
              ]
            }
          ]
        ],
        "state_before": "case pos\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d g f : Perm \u03b1\nh : f = 1\n\u22a2 f.support.card \u2260 1",
        "state_after": "no goals"
      },
      {
        "tactic": "exact ne_of_gt (one_lt_card_support_of_ne_one h)",
        "annotated_tactic": [
          "exact <a>ne_of_gt</a> (<a>one_lt_card_support_of_ne_one</a> h)",
          [
            {
              "full_name": "ne_of_gt",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                104,
                9
              ],
              "def_end_pos": [
                104,
                17
              ]
            },
            {
              "full_name": "Equiv.Perm.one_lt_card_support_of_ne_one",
              "def_path": "Mathlib/GroupTheory/Perm/Support.lean",
              "def_pos": [
                575,
                9
              ],
              "def_end_pos": [
                575,
                38
              ]
            }
          ]
        ],
        "state_before": "case neg\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf\u271d g f : Perm \u03b1\nh : \u00acf = 1\n\u22a2 f.support.card \u2260 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.003512262948789,
    "entry_failed": false
  },
  "6801": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Complex/Circle.lean",
    "full_name": "AddCircle.toCircle_add",
    "start": [
      179,
      1
    ],
    "end": [
      183,
      68
    ],
    "traced_tactics": [
      {
        "tactic": "induction x using QuotientAddGroup.induction_on'",
        "annotated_tactic": [
          "induction x using <a>QuotientAddGroup.induction_on'</a>",
          [
            {
              "full_name": "QuotientAddGroup.induction_on'",
              "def_path": "Mathlib/GroupTheory/Coset.lean",
              "def_pos": [
                467,
                3
              ],
              "def_end_pos": [
                467,
                14
              ]
            }
          ]
        ],
        "state_before": "T : \u211d\nx y : AddCircle T\n\u22a2 (x + y).toCircle = x.toCircle * y.toCircle",
        "state_after": "case H\nT : \u211d\ny : AddCircle T\nz\u271d : \u211d\n\u22a2 (\u2191z\u271d + y).toCircle = toCircle \u2191z\u271d * y.toCircle"
      },
      {
        "tactic": "induction y using QuotientAddGroup.induction_on'",
        "annotated_tactic": [
          "induction y using <a>QuotientAddGroup.induction_on'</a>",
          [
            {
              "full_name": "QuotientAddGroup.induction_on'",
              "def_path": "Mathlib/GroupTheory/Coset.lean",
              "def_pos": [
                467,
                3
              ],
              "def_end_pos": [
                467,
                14
              ]
            }
          ]
        ],
        "state_before": "case H\nT : \u211d\ny : AddCircle T\nz\u271d : \u211d\n\u22a2 (\u2191z\u271d + y).toCircle = toCircle \u2191z\u271d * y.toCircle",
        "state_after": "case H.H\nT z\u271d\u00b9 z\u271d : \u211d\n\u22a2 (\u2191z\u271d\u00b9 + \u2191z\u271d).toCircle = toCircle \u2191z\u271d\u00b9 * toCircle \u2191z\u271d"
      },
      {
        "tactic": "simp_rw [\u2190 coe_add, toCircle_apply_mk, mul_add, expMapCircle_add]",
        "annotated_tactic": [
          "simp_rw [\u2190 <a>coe_add</a>, <a>toCircle_apply_mk</a>, <a>mul_add</a>, <a>expMapCircle_add</a>]",
          [
            {
              "full_name": "AddCircle.coe_add",
              "def_path": "Mathlib/Topology/Instances/AddCircle.lean",
              "def_pos": [
                140,
                9
              ],
              "def_end_pos": [
                140,
                16
              ]
            },
            {
              "full_name": "AddCircle.toCircle_apply_mk",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Complex/Circle.lean",
              "def_pos": [
                176,
                9
              ],
              "def_end_pos": [
                176,
                26
              ]
            },
            {
              "full_name": "mul_add",
              "def_path": "Mathlib/Algebra/Ring/Defs.lean",
              "def_pos": [
                83,
                7
              ],
              "def_end_pos": [
                83,
                14
              ]
            },
            {
              "full_name": "expMapCircle_add",
              "def_path": "Mathlib/Analysis/Complex/Circle.lean",
              "def_pos": [
                136,
                9
              ],
              "def_end_pos": [
                136,
                25
              ]
            }
          ]
        ],
        "state_before": "case H.H\nT z\u271d\u00b9 z\u271d : \u211d\n\u22a2 (\u2191z\u271d\u00b9 + \u2191z\u271d).toCircle = toCircle \u2191z\u271d\u00b9 * toCircle \u2191z\u271d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.9927323220763355,
    "entry_failed": false
  },
  "6806": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Nilpotent/Basic.lean",
    "full_name": "IsNilpotent.neg",
    "start": [
      40,
      1
    ],
    "end": [
      43,
      29
    ],
    "traced_tactics": [
      {
        "tactic": "obtain \u27e8n, hn\u27e9 := h",
        "annotated_tactic": [
          "obtain \u27e8n, hn\u27e9 := h",
          []
        ],
        "state_before": "R : Type u_1\nS : Type u_2\nx y : R\ninst\u271d : Ring R\nh : IsNilpotent x\n\u22a2 IsNilpotent (-x)",
        "state_after": "case intro\nR : Type u_1\nS : Type u_2\nx y : R\ninst\u271d : Ring R\nn : \u2115\nhn : x ^ n = 0\n\u22a2 IsNilpotent (-x)"
      },
      {
        "tactic": "use n",
        "annotated_tactic": [
          "use n",
          []
        ],
        "state_before": "case intro\nR : Type u_1\nS : Type u_2\nx y : R\ninst\u271d : Ring R\nn : \u2115\nhn : x ^ n = 0\n\u22a2 IsNilpotent (-x)",
        "state_after": "case h\nR : Type u_1\nS : Type u_2\nx y : R\ninst\u271d : Ring R\nn : \u2115\nhn : x ^ n = 0\n\u22a2 (-x) ^ n = 0"
      },
      {
        "tactic": "rw [neg_pow, hn, mul_zero]",
        "annotated_tactic": [
          "rw [<a>neg_pow</a>, hn, <a>mul_zero</a>]",
          [
            {
              "full_name": "neg_pow",
              "def_path": "Mathlib/Algebra/Ring/Commute.lean",
              "def_pos": [
                175,
                7
              ],
              "def_end_pos": [
                175,
                14
              ]
            },
            {
              "full_name": "MulZeroClass.mul_zero",
              "def_path": "Mathlib/Algebra/GroupWithZero/Defs.lean",
              "def_pos": [
                39,
                3
              ],
              "def_end_pos": [
                39,
                11
              ]
            }
          ]
        ],
        "state_before": "case h\nR : Type u_1\nS : Type u_2\nx y : R\ninst\u271d : Ring R\nn : \u2115\nhn : x ^ n = 0\n\u22a2 (-x) ^ n = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.24915118701756,
    "entry_failed": false
  },
  "6846": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Group/Invertible/Defs.lean",
    "full_name": "Invertible.congr",
    "start": [
      170,
      1
    ],
    "end": [
      171,
      59
    ],
    "traced_tactics": [
      {
        "tactic": "subst h",
        "annotated_tactic": [
          "subst h",
          []
        ],
        "state_before": "\u03b1 : Type u\ninst\u271d\u00b2 : Monoid \u03b1\na b : \u03b1\ninst\u271d\u00b9 : Invertible a\ninst\u271d : Invertible b\nh : a = b\n\u22a2 \u215fa = \u215fb",
        "state_after": "\u03b1 : Type u\ninst\u271d\u00b2 : Monoid \u03b1\na : \u03b1\ninst\u271d\u00b9 inst\u271d : Invertible a\n\u22a2 \u215fa = \u215fa"
      },
      {
        "tactic": "congr",
        "annotated_tactic": [
          "congr",
          []
        ],
        "state_before": "\u03b1 : Type u\ninst\u271d\u00b2 : Monoid \u03b1\na : \u03b1\ninst\u271d\u00b9 inst\u271d : Invertible a\n\u22a2 \u215fa = \u215fa",
        "state_after": "case h.e_5.h\n\u03b1 : Type u\ninst\u271d\u00b2 : Monoid \u03b1\na : \u03b1\ninst\u271d\u00b9 inst\u271d : Invertible a\n\u22a2 inst\u271d\u00b9 = inst\u271d"
      },
      {
        "tactic": "apply Subsingleton.allEq",
        "annotated_tactic": [
          "apply <a>Subsingleton.allEq</a>",
          [
            {
              "full_name": "Subsingleton.allEq",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1013,
                3
              ],
              "def_end_pos": [
                1013,
                8
              ]
            }
          ]
        ],
        "state_before": "case h.e_5.h\n\u03b1 : Type u\ninst\u271d\u00b2 : Monoid \u03b1\na : \u03b1\ninst\u271d\u00b9 inst\u271d : Invertible a\n\u22a2 inst\u271d\u00b9 = inst\u271d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.1458680600626394,
    "entry_failed": false
  },
  "6873": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/Measure/FiniteMeasure.lean",
    "full_name": "MeasureTheory.FiniteMeasure.eq_of_forall_toMeasure_apply_eq",
    "start": [
      213,
      1
    ],
    "end": [
      217,
      19
    ],
    "traced_tactics": [
      {
        "tactic": "apply Subtype.ext",
        "annotated_tactic": [
          "apply <a>Subtype.ext</a>",
          [
            {
              "full_name": "Subtype.ext",
              "def_path": "Mathlib/Data/Subtype.lean",
              "def_pos": [
                74,
                19
              ],
              "def_end_pos": [
                74,
                22
              ]
            }
          ]
        ],
        "state_before": "\u03a9 : Type u_1\ninst\u271d : MeasurableSpace \u03a9\n\u03bc \u03bd : FiniteMeasure \u03a9\nh : \u2200 (s : Set \u03a9), MeasurableSet s \u2192 \u2191\u03bc s = \u2191\u03bd s\n\u22a2 \u03bc = \u03bd",
        "state_after": "case a\n\u03a9 : Type u_1\ninst\u271d : MeasurableSpace \u03a9\n\u03bc \u03bd : FiniteMeasure \u03a9\nh : \u2200 (s : Set \u03a9), MeasurableSet s \u2192 \u2191\u03bc s = \u2191\u03bd s\n\u22a2 \u2191\u03bc = \u2191\u03bd"
      },
      {
        "tactic": "ext1 s s_mble",
        "annotated_tactic": [
          "ext1 s s_mble",
          []
        ],
        "state_before": "case a\n\u03a9 : Type u_1\ninst\u271d : MeasurableSpace \u03a9\n\u03bc \u03bd : FiniteMeasure \u03a9\nh : \u2200 (s : Set \u03a9), MeasurableSet s \u2192 \u2191\u03bc s = \u2191\u03bd s\n\u22a2 \u2191\u03bc = \u2191\u03bd",
        "state_after": "case a.h\n\u03a9 : Type u_1\ninst\u271d : MeasurableSpace \u03a9\n\u03bc \u03bd : FiniteMeasure \u03a9\nh : \u2200 (s : Set \u03a9), MeasurableSet s \u2192 \u2191\u03bc s = \u2191\u03bd s\ns : Set \u03a9\ns_mble : MeasurableSet s\n\u22a2 \u2191\u03bc s = \u2191\u03bd s"
      },
      {
        "tactic": "exact h s s_mble",
        "annotated_tactic": [
          "exact h s s_mble",
          []
        ],
        "state_before": "case a.h\n\u03a9 : Type u_1\ninst\u271d : MeasurableSpace \u03a9\n\u03bc \u03bd : FiniteMeasure \u03a9\nh : \u2200 (s : Set \u03a9), MeasurableSet s \u2192 \u2191\u03bc s = \u2191\u03bd s\ns : Set \u03a9\ns_mble : MeasurableSet s\n\u22a2 \u2191\u03bc s = \u2191\u03bd s",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.8703759519848973,
    "entry_failed": false
  },
  "6965": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/ReduceOption.lean",
    "full_name": "List.reduceOption_length_eq",
    "start": [
      49,
      1
    ],
    "end": [
      53,
      27
    ],
    "traced_tactics": [
      {
        "tactic": "induction' l with hd tl hl",
        "annotated_tactic": [
          "induction' l with hd tl hl",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl : List (Option \u03b1)\n\u22a2 l.reduceOption.length = (filter Option.isSome l).length",
        "state_after": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u22a2 [].reduceOption.length = (filter Option.isSome []).length\n\ncase cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nhd : Option \u03b1\ntl : List (Option \u03b1)\nhl : tl.reduceOption.length = (filter Option.isSome tl).length\n\u22a2 (hd :: tl).reduceOption.length = (filter Option.isSome (hd :: tl)).length"
      },
      {
        "tactic": "simp_rw [reduceOption_nil, filter_nil, length]",
        "annotated_tactic": [
          "simp_rw [<a>reduceOption_nil</a>, <a>filter_nil</a>, <a>length</a>]",
          [
            {
              "full_name": "List.reduceOption_nil",
              "def_path": "Mathlib/Data/List/ReduceOption.lean",
              "def_pos": [
                30,
                9
              ],
              "def_end_pos": [
                30,
                25
              ]
            },
            {
              "full_name": "List.filter_nil",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean",
              "def_pos": [
                382,
                17
              ],
              "def_end_pos": [
                382,
                27
              ]
            },
            {
              "full_name": "List.length",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                2316,
                5
              ],
              "def_end_pos": [
                2316,
                16
              ]
            }
          ]
        ],
        "state_before": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u22a2 [].reduceOption.length = (filter Option.isSome []).length",
        "state_after": "no goals"
      },
      {
        "tactic": "cases hd <;> simp [hl]",
        "annotated_tactic": [
          "cases hd <;> simp [hl]",
          []
        ],
        "state_before": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nhd : Option \u03b1\ntl : List (Option \u03b1)\nhl : tl.reduceOption.length = (filter Option.isSome tl).length\n\u22a2 (hd :: tl).reduceOption.length = (filter Option.isSome (hd :: tl)).length",
        "state_after": "no goals"
      }
    ],
    "entry_time": 0.9413107390282676,
    "entry_failed": false
  },
  "6970": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/DropRight.lean",
    "full_name": "List.rdropWhile_last_not",
    "start": [
      125,
      1
    ],
    "end": [
      128,
      39
    ],
    "traced_tactics": [
      {
        "tactic": "simp_rw [rdropWhile]",
        "annotated_tactic": [
          "simp_rw [<a>rdropWhile</a>]",
          [
            {
              "full_name": "List.rdropWhile",
              "def_path": "Mathlib/Data/List/DropRight.lean",
              "def_pos": [
                97,
                5
              ],
              "def_end_pos": [
                97,
                15
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl : List \u03b1\nn : \u2115\nhl : rdropWhile p l \u2260 []\n\u22a2 \u00acp ((rdropWhile p l).getLast hl) = true",
        "state_after": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl : List \u03b1\nn : \u2115\nhl : rdropWhile p l \u2260 []\n\u22a2 \u00acp ((dropWhile p l.reverse).reverse.getLast \u22ef) = true"
      },
      {
        "tactic": "rw [getLast_reverse]",
        "annotated_tactic": [
          "rw [<a>getLast_reverse</a>]",
          [
            {
              "full_name": "List.getLast_reverse",
              "def_path": "Mathlib/Data/List/Basic.lean",
              "def_pos": [
                3543,
                9
              ],
              "def_end_pos": [
                3543,
                24
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl : List \u03b1\nn : \u2115\nhl : rdropWhile p l \u2260 []\n\u22a2 \u00acp ((dropWhile p l.reverse).reverse.getLast \u22ef) = true",
        "state_after": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl : List \u03b1\nn : \u2115\nhl : rdropWhile p l \u2260 []\n\u22a2 \u00acp ((dropWhile p l.reverse).get \u27e80, \u22ef\u27e9) = true"
      },
      {
        "tactic": "exact dropWhile_nthLe_zero_not _ _ _",
        "annotated_tactic": [
          "exact <a>dropWhile_nthLe_zero_not</a> _ _ _",
          [
            {
              "full_name": "List.dropWhile_nthLe_zero_not",
              "def_path": "Mathlib/Data/List/Basic.lean",
              "def_pos": [
                2984,
                9
              ],
              "def_end_pos": [
                2984,
                33
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl : List \u03b1\nn : \u2115\nhl : rdropWhile p l \u2260 []\n\u22a2 \u00acp ((dropWhile p l.reverse).get \u27e80, \u22ef\u27e9) = true",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4096542400075123,
    "entry_failed": false
  },
  "7221": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Polynomial/Roots.lean",
    "full_name": "Polynomial.eq_of_infinite_eval_eq",
    "start": [
      154,
      1
    ],
    "end": [
      158,
      45
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 sub_eq_zero]",
        "annotated_tactic": [
          "rw [\u2190 <a>sub_eq_zero</a>]",
          [
            {
              "full_name": "sub_eq_zero",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                1070,
                3
              ],
              "def_end_pos": [
                1070,
                14
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np\u271d q\u271d p q : R[X]\nh : {x | eval x p = eval x q}.Infinite\n\u22a2 p = q",
        "state_after": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np\u271d q\u271d p q : R[X]\nh : {x | eval x p = eval x q}.Infinite\n\u22a2 p - q = 0"
      },
      {
        "tactic": "apply eq_zero_of_infinite_isRoot",
        "annotated_tactic": [
          "apply <a>eq_zero_of_infinite_isRoot</a>",
          [
            {
              "full_name": "Polynomial.eq_zero_of_infinite_isRoot",
              "def_path": "Mathlib/Algebra/Polynomial/Roots.lean",
              "def_pos": [
                142,
                9
              ],
              "def_end_pos": [
                142,
                35
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np\u271d q\u271d p q : R[X]\nh : {x | eval x p = eval x q}.Infinite\n\u22a2 p - q = 0",
        "state_after": "case h\nR : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np\u271d q\u271d p q : R[X]\nh : {x | eval x p = eval x q}.Infinite\n\u22a2 {x | (p - q).IsRoot x}.Infinite"
      },
      {
        "tactic": "simpa only [IsRoot, eval_sub, sub_eq_zero]",
        "annotated_tactic": [
          "simpa only [<a>IsRoot</a>, <a>eval_sub</a>, <a>sub_eq_zero</a>]",
          [
            {
              "full_name": "Polynomial.IsRoot",
              "def_path": "Mathlib/Algebra/Polynomial/Eval.lean",
              "def_pos": [
                488,
                5
              ],
              "def_end_pos": [
                488,
                11
              ]
            },
            {
              "full_name": "Polynomial.eval_sub",
              "def_path": "Mathlib/Algebra/Polynomial/Eval.lean",
              "def_pos": [
                1325,
                9
              ],
              "def_end_pos": [
                1325,
                17
              ]
            },
            {
              "full_name": "sub_eq_zero",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                1070,
                3
              ],
              "def_end_pos": [
                1070,
                14
              ]
            }
          ]
        ],
        "state_before": "case h\nR : Type u\nS : Type v\nT : Type w\na b : R\nn : \u2115\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\np\u271d q\u271d p q : R[X]\nh : {x | eval x p = eval x q}.Infinite\n\u22a2 {x | (p - q).IsRoot x}.Infinite",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.1662742469925433,
    "entry_failed": false
  },
  "7309": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/CommutingProbability.lean",
    "full_name": "commProb_le_one",
    "start": [
      78,
      1
    ],
    "end": [
      81,
      31
    ],
    "traced_tactics": [
      {
        "tactic": "refine div_le_one_of_le ?_ (sq_nonneg (Nat.card M : \u211a))",
        "annotated_tactic": [
          "refine <a>div_le_one_of_le</a> ?_ (<a>sq_nonneg</a> (<a>Nat.card</a> M : \u211a))",
          [
            {
              "full_name": "div_le_one_of_le",
              "def_path": "Mathlib/Algebra/Order/Field/Basic.lean",
              "def_pos": [
                165,
                9
              ],
              "def_end_pos": [
                165,
                25
              ]
            },
            {
              "full_name": "sq_nonneg",
              "def_path": "Mathlib/Algebra/Order/Ring/Defs.lean",
              "def_pos": [
                1160,
                7
              ],
              "def_end_pos": [
                1160,
                16
              ]
            },
            {
              "full_name": "Nat.card",
              "def_path": "Mathlib/SetTheory/Cardinal/Finite.lean",
              "def_pos": [
                35,
                15
              ],
              "def_end_pos": [
                35,
                19
              ]
            }
          ]
        ],
        "state_before": "M : Type u_1\ninst\u271d\u00b9 : Mul M\ninst\u271d : Finite M\n\u22a2 commProb M \u2264 1",
        "state_after": "M : Type u_1\ninst\u271d\u00b9 : Mul M\ninst\u271d : Finite M\n\u22a2 \u2191(Nat.card { p // Commute p.1 p.2 }) \u2264 \u2191(Nat.card M) ^ 2"
      },
      {
        "tactic": "rw [\u2190 Nat.cast_pow, Nat.cast_le, sq, \u2190 Nat.card_prod]",
        "annotated_tactic": [
          "rw [\u2190 <a>Nat.cast_pow</a>, <a>Nat.cast_le</a>, <a>sq</a>, \u2190 <a>Nat.card_prod</a>]",
          [
            {
              "full_name": "Nat.cast_pow",
              "def_path": "Mathlib/Data/Nat/Cast/Basic.lean",
              "def_pos": [
                93,
                7
              ],
              "def_end_pos": [
                93,
                15
              ]
            },
            {
              "full_name": "Nat.cast_le",
              "def_path": "Mathlib/Data/Nat/Cast/Order.lean",
              "def_pos": [
                124,
                9
              ],
              "def_end_pos": [
                124,
                16
              ]
            },
            {
              "full_name": "sq",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                684,
                41
              ],
              "def_end_pos": [
                684,
                43
              ]
            },
            {
              "full_name": "Nat.card_prod",
              "def_path": "Mathlib/SetTheory/Cardinal/Finite.lean",
              "def_pos": [
                173,
                9
              ],
              "def_end_pos": [
                173,
                18
              ]
            }
          ]
        ],
        "state_before": "M : Type u_1\ninst\u271d\u00b9 : Mul M\ninst\u271d : Finite M\n\u22a2 \u2191(Nat.card { p // Commute p.1 p.2 }) \u2264 \u2191(Nat.card M) ^ 2",
        "state_after": "M : Type u_1\ninst\u271d\u00b9 : Mul M\ninst\u271d : Finite M\n\u22a2 Nat.card { p // Commute p.1 p.2 } \u2264 Nat.card (M \u00d7 M)"
      },
      {
        "tactic": "apply Finite.card_subtype_le",
        "annotated_tactic": [
          "apply <a>Finite.card_subtype_le</a>",
          [
            {
              "full_name": "Finite.card_subtype_le",
              "def_path": "Mathlib/Data/Finite/Card.lean",
              "def_pos": [
                180,
                9
              ],
              "def_end_pos": [
                180,
                24
              ]
            }
          ]
        ],
        "state_before": "M : Type u_1\ninst\u271d\u00b9 : Mul M\ninst\u271d : Finite M\n\u22a2 Nat.card { p // Commute p.1 p.2 } \u2264 Nat.card (M \u00d7 M)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.050419330014847,
    "entry_failed": false
  },
  "7413": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Tropical/Basic.lean",
    "full_name": "Tropical.succ_nsmul",
    "start": [
      569,
      1
    ],
    "end": [
      572,
      44
    ],
    "traced_tactics": [
      {
        "tactic": "induction' n with n IH",
        "annotated_tactic": [
          "induction' n with n IH",
          []
        ],
        "state_before": "R\u271d : Type u\ninst\u271d\u00b2 : LinearOrderedAddCommMonoidWithTop R\u271d\nR : Type u_1\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\nx : Tropical R\nn : \u2115\n\u22a2 (n + 1) \u2022 x = x",
        "state_after": "case zero\nR\u271d : Type u\ninst\u271d\u00b2 : LinearOrderedAddCommMonoidWithTop R\u271d\nR : Type u_1\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\nx : Tropical R\n\u22a2 (0 + 1) \u2022 x = x\n\ncase succ\nR\u271d : Type u\ninst\u271d\u00b2 : LinearOrderedAddCommMonoidWithTop R\u271d\nR : Type u_1\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\nx : Tropical R\nn : \u2115\nIH : (n + 1) \u2022 x = x\n\u22a2 (n + 1 + 1) \u2022 x = x"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case zero\nR\u271d : Type u\ninst\u271d\u00b2 : LinearOrderedAddCommMonoidWithTop R\u271d\nR : Type u_1\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\nx : Tropical R\n\u22a2 (0 + 1) \u2022 x = x",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [add_nsmul, IH, one_nsmul, add_self]",
        "annotated_tactic": [
          "rw [<a>add_nsmul</a>, IH, <a>one_nsmul</a>, <a>add_self</a>]",
          [
            {
              "full_name": "add_nsmul",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                702,
                15
              ],
              "def_end_pos": [
                702,
                24
              ]
            },
            {
              "full_name": "one_nsmul",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                662,
                30
              ],
              "def_end_pos": [
                662,
                39
              ]
            },
            {
              "full_name": "Tropical.add_self",
              "def_path": "Mathlib/Algebra/Tropical/Basic.lean",
              "def_pos": [
                346,
                9
              ],
              "def_end_pos": [
                346,
                17
              ]
            }
          ]
        ],
        "state_before": "case succ\nR\u271d : Type u\ninst\u271d\u00b2 : LinearOrderedAddCommMonoidWithTop R\u271d\nR : Type u_1\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\nx : Tropical R\nn : \u2115\nIH : (n + 1) \u2022 x = x\n\u22a2 (n + 1 + 1) \u2022 x = x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.7399408280616626,
    "entry_failed": false
  },
  "7443": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/DifferentialObject.lean",
    "full_name": "CategoryTheory.DifferentialObject.eqToHom_f",
    "start": [
      104,
      1
    ],
    "end": [
      108,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "subst h",
        "annotated_tactic": [
          "subst h",
          []
        ],
        "state_before": "S : Type u_1\ninst\u271d\u00b3 : AddMonoidWithOne S\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : HasZeroMorphisms C\ninst\u271d : HasShift C S\nX Y : DifferentialObject S C\nh : X = Y\n\u22a2 (eqToHom h).f = eqToHom \u22ef",
        "state_after": "S : Type u_1\ninst\u271d\u00b3 : AddMonoidWithOne S\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : HasZeroMorphisms C\ninst\u271d : HasShift C S\nX : DifferentialObject S C\n\u22a2 (eqToHom \u22ef).f = eqToHom \u22ef"
      },
      {
        "tactic": "rw [eqToHom_refl, eqToHom_refl]",
        "annotated_tactic": [
          "rw [<a>eqToHom_refl</a>, <a>eqToHom_refl</a>]",
          [
            {
              "full_name": "CategoryTheory.eqToHom_refl",
              "def_path": "Mathlib/CategoryTheory/EqToHom.lean",
              "def_pos": [
                47,
                9
              ],
              "def_end_pos": [
                47,
                21
              ]
            },
            {
              "full_name": "CategoryTheory.eqToHom_refl",
              "def_path": "Mathlib/CategoryTheory/EqToHom.lean",
              "def_pos": [
                47,
                9
              ],
              "def_end_pos": [
                47,
                21
              ]
            }
          ]
        ],
        "state_before": "S : Type u_1\ninst\u271d\u00b3 : AddMonoidWithOne S\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : HasZeroMorphisms C\ninst\u271d : HasShift C S\nX : DifferentialObject S C\n\u22a2 (eqToHom \u22ef).f = eqToHom \u22ef",
        "state_after": "S : Type u_1\ninst\u271d\u00b3 : AddMonoidWithOne S\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : HasZeroMorphisms C\ninst\u271d : HasShift C S\nX : DifferentialObject S C\n\u22a2 (\ud835\udfd9 X).f = \ud835\udfd9 X.obj"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "S : Type u_1\ninst\u271d\u00b3 : AddMonoidWithOne S\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : HasZeroMorphisms C\ninst\u271d : HasShift C S\nX : DifferentialObject S C\n\u22a2 (\ud835\udfd9 X).f = \ud835\udfd9 X.obj",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.857574751949869,
    "entry_failed": false
  },
  "7501": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Nodup.lean",
    "full_name": "List.nodup_iff_injective_get",
    "start": [
      103,
      1
    ],
    "end": [
      107,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "rw [nodup_iff_injective_getElem]",
        "annotated_tactic": [
          "rw [<a>nodup_iff_injective_getElem</a>]",
          [
            {
              "full_name": "List.nodup_iff_injective_getElem",
              "def_path": "Mathlib/Data/List/Nodup.lean",
              "def_pos": [
                91,
                9
              ],
              "def_end_pos": [
                91,
                36
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nl\u271d l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b : \u03b1\nl : List \u03b1\n\u22a2 l.Nodup \u2194 Injective l.get",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\nl\u271d l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b : \u03b1\nl : List \u03b1\n\u22a2 (Injective fun i => l[\u2191i]) \u2194 Injective l.get"
      },
      {
        "tactic": "change _ \u2194 Injective (fun i => l.get i)",
        "annotated_tactic": [
          "change _ \u2194 <a>Injective</a> (fun i => l.get i)",
          [
            {
              "full_name": "Function.Injective",
              "def_path": "Mathlib/Init/Function.lean",
              "def_pos": [
                123,
                5
              ],
              "def_end_pos": [
                123,
                14
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nl\u271d l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b : \u03b1\nl : List \u03b1\n\u22a2 (Injective fun i => l[\u2191i]) \u2194 Injective l.get",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\nl\u271d l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b : \u03b1\nl : List \u03b1\n\u22a2 (Injective fun i => l[\u2191i]) \u2194 Injective fun i => l.get i"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nl\u271d l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b : \u03b1\nl : List \u03b1\n\u22a2 (Injective fun i => l[\u2191i]) \u2194 Injective fun i => l.get i",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5270807510241866,
    "entry_failed": false
  },
  "7536": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Category/UniformSpace.lean",
    "full_name": "UniformSpaceCat.extension_comp_coe",
    "start": [
      210,
      1
    ],
    "end": [
      215,
      63
    ],
    "traced_tactics": [
      {
        "tactic": "apply Subtype.eq",
        "annotated_tactic": [
          "apply <a>Subtype.eq</a>",
          [
            {
              "full_name": "Subtype.eq",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1110,
                19
              ],
              "def_end_pos": [
                1110,
                21
              ]
            }
          ]
        ],
        "state_before": "X : UniformSpaceCat\nY : CpltSepUniformSpace\nf : (CpltSepUniformSpace.of (Completion \u2191X)).toUniformSpace \u27f6 Y.toUniformSpace\n\u22a2 extensionHom (X.completionHom \u226b f) = f",
        "state_after": "case a\nX : UniformSpaceCat\nY : CpltSepUniformSpace\nf : (CpltSepUniformSpace.of (Completion \u2191X)).toUniformSpace \u27f6 Y.toUniformSpace\n\u22a2 \u2191(extensionHom (X.completionHom \u226b f)) = \u2191f"
      },
      {
        "tactic": "funext x",
        "annotated_tactic": [
          "funext x",
          []
        ],
        "state_before": "case a\nX : UniformSpaceCat\nY : CpltSepUniformSpace\nf : (CpltSepUniformSpace.of (Completion \u2191X)).toUniformSpace \u27f6 Y.toUniformSpace\n\u22a2 \u2191(extensionHom (X.completionHom \u226b f)) = \u2191f",
        "state_after": "case a.h\nX : UniformSpaceCat\nY : CpltSepUniformSpace\nf : (CpltSepUniformSpace.of (Completion \u2191X)).toUniformSpace \u27f6 Y.toUniformSpace\nx : \u2191(completionFunctor.obj X).toUniformSpace\n\u22a2 \u2191(extensionHom (X.completionHom \u226b f)) x = \u2191f x"
      },
      {
        "tactic": "exact congr_fun (Completion.extension_comp_coe f.property) x",
        "annotated_tactic": [
          "exact <a>congr_fun</a> (<a>Completion.extension_comp_coe</a> f.property) x",
          [
            {
              "full_name": "congr_fun",
              "def_path": ".lake/packages/batteries/Batteries/Logic.lean",
              "def_pos": [
                78,
                7
              ],
              "def_end_pos": [
                78,
                16
              ]
            },
            {
              "full_name": "UniformSpace.Completion.extension_comp_coe",
              "def_path": "Mathlib/Topology/UniformSpace/Completion.lean",
              "def_pos": [
                524,
                9
              ],
              "def_end_pos": [
                524,
                27
              ]
            }
          ]
        ],
        "state_before": "case a.h\nX : UniformSpaceCat\nY : CpltSepUniformSpace\nf : (CpltSepUniformSpace.of (Completion \u2191X)).toUniformSpace \u27f6 Y.toUniformSpace\nx : \u2191(completionFunctor.obj X).toUniformSpace\n\u22a2 \u2191(extensionHom (X.completionHom \u226b f)) x = \u2191f x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.2483615080127493,
    "entry_failed": false
  },
  "7646": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Group/Submonoid/Membership.lean",
    "full_name": "Submonoid.list_prod_mem",
    "start": [
      131,
      1
    ],
    "end": [
      134,
      24
    ],
    "traced_tactics": [
      {
        "tactic": "lift l to List s using hl",
        "annotated_tactic": [
          "lift l to <a>List</a> s using hl",
          [
            {
              "full_name": "List",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                2284,
                11
              ],
              "def_end_pos": [
                2284,
                15
              ]
            }
          ]
        ],
        "state_before": "M : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : SetLike B M\ninst\u271d : SubmonoidClass B M\nS : B\ns : Submonoid M\nl : List M\nhl : \u2200 x \u2208 l, x \u2208 s\n\u22a2 l.prod \u2208 s",
        "state_after": "case intro\nM : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : SetLike B M\ninst\u271d : SubmonoidClass B M\nS : B\ns : Submonoid M\nl : List \u21a5s\n\u22a2 (List.map Subtype.val l).prod \u2208 s"
      },
      {
        "tactic": "rw [\u2190 coe_list_prod]",
        "annotated_tactic": [
          "rw [\u2190 <a>coe_list_prod</a>]",
          [
            {
              "full_name": "Submonoid.coe_list_prod",
              "def_path": "Mathlib/Algebra/Group/Submonoid/Membership.lean",
              "def_pos": [
                110,
                9
              ],
              "def_end_pos": [
                110,
                22
              ]
            }
          ]
        ],
        "state_before": "case intro\nM : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : SetLike B M\ninst\u271d : SubmonoidClass B M\nS : B\ns : Submonoid M\nl : List \u21a5s\n\u22a2 (List.map Subtype.val l).prod \u2208 s",
        "state_after": "case intro\nM : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : SetLike B M\ninst\u271d : SubmonoidClass B M\nS : B\ns : Submonoid M\nl : List \u21a5s\n\u22a2 \u2191l.prod \u2208 s"
      },
      {
        "tactic": "exact l.prod.coe_prop",
        "annotated_tactic": [
          "exact l.prod.coe_prop",
          []
        ],
        "state_before": "case intro\nM : Type u_1\nA : Type u_2\nB : Type u_3\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : SetLike B M\ninst\u271d : SubmonoidClass B M\nS : B\ns : Submonoid M\nl : List \u21a5s\n\u22a2 \u2191l.prod \u2208 s",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.686122008948587,
    "entry_failed": false
  },
  "7663": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Finset/Sym.lean",
    "full_name": "Finset.injective_sym2",
    "start": [
      77,
      1
    ],
    "end": [
      80,
      34
    ],
    "traced_tactics": [
      {
        "tactic": "intro s t h",
        "annotated_tactic": [
          "intro s t h",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ns t : Finset \u03b1\na b : \u03b1\n\u22a2 Function.Injective Finset.sym2",
        "state_after": "\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\na b : \u03b1\ns t : Finset \u03b1\nh : s.sym2 = t.sym2\n\u22a2 s = t"
      },
      {
        "tactic": "ext x",
        "annotated_tactic": [
          "ext x",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\na b : \u03b1\ns t : Finset \u03b1\nh : s.sym2 = t.sym2\n\u22a2 s = t",
        "state_after": "case a\n\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\na b : \u03b1\ns t : Finset \u03b1\nh : s.sym2 = t.sym2\nx : \u03b1\n\u22a2 x \u2208 s \u2194 x \u2208 t"
      },
      {
        "tactic": "simpa using congr(s(x, x) \u2208 $h)",
        "annotated_tactic": [
          "simpa using congr(s(x, x) \u2208 $h)",
          []
        ],
        "state_before": "case a\n\u03b1 : Type u_1\ns\u271d t\u271d : Finset \u03b1\na b : \u03b1\ns t : Finset \u03b1\nh : s.sym2 = t.sym2\nx : \u03b1\n\u22a2 x \u2208 s \u2194 x \u2208 t",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.3437076250556856,
    "entry_failed": false
  },
  "7691": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Finite/Card.lean",
    "full_name": "Finite.card_eq",
    "start": [
      72,
      1
    ],
    "end": [
      75,
      56
    ],
    "traced_tactics": [
      {
        "tactic": "haveI := Fintype.ofFinite \u03b1",
        "annotated_tactic": [
          "haveI := <a>Fintype.ofFinite</a> \u03b1",
          [
            {
              "full_name": "Fintype.ofFinite",
              "def_path": "Mathlib/Data/Fintype/Card.lean",
              "def_pos": [
                449,
                19
              ],
              "def_end_pos": [
                449,
                35
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\n\u22a2 Nat.card \u03b1 = Nat.card \u03b2 \u2194 Nonempty (\u03b1 \u2243 \u03b2)",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis : Fintype \u03b1\n\u22a2 Nat.card \u03b1 = Nat.card \u03b2 \u2194 Nonempty (\u03b1 \u2243 \u03b2)"
      },
      {
        "tactic": "haveI := Fintype.ofFinite \u03b2",
        "annotated_tactic": [
          "haveI := <a>Fintype.ofFinite</a> \u03b2",
          [
            {
              "full_name": "Fintype.ofFinite",
              "def_path": "Mathlib/Data/Fintype/Card.lean",
              "def_pos": [
                449,
                19
              ],
              "def_end_pos": [
                449,
                35
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis : Fintype \u03b1\n\u22a2 Nat.card \u03b1 = Nat.card \u03b2 \u2194 Nonempty (\u03b1 \u2243 \u03b2)",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis\u271d : Fintype \u03b1\nthis : Fintype \u03b2\n\u22a2 Nat.card \u03b1 = Nat.card \u03b2 \u2194 Nonempty (\u03b1 \u2243 \u03b2)"
      },
      {
        "tactic": "simp only [Nat.card_eq_fintype_card, Fintype.card_eq]",
        "annotated_tactic": [
          "simp only [<a>Nat.card_eq_fintype_card</a>, <a>Fintype.card_eq</a>]",
          [
            {
              "full_name": "Nat.card_eq_fintype_card",
              "def_path": "Mathlib/SetTheory/Cardinal/Finite.lean",
              "def_pos": [
                40,
                9
              ],
              "def_end_pos": [
                40,
                29
              ]
            },
            {
              "full_name": "Fintype.card_eq",
              "def_path": "Mathlib/Data/Fintype/Card.lean",
              "def_pos": [
                207,
                9
              ],
              "def_end_pos": [
                207,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis\u271d : Fintype \u03b1\nthis : Fintype \u03b2\n\u22a2 Nat.card \u03b1 = Nat.card \u03b2 \u2194 Nonempty (\u03b1 \u2243 \u03b2)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4362372329924256,
    "entry_failed": false
  },
  "7694": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/RamificationInertia.lean",
    "full_name": "Ideal.inertiaDeg_of_subsingleton",
    "start": [
      198,
      1
    ],
    "end": [
      202,
      61
    ],
    "traced_tactics": [
      {
        "tactic": "have := Ideal.Quotient.subsingleton_iff.mp hQ",
        "annotated_tactic": [
          "have := Ideal.Quotient.subsingleton_iff.mp hQ",
          []
        ],
        "state_before": "R : Type u\ninst\u271d\u00b9 : CommRing R\nS : Type v\ninst\u271d : CommRing S\nf : R \u2192+* S\np : Ideal R\nP : Ideal S\nhp : p.IsMaximal\nhQ : Subsingleton (S \u29f8 P)\n\u22a2 inertiaDeg f p P = 0",
        "state_after": "R : Type u\ninst\u271d\u00b9 : CommRing R\nS : Type v\ninst\u271d : CommRing S\nf : R \u2192+* S\np : Ideal R\nP : Ideal S\nhp : p.IsMaximal\nhQ : Subsingleton (S \u29f8 P)\nthis : P = \u22a4\n\u22a2 inertiaDeg f p P = 0"
      },
      {
        "tactic": "subst this",
        "annotated_tactic": [
          "subst this",
          []
        ],
        "state_before": "R : Type u\ninst\u271d\u00b9 : CommRing R\nS : Type v\ninst\u271d : CommRing S\nf : R \u2192+* S\np : Ideal R\nP : Ideal S\nhp : p.IsMaximal\nhQ : Subsingleton (S \u29f8 P)\nthis : P = \u22a4\n\u22a2 inertiaDeg f p P = 0",
        "state_after": "R : Type u\ninst\u271d\u00b9 : CommRing R\nS : Type v\ninst\u271d : CommRing S\nf : R \u2192+* S\np : Ideal R\nhp : p.IsMaximal\nhQ : Subsingleton (S \u29f8 \u22a4)\n\u22a2 inertiaDeg f p \u22a4 = 0"
      },
      {
        "tactic": "exact dif_neg fun h => hp.ne_top <| h.symm.trans comap_top",
        "annotated_tactic": [
          "exact <a>dif_neg</a> fun h => hp.ne_top <| h.symm.trans <a>comap_top</a>",
          [
            {
              "full_name": "dif_neg",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                954,
                9
              ],
              "def_end_pos": [
                954,
                16
              ]
            },
            {
              "full_name": "Ideal.comap_top",
              "def_path": "Mathlib/RingTheory/Ideal/Maps.lean",
              "def_pos": [
                175,
                9
              ],
              "def_end_pos": [
                175,
                18
              ]
            }
          ]
        ],
        "state_before": "R : Type u\ninst\u271d\u00b9 : CommRing R\nS : Type v\ninst\u271d : CommRing S\nf : R \u2192+* S\np : Ideal R\nhp : p.IsMaximal\nhQ : Subsingleton (S \u29f8 \u22a4)\n\u22a2 inertiaDeg f p \u22a4 = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.136499413987622,
    "entry_failed": false
  },
  "7696": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Ring/Divisibility/Basic.lean",
    "full_name": "dvd_mul_sub_mul",
    "start": [
      195,
      1
    ],
    "end": [
      199,
      61
    ],
    "traced_tactics": [
      {
        "tactic": "convert dvd_add (hxy.mul_left a) (hab.mul_right y) using 1",
        "annotated_tactic": [
          "convert <a>dvd_add</a> (hxy.mul_left a) (hab.mul_right y) using 1",
          [
            {
              "full_name": "dvd_add",
              "def_path": "Mathlib/Algebra/Ring/Divisibility/Basic.lean",
              "def_pos": [
                46,
                9
              ],
              "def_end_pos": [
                46,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : NonUnitalCommRing \u03b1\na\u271d b\u271d c k a b x y : \u03b1\nhab : k \u2223 a - b\nhxy : k \u2223 x - y\n\u22a2 k \u2223 a * x - b * y",
        "state_after": "case h.e'_4\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : NonUnitalCommRing \u03b1\na\u271d b\u271d c k a b x y : \u03b1\nhab : k \u2223 a - b\nhxy : k \u2223 x - y\n\u22a2 a * x - b * y = a * (x - y) + (a - b) * y"
      },
      {
        "tactic": "rw [mul_sub_left_distrib, mul_sub_right_distrib]",
        "annotated_tactic": [
          "rw [<a>mul_sub_left_distrib</a>, <a>mul_sub_right_distrib</a>]",
          [
            {
              "full_name": "mul_sub_left_distrib",
              "def_path": "Mathlib/Algebra/Ring/Defs.lean",
              "def_pos": [
                390,
                9
              ],
              "def_end_pos": [
                390,
                29
              ]
            },
            {
              "full_name": "mul_sub_right_distrib",
              "def_path": "Mathlib/Algebra/Ring/Defs.lean",
              "def_pos": [
                397,
                9
              ],
              "def_end_pos": [
                397,
                30
              ]
            }
          ]
        ],
        "state_before": "case h.e'_4\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : NonUnitalCommRing \u03b1\na\u271d b\u271d c k a b x y : \u03b1\nhab : k \u2223 a - b\nhxy : k \u2223 x - y\n\u22a2 a * x - b * y = a * (x - y) + (a - b) * y",
        "state_after": "case h.e'_4\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : NonUnitalCommRing \u03b1\na\u271d b\u271d c k a b x y : \u03b1\nhab : k \u2223 a - b\nhxy : k \u2223 x - y\n\u22a2 a * x - b * y = a * x - a * y + (a * y - b * y)"
      },
      {
        "tactic": "simp only [sub_eq_add_neg, add_assoc, neg_add_cancel_left]",
        "annotated_tactic": [
          "simp only [<a>sub_eq_add_neg</a>, <a>add_assoc</a>, <a>neg_add_cancel_left</a>]",
          [
            {
              "full_name": "sub_eq_add_neg",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                1057,
                3
              ],
              "def_end_pos": [
                1057,
                14
              ]
            },
            {
              "full_name": "add_assoc",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                288,
                3
              ],
              "def_end_pos": [
                288,
                14
              ]
            },
            {
              "full_name": "neg_add_cancel_left",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                1249,
                3
              ],
              "def_end_pos": [
                1249,
                14
              ]
            }
          ]
        ],
        "state_before": "case h.e'_4\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : NonUnitalCommRing \u03b1\na\u271d b\u271d c k a b x y : \u03b1\nhab : k \u2223 a - b\nhxy : k \u2223 x - y\n\u22a2 a * x - b * y = a * x - a * y + (a * y - b * y)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.0962185020325705,
    "entry_failed": false
  },
  "7719": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/GroupAction/Blocks.lean",
    "full_name": "MulAction.orbit.pairwiseDisjoint",
    "start": [
      44,
      1
    ],
    "end": [
      48,
      51
    ],
    "traced_tactics": [
      {
        "tactic": "rintro s \u27e8x, rfl\u27e9 t \u27e8y, rfl\u27e9 h",
        "annotated_tactic": [
          "rintro s \u27e8x, rfl\u27e9 t \u27e8y, rfl\u27e9 h",
          []
        ],
        "state_before": "G : Type u_1\ninst\u271d\u00b9 : Group G\nX : Type u_2\ninst\u271d : MulAction G X\n\u22a2 (Set.range fun x => orbit G x).PairwiseDisjoint id",
        "state_after": "case intro.intro\nG : Type u_1\ninst\u271d\u00b9 : Group G\nX : Type u_2\ninst\u271d : MulAction G X\nx y : X\nh : (fun x => orbit G x) x \u2260 (fun x => orbit G x) y\n\u22a2 (Disjoint on id) ((fun x => orbit G x) x) ((fun x => orbit G x) y)"
      },
      {
        "tactic": "contrapose! h",
        "annotated_tactic": [
          "contrapose! h",
          []
        ],
        "state_before": "case intro.intro\nG : Type u_1\ninst\u271d\u00b9 : Group G\nX : Type u_2\ninst\u271d : MulAction G X\nx y : X\nh : (fun x => orbit G x) x \u2260 (fun x => orbit G x) y\n\u22a2 (Disjoint on id) ((fun x => orbit G x) x) ((fun x => orbit G x) y)",
        "state_after": "case intro.intro\nG : Type u_1\ninst\u271d\u00b9 : Group G\nX : Type u_2\ninst\u271d : MulAction G X\nx y : X\nh : \u00ac(Disjoint on id) (orbit G x) (orbit G y)\n\u22a2 orbit G x = orbit G y"
      },
      {
        "tactic": "exact (orbit.eq_or_disjoint x y).resolve_right h",
        "annotated_tactic": [
          "exact (<a>orbit.eq_or_disjoint</a> x y).<a>resolve_right</a> h",
          [
            {
              "full_name": "MulAction.orbit.eq_or_disjoint",
              "def_path": "Mathlib/GroupTheory/GroupAction/Blocks.lean",
              "def_pos": [
                38,
                9
              ],
              "def_end_pos": [
                38,
                29
              ]
            },
            {
              "full_name": "Or.resolve_right",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                556,
                9
              ],
              "def_end_pos": [
                556,
                25
              ]
            }
          ]
        ],
        "state_before": "case intro.intro\nG : Type u_1\ninst\u271d\u00b9 : Group G\nX : Type u_2\ninst\u271d : MulAction G X\nx y : X\nh : \u00ac(Disjoint on id) (orbit G x) (orbit G y)\n\u22a2 orbit G x = orbit G y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.393003607983701,
    "entry_failed": false
  },
  "7728": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/MeasurableSpace/CountablyGenerated.lean",
    "full_name": "MeasurableSpace.generateFrom_iUnion_memPartition_le",
    "start": [
      396,
      1
    ],
    "end": [
      401,
      13
    ],
    "traced_tactics": [
      {
        "tactic": "refine (generateFrom_iUnion_memPartition t).trans_le (generateFrom_le ?_)",
        "annotated_tactic": [
          "refine (<a>generateFrom_iUnion_memPartition</a> t).<a>trans_le</a> (<a>generateFrom_le</a> ?_)",
          [
            {
              "full_name": "MeasurableSpace.generateFrom_iUnion_memPartition",
              "def_path": "Mathlib/MeasureTheory/MeasurableSpace/CountablyGenerated.lean",
              "def_pos": [
                371,
                7
              ],
              "def_end_pos": [
                371,
                39
              ]
            },
            {
              "full_name": "Eq.trans_le",
              "def_path": "Mathlib/Order/Basic.lean",
              "def_pos": [
                198,
                7
              ],
              "def_end_pos": [
                198,
                18
              ]
            },
            {
              "full_name": "MeasurableSpace.generateFrom_le",
              "def_path": "Mathlib/MeasureTheory/MeasurableSpace/Defs.lean",
              "def_pos": [
                390,
                9
              ],
              "def_end_pos": [
                390,
                24
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nt : \u2115 \u2192 Set \u03b1\nht : \u2200 (n : \u2115), MeasurableSet (t n)\n\u22a2 generateFrom (\u22c3 n, memPartition t n) \u2264 m",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nt : \u2115 \u2192 Set \u03b1\nht : \u2200 (n : \u2115), MeasurableSet (t n)\n\u22a2 \u2200 t_1 \u2208 range t, MeasurableSet t_1"
      },
      {
        "tactic": "rintro s \u27e8i, rfl\u27e9",
        "annotated_tactic": [
          "rintro s \u27e8i, rfl\u27e9",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nt : \u2115 \u2192 Set \u03b1\nht : \u2200 (n : \u2115), MeasurableSet (t n)\n\u22a2 \u2200 t_1 \u2208 range t, MeasurableSet t_1",
        "state_after": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nt : \u2115 \u2192 Set \u03b1\nht : \u2200 (n : \u2115), MeasurableSet (t n)\ni : \u2115\n\u22a2 MeasurableSet (t i)"
      },
      {
        "tactic": "exact ht i",
        "annotated_tactic": [
          "exact ht i",
          []
        ],
        "state_before": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\nt : \u2115 \u2192 Set \u03b1\nht : \u2200 (n : \u2115), MeasurableSet (t n)\ni : \u2115\n\u22a2 MeasurableSet (t i)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.184322632034309,
    "entry_failed": false
  },
  "7731": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Stream/Init.lean",
    "full_name": "Stream'.const_eq",
    "start": [
      240,
      1
    ],
    "end": [
      242,
      18
    ],
    "traced_tactics": [
      {
        "tactic": "apply Stream'.ext",
        "annotated_tactic": [
          "apply <a>Stream'.ext</a>",
          [
            {
              "full_name": "Stream'.ext",
              "def_path": "Mathlib/Data/Stream/Init.lean",
              "def_pos": [
                36,
                19
              ],
              "def_end_pos": [
                36,
                22
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\na : \u03b1\n\u22a2 const a = a :: const a",
        "state_after": "case a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\na : \u03b1\n\u22a2 \u2200 (n : \u2115), (const a).get n = (a :: const a).get n"
      },
      {
        "tactic": "intro n",
        "annotated_tactic": [
          "intro n",
          []
        ],
        "state_before": "case a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\na : \u03b1\n\u22a2 \u2200 (n : \u2115), (const a).get n = (a :: const a).get n",
        "state_after": "case a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\na : \u03b1\nn : \u2115\n\u22a2 (const a).get n = (a :: const a).get n"
      },
      {
        "tactic": "cases n <;> rfl",
        "annotated_tactic": [
          "cases n <;> rfl",
          []
        ],
        "state_before": "case a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\na : \u03b1\nn : \u2115\n\u22a2 (const a).get n = (a :: const a).get n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.0925129540264606,
    "entry_failed": false
  },
  "7911": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Bornology/Basic.lean",
    "full_name": "Bornology.nonempty_of_not_isBounded",
    "start": [
      166,
      1
    ],
    "end": [
      169,
      26
    ],
    "traced_tactics": [
      {
        "tactic": "rw [nonempty_iff_ne_empty]",
        "annotated_tactic": [
          "rw [<a>nonempty_iff_ne_empty</a>]",
          [
            {
              "full_name": "Set.nonempty_iff_ne_empty",
              "def_path": "Mathlib/Data/Set/Basic.lean",
              "def_pos": [
                580,
                9
              ],
              "def_end_pos": [
                580,
                30
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nx\u271d : Bornology \u03b1\ns t : Set \u03b1\nx : \u03b1\nh : \u00acIsBounded s\n\u22a2 s.Nonempty",
        "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nx\u271d : Bornology \u03b1\ns t : Set \u03b1\nx : \u03b1\nh : \u00acIsBounded s\n\u22a2 s \u2260 \u2205"
      },
      {
        "tactic": "rintro rfl",
        "annotated_tactic": [
          "rintro rfl",
          []
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nx\u271d : Bornology \u03b1\ns t : Set \u03b1\nx : \u03b1\nh : \u00acIsBounded s\n\u22a2 s \u2260 \u2205",
        "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nx\u271d : Bornology \u03b1\nt : Set \u03b1\nx : \u03b1\nh : \u00acIsBounded \u2205\n\u22a2 False"
      },
      {
        "tactic": "exact h isBounded_empty",
        "annotated_tactic": [
          "exact h <a>isBounded_empty</a>",
          [
            {
              "full_name": "Bornology.isBounded_empty",
              "def_path": "Mathlib/Topology/Bornology/Basic.lean",
              "def_pos": [
                161,
                9
              ],
              "def_end_pos": [
                161,
                24
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nx\u271d : Bornology \u03b1\nt : Set \u03b1\nx : \u03b1\nh : \u00acIsBounded \u2205\n\u22a2 False",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.586817875970155,
    "entry_failed": false
  },
  "7990": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Setoid/Basic.lean",
    "full_name": "Setoid.sSup_def",
    "start": [
      257,
      1
    ],
    "end": [
      260,
      52
    ],
    "traced_tactics": [
      {
        "tactic": "rw [sSup_eq_eqvGen, sSup_image]",
        "annotated_tactic": [
          "rw [<a>sSup_eq_eqvGen</a>, <a>sSup_image</a>]",
          [
            {
              "full_name": "Setoid.sSup_eq_eqvGen",
              "def_path": "Mathlib/Data/Setoid/Basic.lean",
              "def_pos": [
                246,
                9
              ],
              "def_end_pos": [
                246,
                23
              ]
            },
            {
              "full_name": "sSup_image",
              "def_path": "Mathlib/Order/CompleteLattice.lean",
              "def_pos": [
                1349,
                9
              ],
              "def_end_pos": [
                1349,
                19
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set (Setoid \u03b1)\n\u22a2 sSup s = EqvGen.Setoid (sSup (Rel '' s))",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set (Setoid \u03b1)\n\u22a2 (EqvGen.Setoid fun x y => \u2203 r \u2208 s, r.Rel x y) = EqvGen.Setoid (\u2a06 a \u2208 s, a.Rel)"
      },
      {
        "tactic": "congr with (x y)",
        "annotated_tactic": [
          "congr with (x y)",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set (Setoid \u03b1)\n\u22a2 (EqvGen.Setoid fun x y => \u2203 r \u2208 s, r.Rel x y) = EqvGen.Setoid (\u2a06 a \u2208 s, a.Rel)",
        "state_after": "case e_r.h.h.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set (Setoid \u03b1)\nx y : \u03b1\n\u22a2 (\u2203 r \u2208 s, r.Rel x y) \u2194 (\u2a06 a \u2208 s, a.Rel) x y"
      },
      {
        "tactic": "simp only [iSup_apply, iSup_Prop_eq, exists_prop]",
        "annotated_tactic": [
          "simp only [<a>iSup_apply</a>, <a>iSup_Prop_eq</a>, <a>exists_prop</a>]",
          [
            {
              "full_name": "iSup_apply",
              "def_path": "Mathlib/Order/CompleteLattice.lean",
              "def_pos": [
                1754,
                9
              ],
              "def_end_pos": [
                1754,
                19
              ]
            },
            {
              "full_name": "iSup_Prop_eq",
              "def_path": "Mathlib/Order/CompleteLattice.lean",
              "def_pos": [
                1716,
                9
              ],
              "def_end_pos": [
                1716,
                21
              ]
            },
            {
              "full_name": "exists_prop",
              "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean",
              "def_pos": [
                307,
                17
              ],
              "def_end_pos": [
                307,
                28
              ]
            }
          ]
        ],
        "state_before": "case e_r.h.h.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set (Setoid \u03b1)\nx y : \u03b1\n\u22a2 (\u2203 r \u2208 s, r.Rel x y) \u2194 (\u2a06 a \u2208 s, a.Rel) x y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6935518239624798,
    "entry_failed": false
  },
  "8050": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Hyperoperation.lean",
    "full_name": "hyperoperation_two_two_eq_four",
    "start": [
      98,
      1
    ],
    "end": [
      101,
      70
    ],
    "traced_tactics": [
      {
        "tactic": "induction' n with nn nih",
        "annotated_tactic": [
          "induction' n with nn nih",
          []
        ],
        "state_before": "n : \u2115\n\u22a2 hyperoperation (n + 1) 2 2 = 4",
        "state_after": "case zero\n\n\u22a2 hyperoperation (0 + 1) 2 2 = 4\n\ncase succ\nnn : \u2115\nnih : hyperoperation (nn + 1) 2 2 = 4\n\u22a2 hyperoperation (nn + 1 + 1) 2 2 = 4"
      },
      {
        "tactic": "rw [hyperoperation_one]",
        "annotated_tactic": [
          "rw [<a>hyperoperation_one</a>]",
          [
            {
              "full_name": "hyperoperation_one",
              "def_path": "Mathlib/Data/Nat/Hyperoperation.lean",
              "def_pos": [
                60,
                9
              ],
              "def_end_pos": [
                60,
                27
              ]
            }
          ]
        ],
        "state_before": "case zero\n\n\u22a2 hyperoperation (0 + 1) 2 2 = 4",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [hyperoperation_recursion, hyperoperation_ge_two_eq_self, nih]",
        "annotated_tactic": [
          "rw [<a>hyperoperation_recursion</a>, <a>hyperoperation_ge_two_eq_self</a>, nih]",
          [
            {
              "full_name": "hyperoperation_recursion",
              "def_path": "Mathlib/Data/Nat/Hyperoperation.lean",
              "def_pos": [
                53,
                9
              ],
              "def_end_pos": [
                53,
                33
              ]
            },
            {
              "full_name": "hyperoperation_ge_two_eq_self",
              "def_path": "Mathlib/Data/Nat/Hyperoperation.lean",
              "def_pos": [
                91,
                9
              ],
              "def_end_pos": [
                91,
                38
              ]
            }
          ]
        ],
        "state_before": "case succ\nnn : \u2115\nnih : hyperoperation (nn + 1) 2 2 = 4\n\u22a2 hyperoperation (nn + 1 + 1) 2 2 = 4",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5119250040734187,
    "entry_failed": false
  },
  "8149": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/FLT/Three.lean",
    "full_name": "cube_of_castHom_ne_zero",
    "start": [
      25,
      1
    ],
    "end": [
      27,
      19
    ],
    "traced_tactics": [
      {
        "tactic": "norm_num",
        "annotated_tactic": [
          "norm_num",
          []
        ],
        "state_before": "n : ZMod 9\n\u22a2 3 \u2223 9",
        "state_after": "no goals"
      },
      {
        "tactic": "revert n",
        "annotated_tactic": [
          "revert n",
          []
        ],
        "state_before": "n : ZMod 9\n\u22a2 (castHom \u22ef (ZMod 3)) n \u2260 0 \u2192 n ^ 3 = 1 \u2228 n ^ 3 = 8",
        "state_after": "\u22a2 \u2200 {n : ZMod 9}, (castHom \u22ef (ZMod 3)) n \u2260 0 \u2192 n ^ 3 = 1 \u2228 n ^ 3 = 8"
      },
      {
        "tactic": "decide",
        "annotated_tactic": [
          "decide",
          []
        ],
        "state_before": "\u22a2 \u2200 {n : ZMod 9}, (castHom \u22ef (ZMod 3)) n \u2260 0 \u2192 n ^ 3 = 1 \u2228 n ^ 3 = 8",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.181219324003905,
    "entry_failed": false
  },
  "8173": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/OuterMeasure/Induced.lean",
    "full_name": "MeasureTheory.OuterMeasure.trim_anti_measurableSpace",
    "start": [
      347,
      1
    ],
    "end": [
      351,
      26
    ],
    "traced_tactics": [
      {
        "tactic": "simp only [le_trim_iff]",
        "annotated_tactic": [
          "simp only [<a>le_trim_iff</a>]",
          [
            {
              "full_name": "MeasureTheory.OuterMeasure.le_trim_iff",
              "def_path": "Mathlib/MeasureTheory/OuterMeasure/Induced.lean",
              "def_pos": [
                322,
                9
              ],
              "def_end_pos": [
                322,
                20
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nm\u271d m : OuterMeasure \u03b1\nm0 m1 : MeasurableSpace \u03b1\nh : m0 \u2264 m1\n\u22a2 m.trim \u2264 m.trim",
        "state_after": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nm\u271d m : OuterMeasure \u03b1\nm0 m1 : MeasurableSpace \u03b1\nh : m0 \u2264 m1\n\u22a2 \u2200 (s : Set \u03b1), MeasurableSet s \u2192 m.trim s \u2264 m s"
      },
      {
        "tactic": "intro s hs",
        "annotated_tactic": [
          "intro s hs",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nm\u271d m : OuterMeasure \u03b1\nm0 m1 : MeasurableSpace \u03b1\nh : m0 \u2264 m1\n\u22a2 \u2200 (s : Set \u03b1), MeasurableSet s \u2192 m.trim s \u2264 m s",
        "state_after": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nm\u271d m : OuterMeasure \u03b1\nm0 m1 : MeasurableSpace \u03b1\nh : m0 \u2264 m1\ns : Set \u03b1\nhs : MeasurableSet s\n\u22a2 m.trim s \u2264 m s"
      },
      {
        "tactic": "rw [trim_eq _ (h s hs)]",
        "annotated_tactic": [
          "rw [<a>trim_eq</a> _ (h s hs)]",
          [
            {
              "full_name": "MeasureTheory.OuterMeasure.trim_eq",
              "def_path": "Mathlib/MeasureTheory/OuterMeasure/Induced.lean",
              "def_pos": [
                331,
                9
              ],
              "def_end_pos": [
                331,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nm\u271d m : OuterMeasure \u03b1\nm0 m1 : MeasurableSpace \u03b1\nh : m0 \u2264 m1\ns : Set \u03b1\nhs : MeasurableSet s\n\u22a2 m.trim s \u2264 m s",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.6983541609952226,
    "entry_failed": false
  },
  "8207": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Coxeter/Inversion.lean",
    "full_name": "CoxeterSystem.IsReflection.conj",
    "start": [
      102,
      1
    ],
    "end": [
      105,
      8
    ],
    "traced_tactics": [
      {
        "tactic": "obtain \u27e8u, i, rfl\u27e9 := ht",
        "annotated_tactic": [
          "obtain \u27e8u, i, rfl\u27e9 := ht",
          []
        ],
        "state_before": "B : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nt : W\nht : cs.IsReflection t\nw : W\n\u22a2 cs.IsReflection (w * t * w\u207b\u00b9)",
        "state_after": "case intro.intro\nB : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw u : W\ni : B\n\u22a2 cs.IsReflection (w * (u * cs.simple i * u\u207b\u00b9) * w\u207b\u00b9)"
      },
      {
        "tactic": "use w * u, i",
        "annotated_tactic": [
          "use w * u, i",
          []
        ],
        "state_before": "case intro.intro\nB : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw u : W\ni : B\n\u22a2 cs.IsReflection (w * (u * cs.simple i * u\u207b\u00b9) * w\u207b\u00b9)",
        "state_after": "case h\nB : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw u : W\ni : B\n\u22a2 w * (u * cs.simple i * u\u207b\u00b9) * w\u207b\u00b9 = w * u * cs.simple i * (w * u)\u207b\u00b9"
      },
      {
        "tactic": "group",
        "annotated_tactic": [
          "group",
          []
        ],
        "state_before": "case h\nB : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw u : W\ni : B\n\u22a2 w * (u * cs.simple i * u\u207b\u00b9) * w\u207b\u00b9 = w * u * cs.simple i * (w * u)\u207b\u00b9",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.0674826989416033,
    "entry_failed": false
  },
  "8220": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/Asymptotics/AsymptoticEquivalent.lean",
    "full_name": "Asymptotics.IsEquivalent.neg",
    "start": [
      187,
      1
    ],
    "end": [
      190,
      24
    ],
    "traced_tactics": [
      {
        "tactic": "rw [IsEquivalent]",
        "annotated_tactic": [
          "rw [<a>IsEquivalent</a>]",
          [
            {
              "full_name": "Asymptotics.IsEquivalent",
              "def_path": "Mathlib/Analysis/Asymptotics/AsymptoticEquivalent.lean",
              "def_pos": [
                73,
                5
              ],
              "def_end_pos": [
                73,
                17
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : NormedAddCommGroup \u03b2\nu v w : \u03b1 \u2192 \u03b2\nl : Filter \u03b1\nhuv : u ~[l] v\n\u22a2 (fun x => -u x) ~[l] fun x => -v x",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : NormedAddCommGroup \u03b2\nu v w : \u03b1 \u2192 \u03b2\nl : Filter \u03b1\nhuv : u ~[l] v\n\u22a2 ((fun x => -u x) - fun x => -v x) =o[l] fun x => -v x"
      },
      {
        "tactic": "convert huv.isLittleO.neg_left.neg_right",
        "annotated_tactic": [
          "convert huv.isLittleO.neg_left.neg_right",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : NormedAddCommGroup \u03b2\nu v w : \u03b1 \u2192 \u03b2\nl : Filter \u03b1\nhuv : u ~[l] v\n\u22a2 ((fun x => -u x) - fun x => -v x) =o[l] fun x => -v x",
        "state_after": "case h.e'_7.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : NormedAddCommGroup \u03b2\nu v w : \u03b1 \u2192 \u03b2\nl : Filter \u03b1\nhuv : u ~[l] v\nx\u271d : \u03b1\n\u22a2 ((fun x => -u x) - fun x => -v x) x\u271d = -(u - v) x\u271d"
      },
      {
        "tactic": "simp [neg_add_eq_sub]",
        "annotated_tactic": [
          "simp [<a>neg_add_eq_sub</a>]",
          [
            {
              "full_name": "neg_add_eq_sub",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                740,
                3
              ],
              "def_end_pos": [
                740,
                14
              ]
            }
          ]
        ],
        "state_before": "case h.e'_7.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : NormedAddCommGroup \u03b2\nu v w : \u03b1 \u2192 \u03b2\nl : Filter \u03b1\nhuv : u ~[l] v\nx\u271d : \u03b1\n\u22a2 ((fun x => -u x) - fun x => -v x) x\u271d = -(u - v) x\u271d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.6639159329934046,
    "entry_failed": false
  },
  "8293": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Ordinal/Principal.lean",
    "full_name": "Ordinal.principal_add_of_le_one",
    "start": [
      125,
      1
    ],
    "end": [
      128,
      28
    ],
    "traced_tactics": [
      {
        "tactic": "rcases le_one_iff.1 ho with (rfl | rfl)",
        "annotated_tactic": [
          "rcases <a>le_one_iff</a>.1 ho with (rfl | rfl)",
          [
            {
              "full_name": "Ordinal.le_one_iff",
              "def_path": "Mathlib/SetTheory/Ordinal/Basic.lean",
              "def_pos": [
                1082,
                9
              ],
              "def_end_pos": [
                1082,
                19
              ]
            }
          ]
        ],
        "state_before": "o : Ordinal.{u_1}\nho : o \u2264 1\n\u22a2 Principal (fun x x_1 => x + x_1) o",
        "state_after": "case inl\nho : 0 \u2264 1\n\u22a2 Principal (fun x x_1 => x + x_1) 0\n\ncase inr\nho : 1 \u2264 1\n\u22a2 Principal (fun x x_1 => x + x_1) 1"
      },
      {
        "tactic": "exact principal_zero",
        "annotated_tactic": [
          "exact <a>principal_zero</a>",
          [
            {
              "full_name": "Ordinal.principal_zero",
              "def_path": "Mathlib/SetTheory/Ordinal/Principal.lean",
              "def_pos": [
                57,
                9
              ],
              "def_end_pos": [
                57,
                23
              ]
            }
          ]
        ],
        "state_before": "case inl\nho : 0 \u2264 1\n\u22a2 Principal (fun x x_1 => x + x_1) 0",
        "state_after": "no goals"
      },
      {
        "tactic": "exact principal_add_one",
        "annotated_tactic": [
          "exact <a>principal_add_one</a>",
          [
            {
              "full_name": "Ordinal.principal_add_one",
              "def_path": "Mathlib/SetTheory/Ordinal/Principal.lean",
              "def_pos": [
                121,
                9
              ],
              "def_end_pos": [
                121,
                26
              ]
            }
          ]
        ],
        "state_before": "case inr\nho : 1 \u2264 1\n\u22a2 Principal (fun x x_1 => x + x_1) 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7090574530884624,
    "entry_failed": false
  },
  "8304": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Field/Power.lean",
    "full_name": "zpow_injective",
    "start": [
      97,
      1
    ],
    "end": [
      100,
      40
    ],
    "traced_tactics": [
      {
        "tactic": "rcases h\u2081.lt_or_lt with (H | H)",
        "annotated_tactic": [
          "rcases h\u2081.lt_or_lt with (H | H)",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nh\u2080 : 0 < a\nh\u2081 : a \u2260 1\n\u22a2 Injective fun x => a ^ x",
        "state_after": "case inl\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nh\u2080 : 0 < a\nh\u2081 : a \u2260 1\nH : a < 1\n\u22a2 Injective fun x => a ^ x\n\ncase inr\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nh\u2080 : 0 < a\nh\u2081 : a \u2260 1\nH : 1 < a\n\u22a2 Injective fun x => a ^ x"
      },
      {
        "tactic": "exact (zpow_strictAnti h\u2080 H).injective",
        "annotated_tactic": [
          "exact (<a>zpow_strictAnti</a> h\u2080 H).<a>injective</a>",
          [
            {
              "full_name": "zpow_strictAnti",
              "def_path": "Mathlib/Algebra/Order/Field/Power.lean",
              "def_pos": [
                70,
                9
              ],
              "def_end_pos": [
                70,
                24
              ]
            },
            {
              "full_name": "StrictAnti.injective",
              "def_path": "Mathlib/Order/Monotone/Basic.lean",
              "def_pos": [
                903,
                9
              ],
              "def_end_pos": [
                903,
                29
              ]
            }
          ]
        ],
        "state_before": "case inl\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nh\u2080 : 0 < a\nh\u2081 : a \u2260 1\nH : a < 1\n\u22a2 Injective fun x => a ^ x",
        "state_after": "no goals"
      },
      {
        "tactic": "exact (zpow_strictMono H).injective",
        "annotated_tactic": [
          "exact (<a>zpow_strictMono</a> H).<a>injective</a>",
          [
            {
              "full_name": "zpow_strictMono",
              "def_path": "Mathlib/Algebra/Order/Field/Power.lean",
              "def_pos": [
                62,
                9
              ],
              "def_end_pos": [
                62,
                24
              ]
            },
            {
              "full_name": "StrictMono.injective",
              "def_path": "Mathlib/Order/Monotone/Basic.lean",
              "def_pos": [
                899,
                9
              ],
              "def_end_pos": [
                899,
                29
              ]
            }
          ]
        ],
        "state_before": "case inr\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nh\u2080 : 0 < a\nh\u2081 : a \u2260 1\nH : 1 < a\n\u22a2 Injective fun x => a ^ x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8967994690174237,
    "entry_failed": false
  },
  "8346": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/GCD/Basic.lean",
    "full_name": "Nat.coprime_pow_left_iff",
    "start": [
      243,
      1
    ],
    "end": [
      247,
      54
    ],
    "traced_tactics": [
      {
        "tactic": "obtain \u27e8n, rfl\u27e9 := exists_eq_succ_of_ne_zero hn.ne'",
        "annotated_tactic": [
          "obtain \u27e8n, rfl\u27e9 := <a>exists_eq_succ_of_ne_zero</a> hn.ne'",
          [
            {
              "full_name": "Nat.exists_eq_succ_of_ne_zero",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean",
              "def_pos": [
                691,
                9
              ],
              "def_end_pos": [
                691,
                34
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\nhn : 0 < n\na b : \u2115\n\u22a2 (a ^ n).Coprime b \u2194 a.Coprime b",
        "state_after": "case intro\na b n : \u2115\nhn : 0 < n.succ\n\u22a2 (a ^ n.succ).Coprime b \u2194 a.Coprime b"
      },
      {
        "tactic": "rw [Nat.pow_succ, Nat.coprime_mul_iff_left]",
        "annotated_tactic": [
          "rw [<a>Nat.pow_succ</a>, <a>Nat.coprime_mul_iff_left</a>]",
          [
            {
              "full_name": "Nat.pow_succ",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean",
              "def_pos": [
                749,
                19
              ],
              "def_end_pos": [
                749,
                27
              ]
            },
            {
              "full_name": "Nat.coprime_mul_iff_left",
              "def_path": ".lake/packages/batteries/Batteries/Data/Nat/Gcd.lean",
              "def_pos": [
                123,
                9
              ],
              "def_end_pos": [
                123,
                29
              ]
            }
          ]
        ],
        "state_before": "case intro\na b n : \u2115\nhn : 0 < n.succ\n\u22a2 (a ^ n.succ).Coprime b \u2194 a.Coprime b",
        "state_after": "case intro\na b n : \u2115\nhn : 0 < n.succ\n\u22a2 (a ^ n).Coprime b \u2227 a.Coprime b \u2194 a.Coprime b"
      },
      {
        "tactic": "exact \u27e8And.right, fun hab => \u27e8hab.pow_left _, hab\u27e9\u27e9",
        "annotated_tactic": [
          "exact \u27e8<a>And.right</a>, fun hab => \u27e8hab.pow_left _, hab\u27e9\u27e9",
          [
            {
              "full_name": "And.right",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                524,
                3
              ],
              "def_end_pos": [
                524,
                8
              ]
            }
          ]
        ],
        "state_before": "case intro\na b n : \u2115\nhn : 0 < n.succ\n\u22a2 (a ^ n).Coprime b \u2227 a.Coprime b \u2194 a.Coprime b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.0148377820150927,
    "entry_failed": false
  },
  "8394": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/ModelTheory/FinitelyGenerated.lean",
    "full_name": "FirstOrder.Language.Structure.FG.map_of_surjective",
    "start": [
      219,
      1
    ],
    "end": [
      223,
      18
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 Hom.range_eq_top] at hs",
        "annotated_tactic": [
          "rw [\u2190 <a>Hom.range_eq_top</a>] at hs",
          [
            {
              "full_name": "FirstOrder.Language.Hom.range_eq_top",
              "def_path": "Mathlib/ModelTheory/Substructures.lean",
              "def_pos": [
                870,
                9
              ],
              "def_end_pos": [
                870,
                21
              ]
            }
          ]
        ],
        "state_before": "L : Language\nM : Type u_1\ninst\u271d\u00b9 : L.Structure M\nN : Type u_2\ninst\u271d : L.Structure N\nh : FG L M\nf : M \u2192[L] N\nhs : Function.Surjective \u21d1f\n\u22a2 FG L N",
        "state_after": "L : Language\nM : Type u_1\ninst\u271d\u00b9 : L.Structure M\nN : Type u_2\ninst\u271d : L.Structure N\nh : FG L M\nf : M \u2192[L] N\nhs : f.range = \u22a4\n\u22a2 FG L N"
      },
      {
        "tactic": "rw [fg_def, \u2190 hs]",
        "annotated_tactic": [
          "rw [<a>fg_def</a>, \u2190 hs]",
          [
            {
              "full_name": "FirstOrder.Language.Structure.fg_def",
              "def_path": "Mathlib/ModelTheory/FinitelyGenerated.lean",
              "def_pos": [
                205,
                9
              ],
              "def_end_pos": [
                205,
                15
              ]
            }
          ]
        ],
        "state_before": "L : Language\nM : Type u_1\ninst\u271d\u00b9 : L.Structure M\nN : Type u_2\ninst\u271d : L.Structure N\nh : FG L M\nf : M \u2192[L] N\nhs : f.range = \u22a4\n\u22a2 FG L N",
        "state_after": "L : Language\nM : Type u_1\ninst\u271d\u00b9 : L.Structure M\nN : Type u_2\ninst\u271d : L.Structure N\nh : FG L M\nf : M \u2192[L] N\nhs : f.range = \u22a4\n\u22a2 f.range.FG"
      },
      {
        "tactic": "exact h.range f",
        "annotated_tactic": [
          "exact h.range f",
          []
        ],
        "state_before": "L : Language\nM : Type u_1\ninst\u271d\u00b9 : L.Structure M\nN : Type u_2\ninst\u271d : L.Structure N\nh : FG L M\nf : M \u2192[L] N\nhs : f.range = \u22a4\n\u22a2 f.range.FG",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.045170983998105,
    "entry_failed": false
  },
  "8456": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/Enumerative/Composition.lean",
    "full_name": "Composition.index_embedding",
    "start": [
      416,
      1
    ],
    "end": [
      420,
      27
    ],
    "traced_tactics": [
      {
        "tactic": "symm",
        "annotated_tactic": [
          "symm",
          []
        ],
        "state_before": "n : \u2115\nc : Composition n\ni : Fin c.length\nj : Fin (c.blocksFun i)\n\u22a2 c.index ((c.embedding i) j) = i",
        "state_after": "n : \u2115\nc : Composition n\ni : Fin c.length\nj : Fin (c.blocksFun i)\n\u22a2 i = c.index ((c.embedding i) j)"
      },
      {
        "tactic": "rw [\u2190 mem_range_embedding_iff']",
        "annotated_tactic": [
          "rw [\u2190 <a>mem_range_embedding_iff'</a>]",
          [
            {
              "full_name": "Composition.mem_range_embedding_iff'",
              "def_path": "Mathlib/Combinatorics/Enumerative/Composition.lean",
              "def_pos": [
                405,
                9
              ],
              "def_end_pos": [
                405,
                33
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\nc : Composition n\ni : Fin c.length\nj : Fin (c.blocksFun i)\n\u22a2 i = c.index ((c.embedding i) j)",
        "state_after": "n : \u2115\nc : Composition n\ni : Fin c.length\nj : Fin (c.blocksFun i)\n\u22a2 (c.embedding i) j \u2208 Set.range \u21d1(c.embedding i)"
      },
      {
        "tactic": "apply Set.mem_range_self",
        "annotated_tactic": [
          "apply <a>Set.mem_range_self</a>",
          [
            {
              "full_name": "Set.mem_range_self",
              "def_path": "Mathlib/Data/Set/Defs.lean",
              "def_pos": [
                163,
                23
              ],
              "def_end_pos": [
                163,
                37
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\nc : Composition n\ni : Fin c.length\nj : Fin (c.blocksFun i)\n\u22a2 (c.embedding i) j \u2208 Set.range \u21d1(c.embedding i)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.2222553809406236,
    "entry_failed": false
  },
  "8461": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/LinearAlgebra/Matrix/ZPow.lean",
    "full_name": "Matrix.zero_zpow_eq",
    "start": [
      92,
      1
    ],
    "end": [
      95,
      23
    ],
    "traced_tactics": [
      {
        "tactic": "split_ifs with h",
        "annotated_tactic": [
          "split_ifs with h",
          []
        ],
        "state_before": "n' : Type u_1\ninst\u271d\u00b2 : DecidableEq n'\ninst\u271d\u00b9 : Fintype n'\nR : Type u_2\ninst\u271d : CommRing R\nn : \u2124\n\u22a2 0 ^ n = if n = 0 then 1 else 0",
        "state_after": "case pos\nn' : Type u_1\ninst\u271d\u00b2 : DecidableEq n'\ninst\u271d\u00b9 : Fintype n'\nR : Type u_2\ninst\u271d : CommRing R\nn : \u2124\nh : n = 0\n\u22a2 0 ^ n = 1\n\ncase neg\nn' : Type u_1\ninst\u271d\u00b2 : DecidableEq n'\ninst\u271d\u00b9 : Fintype n'\nR : Type u_2\ninst\u271d : CommRing R\nn : \u2124\nh : \u00acn = 0\n\u22a2 0 ^ n = 0"
      },
      {
        "tactic": "rw [h, zpow_zero]",
        "annotated_tactic": [
          "rw [h, <a>zpow_zero</a>]",
          [
            {
              "full_name": "zpow_zero",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                1015,
                50
              ],
              "def_end_pos": [
                1015,
                59
              ]
            }
          ]
        ],
        "state_before": "case pos\nn' : Type u_1\ninst\u271d\u00b2 : DecidableEq n'\ninst\u271d\u00b9 : Fintype n'\nR : Type u_2\ninst\u271d : CommRing R\nn : \u2124\nh : n = 0\n\u22a2 0 ^ n = 1",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [zero_zpow _ h]",
        "annotated_tactic": [
          "rw [<a>zero_zpow</a> _ h]",
          [
            {
              "full_name": "Matrix.zero_zpow",
              "def_path": "Mathlib/LinearAlgebra/Matrix/ZPow.lean",
              "def_pos": [
                85,
                9
              ],
              "def_end_pos": [
                85,
                18
              ]
            }
          ]
        ],
        "state_before": "case neg\nn' : Type u_1\ninst\u271d\u00b2 : DecidableEq n'\ninst\u271d\u00b9 : Fintype n'\nR : Type u_2\ninst\u271d : CommRing R\nn : \u2124\nh : \u00acn = 0\n\u22a2 0 ^ n = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.8745035720057786,
    "entry_failed": false
  },
  "8490": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Ordinal/NaturalOps.lean",
    "full_name": "Ordinal.nadd_le_nadd_left",
    "start": [
      253,
      1
    ],
    "end": [
      256,
      17
    ],
    "traced_tactics": [
      {
        "tactic": "rcases lt_or_eq_of_le h with (h | rfl)",
        "annotated_tactic": [
          "rcases <a>lt_or_eq_of_le</a> h with (h | rfl)",
          [
            {
              "full_name": "lt_or_eq_of_le",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                230,
                9
              ],
              "def_end_pos": [
                230,
                23
              ]
            }
          ]
        ],
        "state_before": "a\u271d b c : Ordinal.{u}\nh : b \u2264 c\na : Ordinal.{u}\n\u22a2 a \u266f b \u2264 a \u266f c",
        "state_after": "case inl\na\u271d b c : Ordinal.{u}\nh\u271d : b \u2264 c\na : Ordinal.{u}\nh : b < c\n\u22a2 a \u266f b \u2264 a \u266f c\n\ncase inr\na\u271d b a : Ordinal.{u}\nh : b \u2264 b\n\u22a2 a \u266f b \u2264 a \u266f b"
      },
      {
        "tactic": "exact (nadd_lt_nadd_left h a).le",
        "annotated_tactic": [
          "exact (<a>nadd_lt_nadd_left</a> h a).<a>le</a>",
          [
            {
              "full_name": "Ordinal.nadd_lt_nadd_left",
              "def_path": "Mathlib/SetTheory/Ordinal/NaturalOps.lean",
              "def_pos": [
                245,
                9
              ],
              "def_end_pos": [
                245,
                26
              ]
            },
            {
              "full_name": "LT.lt.le",
              "def_path": "Mathlib/Order/Basic.lean",
              "def_pos": [
                137,
                7
              ],
              "def_end_pos": [
                137,
                15
              ]
            }
          ]
        ],
        "state_before": "case inl\na\u271d b c : Ordinal.{u}\nh\u271d : b \u2264 c\na : Ordinal.{u}\nh : b < c\n\u22a2 a \u266f b \u2264 a \u266f c",
        "state_after": "no goals"
      },
      {
        "tactic": "exact le_rfl",
        "annotated_tactic": [
          "exact <a>le_rfl</a>",
          [
            {
              "full_name": "le_rfl",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                50,
                9
              ],
              "def_end_pos": [
                50,
                15
              ]
            }
          ]
        ],
        "state_before": "case inr\na\u271d b a : Ordinal.{u}\nh : b \u2264 b\n\u22a2 a \u266f b \u2264 a \u266f b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.922723885974847,
    "entry_failed": false
  },
  "8560": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/Harmonic/Defs.lean",
    "full_name": "harmonic_pos",
    "start": [
      31,
      1
    ],
    "end": [
      34,
      13
    ],
    "traced_tactics": [
      {
        "tactic": "unfold harmonic",
        "annotated_tactic": [
          "unfold <a>harmonic</a>",
          [
            {
              "full_name": "harmonic",
              "def_path": "Mathlib/NumberTheory/Harmonic/Defs.lean",
              "def_pos": [
                21,
                5
              ],
              "def_end_pos": [
                21,
                13
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\nHn : n \u2260 0\n\u22a2 0 < harmonic n",
        "state_after": "n : \u2115\nHn : n \u2260 0\n\u22a2 0 < \u2211 i \u2208 Finset.range n, (\u2191(i + 1))\u207b\u00b9"
      },
      {
        "tactic": "rw [\u2190 Finset.nonempty_range_iff] at Hn",
        "annotated_tactic": [
          "rw [\u2190 <a>Finset.nonempty_range_iff</a>] at Hn",
          [
            {
              "full_name": "Finset.nonempty_range_iff",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                2995,
                9
              ],
              "def_end_pos": [
                2995,
                27
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\nHn : n \u2260 0\n\u22a2 0 < \u2211 i \u2208 Finset.range n, (\u2191(i + 1))\u207b\u00b9",
        "state_after": "n : \u2115\nHn : (Finset.range n).Nonempty\n\u22a2 0 < \u2211 i \u2208 Finset.range n, (\u2191(i + 1))\u207b\u00b9"
      },
      {
        "tactic": "positivity",
        "annotated_tactic": [
          "positivity",
          []
        ],
        "state_before": "n : \u2115\nHn : (Finset.range n).Nonempty\n\u22a2 0 < \u2211 i \u2208 Finset.range n, (\u2191(i + 1))\u207b\u00b9",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.078905259957537,
    "entry_failed": false
  },
  "8616": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Polynomial/Content.lean",
    "full_name": "Polynomial.eq_C_content_mul_primPart",
    "start": [
      251,
      1
    ],
    "end": [
      253,
      69
    ],
    "traced_tactics": [
      {
        "tactic": "by_cases h : p = 0",
        "annotated_tactic": [
          "by_cases h : p = 0",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\n\u22a2 p = C p.content * p.primPart",
        "state_after": "case pos\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nh : p = 0\n\u22a2 p = C p.content * p.primPart\n\ncase neg\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nh : \u00acp = 0\n\u22a2 p = C p.content * p.primPart"
      },
      {
        "tactic": "rw [primPart, if_neg h, \u2190 Classical.choose_spec (C_content_dvd p)]",
        "annotated_tactic": [
          "rw [<a>primPart</a>, <a>if_neg</a> h, \u2190 <a>Classical.choose_spec</a> (<a>C_content_dvd</a> p)]",
          [
            {
              "full_name": "Polynomial.primPart",
              "def_path": "Mathlib/RingTheory/Polynomial/Content.lean",
              "def_pos": [
                246,
                19
              ],
              "def_end_pos": [
                246,
                27
              ]
            },
            {
              "full_name": "if_neg",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                937,
                9
              ],
              "def_end_pos": [
                937,
                15
              ]
            },
            {
              "full_name": "Classical.choose_spec",
              "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean",
              "def_pos": [
                28,
                9
              ],
              "def_end_pos": [
                28,
                20
              ]
            },
            {
              "full_name": "Polynomial.C_content_dvd",
              "def_path": "Mathlib/RingTheory/Polynomial/Content.lean",
              "def_pos": [
                227,
                9
              ],
              "def_end_pos": [
                227,
                22
              ]
            }
          ]
        ],
        "state_before": "case neg\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nh : \u00acp = 0\n\u22a2 p = C p.content * p.primPart",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [h]",
        "annotated_tactic": [
          "simp [h]",
          []
        ],
        "state_before": "case pos\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\np : R[X]\nh : p = 0\n\u22a2 p = C p.content * p.primPart",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.333974077948369,
    "entry_failed": false
  },
  "8636": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": ".lake/packages/batteries/Batteries/Data/Rat/Lemmas.lean",
    "full_name": "Rat.ofScientific_true_def",
    "start": [
      325,
      1
    ],
    "end": [
      326,
      56
    ],
    "traced_tactics": [
      {
        "tactic": "unfold Rat.ofScientific",
        "annotated_tactic": [
          "unfold <a>Rat.ofScientific</a>",
          [
            {
              "full_name": "Rat.ofScientific",
              "def_path": ".lake/packages/batteries/Batteries/Data/Rat/Basic.lean",
              "def_pos": [
                110,
                30
              ],
              "def_end_pos": [
                110,
                42
              ]
            }
          ]
        ],
        "state_before": "m e : Nat\n\u22a2 Rat.ofScientific m true e = mkRat (\u2191m) (10 ^ e)",
        "state_after": "m e : Nat\n\u22a2 (if true = true then normalize (\u2191m) (10 ^ e) \u22ef else \u2191(m * 10 ^ e)) = mkRat (\u2191m) (10 ^ e)"
      },
      {
        "tactic": "rw [normalize_eq_mkRat]",
        "annotated_tactic": [
          "rw [<a>normalize_eq_mkRat</a>]",
          [
            {
              "full_name": "Rat.normalize_eq_mkRat",
              "def_path": ".lake/packages/batteries/Batteries/Data/Rat/Lemmas.lean",
              "def_pos": [
                98,
                9
              ],
              "def_end_pos": [
                98,
                27
              ]
            }
          ]
        ],
        "state_before": "m e : Nat\n\u22a2 (if true = true then normalize (\u2191m) (10 ^ e) \u22ef else \u2191(m * 10 ^ e)) = mkRat (\u2191m) (10 ^ e)",
        "state_after": "m e : Nat\n\u22a2 (if true = true then mkRat (\u2191m) (10 ^ e) else \u2191(m * 10 ^ e)) = mkRat (\u2191m) (10 ^ e)"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "m e : Nat\n\u22a2 (if true = true then mkRat (\u2191m) (10 ^ e) else \u2191(m * 10 ^ e)) = mkRat (\u2191m) (10 ^ e)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.3734606070211157,
    "entry_failed": false
  },
  "8707": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/ModEq.lean",
    "full_name": "Nat.ModEq.eq_of_abs_lt",
    "start": [
      270,
      1
    ],
    "end": [
      273,
      43
    ],
    "traced_tactics": [
      {
        "tactic": "apply Int.ofNat.inj",
        "annotated_tactic": [
          "apply Int.ofNat.inj",
          []
        ],
        "state_before": "m n a b c d : \u2115\nh : a \u2261 b [MOD m]\nh2 : |\u2191b - \u2191a| < \u2191m\n\u22a2 a = b",
        "state_after": "case x\nm n a b c d : \u2115\nh : a \u2261 b [MOD m]\nh2 : |\u2191b - \u2191a| < \u2191m\n\u22a2 Int.ofNat a = Int.ofNat b"
      },
      {
        "tactic": "rw [eq_comm, \u2190 sub_eq_zero]",
        "annotated_tactic": [
          "rw [<a>eq_comm</a>, \u2190 <a>sub_eq_zero</a>]",
          [
            {
              "full_name": "eq_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                811,
                9
              ],
              "def_end_pos": [
                811,
                16
              ]
            },
            {
              "full_name": "sub_eq_zero",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                1070,
                3
              ],
              "def_end_pos": [
                1070,
                14
              ]
            }
          ]
        ],
        "state_before": "case x\nm n a b c d : \u2115\nh : a \u2261 b [MOD m]\nh2 : |\u2191b - \u2191a| < \u2191m\n\u22a2 Int.ofNat a = Int.ofNat b",
        "state_after": "case x\nm n a b c d : \u2115\nh : a \u2261 b [MOD m]\nh2 : |\u2191b - \u2191a| < \u2191m\n\u22a2 Int.ofNat b - Int.ofNat a = 0"
      },
      {
        "tactic": "exact Int.eq_zero_of_abs_lt_dvd h.dvd h2",
        "annotated_tactic": [
          "exact <a>Int.eq_zero_of_abs_lt_dvd</a> h.dvd h2",
          [
            {
              "full_name": "Int.eq_zero_of_abs_lt_dvd",
              "def_path": "Mathlib/Data/Int/Order/Lemmas.lean",
              "def_pos": [
                54,
                9
              ],
              "def_end_pos": [
                54,
                30
              ]
            }
          ]
        ],
        "state_before": "case x\nm n a b c d : \u2115\nh : a \u2261 b [MOD m]\nh2 : |\u2191b - \u2191a| < \u2191m\n\u22a2 Int.ofNat b - Int.ofNat a = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.4685280729318038,
    "entry_failed": false
  },
  "8728": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Set/Countable.lean",
    "full_name": "Set.countable_iUnion",
    "start": [
      222,
      1
    ],
    "end": [
      226,
      24
    ],
    "traced_tactics": [
      {
        "tactic": "have := fun i \u21a6 (ht i).to_subtype",
        "annotated_tactic": [
          "have := fun i \u21a6 (ht i).<a>to_subtype</a>",
          [
            {
              "full_name": "Set.Countable.to_subtype",
              "def_path": "Mathlib/Data/Set/Countable.lean",
              "def_pos": [
                57,
                33
              ],
              "def_end_pos": [
                57,
                53
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\nt : \u03b9 \u2192 Set \u03b1\ninst\u271d : Countable \u03b9\nht : \u2200 (i : \u03b9), (t i).Countable\n\u22a2 (\u22c3 i, t i).Countable",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\nt : \u03b9 \u2192 Set \u03b1\ninst\u271d : Countable \u03b9\nht : \u2200 (i : \u03b9), (t i).Countable\nthis : \u2200 (i : \u03b9), Countable \u2191(t i)\n\u22a2 (\u22c3 i, t i).Countable"
      },
      {
        "tactic": "rw [iUnion_eq_range_psigma]",
        "annotated_tactic": [
          "rw [<a>iUnion_eq_range_psigma</a>]",
          [
            {
              "full_name": "Set.iUnion_eq_range_psigma",
              "def_path": "Mathlib/Data/Set/Lattice.lean",
              "def_pos": [
                1264,
                9
              ],
              "def_end_pos": [
                1264,
                31
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\nt : \u03b9 \u2192 Set \u03b1\ninst\u271d : Countable \u03b9\nht : \u2200 (i : \u03b9), (t i).Countable\nthis : \u2200 (i : \u03b9), Countable \u2191(t i)\n\u22a2 (\u22c3 i, t i).Countable",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\nt : \u03b9 \u2192 Set \u03b1\ninst\u271d : Countable \u03b9\nht : \u2200 (i : \u03b9), (t i).Countable\nthis : \u2200 (i : \u03b9), Countable \u2191(t i)\n\u22a2 (range fun a => \u2191a.snd).Countable"
      },
      {
        "tactic": "apply countable_range",
        "annotated_tactic": [
          "apply <a>countable_range</a>",
          [
            {
              "full_name": "Set.countable_range",
              "def_path": "Mathlib/Data/Set/Countable.lean",
              "def_pos": [
                125,
                9
              ],
              "def_end_pos": [
                125,
                24
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\nt : \u03b9 \u2192 Set \u03b1\ninst\u271d : Countable \u03b9\nht : \u2200 (i : \u03b9), (t i).Countable\nthis : \u2200 (i : \u03b9), Countable \u2191(t i)\n\u22a2 (range fun a => \u2191a.snd).Countable",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7459889389574528,
    "entry_failed": false
  },
  "8764": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Tactic/NormNum/NatSqrt.lean",
    "full_name": "Tactic.NormNum.nat_sqrt_helper",
    "start": [
      20,
      1
    ],
    "end": [
      24,
      55
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 hr, \u2190 pow_two]",
        "annotated_tactic": [
          "rw [\u2190 hr, \u2190 <a>pow_two</a>]",
          [
            {
              "full_name": "pow_two",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                679,
                32
              ],
              "def_end_pos": [
                679,
                39
              ]
            }
          ]
        ],
        "state_before": "x y r : \u2115\nhr : y * y + r = x\nhle : r.ble (2 * y) = true\n\u22a2 x.sqrt = y",
        "state_after": "x y r : \u2115\nhr : y * y + r = x\nhle : r.ble (2 * y) = true\n\u22a2 (y ^ 2 + r).sqrt = y"
      },
      {
        "tactic": "rw [two_mul] at hle",
        "annotated_tactic": [
          "rw [<a>two_mul</a>] at hle",
          [
            {
              "full_name": "two_mul",
              "def_path": "Mathlib/Algebra/Ring/Defs.lean",
              "def_pos": [
                179,
                9
              ],
              "def_end_pos": [
                179,
                16
              ]
            }
          ]
        ],
        "state_before": "x y r : \u2115\nhr : y * y + r = x\nhle : r.ble (2 * y) = true\n\u22a2 (y ^ 2 + r).sqrt = y",
        "state_after": "x y r : \u2115\nhr : y * y + r = x\nhle : r.ble (y + y) = true\n\u22a2 (y ^ 2 + r).sqrt = y"
      },
      {
        "tactic": "exact Nat.sqrt_add_eq' _ (Nat.le_of_ble_eq_true hle)",
        "annotated_tactic": [
          "exact <a>Nat.sqrt_add_eq'</a> _ (<a>Nat.le_of_ble_eq_true</a> hle)",
          [
            {
              "full_name": "Nat.sqrt_add_eq'",
              "def_path": "Mathlib/Data/Nat/Defs.lean",
              "def_pos": [
                1674,
                7
              ],
              "def_end_pos": [
                1674,
                19
              ]
            },
            {
              "full_name": "Nat.le_of_ble_eq_true",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                1760,
                9
              ],
              "def_end_pos": [
                1760,
                30
              ]
            }
          ]
        ],
        "state_before": "x y r : \u2115\nhr : y * y + r = x\nhle : r.ble (y + y) = true\n\u22a2 (y ^ 2 + r).sqrt = y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.0248685029800981,
    "entry_failed": false
  },
  "8808": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Perm/List.lean",
    "full_name": "List.formPerm_cons_concat_apply_last",
    "start": [
      142,
      1
    ],
    "end": [
      146,
      14
    ],
    "traced_tactics": [
      {
        "tactic": "induction' xs with z xs IH generalizing x y",
        "annotated_tactic": [
          "induction' xs with z xs IH generalizing x y",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx\u271d x y : \u03b1\nxs : List \u03b1\n\u22a2 (x :: (xs ++ [y])).formPerm y = x",
        "state_after": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx\u271d x y : \u03b1\n\u22a2 (x :: ([] ++ [y])).formPerm y = x\n\ncase cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx\u271d z : \u03b1\nxs : List \u03b1\nIH : \u2200 (x y : \u03b1), (x :: (xs ++ [y])).formPerm y = x\nx y : \u03b1\n\u22a2 (x :: (z :: xs ++ [y])).formPerm y = x"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx\u271d x y : \u03b1\n\u22a2 (x :: ([] ++ [y])).formPerm y = x",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [IH]",
        "annotated_tactic": [
          "simp [IH]",
          []
        ],
        "state_before": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx\u271d z : \u03b1\nxs : List \u03b1\nIH : \u2200 (x y : \u03b1), (x :: (xs ++ [y])).formPerm y = x\nx y : \u03b1\n\u22a2 (x :: (z :: xs ++ [y])).formPerm y = x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.0446113749640062,
    "entry_failed": false
  },
  "8911": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Factorial/Basic.lean",
    "full_name": "Nat.add_factorial_le_factorial_add",
    "start": [
      182,
      1
    ],
    "end": [
      185,
      53
    ],
    "traced_tactics": [
      {
        "tactic": "cases' n1 with h",
        "annotated_tactic": [
          "cases' n1 with h",
          []
        ],
        "state_before": "m n\u271d i n : \u2115\nn1 : 1 \u2264 n\n\u22a2 i + n ! \u2264 (i + n)!",
        "state_after": "case refl\nm n i : \u2115\n\u22a2 i + 1! \u2264 (i + 1)!\n\ncase step\nm n i h : \u2115\na\u271d : Nat.le 1 h\n\u22a2 i + h.succ ! \u2264 (i + h.succ)!"
      },
      {
        "tactic": "exact add_factorial_succ_le_factorial_add_succ i h",
        "annotated_tactic": [
          "exact <a>add_factorial_succ_le_factorial_add_succ</a> i h",
          [
            {
              "full_name": "Nat.add_factorial_succ_le_factorial_add_succ",
              "def_path": "Mathlib/Data/Nat/Factorial/Basic.lean",
              "def_pos": [
                166,
                9
              ],
              "def_end_pos": [
                166,
                49
              ]
            }
          ]
        ],
        "state_before": "case step\nm n i h : \u2115\na\u271d : Nat.le 1 h\n\u22a2 i + h.succ ! \u2264 (i + h.succ)!",
        "state_after": "no goals"
      },
      {
        "tactic": "exact self_le_factorial _",
        "annotated_tactic": [
          "exact <a>self_le_factorial</a> _",
          [
            {
              "full_name": "Nat.self_le_factorial",
              "def_path": "Mathlib/Data/Nat/Factorial/Basic.lean",
              "def_pos": [
                137,
                9
              ],
              "def_end_pos": [
                137,
                26
              ]
            }
          ]
        ],
        "state_before": "case refl\nm n i : \u2115\n\u22a2 i + 1! \u2264 (i + 1)!",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.75259903492406,
    "entry_failed": false
  },
  "8984": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/OuterMeasure/Induced.lean",
    "full_name": "MeasureTheory.le_extend",
    "start": [
      65,
      1
    ],
    "end": [
      68,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "simp only [extend, le_iInf_iff]",
        "annotated_tactic": [
          "simp only [<a>extend</a>, <a>le_iInf_iff</a>]",
          [
            {
              "full_name": "MeasureTheory.extend",
              "def_path": "Mathlib/MeasureTheory/OuterMeasure/Induced.lean",
              "def_pos": [
                45,
                5
              ],
              "def_end_pos": [
                45,
                11
              ]
            },
            {
              "full_name": "le_iInf_iff",
              "def_path": "Mathlib/Order/CompleteLattice.lean",
              "def_pos": [
                854,
                9
              ],
              "def_end_pos": [
                854,
                20
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nP : \u03b1 \u2192 Prop\nm : (s : \u03b1) \u2192 P s \u2192 \u211d\u22650\u221e\ns : \u03b1\nh : P s\n\u22a2 m s h \u2264 extend m s",
        "state_after": "\u03b1 : Type u_1\nP : \u03b1 \u2192 Prop\nm : (s : \u03b1) \u2192 P s \u2192 \u211d\u22650\u221e\ns : \u03b1\nh : P s\n\u22a2 \u2200 (i : P s), m s h \u2264 m s i"
      },
      {
        "tactic": "intro",
        "annotated_tactic": [
          "intro",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nP : \u03b1 \u2192 Prop\nm : (s : \u03b1) \u2192 P s \u2192 \u211d\u22650\u221e\ns : \u03b1\nh : P s\n\u22a2 \u2200 (i : P s), m s h \u2264 m s i",
        "state_after": "\u03b1 : Type u_1\nP : \u03b1 \u2192 Prop\nm : (s : \u03b1) \u2192 P s \u2192 \u211d\u22650\u221e\ns : \u03b1\nh i\u271d : P s\n\u22a2 m s h \u2264 m s i\u271d"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nP : \u03b1 \u2192 Prop\nm : (s : \u03b1) \u2192 P s \u2192 \u211d\u22650\u221e\ns : \u03b1\nh i\u271d : P s\n\u22a2 m s h \u2264 m s i\u271d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9527519720140845,
    "entry_failed": false
  },
  "8995": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/ZMod/Basic.lean",
    "full_name": "ZMod.natCast_comp_val",
    "start": [
      273,
      1
    ],
    "end": [
      276,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "cases n",
        "annotated_tactic": [
          "cases n",
          []
        ],
        "state_before": "n : \u2115\nR : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : NeZero n\n\u22a2 Nat.cast \u2218 val = cast",
        "state_after": "case zero\nR : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : NeZero 0\n\u22a2 Nat.cast \u2218 val = cast\n\ncase succ\nR : Type u_1\ninst\u271d\u00b9 : Ring R\nn\u271d : \u2115\ninst\u271d : NeZero (n\u271d + 1)\n\u22a2 Nat.cast \u2218 val = cast"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case succ\nR : Type u_1\ninst\u271d\u00b9 : Ring R\nn\u271d : \u2115\ninst\u271d : NeZero (n\u271d + 1)\n\u22a2 Nat.cast \u2218 val = cast",
        "state_after": "no goals"
      },
      {
        "tactic": "cases NeZero.ne 0 rfl",
        "annotated_tactic": [
          "cases <a>NeZero.ne</a> 0 <a>rfl</a>",
          [
            {
              "full_name": "NeZero.ne",
              "def_path": "Mathlib/Algebra/NeZero.lean",
              "def_pos": [
                30,
                9
              ],
              "def_end_pos": [
                30,
                18
              ]
            },
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "case zero\nR : Type u_1\ninst\u271d\u00b9 : Ring R\ninst\u271d : NeZero 0\n\u22a2 Nat.cast \u2218 val = cast",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.9511842840583995,
    "entry_failed": false
  },
  "9026": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/Padics/PadicVal.lean",
    "full_name": "dvd_of_one_le_padicValNat",
    "start": [
      564,
      1
    ],
    "end": [
      567,
      52
    ],
    "traced_tactics": [
      {
        "tactic": "by_contra h",
        "annotated_tactic": [
          "by_contra h",
          []
        ],
        "state_before": "p n : \u2115\nhp : 1 \u2264 padicValNat p n\n\u22a2 p \u2223 n",
        "state_after": "p n : \u2115\nhp : 1 \u2264 padicValNat p n\nh : \u00acp \u2223 n\n\u22a2 False"
      },
      {
        "tactic": "rw [padicValNat.eq_zero_of_not_dvd h] at hp",
        "annotated_tactic": [
          "rw [<a>padicValNat.eq_zero_of_not_dvd</a> h] at hp",
          [
            {
              "full_name": "padicValNat.eq_zero_of_not_dvd",
              "def_path": "Mathlib/NumberTheory/Padics/PadicVal.lean",
              "def_pos": [
                113,
                9
              ],
              "def_end_pos": [
                113,
                27
              ]
            }
          ]
        ],
        "state_before": "p n : \u2115\nhp : 1 \u2264 padicValNat p n\nh : \u00acp \u2223 n\n\u22a2 False",
        "state_after": "p n : \u2115\nhp : 1 \u2264 0\nh : \u00acp \u2223 n\n\u22a2 False"
      },
      {
        "tactic": "exact lt_irrefl 0 (lt_of_lt_of_le zero_lt_one hp)",
        "annotated_tactic": [
          "exact <a>lt_irrefl</a> 0 (<a>lt_of_lt_of_le</a> <a>zero_lt_one</a> hp)",
          [
            {
              "full_name": "lt_irrefl",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                79,
                9
              ],
              "def_end_pos": [
                79,
                18
              ]
            },
            {
              "full_name": "lt_of_lt_of_le",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                115,
                9
              ],
              "def_end_pos": [
                115,
                23
              ]
            },
            {
              "full_name": "zero_lt_one",
              "def_path": "Mathlib/Algebra/Order/ZeroLEOne.lean",
              "def_pos": [
                39,
                15
              ],
              "def_end_pos": [
                39,
                26
              ]
            }
          ]
        ],
        "state_before": "p n : \u2115\nhp : 1 \u2264 0\nh : \u00acp \u2223 n\n\u22a2 False",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.6520268969470635,
    "entry_failed": false
  },
  "9035": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/Complex/Angle.lean",
    "full_name": "Complex.angle_div_left_eq_angle_mul_right",
    "start": [
      56,
      1
    ],
    "end": [
      59,
      52
    ],
    "traced_tactics": [
      {
        "tactic": "obtain rfl | ha := eq_or_ne a 0",
        "annotated_tactic": [
          "obtain rfl | ha := <a>eq_or_ne</a> a 0",
          [
            {
              "full_name": "eq_or_ne",
              "def_path": "Mathlib/Logic/Basic.lean",
              "def_pos": [
                212,
                9
              ],
              "def_end_pos": [
                212,
                17
              ]
            }
          ]
        ],
        "state_before": "a\u271d x\u271d y\u271d a x y : \u2102\n\u22a2 angle (x / a) y = angle x (y * a)",
        "state_after": "case inl\na x\u271d y\u271d x y : \u2102\n\u22a2 angle (x / 0) y = angle x (y * 0)\n\ncase inr\na\u271d x\u271d y\u271d a x y : \u2102\nha : a \u2260 0\n\u22a2 angle (x / a) y = angle x (y * a)"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case inl\na x\u271d y\u271d x y : \u2102\n\u22a2 angle (x / 0) y = angle x (y * 0)",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [\u2190 angle_mul_right ha, div_mul_cancel\u2080 _ ha]",
        "annotated_tactic": [
          "rw [\u2190 <a>angle_mul_right</a> ha, <a>div_mul_cancel\u2080</a> _ ha]",
          [
            {
              "full_name": "Complex.angle_mul_right",
              "def_path": "Mathlib/Analysis/Complex/Angle.lean",
              "def_pos": [
                53,
                15
              ],
              "def_end_pos": [
                53,
                30
              ]
            },
            {
              "full_name": "div_mul_cancel\u2080",
              "def_path": "Mathlib/Algebra/GroupWithZero/Units/Basic.lean",
              "def_pos": [
                342,
                15
              ],
              "def_end_pos": [
                342,
                30
              ]
            }
          ]
        ],
        "state_before": "case inr\na\u271d x\u271d y\u271d a x y : \u2102\nha : a \u2260 0\n\u22a2 angle (x / a) y = angle x (y * a)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.209900947054848,
    "entry_failed": false
  },
  "9107": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Surreal/Basic.lean",
    "full_name": "SetTheory.PGame.numeric_toPGame",
    "start": [
      269,
      1
    ],
    "end": [
      272,
      67
    ],
    "traced_tactics": [
      {
        "tactic": "induction' o using Ordinal.induction with o IH",
        "annotated_tactic": [
          "induction' o using <a>Ordinal.induction</a> with o IH",
          [
            {
              "full_name": "Ordinal.induction",
              "def_path": "Mathlib/SetTheory/Ordinal/Basic.lean",
              "def_pos": [
                588,
                9
              ],
              "def_end_pos": [
                588,
                18
              ]
            }
          ]
        ],
        "state_before": "o : Ordinal.{u_1}\n\u22a2 o.toPGame.Numeric",
        "state_after": "case h\no : Ordinal.{u_1}\nIH : \u2200 k < o, k.toPGame.Numeric\n\u22a2 o.toPGame.Numeric"
      },
      {
        "tactic": "apply numeric_of_isEmpty_rightMoves",
        "annotated_tactic": [
          "apply <a>numeric_of_isEmpty_rightMoves</a>",
          [
            {
              "full_name": "SetTheory.PGame.numeric_of_isEmpty_rightMoves",
              "def_path": "Mathlib/SetTheory/Surreal/Basic.lean",
              "def_pos": [
                200,
                9
              ],
              "def_end_pos": [
                200,
                38
              ]
            }
          ]
        ],
        "state_before": "case h\no : Ordinal.{u_1}\nIH : \u2200 k < o, k.toPGame.Numeric\n\u22a2 o.toPGame.Numeric",
        "state_after": "case h.H\no : Ordinal.{u_1}\nIH : \u2200 k < o, k.toPGame.Numeric\n\u22a2 \u2200 (i : o.toPGame.LeftMoves), (o.toPGame.moveLeft i).Numeric"
      },
      {
        "tactic": "simpa using fun i => IH _ (Ordinal.toLeftMovesToPGame_symm_lt i)",
        "annotated_tactic": [
          "simpa using fun i => IH _ (<a>Ordinal.toLeftMovesToPGame_symm_lt</a> i)",
          [
            {
              "full_name": "Ordinal.toLeftMovesToPGame_symm_lt",
              "def_path": "Mathlib/SetTheory/Game/Ordinal.lean",
              "def_pos": [
                77,
                9
              ],
              "def_end_pos": [
                77,
                35
              ]
            }
          ]
        ],
        "state_before": "case h.H\no : Ordinal.{u_1}\nIH : \u2200 k < o, k.toPGame.Numeric\n\u22a2 \u2200 (i : o.toPGame.LeftMoves), (o.toPGame.moveLeft i).Numeric",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.4675140859326348,
    "entry_failed": false
  },
  "9239": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Set/Countable.lean",
    "full_name": "Set.Countable.image",
    "start": [
      170,
      1
    ],
    "end": [
      173,
      24
    ],
    "traced_tactics": [
      {
        "tactic": "rw [image_eq_range]",
        "annotated_tactic": [
          "rw [<a>image_eq_range</a>]",
          [
            {
              "full_name": "Set.image_eq_range",
              "def_path": "Mathlib/Data/Set/Image.lean",
              "def_pos": [
                1055,
                9
              ],
              "def_end_pos": [
                1055,
                23
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ns : Set \u03b1\nhs : s.Countable\nf : \u03b1 \u2192 \u03b2\n\u22a2 (f '' s).Countable",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ns : Set \u03b1\nhs : s.Countable\nf : \u03b1 \u2192 \u03b2\n\u22a2 (range fun x => f \u2191x).Countable"
      },
      {
        "tactic": "have := hs.to_subtype",
        "annotated_tactic": [
          "have := hs.to_subtype",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ns : Set \u03b1\nhs : s.Countable\nf : \u03b1 \u2192 \u03b2\n\u22a2 (range fun x => f \u2191x).Countable",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ns : Set \u03b1\nhs : s.Countable\nf : \u03b1 \u2192 \u03b2\nthis : Countable \u2191s\n\u22a2 (range fun x => f \u2191x).Countable"
      },
      {
        "tactic": "apply countable_range",
        "annotated_tactic": [
          "apply <a>countable_range</a>",
          [
            {
              "full_name": "Set.countable_range",
              "def_path": "Mathlib/Data/Set/Countable.lean",
              "def_pos": [
                125,
                9
              ],
              "def_end_pos": [
                125,
                24
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ns : Set \u03b1\nhs : s.Countable\nf : \u03b1 \u2192 \u03b2\nthis : Countable \u2191s\n\u22a2 (range fun x => f \u2191x).Countable",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.506143918959424,
    "entry_failed": false
  },
  "9259": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Totient.lean",
    "full_name": "Nat.card_units_zmod_lt_sub_one",
    "start": [
      242,
      1
    ],
    "end": [
      246,
      51
    ],
    "traced_tactics": [
      {
        "tactic": "haveI : NeZero p := \u27e8(pos_of_gt hp).ne'\u27e9",
        "annotated_tactic": [
          "haveI : <a>NeZero</a> p := \u27e8(<a>pos_of_gt</a> hp).<a>ne'</a>\u27e9",
          [
            {
              "full_name": "NeZero",
              "def_path": "Mathlib/Algebra/NeZero.lean",
              "def_pos": [
                25,
                7
              ],
              "def_end_pos": [
                25,
                13
              ]
            },
            {
              "full_name": "pos_of_gt",
              "def_path": "Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean",
              "def_pos": [
                291,
                9
              ],
              "def_end_pos": [
                291,
                18
              ]
            },
            {
              "full_name": "LT.lt.ne'",
              "def_path": "Mathlib/Order/Basic.lean",
              "def_pos": [
                306,
                9
              ],
              "def_end_pos": [
                306,
                12
              ]
            }
          ]
        ],
        "state_before": "p : \u2115\nhp : 1 < p\ninst\u271d : Fintype (ZMod p)\u02e3\n\u22a2 Fintype.card (ZMod p)\u02e3 \u2264 p - 1",
        "state_after": "p : \u2115\nhp : 1 < p\ninst\u271d : Fintype (ZMod p)\u02e3\nthis : NeZero p\n\u22a2 Fintype.card (ZMod p)\u02e3 \u2264 p - 1"
      },
      {
        "tactic": "rw [ZMod.card_units_eq_totient p]",
        "annotated_tactic": [
          "rw [<a>ZMod.card_units_eq_totient</a> p]",
          [
            {
              "full_name": "ZMod.card_units_eq_totient",
              "def_path": "Mathlib/Data/Nat/Totient.lean",
              "def_pos": [
                113,
                9
              ],
              "def_end_pos": [
                113,
                42
              ]
            }
          ]
        ],
        "state_before": "p : \u2115\nhp : 1 < p\ninst\u271d : Fintype (ZMod p)\u02e3\nthis : NeZero p\n\u22a2 Fintype.card (ZMod p)\u02e3 \u2264 p - 1",
        "state_after": "p : \u2115\nhp : 1 < p\ninst\u271d : Fintype (ZMod p)\u02e3\nthis : NeZero p\n\u22a2 \u03c6 p \u2264 p - 1"
      },
      {
        "tactic": "exact Nat.le_sub_one_of_lt (Nat.totient_lt p hp)",
        "annotated_tactic": [
          "exact <a>Nat.le_sub_one_of_lt</a> (<a>Nat.totient_lt</a> p hp)",
          [
            {
              "full_name": "Nat.le_sub_one_of_lt",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean",
              "def_pos": [
                682,
                9
              ],
              "def_end_pos": [
                682,
                25
              ]
            },
            {
              "full_name": "Nat.totient_lt",
              "def_path": "Mathlib/Data/Nat/Totient.lean",
              "def_pos": [
                63,
                9
              ],
              "def_end_pos": [
                63,
                19
              ]
            }
          ]
        ],
        "state_before": "p : \u2115\nhp : 1 < p\ninst\u271d : Fintype (ZMod p)\u02e3\nthis : NeZero p\n\u22a2 \u03c6 p \u2264 p - 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.8378058680100366,
    "entry_failed": false
  },
  "9274": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Base.lean",
    "full_name": "Real.logb_eq_iff_rpow_eq",
    "start": [
      157,
      1
    ],
    "end": [
      160,
      35
    ],
    "traced_tactics": [
      {
        "tactic": "constructor <;> rintro rfl",
        "annotated_tactic": [
          "constructor <;> rintro rfl",
          []
        ],
        "state_before": "b x y : \u211d\nb_pos : 0 < b\nb_ne_one : b \u2260 1\nhy : 0 < y\n\u22a2 logb b y = x \u2194 b ^ x = y",
        "state_after": "case mp\nb y : \u211d\nb_pos : 0 < b\nb_ne_one : b \u2260 1\nhy : 0 < y\n\u22a2 b ^ logb b y = y\n\ncase mpr\nb x : \u211d\nb_pos : 0 < b\nb_ne_one : b \u2260 1\nhy : 0 < b ^ x\n\u22a2 logb b (b ^ x) = x"
      },
      {
        "tactic": "exact rpow_logb b_pos b_ne_one hy",
        "annotated_tactic": [
          "exact <a>rpow_logb</a> b_pos b_ne_one hy",
          [
            {
              "full_name": "Real.rpow_logb",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Log/Base.lean",
              "def_pos": [
                147,
                9
              ],
              "def_end_pos": [
                147,
                18
              ]
            }
          ]
        ],
        "state_before": "case mp\nb y : \u211d\nb_pos : 0 < b\nb_ne_one : b \u2260 1\nhy : 0 < y\n\u22a2 b ^ logb b y = y",
        "state_after": "no goals"
      },
      {
        "tactic": "exact logb_rpow b_pos b_ne_one",
        "annotated_tactic": [
          "exact <a>logb_rpow</a> b_pos b_ne_one",
          [
            {
              "full_name": "Real.logb_rpow",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Log/Base.lean",
              "def_pos": [
                132,
                9
              ],
              "def_end_pos": [
                132,
                18
              ]
            }
          ]
        ],
        "state_before": "case mpr\nb x : \u211d\nb_pos : 0 < b\nb_ne_one : b \u2260 1\nhy : 0 < b ^ x\n\u22a2 logb b (b ^ x) = x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.6532057479489595,
    "entry_failed": false
  },
  "9460": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Interval/Set/SurjOn.lean",
    "full_name": "surjOn_Ioi_of_monotone_surjective",
    "start": [
      63,
      1
    ],
    "end": [
      67,
      39
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 compl_Iic, \u2190 compl_compl (Ioi (f a))]",
        "annotated_tactic": [
          "rw [\u2190 <a>compl_Iic</a>, \u2190 <a>compl_compl</a> (<a>Ioi</a> (f a))]",
          [
            {
              "full_name": "Set.compl_Iic",
              "def_path": "Mathlib/Order/Interval/Set/Basic.lean",
              "def_pos": [
                1096,
                9
              ],
              "def_end_pos": [
                1096,
                18
              ]
            },
            {
              "full_name": "compl_compl",
              "def_path": "Mathlib/Order/BooleanAlgebra.lean",
              "def_pos": [
                655,
                9
              ],
              "def_end_pos": [
                655,
                20
              ]
            },
            {
              "full_name": "Set.Ioi",
              "def_path": "Mathlib/Order/Interval/Set/Basic.lean",
              "def_pos": [
                79,
                5
              ],
              "def_end_pos": [
                79,
                8
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\nh_mono : Monotone f\nh_surj : Surjective f\na : \u03b1\n\u22a2 SurjOn f (Ioi a) (Ioi (f a))",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\nh_mono : Monotone f\nh_surj : Surjective f\na : \u03b1\n\u22a2 SurjOn f (Iic a)\u1d9c (Ioi (f a))\u1d9c\u1d9c"
      },
      {
        "tactic": "refine MapsTo.surjOn_compl ?_ h_surj",
        "annotated_tactic": [
          "refine <a>MapsTo.surjOn_compl</a> ?_ h_surj",
          [
            {
              "full_name": "Set.MapsTo.surjOn_compl",
              "def_path": "Mathlib/Data/Set/Function.lean",
              "def_pos": [
                994,
                9
              ],
              "def_end_pos": [
                994,
                28
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\nh_mono : Monotone f\nh_surj : Surjective f\na : \u03b1\n\u22a2 SurjOn f (Iic a)\u1d9c (Ioi (f a))\u1d9c\u1d9c",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\nh_mono : Monotone f\nh_surj : Surjective f\na : \u03b1\n\u22a2 MapsTo f (Iic a) (Ioi (f a))\u1d9c"
      },
      {
        "tactic": "exact fun x hx => (h_mono hx).not_lt",
        "annotated_tactic": [
          "exact fun x hx => (h_mono hx).<a>not_lt</a>",
          [
            {
              "full_name": "LE.le.not_lt",
              "def_path": "Mathlib/Order/Basic.lean",
              "def_pos": [
                346,
                7
              ],
              "def_end_pos": [
                346,
                19
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : PartialOrder \u03b2\nf : \u03b1 \u2192 \u03b2\nh_mono : Monotone f\nh_surj : Surjective f\na : \u03b1\n\u22a2 MapsTo f (Iic a) (Ioi (f a))\u1d9c",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2303285570815206,
    "entry_failed": false
  },
  "9464": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Cardinal/Finite.lean",
    "full_name": "Nat.card_zmod",
    "start": [
      197,
      1
    ],
    "end": [
      200,
      45
    ],
    "traced_tactics": [
      {
        "tactic": "cases n",
        "annotated_tactic": [
          "cases n",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : \u2115\n\u22a2 Nat.card (ZMod n) = n",
        "state_after": "case zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u22a2 Nat.card (ZMod 0) = 0\n\ncase succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nn\u271d : \u2115\n\u22a2 Nat.card (ZMod (n\u271d + 1)) = n\u271d + 1"
      },
      {
        "tactic": "exact @Nat.card_eq_zero_of_infinite _ Int.infinite",
        "annotated_tactic": [
          "exact @<a>Nat.card_eq_zero_of_infinite</a> _ <a>Int.infinite</a>",
          [
            {
              "full_name": "Nat.card_eq_zero_of_infinite",
              "def_path": "Mathlib/SetTheory/Cardinal/Finite.lean",
              "def_pos": [
                61,
                15
              ],
              "def_end_pos": [
                61,
                39
              ]
            },
            {
              "full_name": "Int.infinite",
              "def_path": "Mathlib/Data/Fintype/Card.lean",
              "def_pos": [
                1066,
                10
              ],
              "def_end_pos": [
                1066,
                22
              ]
            }
          ]
        ],
        "state_before": "case zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u22a2 Nat.card (ZMod 0) = 0",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [Nat.card_eq_fintype_card, ZMod.card]",
        "annotated_tactic": [
          "rw [<a>Nat.card_eq_fintype_card</a>, <a>ZMod.card</a>]",
          [
            {
              "full_name": "Nat.card_eq_fintype_card",
              "def_path": "Mathlib/SetTheory/Cardinal/Finite.lean",
              "def_pos": [
                40,
                9
              ],
              "def_end_pos": [
                40,
                29
              ]
            },
            {
              "full_name": "ZMod.card",
              "def_path": "Mathlib/Data/ZMod/Defs.lean",
              "def_pos": [
                124,
                9
              ],
              "def_end_pos": [
                124,
                13
              ]
            }
          ]
        ],
        "state_before": "case succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nn\u271d : \u2115\n\u22a2 Nat.card (ZMod (n\u271d + 1)) = n\u271d + 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.6342228200519457,
    "entry_failed": false
  },
  "9547": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Sym/Sym2.lean",
    "full_name": "Sym2.IsDiag.mem_range_diag",
    "start": [
      467,
      1
    ],
    "end": [
      470,
      17
    ],
    "traced_tactics": [
      {
        "tactic": "induction' z with x y",
        "annotated_tactic": [
          "induction' z with x y",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ne : Sym2 \u03b1\nf : \u03b1 \u2192 \u03b2\nz : Sym2 \u03b1\n\u22a2 z.IsDiag \u2192 z \u2208 Set.range diag",
        "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ne : Sym2 \u03b1\nf : \u03b1 \u2192 \u03b2\nx y : \u03b1\n\u22a2 s(x, y).IsDiag \u2192 s(x, y) \u2208 Set.range diag"
      },
      {
        "tactic": "rintro (rfl : x = y)",
        "annotated_tactic": [
          "rintro (rfl : x = y)",
          []
        ],
        "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ne : Sym2 \u03b1\nf : \u03b1 \u2192 \u03b2\nx y : \u03b1\n\u22a2 s(x, y).IsDiag \u2192 s(x, y) \u2208 Set.range diag",
        "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ne : Sym2 \u03b1\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\n\u22a2 s(x, x) \u2208 Set.range diag"
      },
      {
        "tactic": "exact \u27e8_, rfl\u27e9",
        "annotated_tactic": [
          "exact \u27e8_, <a>rfl</a>\u27e9",
          [
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ne : Sym2 \u03b1\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\n\u22a2 s(x, x) \u2208 Set.range diag",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.2481299699284136,
    "entry_failed": false
  },
  "9586": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Fintype/Basic.lean",
    "full_name": "Set.toFinset_congr",
    "start": [
      616,
      1
    ],
    "end": [
      617,
      78
    ],
    "traced_tactics": [
      {
        "tactic": "subst h",
        "annotated_tactic": [
          "subst h",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns\u271d t\u271d s t : Set \u03b1\ninst\u271d\u00b9 : Fintype \u2191s\ninst\u271d : Fintype \u2191t\nh : s = t\n\u22a2 s.toFinset = t.toFinset",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns\u271d t s : Set \u03b1\ninst\u271d\u00b9 inst\u271d : Fintype \u2191s\n\u22a2 s.toFinset = s.toFinset"
      },
      {
        "tactic": "congr",
        "annotated_tactic": [
          "congr",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns\u271d t s : Set \u03b1\ninst\u271d\u00b9 inst\u271d : Fintype \u2191s\n\u22a2 s.toFinset = s.toFinset",
        "state_after": "case h.e_3.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns\u271d t s : Set \u03b1\ninst\u271d\u00b9 inst\u271d : Fintype \u2191s\n\u22a2 inst\u271d\u00b9 = inst\u271d"
      },
      {
        "tactic": "exact Subsingleton.elim _ _",
        "annotated_tactic": [
          "exact <a>Subsingleton.elim</a> _ _",
          [
            {
              "full_name": "Subsingleton.elim",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1015,
                19
              ],
              "def_end_pos": [
                1015,
                36
              ]
            }
          ]
        ],
        "state_before": "case h.e_3.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns\u271d t s : Set \u03b1\ninst\u271d\u00b9 inst\u271d : Fintype \u2191s\n\u22a2 inst\u271d\u00b9 = inst\u271d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.617179478984326,
    "entry_failed": false
  },
  "9614": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/PNat/Factors.lean",
    "full_name": "PrimeMultiset.prod_ofPNatList",
    "start": [
      207,
      1
    ],
    "end": [
      210,
      13
    ],
    "traced_tactics": [
      {
        "tactic": "have := prod_ofPNatMultiset (l : Multiset \u2115+) h",
        "annotated_tactic": [
          "have := <a>prod_ofPNatMultiset</a> (l : <a>Multiset</a> \u2115+) h",
          [
            {
              "full_name": "PrimeMultiset.prod_ofPNatMultiset",
              "def_path": "Mathlib/Data/PNat/Factors.lean",
              "def_pos": [
                184,
                9
              ],
              "def_end_pos": [
                184,
                28
              ]
            },
            {
              "full_name": "Multiset",
              "def_path": "Mathlib/Data/Multiset/Basic.lean",
              "def_pos": [
                30,
                5
              ],
              "def_end_pos": [
                30,
                13
              ]
            }
          ]
        ],
        "state_before": "l : List \u2115+\nh : \u2200 p \u2208 l, p.Prime\n\u22a2 (ofPNatList l h).prod = l.prod",
        "state_after": "l : List \u2115+\nh : \u2200 p \u2208 l, p.Prime\nthis : (ofPNatMultiset (\u2191l) h).prod = (\u2191l).prod\n\u22a2 (ofPNatList l h).prod = l.prod"
      },
      {
        "tactic": "rw [Multiset.prod_coe] at this",
        "annotated_tactic": [
          "rw [<a>Multiset.prod_coe</a>] at this",
          [
            {
              "full_name": "Multiset.prod_coe",
              "def_path": "Mathlib/Algebra/BigOperators/Group/Multiset.lean",
              "def_pos": [
                60,
                9
              ],
              "def_end_pos": [
                60,
                17
              ]
            }
          ]
        ],
        "state_before": "l : List \u2115+\nh : \u2200 p \u2208 l, p.Prime\nthis : (ofPNatMultiset (\u2191l) h).prod = (\u2191l).prod\n\u22a2 (ofPNatList l h).prod = l.prod",
        "state_after": "l : List \u2115+\nh : \u2200 p \u2208 l, p.Prime\nthis : (ofPNatMultiset (\u2191l) h).prod = l.prod\n\u22a2 (ofPNatList l h).prod = l.prod"
      },
      {
        "tactic": "exact this",
        "annotated_tactic": [
          "exact this",
          []
        ],
        "state_before": "l : List \u2115+\nh : \u2200 p \u2208 l, p.Prime\nthis : (ofPNatMultiset (\u2191l) h).prod = l.prod\n\u22a2 (ofPNatList l h).prod = l.prod",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.974843970965594,
    "entry_failed": false
  },
  "9620": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Ring/Abs.lean",
    "full_name": "Odd.ne_two_of_dvd_nat",
    "start": [
      275,
      1
    ],
    "end": [
      278,
      46
    ],
    "traced_tactics": [
      {
        "tactic": "rintro rfl",
        "annotated_tactic": [
          "rintro rfl",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nm\u271d n\u271d a m n : \u2115\nhn : Odd n\nhm : m \u2223 n\n\u22a2 m \u2260 2",
        "state_after": "\u03b1 : Type u_1\nm n\u271d a n : \u2115\nhn : Odd n\nhm : 2 \u2223 n\n\u22a2 False"
      },
      {
        "tactic": "exact absurd (hn.of_dvd_nat hm) (by decide)",
        "annotated_tactic": [
          "exact <a>absurd</a> (hn.of_dvd_nat hm) (by decide)",
          [
            {
              "full_name": "absurd",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                246,
                21
              ],
              "def_end_pos": [
                246,
                27
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nm n\u271d a n : \u2115\nhn : Odd n\nhm : 2 \u2223 n\n\u22a2 False",
        "state_after": "no goals"
      },
      {
        "tactic": "decide",
        "annotated_tactic": [
          "decide",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nm n\u271d a n : \u2115\nhn : Odd n\nhm : 2 \u2223 n\n\u22a2 \u00acOdd 2",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.936751654953696,
    "entry_failed": false
  },
  "9629": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Fintype/Basic.lean",
    "full_name": "Finset.Nonempty.eq_univ",
    "start": [
      99,
      1
    ],
    "end": [
      101,
      66
    ],
    "traced_tactics": [
      {
        "tactic": "rintro \u27e8x, hx\u27e9",
        "annotated_tactic": [
          "rintro \u27e8x, hx\u27e9",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Fintype \u03b1\ns t : Finset \u03b1\ninst\u271d : Subsingleton \u03b1\n\u22a2 s.Nonempty \u2192 s = univ",
        "state_after": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Fintype \u03b1\ns t : Finset \u03b1\ninst\u271d : Subsingleton \u03b1\nx : \u03b1\nhx : x \u2208 s\n\u22a2 s = univ"
      },
      {
        "tactic": "exact eq_univ_of_forall fun y => by rwa [Subsingleton.elim y x]",
        "annotated_tactic": [
          "exact <a>eq_univ_of_forall</a> fun y => by rwa [<a>Subsingleton.elim</a> y x]",
          [
            {
              "full_name": "Finset.eq_univ_of_forall",
              "def_path": "Mathlib/Data/Fintype/Basic.lean",
              "def_pos": [
                87,
                9
              ],
              "def_end_pos": [
                87,
                26
              ]
            },
            {
              "full_name": "Subsingleton.elim",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1015,
                19
              ],
              "def_end_pos": [
                1015,
                36
              ]
            }
          ]
        ],
        "state_before": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Fintype \u03b1\ns t : Finset \u03b1\ninst\u271d : Subsingleton \u03b1\nx : \u03b1\nhx : x \u2208 s\n\u22a2 s = univ",
        "state_after": "no goals"
      },
      {
        "tactic": "rwa [Subsingleton.elim y x]",
        "annotated_tactic": [
          "rwa [<a>Subsingleton.elim</a> y x]",
          [
            {
              "full_name": "Subsingleton.elim",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1015,
                19
              ],
              "def_end_pos": [
                1015,
                36
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Fintype \u03b1\ns t : Finset \u03b1\ninst\u271d : Subsingleton \u03b1\nx : \u03b1\nhx : x \u2208 s\ny : \u03b1\n\u22a2 y \u2208 s",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.4610355959739536,
    "entry_failed": false
  },
  "9634": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Perm/Basic.lean",
    "full_name": "Equiv.Perm.sigmaCongrRightHom_injective",
    "start": [
      278,
      1
    ],
    "end": [
      282,
      39
    ],
    "traced_tactics": [
      {
        "tactic": "intro x y h",
        "annotated_tactic": [
          "intro x y h",
          []
        ],
        "state_before": "\u03b1\u271d : Type u\n\u03b2\u271d : Type v\n\u03b1 : Type u_1\n\u03b2 : \u03b1 \u2192 Type u_2\n\u22a2 Function.Injective \u21d1(sigmaCongrRightHom \u03b2)",
        "state_after": "\u03b1\u271d : Type u\n\u03b2\u271d : Type v\n\u03b1 : Type u_1\n\u03b2 : \u03b1 \u2192 Type u_2\nx y : (a : \u03b1) \u2192 Perm (\u03b2 a)\nh : (sigmaCongrRightHom \u03b2) x = (sigmaCongrRightHom \u03b2) y\n\u22a2 x = y"
      },
      {
        "tactic": "ext a b",
        "annotated_tactic": [
          "ext a b",
          []
        ],
        "state_before": "\u03b1\u271d : Type u\n\u03b2\u271d : Type v\n\u03b1 : Type u_1\n\u03b2 : \u03b1 \u2192 Type u_2\nx y : (a : \u03b1) \u2192 Perm (\u03b2 a)\nh : (sigmaCongrRightHom \u03b2) x = (sigmaCongrRightHom \u03b2) y\n\u22a2 x = y",
        "state_after": "case h.H\n\u03b1\u271d : Type u\n\u03b2\u271d : Type v\n\u03b1 : Type u_1\n\u03b2 : \u03b1 \u2192 Type u_2\nx y : (a : \u03b1) \u2192 Perm (\u03b2 a)\nh : (sigmaCongrRightHom \u03b2) x = (sigmaCongrRightHom \u03b2) y\na : \u03b1\nb : \u03b2 a\n\u22a2 (x a) b = (y a) b"
      },
      {
        "tactic": "simpa using Equiv.congr_fun h \u27e8a, b\u27e9",
        "annotated_tactic": [
          "simpa using <a>Equiv.congr_fun</a> h \u27e8a, b\u27e9",
          [
            {
              "full_name": "Equiv.congr_fun",
              "def_path": "Mathlib/Logic/Equiv/Defs.lean",
              "def_pos": [
                133,
                19
              ],
              "def_end_pos": [
                133,
                28
              ]
            }
          ]
        ],
        "state_before": "case h.H\n\u03b1\u271d : Type u\n\u03b2\u271d : Type v\n\u03b1 : Type u_1\n\u03b2 : \u03b1 \u2192 Type u_2\nx y : (a : \u03b1) \u2192 Perm (\u03b2 a)\nh : (sigmaCongrRightHom \u03b2) x = (sigmaCongrRightHom \u03b2) y\na : \u03b1\nb : \u03b2 a\n\u22a2 (x a) b = (y a) b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.0138873850228265,
    "entry_failed": false
  },
  "9659": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/Divisors.lean",
    "full_name": "Nat.dvd_of_mem_divisors",
    "start": [
      109,
      1
    ],
    "end": [
      112,
      28
    ],
    "traced_tactics": [
      {
        "tactic": "cases m",
        "annotated_tactic": [
          "cases m",
          []
        ],
        "state_before": "n m : \u2115\nh : n \u2208 m.divisors\n\u22a2 n \u2223 m",
        "state_after": "case zero\nn : \u2115\nh : n \u2208 divisors 0\n\u22a2 n \u2223 0\n\ncase succ\nn n\u271d : \u2115\nh : n \u2208 (n\u271d + 1).divisors\n\u22a2 n \u2223 n\u271d + 1"
      },
      {
        "tactic": "apply dvd_zero",
        "annotated_tactic": [
          "apply <a>dvd_zero</a>",
          [
            {
              "full_name": "dvd_zero",
              "def_path": "Mathlib/Algebra/GroupWithZero/Divisibility.lean",
              "def_pos": [
                41,
                9
              ],
              "def_end_pos": [
                41,
                17
              ]
            }
          ]
        ],
        "state_before": "case zero\nn : \u2115\nh : n \u2208 divisors 0\n\u22a2 n \u2223 0",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [mem_divisors.1 h]",
        "annotated_tactic": [
          "simp [<a>mem_divisors</a>.1 h]",
          [
            {
              "full_name": "Nat.mem_divisors",
              "def_path": "Mathlib/NumberTheory/Divisors.lean",
              "def_pos": [
                95,
                9
              ],
              "def_end_pos": [
                95,
                21
              ]
            }
          ]
        ],
        "state_before": "case succ\nn n\u271d : \u2115\nh : n \u2208 (n\u271d + 1).divisors\n\u22a2 n \u2223 n\u271d + 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.871342696947977,
    "entry_failed": false
  },
  "9716": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Polynomial/Monic.lean",
    "full_name": "Polynomial.Monic.not_dvd_of_natDegree_lt",
    "start": [
      203,
      1
    ],
    "end": [
      207,
      41
    ],
    "traced_tactics": [
      {
        "tactic": "rintro \u27e8r, rfl\u27e9",
        "annotated_tactic": [
          "rintro \u27e8r, rfl\u27e9",
          []
        ],
        "state_before": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : p.Monic\nh0 : q \u2260 0\nhl : q.natDegree < p.natDegree\n\u22a2 \u00acp \u2223 q",
        "state_after": "case intro\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np r\u271d : R[X]\nhp : p.Monic\nr : R[X]\nh0 : p * r \u2260 0\nhl : (p * r).natDegree < p.natDegree\n\u22a2 False"
      },
      {
        "tactic": "rw [hp.natDegree_mul' <| right_ne_zero_of_mul h0] at hl",
        "annotated_tactic": [
          "rw [hp.natDegree_mul' <| <a>right_ne_zero_of_mul</a> h0] at hl",
          [
            {
              "full_name": "right_ne_zero_of_mul",
              "def_path": "Mathlib/Algebra/GroupWithZero/Basic.lean",
              "def_pos": [
                56,
                9
              ],
              "def_end_pos": [
                56,
                29
              ]
            }
          ]
        ],
        "state_before": "case intro\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np r\u271d : R[X]\nhp : p.Monic\nr : R[X]\nh0 : p * r \u2260 0\nhl : (p * r).natDegree < p.natDegree\n\u22a2 False",
        "state_after": "case intro\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np r\u271d : R[X]\nhp : p.Monic\nr : R[X]\nh0 : p * r \u2260 0\nhl : p.natDegree + r.natDegree < p.natDegree\n\u22a2 False"
      },
      {
        "tactic": "exact hl.not_le (Nat.le_add_right _ _)",
        "annotated_tactic": [
          "exact hl.not_le (<a>Nat.le_add_right</a> _ _)",
          [
            {
              "full_name": "Nat.le_add_right",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean",
              "def_pos": [
                395,
                9
              ],
              "def_end_pos": [
                395,
                21
              ]
            }
          ]
        ],
        "state_before": "case intro\nR : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np r\u271d : R[X]\nhp : p.Monic\nr : R[X]\nh0 : p * r \u2260 0\nhl : p.natDegree + r.natDegree < p.natDegree\n\u22a2 False",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.114734017988667,
    "entry_failed": false
  },
  "9722": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Int/Lemmas.lean",
    "full_name": "Int.le_natCast_sub",
    "start": [
      26,
      1
    ],
    "end": [
      29,
      36
    ],
    "traced_tactics": [
      {
        "tactic": "by_cases h : m \u2265 n",
        "annotated_tactic": [
          "by_cases h : m \u2265 n",
          []
        ],
        "state_before": "m n : \u2115\n\u22a2 \u2191m - \u2191n \u2264 \u2191(m - n)",
        "state_after": "case pos\nm n : \u2115\nh : m \u2265 n\n\u22a2 \u2191m - \u2191n \u2264 \u2191(m - n)\n\ncase neg\nm n : \u2115\nh : \u00acm \u2265 n\n\u22a2 \u2191m - \u2191n \u2264 \u2191(m - n)"
      },
      {
        "tactic": "exact le_of_eq (Int.ofNat_sub h).symm",
        "annotated_tactic": [
          "exact <a>le_of_eq</a> (<a>Int.ofNat_sub</a> h).<a>symm</a>",
          [
            {
              "full_name": "le_of_eq",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                72,
                9
              ],
              "def_end_pos": [
                72,
                17
              ]
            },
            {
              "full_name": "Int.ofNat_sub",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Lemmas.lean",
              "def_pos": [
                302,
                22
              ],
              "def_end_pos": [
                302,
                31
              ]
            },
            {
              "full_name": "Eq.symm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                323,
                9
              ],
              "def_end_pos": [
                323,
                16
              ]
            }
          ]
        ],
        "state_before": "case pos\nm n : \u2115\nh : m \u2265 n\n\u22a2 \u2191m - \u2191n \u2264 \u2191(m - n)",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [le_of_not_ge h, ofNat_le]",
        "annotated_tactic": [
          "simp [<a>le_of_not_ge</a> h, <a>ofNat_le</a>]",
          [
            {
              "full_name": "le_of_not_ge",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                301,
                9
              ],
              "def_end_pos": [
                301,
                21
              ]
            },
            {
              "full_name": "Int.ofNat_le",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean",
              "def_pos": [
                51,
                28
              ],
              "def_end_pos": [
                51,
                36
              ]
            }
          ]
        ],
        "state_before": "case neg\nm n : \u2115\nh : \u00acm \u2265 n\n\u22a2 \u2191m - \u2191n \u2264 \u2191(m - n)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.0873846430331469,
    "entry_failed": false
  },
  "9737": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Category/Compactum.lean",
    "full_name": "Compactum.str_hom_commute",
    "start": [
      149,
      1
    ],
    "end": [
      153,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "change (X.a \u226b f.f) _ = _",
        "annotated_tactic": [
          "change (X.a \u226b f.f) _ = _",
          []
        ],
        "state_before": "X Y : Compactum\nf : X \u27f6 Y\nxs : Ultrafilter X.A\n\u22a2 f.f (X.str xs) = Y.str (Ultrafilter.map f.f xs)",
        "state_after": "X Y : Compactum\nf : X \u27f6 Y\nxs : Ultrafilter X.A\n\u22a2 (X.a \u226b f.f) xs = Y.str (Ultrafilter.map f.f xs)"
      },
      {
        "tactic": "rw [\u2190 f.h]",
        "annotated_tactic": [
          "rw [\u2190 f.h]",
          []
        ],
        "state_before": "X Y : Compactum\nf : X \u27f6 Y\nxs : Ultrafilter X.A\n\u22a2 (X.a \u226b f.f) xs = Y.str (Ultrafilter.map f.f xs)",
        "state_after": "X Y : Compactum\nf : X \u27f6 Y\nxs : Ultrafilter X.A\n\u22a2 (\u03b2.map f.f \u226b Y.a) xs = Y.str (Ultrafilter.map f.f xs)"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "X Y : Compactum\nf : X \u27f6 Y\nxs : Ultrafilter X.A\n\u22a2 (\u03b2.map f.f \u226b Y.a) xs = Y.str (Ultrafilter.map f.f xs)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.3303556389873847,
    "entry_failed": false
  },
  "9760": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/Asymptotics/SpecificAsymptotics.lean",
    "full_name": "tendsto_pow_div_pow_atTop_atTop",
    "start": [
      56,
      1
    ],
    "end": [
      60,
      8
    ],
    "traced_tactics": [
      {
        "tactic": "rw [tendsto_congr' pow_div_pow_eventuallyEq_atTop]",
        "annotated_tactic": [
          "rw [<a>tendsto_congr'</a> <a>pow_div_pow_eventuallyEq_atTop</a>]",
          [
            {
              "full_name": "Filter.tendsto_congr'",
              "def_path": "Mathlib/Order/Filter/Basic.lean",
              "def_pos": [
                3071,
                9
              ],
              "def_end_pos": [
                3071,
                23
              ]
            },
            {
              "full_name": "pow_div_pow_eventuallyEq_atTop",
              "def_path": "Mathlib/Analysis/Asymptotics/SpecificAsymptotics.lean",
              "def_pos": [
                42,
                9
              ],
              "def_end_pos": [
                42,
                39
              ]
            }
          ]
        ],
        "state_before": "\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\np q : \u2115\nhpq : q < p\n\u22a2 Tendsto (fun x => x ^ p / x ^ q) atTop atTop",
        "state_after": "\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\np q : \u2115\nhpq : q < p\n\u22a2 Tendsto (fun x => x ^ (\u2191p - \u2191q)) atTop atTop"
      },
      {
        "tactic": "apply tendsto_zpow_atTop_atTop",
        "annotated_tactic": [
          "apply <a>tendsto_zpow_atTop_atTop</a>",
          [
            {
              "full_name": "Filter.tendsto_zpow_atTop_atTop",
              "def_path": "Mathlib/Order/Filter/AtTopBot.lean",
              "def_pos": [
                1123,
                7
              ],
              "def_end_pos": [
                1123,
                31
              ]
            }
          ]
        ],
        "state_before": "\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\np q : \u2115\nhpq : q < p\n\u22a2 Tendsto (fun x => x ^ (\u2191p - \u2191q)) atTop atTop",
        "state_after": "case hn\n\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\np q : \u2115\nhpq : q < p\n\u22a2 0 < \u2191p - \u2191q"
      },
      {
        "tactic": "omega",
        "annotated_tactic": [
          "omega",
          []
        ],
        "state_before": "case hn\n\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\np q : \u2115\nhpq : q < p\n\u22a2 0 < \u2191p - \u2191q",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9504137360490859,
    "entry_failed": false
  },
  "9763": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/LegendreSymbol/Basic.lean",
    "full_name": "legendreSym.sq_one'",
    "start": [
      179,
      1
    ],
    "end": [
      182,
      33
    ],
    "traced_tactics": [
      {
        "tactic": "dsimp only [legendreSym]",
        "annotated_tactic": [
          "dsimp only [<a>legendreSym</a>]",
          [
            {
              "full_name": "legendreSym",
              "def_path": "Mathlib/NumberTheory/LegendreSymbol/Basic.lean",
              "def_pos": [
                109,
                5
              ],
              "def_end_pos": [
                109,
                16
              ]
            }
          ]
        ],
        "state_before": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : \u2124\nha : \u2191a \u2260 0\n\u22a2 legendreSym p (a ^ 2) = 1",
        "state_after": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : \u2124\nha : \u2191a \u2260 0\n\u22a2 (quadraticChar (ZMod p)) \u2191(a ^ 2) = 1"
      },
      {
        "tactic": "rw [Int.cast_pow]",
        "annotated_tactic": [
          "rw [<a>Int.cast_pow</a>]",
          [
            {
              "full_name": "Int.cast_pow",
              "def_path": "Mathlib/Algebra/Ring/Int.lean",
              "def_pos": [
                68,
                26
              ],
              "def_end_pos": [
                68,
                34
              ]
            }
          ]
        ],
        "state_before": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : \u2124\nha : \u2191a \u2260 0\n\u22a2 (quadraticChar (ZMod p)) \u2191(a ^ 2) = 1",
        "state_after": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : \u2124\nha : \u2191a \u2260 0\n\u22a2 (quadraticChar (ZMod p)) (\u2191a ^ 2) = 1"
      },
      {
        "tactic": "exact quadraticChar_sq_one' ha",
        "annotated_tactic": [
          "exact <a>quadraticChar_sq_one'</a> ha",
          [
            {
              "full_name": "quadraticChar_sq_one'",
              "def_path": "Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/Basic.lean",
              "def_pos": [
                156,
                9
              ],
              "def_end_pos": [
                156,
                30
              ]
            }
          ]
        ],
        "state_before": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : \u2124\nha : \u2191a \u2260 0\n\u22a2 (quadraticChar (ZMod p)) (\u2191a ^ 2) = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.826100329984911,
    "entry_failed": false
  },
  "9848": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Polynomial/Pochhammer.lean",
    "full_name": "descPochhammer_map",
    "start": [
      276,
      1
    ],
    "end": [
      280,
      50
    ],
    "traced_tactics": [
      {
        "tactic": "induction' n with n ih",
        "annotated_tactic": [
          "induction' n with n ih",
          []
        ],
        "state_before": "R : Type u\ninst\u271d\u00b9 : Ring R\nT : Type v\ninst\u271d : Ring T\nf : R \u2192+* T\nn : \u2115\n\u22a2 map f (descPochhammer R n) = descPochhammer T n",
        "state_after": "case zero\nR : Type u\ninst\u271d\u00b9 : Ring R\nT : Type v\ninst\u271d : Ring T\nf : R \u2192+* T\n\u22a2 map f (descPochhammer R 0) = descPochhammer T 0\n\ncase succ\nR : Type u\ninst\u271d\u00b9 : Ring R\nT : Type v\ninst\u271d : Ring T\nf : R \u2192+* T\nn : \u2115\nih : map f (descPochhammer R n) = descPochhammer T n\n\u22a2 map f (descPochhammer R (n + 1)) = descPochhammer T (n + 1)"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case zero\nR : Type u\ninst\u271d\u00b9 : Ring R\nT : Type v\ninst\u271d : Ring T\nf : R \u2192+* T\n\u22a2 map f (descPochhammer R 0) = descPochhammer T 0",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [ih, descPochhammer_succ_left, map_comp]",
        "annotated_tactic": [
          "simp [ih, <a>descPochhammer_succ_left</a>, <a>map_comp</a>]",
          [
            {
              "full_name": "descPochhammer_succ_left",
              "def_path": "Mathlib/RingTheory/Polynomial/Pochhammer.lean",
              "def_pos": [
                258,
                9
              ],
              "def_end_pos": [
                258,
                33
              ]
            },
            {
              "full_name": "Polynomial.map_comp",
              "def_path": "Mathlib/Algebra/Polynomial/Eval.lean",
              "def_pos": [
                973,
                9
              ],
              "def_end_pos": [
                973,
                17
              ]
            }
          ]
        ],
        "state_before": "case succ\nR : Type u\ninst\u271d\u00b9 : Ring R\nT : Type v\ninst\u271d : Ring T\nf : R \u2192+* T\nn : \u2115\nih : map f (descPochhammer R n) = descPochhammer T n\n\u22a2 map f (descPochhammer R (n + 1)) = descPochhammer T (n + 1)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.414950920967385,
    "entry_failed": false
  },
  "9871": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean",
    "full_name": "CategoryTheory.Limits.IsZero.of_mono",
    "start": [
      235,
      1
    ],
    "end": [
      238,
      32
    ],
    "traced_tactics": [
      {
        "tactic": "have hf := i.eq_zero_of_tgt f",
        "annotated_tactic": [
          "have hf := i.eq_zero_of_tgt f",
          []
        ],
        "state_before": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nD : Type u'\ninst\u271d\u00b2 : Category.{v', u'} D\ninst\u271d\u00b9 : HasZeroMorphisms C\nX Y : C\nf : X \u27f6 Y\ninst\u271d : Mono f\ni : IsZero Y\n\u22a2 IsZero X",
        "state_after": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nD : Type u'\ninst\u271d\u00b2 : Category.{v', u'} D\ninst\u271d\u00b9 : HasZeroMorphisms C\nX Y : C\nf : X \u27f6 Y\ninst\u271d : Mono f\ni : IsZero Y\nhf : f = 0\n\u22a2 IsZero X"
      },
      {
        "tactic": "subst hf",
        "annotated_tactic": [
          "subst hf",
          []
        ],
        "state_before": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nD : Type u'\ninst\u271d\u00b2 : Category.{v', u'} D\ninst\u271d\u00b9 : HasZeroMorphisms C\nX Y : C\nf : X \u27f6 Y\ninst\u271d : Mono f\ni : IsZero Y\nhf : f = 0\n\u22a2 IsZero X",
        "state_after": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nD : Type u'\ninst\u271d\u00b2 : Category.{v', u'} D\ninst\u271d\u00b9 : HasZeroMorphisms C\nX Y : C\ni : IsZero Y\ninst\u271d : Mono 0\n\u22a2 IsZero X"
      },
      {
        "tactic": "exact IsZero.of_mono_zero X Y",
        "annotated_tactic": [
          "exact <a>IsZero.of_mono_zero</a> X Y",
          [
            {
              "full_name": "CategoryTheory.Limits.IsZero.of_mono_zero",
              "def_path": "Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean",
              "def_pos": [
                197,
                9
              ],
              "def_end_pos": [
                197,
                21
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nD : Type u'\ninst\u271d\u00b2 : Category.{v', u'} D\ninst\u271d\u00b9 : HasZeroMorphisms C\nX Y : C\ni : IsZero Y\ninst\u271d : Mono 0\n\u22a2 IsZero X",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.3365181270055473,
    "entry_failed": false
  },
  "9877": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Digits.lean",
    "full_name": "Nat.ofDigits_lt_base_pow_length",
    "start": [
      440,
      1
    ],
    "end": [
      443,
      40
    ],
    "traced_tactics": [
      {
        "tactic": "rcases b with (_ | _ | b) <;> try simp_all",
        "annotated_tactic": [
          "rcases b with (_ | _ | b) <;> try simp_all",
          []
        ],
        "state_before": "n b : \u2115\nl : List \u2115\nhb : 1 < b\nhl : \u2200 x \u2208 l, x < b\n\u22a2 ofDigits b l < b ^ l.length",
        "state_after": "case succ.succ\nn : \u2115\nl : List \u2115\nb : \u2115\nhl : \u2200 x \u2208 l, x < b + 1 + 1\n\u22a2 ofDigits (b + 1 + 1) l < (b + 1 + 1) ^ l.length"
      },
      {
        "tactic": "exact ofDigits_lt_base_pow_length' hl",
        "annotated_tactic": [
          "exact <a>ofDigits_lt_base_pow_length'</a> hl",
          [
            {
              "full_name": "Nat.ofDigits_lt_base_pow_length'",
              "def_path": "Mathlib/Data/Nat/Digits.lean",
              "def_pos": [
                427,
                9
              ],
              "def_end_pos": [
                427,
                37
              ]
            }
          ]
        ],
        "state_before": "case succ.succ\nn : \u2115\nl : List \u2115\nb : \u2115\nhl : \u2200 x \u2208 l, x < b + 1 + 1\n\u22a2 ofDigits (b + 1 + 1) l < (b + 1 + 1) ^ l.length",
        "state_after": "no goals"
      },
      {
        "tactic": "simp_all",
        "annotated_tactic": [
          "simp_all",
          []
        ],
        "state_before": "case succ.succ\nn : \u2115\nl : List \u2115\nb : \u2115\nhb : 1 < b + 1 + 1\nhl : \u2200 x \u2208 l, x < b + 1 + 1\n\u22a2 ofDigits (b + 1 + 1) l < (b + 1 + 1) ^ l.length",
        "state_after": "case succ.succ\nn : \u2115\nl : List \u2115\nb : \u2115\nhl : \u2200 x \u2208 l, x < b + 1 + 1\n\u22a2 ofDigits (b + 1 + 1) l < (b + 1 + 1) ^ l.length"
      }
    ],
    "entry_time": 4.678922159946524,
    "entry_failed": false
  },
  "9898": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/Complex/Angle.lean",
    "full_name": "Complex.angle_le_mul_norm_sub",
    "start": [
      118,
      1
    ],
    "end": [
      120,
      98
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 div_le_iff' <| by positivity, div_eq_inv_mul, inv_div]",
        "annotated_tactic": [
          "rw [\u2190 <a>div_le_iff'</a> <| by positivity, <a>div_eq_inv_mul</a>, <a>inv_div</a>]",
          [
            {
              "full_name": "div_le_iff'",
              "def_path": "Mathlib/Algebra/Order/Field/Basic.lean",
              "def_pos": [
                76,
                9
              ],
              "def_end_pos": [
                76,
                20
              ]
            },
            {
              "full_name": "div_eq_inv_mul",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                736,
                9
              ],
              "def_end_pos": [
                736,
                23
              ]
            },
            {
              "full_name": "inv_div",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                554,
                9
              ],
              "def_end_pos": [
                554,
                16
              ]
            }
          ]
        ],
        "state_before": "a x y : \u2102\nhx : \u2016x\u2016 = 1\nhy : \u2016y\u2016 = 1\n\u22a2 angle x y \u2264 \u03c0 / 2 * \u2016x - y\u2016",
        "state_after": "a x y : \u2102\nhx : \u2016x\u2016 = 1\nhy : \u2016y\u2016 = 1\n\u22a2 2 / \u03c0 * angle x y \u2264 \u2016x - y\u2016"
      },
      {
        "tactic": "exact mul_angle_le_norm_sub hx hy",
        "annotated_tactic": [
          "exact <a>mul_angle_le_norm_sub</a> hx hy",
          [
            {
              "full_name": "Complex.mul_angle_le_norm_sub",
              "def_path": "Mathlib/Analysis/Complex/Angle.lean",
              "def_pos": [
                115,
                7
              ],
              "def_end_pos": [
                115,
                28
              ]
            }
          ]
        ],
        "state_before": "a x y : \u2102\nhx : \u2016x\u2016 = 1\nhy : \u2016y\u2016 = 1\n\u22a2 2 / \u03c0 * angle x y \u2264 \u2016x - y\u2016",
        "state_after": "no goals"
      },
      {
        "tactic": "positivity",
        "annotated_tactic": [
          "positivity",
          []
        ],
        "state_before": "a x y : \u2102\nhx : \u2016x\u2016 = 1\nhy : \u2016y\u2016 = 1\n\u22a2 0 < \u03c0 / 2",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.9997793830698356,
    "entry_failed": false
  },
  "9951": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Category/Profinite/Limits.lean",
    "full_name": "Profinite.finiteCoproduct.\u03b9_desc_apply",
    "start": [
      213,
      1
    ],
    "end": [
      217,
      21
    ],
    "traced_tactics": [
      {
        "tactic": "intro x",
        "annotated_tactic": [
          "intro x",
          []
        ],
        "state_before": "\u03b1 : Type w\ninst\u271d : Finite \u03b1\nX : \u03b1 \u2192 Profinite\nB : Profinite\n\u03c0 : (a : \u03b1) \u2192 X a \u27f6 B\na : \u03b1\n\u22a2 \u2200 (x : (forget Profinite).obj (X a)), (desc X \u03c0) ((\u03b9 X a) x) = (\u03c0 a) x",
        "state_after": "\u03b1 : Type w\ninst\u271d : Finite \u03b1\nX : \u03b1 \u2192 Profinite\nB : Profinite\n\u03c0 : (a : \u03b1) \u2192 X a \u27f6 B\na : \u03b1\nx : (forget Profinite).obj (X a)\n\u22a2 (desc X \u03c0) ((\u03b9 X a) x) = (\u03c0 a) x"
      },
      {
        "tactic": "change (\u03b9 X a \u226b desc X \u03c0) _ = _",
        "annotated_tactic": [
          "change (<a>\u03b9</a> X a \u226b <a>desc</a> X \u03c0) _ = _",
          [
            {
              "full_name": "Profinite.finiteCoproduct.\u03b9",
              "def_path": "Mathlib/Topology/Category/Profinite/Limits.lean",
              "def_pos": [
                148,
                5
              ],
              "def_end_pos": [
                148,
                22
              ]
            },
            {
              "full_name": "Profinite.finiteCoproduct.desc",
              "def_path": "Mathlib/Topology/Category/Profinite/Limits.lean",
              "def_pos": [
                157,
                5
              ],
              "def_end_pos": [
                157,
                25
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type w\ninst\u271d : Finite \u03b1\nX : \u03b1 \u2192 Profinite\nB : Profinite\n\u03c0 : (a : \u03b1) \u2192 X a \u27f6 B\na : \u03b1\nx : (forget Profinite).obj (X a)\n\u22a2 (desc X \u03c0) ((\u03b9 X a) x) = (\u03c0 a) x",
        "state_after": "\u03b1 : Type w\ninst\u271d : Finite \u03b1\nX : \u03b1 \u2192 Profinite\nB : Profinite\n\u03c0 : (a : \u03b1) \u2192 X a \u27f6 B\na : \u03b1\nx : (forget Profinite).obj (X a)\n\u22a2 (\u03b9 X a \u226b desc X \u03c0) x = (\u03c0 a) x"
      },
      {
        "tactic": "simp only [\u03b9_desc]",
        "annotated_tactic": [
          "simp only [<a>\u03b9_desc</a>]",
          [
            {
              "full_name": "Profinite.finiteCoproduct.\u03b9_desc",
              "def_path": "Mathlib/Topology/Category/Profinite/Limits.lean",
              "def_pos": [
                166,
                7
              ],
              "def_end_pos": [
                166,
                29
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type w\ninst\u271d : Finite \u03b1\nX : \u03b1 \u2192 Profinite\nB : Profinite\n\u03c0 : (a : \u03b1) \u2192 X a \u27f6 B\na : \u03b1\nx : (forget Profinite).obj (X a)\n\u22a2 (\u03b9 X a \u226b desc X \u03c0) x = (\u03c0 a) x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.203344000969082,
    "entry_failed": false
  },
  "10025": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Squarefree/Basic.lean",
    "full_name": "not_squarefree_zero",
    "start": [
      55,
      1
    ],
    "end": [
      57,
      21
    ],
    "traced_tactics": [
      {
        "tactic": "erw [not_forall]",
        "annotated_tactic": [
          "erw [<a>not_forall</a>]",
          [
            {
              "full_name": "Classical.not_forall",
              "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean",
              "def_pos": [
                137,
                21
              ],
              "def_end_pos": [
                137,
                31
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d\u00b9 : MonoidWithZero R\ninst\u271d : Nontrivial R\n\u22a2 \u00acSquarefree 0",
        "state_after": "R : Type u_1\ninst\u271d\u00b9 : MonoidWithZero R\ninst\u271d : Nontrivial R\n\u22a2 \u2203 x, \u00ac(x * x \u2223 0 \u2192 IsUnit x)"
      },
      {
        "tactic": "exact \u27e80, by simp\u27e9",
        "annotated_tactic": [
          "exact \u27e80, by simp\u27e9",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d\u00b9 : MonoidWithZero R\ninst\u271d : Nontrivial R\n\u22a2 \u2203 x, \u00ac(x * x \u2223 0 \u2192 IsUnit x)",
        "state_after": "no goals"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d\u00b9 : MonoidWithZero R\ninst\u271d : Nontrivial R\n\u22a2 \u00ac(0 * 0 \u2223 0 \u2192 IsUnit 0)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7990843000588939,
    "entry_failed": false
  },
  "10121": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Divisibility/Basic.lean",
    "full_name": "mul_dvd_mul_left",
    "start": [
      171,
      1
    ],
    "end": [
      174,
      17
    ],
    "traced_tactics": [
      {
        "tactic": "obtain \u27e8d, rfl\u27e9 := h",
        "annotated_tactic": [
          "obtain \u27e8d, rfl\u27e9 := h",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na\u271d b c : \u03b1\nm n : \u2115\na : \u03b1\nh : b \u2223 c\n\u22a2 a * b \u2223 a * c",
        "state_after": "case intro\n\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na\u271d b : \u03b1\nm n : \u2115\na d : \u03b1\n\u22a2 a * b \u2223 a * (b * d)"
      },
      {
        "tactic": "use d",
        "annotated_tactic": [
          "use d",
          []
        ],
        "state_before": "case intro\n\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na\u271d b : \u03b1\nm n : \u2115\na d : \u03b1\n\u22a2 a * b \u2223 a * (b * d)",
        "state_after": "case h\n\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na\u271d b : \u03b1\nm n : \u2115\na d : \u03b1\n\u22a2 a * (b * d) = a * b * d"
      },
      {
        "tactic": "rw [mul_assoc]",
        "annotated_tactic": [
          "rw [<a>mul_assoc</a>]",
          [
            {
              "full_name": "mul_assoc",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                289,
                9
              ],
              "def_end_pos": [
                289,
                18
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\na\u271d b : \u03b1\nm n : \u2115\na d : \u03b1\n\u22a2 a * (b * d) = a * b * d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4886295459000394,
    "entry_failed": false
  },
  "10159": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/Quotient.lean",
    "full_name": "CategoryTheory.Quotient.functor_map_eq_iff",
    "start": [
      153,
      1
    ],
    "end": [
      157,
      57
    ],
    "traced_tactics": [
      {
        "tactic": "dsimp [functor]",
        "annotated_tactic": [
          "dsimp [<a>functor</a>]",
          [
            {
              "full_name": "CategoryTheory.Quotient.functor",
              "def_path": "Mathlib/CategoryTheory/Quotient.lean",
              "def_pos": [
                113,
                5
              ],
              "def_end_pos": [
                113,
                12
              ]
            }
          ]
        ],
        "state_before": "C : Type u_1\ninst\u271d : Category.{u_2, u_1} C\nr : HomRel C\nh : Congruence r\nX Y : C\nf f' : X \u27f6 Y\n\u22a2 (functor r).map f = (functor r).map f' \u2194 r f f'",
        "state_after": "C : Type u_1\ninst\u271d : Category.{u_2, u_1} C\nr : HomRel C\nh : Congruence r\nX Y : C\nf f' : X \u27f6 Y\n\u22a2 Quot.mk (CompClosure r) f = Quot.mk (CompClosure r) f' \u2194 r f f'"
      },
      {
        "tactic": "rw [Equivalence.quot_mk_eq_iff, compClosure_eq_self r]",
        "annotated_tactic": [
          "rw [<a>Equivalence.quot_mk_eq_iff</a>, <a>compClosure_eq_self</a> r]",
          [
            {
              "full_name": "Equivalence.quot_mk_eq_iff",
              "def_path": "Mathlib/Data/Quot.lean",
              "def_pos": [
                848,
                7
              ],
              "def_end_pos": [
                848,
                33
              ]
            },
            {
              "full_name": "CategoryTheory.Quotient.compClosure_eq_self",
              "def_path": "Mathlib/CategoryTheory/Quotient.lean",
              "def_pos": [
                148,
                9
              ],
              "def_end_pos": [
                148,
                28
              ]
            }
          ]
        ],
        "state_before": "C : Type u_1\ninst\u271d : Category.{u_2, u_1} C\nr : HomRel C\nh : Congruence r\nX Y : C\nf f' : X \u27f6 Y\n\u22a2 Quot.mk (CompClosure r) f = Quot.mk (CompClosure r) f' \u2194 r f f'",
        "state_after": "case h\nC : Type u_1\ninst\u271d : Category.{u_2, u_1} C\nr : HomRel C\nh : Congruence r\nX Y : C\nf f' : X \u27f6 Y\n\u22a2 _root_.Equivalence (CompClosure r)"
      },
      {
        "tactic": "simpa only [compClosure_eq_self r] using h.equivalence",
        "annotated_tactic": [
          "simpa only [<a>compClosure_eq_self</a> r] using h.equivalence",
          [
            {
              "full_name": "CategoryTheory.Quotient.compClosure_eq_self",
              "def_path": "Mathlib/CategoryTheory/Quotient.lean",
              "def_pos": [
                148,
                9
              ],
              "def_end_pos": [
                148,
                28
              ]
            }
          ]
        ],
        "state_before": "case h\nC : Type u_1\ninst\u271d : Category.{u_2, u_1} C\nr : HomRel C\nh : Congruence r\nX Y : C\nf f' : X \u27f6 Y\n\u22a2 _root_.Equivalence (CompClosure r)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7219416699372232,
    "entry_failed": false
  },
  "10191": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/Young/SemistandardTableau.lean",
    "full_name": "SemistandardYoungTableau.col_weak",
    "start": [
      136,
      1
    ],
    "end": [
      140,
      41
    ],
    "traced_tactics": [
      {
        "tactic": "cases' eq_or_lt_of_le hi with h h",
        "annotated_tactic": [
          "cases' <a>eq_or_lt_of_le</a> hi with h h",
          [
            {
              "full_name": "eq_or_lt_of_le",
              "def_path": "Mathlib/Order/Basic.lean",
              "def_pos": [
                381,
                9
              ],
              "def_end_pos": [
                381,
                23
              ]
            }
          ]
        ],
        "state_before": "\u03bc : YoungDiagram\nT : SemistandardYoungTableau \u03bc\ni1 i2 j : \u2115\nhi : i1 \u2264 i2\ncell : (i2, j) \u2208 \u03bc\n\u22a2 T i1 j \u2264 T i2 j",
        "state_after": "case inl\n\u03bc : YoungDiagram\nT : SemistandardYoungTableau \u03bc\ni1 i2 j : \u2115\nhi : i1 \u2264 i2\ncell : (i2, j) \u2208 \u03bc\nh : i1 = i2\n\u22a2 T i1 j \u2264 T i2 j\n\ncase inr\n\u03bc : YoungDiagram\nT : SemistandardYoungTableau \u03bc\ni1 i2 j : \u2115\nhi : i1 \u2264 i2\ncell : (i2, j) \u2208 \u03bc\nh : i1 < i2\n\u22a2 T i1 j \u2264 T i2 j"
      },
      {
        "tactic": "rw [h]",
        "annotated_tactic": [
          "rw [h]",
          []
        ],
        "state_before": "case inl\n\u03bc : YoungDiagram\nT : SemistandardYoungTableau \u03bc\ni1 i2 j : \u2115\nhi : i1 \u2264 i2\ncell : (i2, j) \u2208 \u03bc\nh : i1 = i2\n\u22a2 T i1 j \u2264 T i2 j",
        "state_after": "no goals"
      },
      {
        "tactic": "exact le_of_lt (T.col_strict h cell)",
        "annotated_tactic": [
          "exact <a>le_of_lt</a> (T.col_strict h cell)",
          [
            {
              "full_name": "le_of_lt",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                110,
                9
              ],
              "def_end_pos": [
                110,
                17
              ]
            }
          ]
        ],
        "state_before": "case inr\n\u03bc : YoungDiagram\nT : SemistandardYoungTableau \u03bc\ni1 i2 j : \u2115\nhi : i1 \u2264 i2\ncell : (i2, j) \u2208 \u03bc\nh : i1 < i2\n\u22a2 T i1 j \u2264 T i2 j",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.3508842419832945,
    "entry_failed": false
  },
  "10215": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Archimedean.lean",
    "full_name": "pow_unbounded_of_one_lt",
    "start": [
      151,
      1
    ],
    "end": [
      154,
      42
    ],
    "traced_tactics": [
      {
        "tactic": "obtain \u27e8z, hz, rfl\u27e9 := exists_pos_add_of_lt' hy1",
        "annotated_tactic": [
          "obtain \u27e8z, hz, rfl\u27e9 := <a>exists_pos_add_of_lt'</a> hy1",
          [
            {
              "full_name": "exists_pos_add_of_lt'",
              "def_path": "Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean",
              "def_pos": [
                55,
                3
              ],
              "def_end_pos": [
                55,
                14
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : StrictOrderedSemiring \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ny : \u03b1\ninst\u271d : ExistsAddOfLE \u03b1\nx : \u03b1\nhy1 : 1 < y\n\u22a2 \u2203 n, x < y ^ n",
        "state_after": "case intro.intro\n\u03b1 : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : StrictOrderedSemiring \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : ExistsAddOfLE \u03b1\nx z : \u03b1\nhz : 0 < z\nhy1 : 1 < 1 + z\n\u22a2 \u2203 n, x < (1 + z) ^ n"
      },
      {
        "tactic": "rw [add_comm]",
        "annotated_tactic": [
          "rw [<a>add_comm</a>]",
          [
            {
              "full_name": "add_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                331,
                3
              ],
              "def_end_pos": [
                331,
                14
              ]
            }
          ]
        ],
        "state_before": "case intro.intro\n\u03b1 : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : StrictOrderedSemiring \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : ExistsAddOfLE \u03b1\nx z : \u03b1\nhz : 0 < z\nhy1 : 1 < 1 + z\n\u22a2 \u2203 n, x < (1 + z) ^ n",
        "state_after": "case intro.intro\n\u03b1 : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : StrictOrderedSemiring \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : ExistsAddOfLE \u03b1\nx z : \u03b1\nhz : 0 < z\nhy1 : 1 < 1 + z\n\u22a2 \u2203 n, x < (z + 1) ^ n"
      },
      {
        "tactic": "exact add_one_pow_unbounded_of_pos _ hz",
        "annotated_tactic": [
          "exact <a>add_one_pow_unbounded_of_pos</a> _ hz",
          [
            {
              "full_name": "add_one_pow_unbounded_of_pos",
              "def_path": "Mathlib/Algebra/Order/Archimedean.lean",
              "def_pos": [
                138,
                9
              ],
              "def_end_pos": [
                138,
                37
              ]
            }
          ]
        ],
        "state_before": "case intro.intro\n\u03b1 : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : StrictOrderedSemiring \u03b1\ninst\u271d\u00b9 : Archimedean \u03b1\ninst\u271d : ExistsAddOfLE \u03b1\nx z : \u03b1\nhz : 0 < z\nhy1 : 1 < 1 + z\n\u22a2 \u2203 n, x < (z + 1) ^ n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.706189131946303,
    "entry_failed": false
  },
  "10236": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/Divisors.lean",
    "full_name": "Nat.divisors_prime_pow",
    "start": [
      382,
      1
    ],
    "end": [
      386,
      30
    ],
    "traced_tactics": [
      {
        "tactic": "ext a",
        "annotated_tactic": [
          "ext a",
          []
        ],
        "state_before": "n p : \u2115\npp : Prime p\nk : \u2115\n\u22a2 (p ^ k).divisors = map { toFun := fun x => p ^ x, inj' := \u22ef } (range (k + 1))",
        "state_after": "case a\nn p : \u2115\npp : Prime p\nk a : \u2115\n\u22a2 a \u2208 (p ^ k).divisors \u2194 a \u2208 map { toFun := fun x => p ^ x, inj' := \u22ef } (range (k + 1))"
      },
      {
        "tactic": "rw [mem_divisors_prime_pow pp]",
        "annotated_tactic": [
          "rw [<a>mem_divisors_prime_pow</a> pp]",
          [
            {
              "full_name": "Nat.mem_divisors_prime_pow",
              "def_path": "Mathlib/NumberTheory/Divisors.lean",
              "def_pos": [
                367,
                9
              ],
              "def_end_pos": [
                367,
                31
              ]
            }
          ]
        ],
        "state_before": "case a\nn p : \u2115\npp : Prime p\nk a : \u2115\n\u22a2 a \u2208 (p ^ k).divisors \u2194 a \u2208 map { toFun := fun x => p ^ x, inj' := \u22ef } (range (k + 1))",
        "state_after": "case a\nn p : \u2115\npp : Prime p\nk a : \u2115\n\u22a2 (\u2203 j \u2264 k, a = p ^ j) \u2194 a \u2208 map { toFun := fun x => p ^ x, inj' := \u22ef } (range (k + 1))"
      },
      {
        "tactic": "simp [Nat.lt_succ, eq_comm]",
        "annotated_tactic": [
          "simp [<a>Nat.lt_succ</a>, <a>eq_comm</a>]",
          [
            {
              "full_name": "Nat.lt_succ",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean",
              "def_pos": [
                620,
                9
              ],
              "def_end_pos": [
                620,
                16
              ]
            },
            {
              "full_name": "eq_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                811,
                9
              ],
              "def_end_pos": [
                811,
                16
              ]
            }
          ]
        ],
        "state_before": "case a\nn p : \u2115\npp : Prime p\nk a : \u2115\n\u22a2 (\u2203 j \u2264 k, a = p ^ j) \u2194 a \u2208 map { toFun := fun x => p ^ x, inj' := \u22ef } (range (k + 1))",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.0762714060256258,
    "entry_failed": false
  },
  "10287": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Tropical/BigOperators.lean",
    "full_name": "trop_sum",
    "start": [
      51,
      1
    ],
    "end": [
      55,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "convert Multiset.trop_sum (s.val.map f)",
        "annotated_tactic": [
          "convert <a>Multiset.trop_sum</a> (s.val.map f)",
          [
            {
              "full_name": "Multiset.trop_sum",
              "def_path": "Mathlib/Algebra/Tropical/BigOperators.lean",
              "def_pos": [
                46,
                9
              ],
              "def_end_pos": [
                46,
                26
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\nS : Type u_2\ninst\u271d : AddCommMonoid R\ns : Finset S\nf : S \u2192 R\n\u22a2 trop (\u2211 i \u2208 s, f i) = \u220f i \u2208 s, trop (f i)",
        "state_after": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d : AddCommMonoid R\ns : Finset S\nf : S \u2192 R\n\u22a2 \u220f i \u2208 s, trop (f i) = (Multiset.map trop (Multiset.map f s.val)).prod"
      },
      {
        "tactic": "simp only [Multiset.map_map, Function.comp_apply]",
        "annotated_tactic": [
          "simp only [<a>Multiset.map_map</a>, <a>Function.comp_apply</a>]",
          [
            {
              "full_name": "Multiset.map_map",
              "def_path": "Mathlib/Data/Multiset/Basic.lean",
              "def_pos": [
                1332,
                9
              ],
              "def_end_pos": [
                1332,
                16
              ]
            },
            {
              "full_name": "Function.comp_apply",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                35,
                17
              ],
              "def_end_pos": [
                35,
                36
              ]
            }
          ]
        ],
        "state_before": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d : AddCommMonoid R\ns : Finset S\nf : S \u2192 R\n\u22a2 \u220f i \u2208 s, trop (f i) = (Multiset.map trop (Multiset.map f s.val)).prod",
        "state_after": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d : AddCommMonoid R\ns : Finset S\nf : S \u2192 R\n\u22a2 \u220f i \u2208 s, trop (f i) = (Multiset.map (fun i => trop (f i)) s.val).prod"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d : AddCommMonoid R\ns : Finset S\nf : S \u2192 R\n\u22a2 \u220f i \u2208 s, trop (f i) = (Multiset.map (fun i => trop (f i)) s.val).prod",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.34623467491474,
    "entry_failed": false
  },
  "10330": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Sigma.lean",
    "full_name": "List.lookupAll_nodup",
    "start": [
      326,
      1
    ],
    "end": [
      327,
      61
    ],
    "traced_tactics": [
      {
        "tactic": "(rw [lookupAll_eq_dlookup a h]; apply Option.toList_nodup)",
        "annotated_tactic": [
          "(rw [<a>lookupAll_eq_dlookup</a> a h]; apply <a>Option.toList_nodup</a>)",
          [
            {
              "full_name": "List.lookupAll_eq_dlookup",
              "def_path": "Mathlib/Data/List/Sigma.lean",
              "def_pos": [
                318,
                9
              ],
              "def_end_pos": [
                318,
                29
              ]
            },
            {
              "full_name": "Option.toList_nodup",
              "def_path": "Mathlib/Data/List/Nodup.lean",
              "def_pos": [
                497,
                9
              ],
              "def_end_pos": [
                497,
                28
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\nl\u271d l\u2081 l\u2082 : List (Sigma \u03b2)\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List (Sigma \u03b2)\nh : l.NodupKeys\n\u22a2 (lookupAll a l).Nodup",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [lookupAll_eq_dlookup a h]",
        "annotated_tactic": [
          "rw [<a>lookupAll_eq_dlookup</a> a h]",
          [
            {
              "full_name": "List.lookupAll_eq_dlookup",
              "def_path": "Mathlib/Data/List/Sigma.lean",
              "def_pos": [
                318,
                9
              ],
              "def_end_pos": [
                318,
                29
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\nl\u271d l\u2081 l\u2082 : List (Sigma \u03b2)\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List (Sigma \u03b2)\nh : l.NodupKeys\n\u22a2 (lookupAll a l).Nodup",
        "state_after": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\nl\u271d l\u2081 l\u2082 : List (Sigma \u03b2)\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List (Sigma \u03b2)\nh : l.NodupKeys\n\u22a2 (dlookup a l).toList.Nodup"
      },
      {
        "tactic": "apply Option.toList_nodup",
        "annotated_tactic": [
          "apply <a>Option.toList_nodup</a>",
          [
            {
              "full_name": "Option.toList_nodup",
              "def_path": "Mathlib/Data/List/Nodup.lean",
              "def_pos": [
                497,
                9
              ],
              "def_end_pos": [
                497,
                28
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\nl\u271d l\u2081 l\u2082 : List (Sigma \u03b2)\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List (Sigma \u03b2)\nh : l.NodupKeys\n\u22a2 (dlookup a l).toList.Nodup",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.5800217230571434,
    "entry_failed": false
  },
  "10405": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": ".lake/packages/batteries/Batteries/Logic.lean",
    "full_name": "Eq.congr",
    "start": [
      69,
      11
    ],
    "end": [
      70,
      26
    ],
    "traced_tactics": [
      {
        "tactic": "subst h\u2081",
        "annotated_tactic": [
          "subst h\u2081",
          []
        ],
        "state_before": "\u03b1\u271d : Sort u_1\nx\u2081 y\u2081 x\u2082 y\u2082 : \u03b1\u271d\nh\u2081 : x\u2081 = y\u2081\nh\u2082 : x\u2082 = y\u2082\n\u22a2 x\u2081 = x\u2082 \u2194 y\u2081 = y\u2082",
        "state_after": "\u03b1\u271d : Sort u_1\nx\u2081 x\u2082 y\u2082 : \u03b1\u271d\nh\u2082 : x\u2082 = y\u2082\n\u22a2 x\u2081 = x\u2082 \u2194 x\u2081 = y\u2082"
      },
      {
        "tactic": "subst h\u2082",
        "annotated_tactic": [
          "subst h\u2082",
          []
        ],
        "state_before": "\u03b1\u271d : Sort u_1\nx\u2081 x\u2082 y\u2082 : \u03b1\u271d\nh\u2082 : x\u2082 = y\u2082\n\u22a2 x\u2081 = x\u2082 \u2194 x\u2081 = y\u2082",
        "state_after": "\u03b1\u271d : Sort u_1\nx\u2081 x\u2082 : \u03b1\u271d\n\u22a2 x\u2081 = x\u2082 \u2194 x\u2081 = x\u2082"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "\u03b1\u271d : Sort u_1\nx\u2081 x\u2082 : \u03b1\u271d\n\u22a2 x\u2081 = x\u2082 \u2194 x\u2081 = x\u2082",
        "state_after": "no goals"
      }
    ],
    "entry_time": 0.8367428820347413,
    "entry_failed": false
  },
  "10618": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/SupIndep.lean",
    "full_name": "CompleteLattice.Independent.setIndependent_range",
    "start": [
      408,
      1
    ],
    "end": [
      411,
      39
    ],
    "traced_tactics": [
      {
        "tactic": "rw [setIndependent_iff]",
        "annotated_tactic": [
          "rw [<a>setIndependent_iff</a>]",
          [
            {
              "full_name": "CompleteLattice.setIndependent_iff",
              "def_path": "Mathlib/Order/SupIndep.lean",
              "def_pos": [
                348,
                9
              ],
              "def_end_pos": [
                348,
                27
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\nhs : SetIndependent s\nt : \u03b9 \u2192 \u03b1\nht\u271d ht : Independent t\n\u22a2 SetIndependent (range t)",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\nhs : SetIndependent s\nt : \u03b9 \u2192 \u03b1\nht\u271d ht : Independent t\n\u22a2 Independent Subtype.val"
      },
      {
        "tactic": "rw [\u2190 coe_comp_rangeFactorization t] at ht",
        "annotated_tactic": [
          "rw [\u2190 <a>coe_comp_rangeFactorization</a> t] at ht",
          [
            {
              "full_name": "Set.coe_comp_rangeFactorization",
              "def_path": "Mathlib/Data/Set/Image.lean",
              "def_pos": [
                1049,
                9
              ],
              "def_end_pos": [
                1049,
                36
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\nhs : SetIndependent s\nt : \u03b9 \u2192 \u03b1\nht\u271d ht : Independent t\n\u22a2 Independent Subtype.val",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\nhs : SetIndependent s\nt : \u03b9 \u2192 \u03b1\nht\u271d : Independent t\nht : Independent (Subtype.val \u2218 rangeFactorization t)\n\u22a2 Independent Subtype.val"
      },
      {
        "tactic": "exact ht.comp' surjective_onto_range",
        "annotated_tactic": [
          "exact ht.comp' <a>surjective_onto_range</a>",
          [
            {
              "full_name": "Set.surjective_onto_range",
              "def_path": "Mathlib/Data/Set/Image.lean",
              "def_pos": [
                1052,
                9
              ],
              "def_end_pos": [
                1052,
                30
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u03b9' : Type u_4\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\nhs : SetIndependent s\nt : \u03b9 \u2192 \u03b1\nht\u271d : Independent t\nht : Independent (Subtype.val \u2218 rangeFactorization t)\n\u22a2 Independent Subtype.val",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.5711123790824786,
    "entry_failed": false
  },
  "10667": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Antidiag/Prod.lean",
    "full_name": "Finset.antidiagonal.snd_le",
    "start": [
      140,
      1
    ],
    "end": [
      143,
      51
    ],
    "traced_tactics": [
      {
        "tactic": "rw [le_iff_exists_add]",
        "annotated_tactic": [
          "rw [<a>le_iff_exists_add</a>]",
          [
            {
              "full_name": "le_iff_exists_add",
              "def_path": "Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean",
              "def_pos": [
                190,
                3
              ],
              "def_end_pos": [
                190,
                14
              ]
            }
          ]
        ],
        "state_before": "A : Type u_1\ninst\u271d\u00b9 : CanonicallyOrderedAddCommMonoid A\ninst\u271d : HasAntidiagonal A\nn : A\nkl : A \u00d7 A\nhlk : kl \u2208 antidiagonal n\n\u22a2 kl.2 \u2264 n",
        "state_after": "A : Type u_1\ninst\u271d\u00b9 : CanonicallyOrderedAddCommMonoid A\ninst\u271d : HasAntidiagonal A\nn : A\nkl : A \u00d7 A\nhlk : kl \u2208 antidiagonal n\n\u22a2 \u2203 c, n = kl.2 + c"
      },
      {
        "tactic": "use kl.1",
        "annotated_tactic": [
          "use kl.1",
          []
        ],
        "state_before": "A : Type u_1\ninst\u271d\u00b9 : CanonicallyOrderedAddCommMonoid A\ninst\u271d : HasAntidiagonal A\nn : A\nkl : A \u00d7 A\nhlk : kl \u2208 antidiagonal n\n\u22a2 \u2203 c, n = kl.2 + c",
        "state_after": "case h\nA : Type u_1\ninst\u271d\u00b9 : CanonicallyOrderedAddCommMonoid A\ninst\u271d : HasAntidiagonal A\nn : A\nkl : A \u00d7 A\nhlk : kl \u2208 antidiagonal n\n\u22a2 n = kl.2 + kl.1"
      },
      {
        "tactic": "rwa [mem_antidiagonal, eq_comm, add_comm] at hlk",
        "annotated_tactic": [
          "rwa [<a>mem_antidiagonal</a>, <a>eq_comm</a>, <a>add_comm</a>] at hlk",
          [
            {
              "full_name": "Finset.HasAntidiagonal.mem_antidiagonal",
              "def_path": "Mathlib/Algebra/Order/Antidiag/Prod.lean",
              "def_pos": [
                58,
                3
              ],
              "def_end_pos": [
                58,
                19
              ]
            },
            {
              "full_name": "eq_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                811,
                9
              ],
              "def_end_pos": [
                811,
                16
              ]
            },
            {
              "full_name": "add_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                331,
                3
              ],
              "def_end_pos": [
                331,
                14
              ]
            }
          ]
        ],
        "state_before": "case h\nA : Type u_1\ninst\u271d\u00b9 : CanonicallyOrderedAddCommMonoid A\ninst\u271d : HasAntidiagonal A\nn : A\nkl : A \u00d7 A\nhlk : kl \u2208 antidiagonal n\n\u22a2 n = kl.2 + kl.1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5250976369716227,
    "entry_failed": false
  },
  "10673": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/PrimeIdeal.lean",
    "full_name": "Order.Ideal.PrimePair.I_isProper",
    "start": [
      68,
      1
    ],
    "end": [
      71,
      31
    ],
    "traced_tactics": [
      {
        "tactic": "cases' IF.F.nonempty with w h",
        "annotated_tactic": [
          "cases' IF.F.nonempty with w h",
          []
        ],
        "state_before": "P : Type u_1\ninst\u271d : Preorder P\nIF : PrimePair P\n\u22a2 IF.I.IsProper",
        "state_after": "case intro\nP : Type u_1\ninst\u271d : Preorder P\nIF : PrimePair P\nw : P\nh : w \u2208 \u2191IF.F\n\u22a2 IF.I.IsProper"
      },
      {
        "tactic": "apply isProper_of_not_mem (_ : w \u2209 IF.I)",
        "annotated_tactic": [
          "apply <a>isProper_of_not_mem</a> (_ : w \u2209 IF.I)",
          [
            {
              "full_name": "Order.Ideal.isProper_of_not_mem",
              "def_path": "Mathlib/Order/Ideal.lean",
              "def_pos": [
                174,
                9
              ],
              "def_end_pos": [
                174,
                28
              ]
            }
          ]
        ],
        "state_before": "case intro\nP : Type u_1\ninst\u271d : Preorder P\nIF : PrimePair P\nw : P\nh : w \u2208 \u2191IF.F\n\u22a2 IF.I.IsProper",
        "state_after": "P : Type u_1\ninst\u271d : Preorder P\nIF : PrimePair P\nw : P\nh : w \u2208 \u2191IF.F\n\u22a2 w \u2209 IF.I"
      },
      {
        "tactic": "rwa [\u2190 IF.compl_I_eq_F] at h",
        "annotated_tactic": [
          "rwa [\u2190 IF.compl_I_eq_F] at h",
          []
        ],
        "state_before": "P : Type u_1\ninst\u271d : Preorder P\nIF : PrimePair P\nw : P\nh : w \u2208 \u2191IF.F\n\u22a2 w \u2209 IF.I",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.244898475939408,
    "entry_failed": false
  },
  "10740": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Regular/Basic.lean",
    "full_name": "IsRightRegular.mul_right_eq_zero_iff",
    "start": [
      292,
      1
    ],
    "end": [
      294,
      44
    ],
    "traced_tactics": [
      {
        "tactic": "nth_rw 1 [\u2190 zero_mul b]",
        "annotated_tactic": [
          "nth_rw 1 [\u2190 <a>zero_mul</a> b]",
          [
            {
              "full_name": "MulZeroClass.zero_mul",
              "def_path": "Mathlib/Algebra/GroupWithZero/Defs.lean",
              "def_pos": [
                37,
                3
              ],
              "def_end_pos": [
                37,
                11
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d : MulZeroClass R\na b : R\nhb : IsRightRegular b\n\u22a2 a * b = 0 \u2194 a = 0",
        "state_after": "R : Type u_1\ninst\u271d : MulZeroClass R\na b : R\nhb : IsRightRegular b\n\u22a2 a * b = 0 * b \u2194 a = 0"
      },
      {
        "tactic": "exact \u27e8fun h \u21a6 hb h, fun ha \u21a6 by rw [ha]\u27e9",
        "annotated_tactic": [
          "exact \u27e8fun h \u21a6 hb h, fun ha \u21a6 by rw [ha]\u27e9",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d : MulZeroClass R\na b : R\nhb : IsRightRegular b\n\u22a2 a * b = 0 * b \u2194 a = 0",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [ha]",
        "annotated_tactic": [
          "rw [ha]",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d : MulZeroClass R\na b : R\nhb : IsRightRegular b\nha : a = 0\n\u22a2 a * b = 0 * b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7036437460919842,
    "entry_failed": false
  },
  "10808": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/VonMangoldt.lean",
    "full_name": "ArithmeticFunction.vonMangoldt_mul_zeta",
    "start": [
      126,
      1
    ],
    "end": [
      127,
      55
    ],
    "traced_tactics": [
      {
        "tactic": "ext n",
        "annotated_tactic": [
          "ext n",
          []
        ],
        "state_before": "\u22a2 \u039b * \u2191\u03b6 = log",
        "state_after": "case h\nn : \u2115\n\u22a2 (\u039b * \u2191\u03b6) n = log n"
      },
      {
        "tactic": "rw [coe_mul_zeta_apply, vonMangoldt_sum]",
        "annotated_tactic": [
          "rw [<a>coe_mul_zeta_apply</a>, <a>vonMangoldt_sum</a>]",
          [
            {
              "full_name": "ArithmeticFunction.coe_mul_zeta_apply",
              "def_path": "Mathlib/NumberTheory/ArithmeticFunction.lean",
              "def_pos": [
                468,
                9
              ],
              "def_end_pos": [
                468,
                27
              ]
            },
            {
              "full_name": "ArithmeticFunction.vonMangoldt_sum",
              "def_path": "Mathlib/NumberTheory/VonMangoldt.lean",
              "def_pos": [
                111,
                9
              ],
              "def_end_pos": [
                111,
                24
              ]
            }
          ]
        ],
        "state_before": "case h\nn : \u2115\n\u22a2 (\u039b * \u2191\u03b6) n = log n",
        "state_after": "case h\nn : \u2115\n\u22a2 Real.log \u2191n = log n"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case h\nn : \u2115\n\u22a2 Real.log \u2191n = log n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.2364028020529076,
    "entry_failed": false
  },
  "10854": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
    "full_name": "Polynomial.degree_eq_iff_natDegree_eq_of_pos",
    "start": [
      150,
      1
    ],
    "end": [
      154,
      39
    ],
    "traced_tactics": [
      {
        "tactic": "obtain rfl|h := eq_or_ne p 0",
        "annotated_tactic": [
          "obtain rfl|h := <a>eq_or_ne</a> p 0",
          [
            {
              "full_name": "eq_or_ne",
              "def_path": "Mathlib/Logic/Basic.lean",
              "def_pos": [
                212,
                9
              ],
              "def_end_pos": [
                212,
                17
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\na b c d : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np\u271d q r p : R[X]\nn : \u2115\nhn : 0 < n\n\u22a2 p.degree = \u2191n \u2194 p.natDegree = n",
        "state_after": "case inl\nR : Type u\nS : Type v\na b c d : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nn : \u2115\nhn : 0 < n\n\u22a2 degree 0 = \u2191n \u2194 natDegree 0 = n\n\ncase inr\nR : Type u\nS : Type v\na b c d : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np\u271d q r p : R[X]\nn : \u2115\nhn : 0 < n\nh : p \u2260 0\n\u22a2 p.degree = \u2191n \u2194 p.natDegree = n"
      },
      {
        "tactic": "simp [hn.ne]",
        "annotated_tactic": [
          "simp [hn.ne]",
          []
        ],
        "state_before": "case inl\nR : Type u\nS : Type v\na b c d : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nn : \u2115\nhn : 0 < n\n\u22a2 degree 0 = \u2191n \u2194 natDegree 0 = n",
        "state_after": "no goals"
      },
      {
        "tactic": "exact degree_eq_iff_natDegree_eq h",
        "annotated_tactic": [
          "exact <a>degree_eq_iff_natDegree_eq</a> h",
          [
            {
              "full_name": "Polynomial.degree_eq_iff_natDegree_eq",
              "def_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
              "def_pos": [
                146,
                9
              ],
              "def_end_pos": [
                146,
                35
              ]
            }
          ]
        ],
        "state_before": "case inr\nR : Type u\nS : Type v\na b c d : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np\u271d q r p : R[X]\nn : \u2115\nhn : 0 < n\nh : p \u2260 0\n\u22a2 p.degree = \u2191n \u2194 p.natDegree = n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.04400028695818,
    "entry_failed": false
  },
  "10860": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/ComplexDeriv.lean",
    "full_name": "Complex.hasStrictDerivAt_tan",
    "start": [
      25,
      1
    ],
    "end": [
      28,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "convert (hasStrictDerivAt_sin x).div (hasStrictDerivAt_cos x) h using 1",
        "annotated_tactic": [
          "convert (<a>hasStrictDerivAt_sin</a> x).<a>div</a> (<a>hasStrictDerivAt_cos</a> x) h using 1",
          [
            {
              "full_name": "Complex.hasStrictDerivAt_sin",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Deriv.lean",
              "def_pos": [
                35,
                9
              ],
              "def_end_pos": [
                35,
                29
              ]
            },
            {
              "full_name": "HasStrictDerivAt.div",
              "def_path": "Mathlib/Analysis/Calculus/Deriv/Inv.lean",
              "def_pos": [
                187,
                9
              ],
              "def_end_pos": [
                187,
                29
              ]
            },
            {
              "full_name": "Complex.hasStrictDerivAt_cos",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Deriv.lean",
              "def_pos": [
                68,
                9
              ],
              "def_end_pos": [
                68,
                29
              ]
            }
          ]
        ],
        "state_before": "x : \u2102\nh : cos x \u2260 0\n\u22a2 HasStrictDerivAt tan (1 / cos x ^ 2) x",
        "state_after": "case h.e'_7\nx : \u2102\nh : cos x \u2260 0\n\u22a2 1 / cos x ^ 2 = (cos x * cos x - sin x * -sin x) / cos x ^ 2"
      },
      {
        "tactic": "rw_mod_cast [\u2190 sin_sq_add_cos_sq x]",
        "annotated_tactic": [
          "rw_mod_cast [\u2190 <a>sin_sq_add_cos_sq</a> x]",
          [
            {
              "full_name": "Complex.sin_sq_add_cos_sq",
              "def_path": "Mathlib/Data/Complex/Exponential.lean",
              "def_pos": [
                712,
                9
              ],
              "def_end_pos": [
                712,
                26
              ]
            }
          ]
        ],
        "state_before": "case h.e'_7\nx : \u2102\nh : cos x \u2260 0\n\u22a2 1 / cos x ^ 2 = (cos x * cos x - sin x * -sin x) / cos x ^ 2",
        "state_after": "case h.e'_7\nx : \u2102\nh : \u00accos x = 0\n\u22a2 (sin x ^ 2 + cos x ^ 2) / cos x ^ 2 = (cos x * cos x - sin x * -sin x) / cos x ^ 2"
      },
      {
        "tactic": "ring",
        "annotated_tactic": [
          "ring",
          []
        ],
        "state_before": "case h.e'_7\nx : \u2102\nh : \u00accos x = 0\n\u22a2 (sin x ^ 2 + cos x ^ 2) / cos x ^ 2 = (cos x * cos x - sin x * -sin x) / cos x ^ 2",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.644371059956029,
    "entry_failed": false
  },
  "10931": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Int/Bitwise.lean",
    "full_name": "Int.bodd_bit",
    "start": [
      263,
      1
    ],
    "end": [
      265,
      67
    ],
    "traced_tactics": [
      {
        "tactic": "rw [bit_val]",
        "annotated_tactic": [
          "rw [<a>bit_val</a>]",
          [
            {
              "full_name": "Int.bit_val",
              "def_path": "Mathlib/Data/Int/Bitwise.lean",
              "def_pos": [
                228,
                9
              ],
              "def_end_pos": [
                228,
                16
              ]
            }
          ]
        ],
        "state_before": "b : Bool\nn : \u2124\n\u22a2 (bit b n).bodd = b",
        "state_after": "b : Bool\nn : \u2124\n\u22a2 (2 * n + bif b then 1 else 0).bodd = b"
      },
      {
        "tactic": "cases b <;> cases bodd n <;> simp [(show bodd 2 = false by rfl)]",
        "annotated_tactic": [
          "cases b <;> cases <a>bodd</a> n <;> simp [(show <a>bodd</a> 2 = <a>false</a> by rfl)]",
          [
            {
              "full_name": "Int.bodd",
              "def_path": "Mathlib/Data/Int/Bitwise.lean",
              "def_pos": [
                32,
                5
              ],
              "def_end_pos": [
                32,
                9
              ]
            },
            {
              "full_name": "Int.bodd",
              "def_path": "Mathlib/Data/Int/Bitwise.lean",
              "def_pos": [
                32,
                5
              ],
              "def_end_pos": [
                32,
                9
              ]
            },
            {
              "full_name": "Bool.false",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                569,
                5
              ],
              "def_end_pos": [
                569,
                10
              ]
            }
          ]
        ],
        "state_before": "b : Bool\nn : \u2124\n\u22a2 (2 * n + bif b then 1 else 0).bodd = b",
        "state_after": "no goals"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "n : \u2124\n\u22a2 bodd 2 = false",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8821233140770346,
    "entry_failed": false
  },
  "10951": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Sym/Sym2.lean",
    "full_name": "Sym2.fromRel_top",
    "start": [
      518,
      1
    ],
    "end": [
      521,
      44
    ],
    "traced_tactics": [
      {
        "tactic": "apply Set.eq_univ_of_forall fun e => _",
        "annotated_tactic": [
          "apply <a>Set.eq_univ_of_forall</a> fun e => _",
          [
            {
              "full_name": "Set.eq_univ_of_forall",
              "def_path": "Mathlib/Data/Set/Basic.lean",
              "def_pos": [
                672,
                9
              ],
              "def_end_pos": [
                672,
                26
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ne : Sym2 \u03b1\nf : \u03b1 \u2192 \u03b2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 fromRel \u22ef = Set.univ",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ne : Sym2 \u03b1\nf : \u03b1 \u2192 \u03b2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 \u2200 (e : Sym2 \u03b1), e \u2208 fromRel \u22ef"
      },
      {
        "tactic": "apply Sym2.ind",
        "annotated_tactic": [
          "apply <a>Sym2.ind</a>",
          [
            {
              "full_name": "Sym2.ind",
              "def_path": "Mathlib/Data/Sym/Sym2.lean",
              "def_pos": [
                128,
                19
              ],
              "def_end_pos": [
                128,
                22
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ne : Sym2 \u03b1\nf : \u03b1 \u2192 \u03b2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 \u2200 (e : Sym2 \u03b1), e \u2208 fromRel \u22ef",
        "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ne : Sym2 \u03b1\nf : \u03b1 \u2192 \u03b2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 \u2200 (x y : \u03b1), s(x, y) \u2208 fromRel \u22ef"
      },
      {
        "tactic": "simp [-Set.top_eq_univ, Prop.top_eq_true]",
        "annotated_tactic": [
          "simp [-<a>Set.top_eq_univ</a>, <a>Prop.top_eq_true</a>]",
          [
            {
              "full_name": "Set.top_eq_univ",
              "def_path": "Mathlib/Data/Set/Basic.lean",
              "def_pos": [
                91,
                9
              ],
              "def_end_pos": [
                91,
                20
              ]
            },
            {
              "full_name": "Prop.top_eq_true",
              "def_path": "Mathlib/Order/PropInstances.lean",
              "def_pos": [
                45,
                9
              ],
              "def_end_pos": [
                45,
                25
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ne : Sym2 \u03b1\nf : \u03b1 \u2192 \u03b2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 \u2200 (x y : \u03b1), s(x, y) \u2208 fromRel \u22ef",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.2446922189556062,
    "entry_failed": false
  },
  "11151": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Archimedean.lean",
    "full_name": "AddSubgroup.cyclic_of_isolated_zero",
    "start": [
      91,
      1
    ],
    "end": [
      95,
      69
    ],
    "traced_tactics": [
      {
        "tactic": "rcases eq_or_ne H \u22a5 with rfl | hbot",
        "annotated_tactic": [
          "rcases <a>eq_or_ne</a> H \u22a5 with rfl | hbot",
          [
            {
              "full_name": "eq_or_ne",
              "def_path": "Mathlib/Logic/Basic.lean",
              "def_pos": [
                212,
                9
              ],
              "def_end_pos": [
                212,
                17
              ]
            }
          ]
        ],
        "state_before": "G : Type u_1\ninst\u271d\u00b9 : LinearOrderedAddCommGroup G\ninst\u271d : Archimedean G\nH : AddSubgroup G\na : G\nh\u2080 : 0 < a\nhd : Disjoint (\u2191H) (Ioo 0 a)\n\u22a2 \u2203 b, H = closure {b}",
        "state_after": "case inl\nG : Type u_1\ninst\u271d\u00b9 : LinearOrderedAddCommGroup G\ninst\u271d : Archimedean G\na : G\nh\u2080 : 0 < a\nhd : Disjoint (\u2191\u22a5) (Ioo 0 a)\n\u22a2 \u2203 b, \u22a5 = closure {b}\n\ncase inr\nG : Type u_1\ninst\u271d\u00b9 : LinearOrderedAddCommGroup G\ninst\u271d : Archimedean G\nH : AddSubgroup G\na : G\nh\u2080 : 0 < a\nhd : Disjoint (\u2191H) (Ioo 0 a)\nhbot : H \u2260 \u22a5\n\u22a2 \u2203 b, H = closure {b}"
      },
      {
        "tactic": "exact \u27e80, closure_singleton_zero.symm\u27e9",
        "annotated_tactic": [
          "exact \u27e80, closure_singleton_zero.symm\u27e9",
          []
        ],
        "state_before": "case inl\nG : Type u_1\ninst\u271d\u00b9 : LinearOrderedAddCommGroup G\ninst\u271d : Archimedean G\na : G\nh\u2080 : 0 < a\nhd : Disjoint (\u2191\u22a5) (Ioo 0 a)\n\u22a2 \u2203 b, \u22a5 = closure {b}",
        "state_after": "no goals"
      },
      {
        "tactic": "exact (exists_isLeast_pos hbot h\u2080 hd).imp fun _ => cyclic_of_min",
        "annotated_tactic": [
          "exact (<a>exists_isLeast_pos</a> hbot h\u2080 hd).<a>imp</a> fun _ => <a>cyclic_of_min</a>",
          [
            {
              "full_name": "AddSubgroup.exists_isLeast_pos",
              "def_path": "Mathlib/GroupTheory/Archimedean.lean",
              "def_pos": [
                60,
                9
              ],
              "def_end_pos": [
                60,
                39
              ]
            },
            {
              "full_name": "Exists.imp",
              "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean",
              "def_pos": [
                193,
                9
              ],
              "def_end_pos": [
                193,
                19
              ]
            },
            {
              "full_name": "AddSubgroup.cyclic_of_min",
              "def_path": "Mathlib/GroupTheory/Archimedean.lean",
              "def_pos": [
                40,
                9
              ],
              "def_end_pos": [
                40,
                34
              ]
            }
          ]
        ],
        "state_before": "case inr\nG : Type u_1\ninst\u271d\u00b9 : LinearOrderedAddCommGroup G\ninst\u271d : Archimedean G\nH : AddSubgroup G\na : G\nh\u2080 : 0 < a\nhd : Disjoint (\u2191H) (Ioo 0 a)\nhbot : H \u2260 \u22a5\n\u22a2 \u2203 b, H = closure {b}",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.119088741019368,
    "entry_failed": false
  },
  "11204": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/ZMod/Basic.lean",
    "full_name": "ZMod.val_lt",
    "start": [
      52,
      1
    ],
    "end": [
      55,
      20
    ],
    "traced_tactics": [
      {
        "tactic": "cases n",
        "annotated_tactic": [
          "cases n",
          []
        ],
        "state_before": "n : \u2115\ninst\u271d : NeZero n\na : ZMod n\n\u22a2 a.val < n",
        "state_after": "case zero\ninst\u271d : NeZero 0\na : ZMod 0\n\u22a2 a.val < 0\n\ncase succ\nn\u271d : \u2115\ninst\u271d : NeZero (n\u271d + 1)\na : ZMod (n\u271d + 1)\n\u22a2 a.val < n\u271d + 1"
      },
      {
        "tactic": "exact Fin.is_lt a",
        "annotated_tactic": [
          "exact <a>Fin.is_lt</a> a",
          [
            {
              "full_name": "Fin.is_lt",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Fin/Lemmas.lean",
              "def_pos": [
                31,
                17
              ],
              "def_end_pos": [
                31,
                22
              ]
            }
          ]
        ],
        "state_before": "case succ\nn\u271d : \u2115\ninst\u271d : NeZero (n\u271d + 1)\na : ZMod (n\u271d + 1)\n\u22a2 a.val < n\u271d + 1",
        "state_after": "no goals"
      },
      {
        "tactic": "cases NeZero.ne 0 rfl",
        "annotated_tactic": [
          "cases <a>NeZero.ne</a> 0 <a>rfl</a>",
          [
            {
              "full_name": "NeZero.ne",
              "def_path": "Mathlib/Algebra/NeZero.lean",
              "def_pos": [
                30,
                9
              ],
              "def_end_pos": [
                30,
                18
              ]
            },
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "case zero\ninst\u271d : NeZero 0\na : ZMod 0\n\u22a2 a.val < 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.0360283609479666,
    "entry_failed": false
  },
  "11245": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Index.lean",
    "full_name": "Subgroup.index_ne_zero_of_finite",
    "start": [
      507,
      1
    ],
    "end": [
      510,
      29
    ],
    "traced_tactics": [
      {
        "tactic": "cases nonempty_fintype (G \u29f8 H)",
        "annotated_tactic": [
          "cases <a>nonempty_fintype</a> (G \u29f8 H)",
          [
            {
              "full_name": "nonempty_fintype",
              "def_path": "Mathlib/Data/Fintype/Card.lean",
              "def_pos": [
                443,
                9
              ],
              "def_end_pos": [
                443,
                25
              ]
            }
          ]
        ],
        "state_before": "G : Type u_1\ninst\u271d : Group G\nH K L : Subgroup G\nhH : Finite (G \u29f8 H)\n\u22a2 H.index \u2260 0",
        "state_after": "case intro\nG : Type u_1\ninst\u271d : Group G\nH K L : Subgroup G\nhH : Finite (G \u29f8 H)\nval\u271d : Fintype (G \u29f8 H)\n\u22a2 H.index \u2260 0"
      },
      {
        "tactic": "rw [index_eq_card]",
        "annotated_tactic": [
          "rw [<a>index_eq_card</a>]",
          [
            {
              "full_name": "Subgroup.index_eq_card",
              "def_path": "Mathlib/GroupTheory/Index.lean",
              "def_pos": [
                356,
                9
              ],
              "def_end_pos": [
                356,
                22
              ]
            }
          ]
        ],
        "state_before": "case intro\nG : Type u_1\ninst\u271d : Group G\nH K L : Subgroup G\nhH : Finite (G \u29f8 H)\nval\u271d : Fintype (G \u29f8 H)\n\u22a2 H.index \u2260 0",
        "state_after": "case intro\nG : Type u_1\ninst\u271d : Group G\nH K L : Subgroup G\nhH : Finite (G \u29f8 H)\nval\u271d : Fintype (G \u29f8 H)\n\u22a2 Fintype.card (G \u29f8 H) \u2260 0"
      },
      {
        "tactic": "exact Fintype.card_ne_zero",
        "annotated_tactic": [
          "exact <a>Fintype.card_ne_zero</a>",
          [
            {
              "full_name": "Fintype.card_ne_zero",
              "def_path": "Mathlib/Data/Fintype/Card.lean",
              "def_pos": [
                569,
                9
              ],
              "def_end_pos": [
                569,
                21
              ]
            }
          ]
        ],
        "state_before": "case intro\nG : Type u_1\ninst\u271d : Group G\nH K L : Subgroup G\nhH : Finite (G \u29f8 H)\nval\u271d : Fintype (G \u29f8 H)\n\u22a2 Fintype.card (G \u29f8 H) \u2260 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.420430533005856,
    "entry_failed": false
  },
  "11277": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Fin/Tuple/Sort.lean",
    "full_name": "Tuple.sort_eq_refl_iff_monotone",
    "start": [
      186,
      1
    ],
    "end": [
      189,
      31
    ],
    "traced_tactics": [
      {
        "tactic": "rw [eq_comm, eq_sort_iff, Equiv.coe_refl, Function.comp_id]",
        "annotated_tactic": [
          "rw [<a>eq_comm</a>, <a>eq_sort_iff</a>, <a>Equiv.coe_refl</a>, <a>Function.comp_id</a>]",
          [
            {
              "full_name": "eq_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                811,
                9
              ],
              "def_end_pos": [
                811,
                16
              ]
            },
            {
              "full_name": "Tuple.eq_sort_iff",
              "def_path": "Mathlib/Data/Fin/Tuple/Sort.lean",
              "def_pos": [
                176,
                9
              ],
              "def_end_pos": [
                176,
                20
              ]
            },
            {
              "full_name": "Equiv.coe_refl",
              "def_path": "Mathlib/Logic/Equiv/Defs.lean",
              "def_pos": [
                257,
                17
              ],
              "def_end_pos": [
                257,
                25
              ]
            },
            {
              "full_name": "Function.comp_id",
              "def_path": "Mathlib/Init/Function.lean",
              "def_pos": [
                101,
                9
              ],
              "def_end_pos": [
                101,
                16
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nf : Fin n \u2192 \u03b1\n\u03c3 : Equiv.Perm (Fin n)\n\u22a2 sort f = Equiv.refl (Fin n) \u2194 Monotone f",
        "state_after": "n : \u2115\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nf : Fin n \u2192 \u03b1\n\u03c3 : Equiv.Perm (Fin n)\n\u22a2 (Monotone f \u2227 \u2200 (i j : Fin n), i < j \u2192 f (id i) = f (id j) \u2192 id i < id j) \u2194 Monotone f"
      },
      {
        "tactic": "simp only [id, and_iff_left_iff_imp]",
        "annotated_tactic": [
          "simp only [<a>id</a>, <a>and_iff_left_iff_imp</a>]",
          [
            {
              "full_name": "id",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                33,
                15
              ],
              "def_end_pos": [
                33,
                17
              ]
            },
            {
              "full_name": "and_iff_left_iff_imp",
              "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean",
              "def_pos": [
                164,
                17
              ],
              "def_end_pos": [
                164,
                37
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nf : Fin n \u2192 \u03b1\n\u03c3 : Equiv.Perm (Fin n)\n\u22a2 (Monotone f \u2227 \u2200 (i j : Fin n), i < j \u2192 f (id i) = f (id j) \u2192 id i < id j) \u2194 Monotone f",
        "state_after": "n : \u2115\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nf : Fin n \u2192 \u03b1\n\u03c3 : Equiv.Perm (Fin n)\n\u22a2 Monotone f \u2192 \u2200 (i j : Fin n), i < j \u2192 f i = f j \u2192 i < j"
      },
      {
        "tactic": "exact fun _ _ _ hij _ => hij",
        "annotated_tactic": [
          "exact fun _ _ _ hij _ => hij",
          []
        ],
        "state_before": "n : \u2115\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nf : Fin n \u2192 \u03b1\n\u03c3 : Equiv.Perm (Fin n)\n\u22a2 Monotone f \u2192 \u2200 (i j : Fin n), i < j \u2192 f i = f j \u2192 i < j",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.3703145360341296,
    "entry_failed": false
  },
  "11312": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Int/Defs.lean",
    "full_name": "Int.dvd_of_mul_dvd_mul_left",
    "start": [
      688,
      1
    ],
    "end": [
      691,
      16
    ],
    "traced_tactics": [
      {
        "tactic": "obtain \u27e8b, hb\u27e9 := h",
        "annotated_tactic": [
          "obtain \u27e8b, hb\u27e9 := h",
          []
        ],
        "state_before": "a b c d m n : \u2124\nha : a \u2260 0\nh : a * m \u2223 a * n\n\u22a2 m \u2223 n",
        "state_after": "case intro\na b\u271d c d m n : \u2124\nha : a \u2260 0\nb : \u2124\nhb : a * n = a * m * b\n\u22a2 m \u2223 n"
      },
      {
        "tactic": "rw [Int.mul_assoc, Int.mul_eq_mul_left_iff ha] at hb",
        "annotated_tactic": [
          "rw [<a>Int.mul_assoc</a>, <a>Int.mul_eq_mul_left_iff</a> ha] at hb",
          [
            {
              "full_name": "Int.mul_assoc",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Lemmas.lean",
              "def_pos": [
                376,
                19
              ],
              "def_end_pos": [
                376,
                28
              ]
            },
            {
              "full_name": "Int.mul_eq_mul_left_iff",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Lemmas.lean",
              "def_pos": [
                499,
                9
              ],
              "def_end_pos": [
                499,
                28
              ]
            }
          ]
        ],
        "state_before": "case intro\na b\u271d c d m n : \u2124\nha : a \u2260 0\nb : \u2124\nhb : a * n = a * m * b\n\u22a2 m \u2223 n",
        "state_after": "case intro\na b\u271d c d m n : \u2124\nha : a \u2260 0\nb : \u2124\nhb : n = m * b\n\u22a2 m \u2223 n"
      },
      {
        "tactic": "exact \u27e8_, hb\u27e9",
        "annotated_tactic": [
          "exact \u27e8_, hb\u27e9",
          []
        ],
        "state_before": "case intro\na b\u271d c d m n : \u2124\nha : a \u2260 0\nb : \u2124\nhb : n = m * b\n\u22a2 m \u2223 n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.8859107489697635,
    "entry_failed": false
  },
  "11332": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/Padics/PadicVal.lean",
    "full_name": "padicValNat_dvd_iff",
    "start": [
      581,
      1
    ],
    "end": [
      585,
      52
    ],
    "traced_tactics": [
      {
        "tactic": "rcases eq_or_ne a 0 with (rfl | ha)",
        "annotated_tactic": [
          "rcases <a>eq_or_ne</a> a 0 with (rfl | ha)",
          [
            {
              "full_name": "eq_or_ne",
              "def_path": "Mathlib/Logic/Basic.lean",
              "def_pos": [
                212,
                9
              ],
              "def_end_pos": [
                212,
                17
              ]
            }
          ]
        ],
        "state_before": "p n : \u2115\nhp : Fact (Nat.Prime p)\na : \u2115\n\u22a2 p ^ n \u2223 a \u2194 a = 0 \u2228 n \u2264 padicValNat p a",
        "state_after": "case inl\np n : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 p ^ n \u2223 0 \u2194 0 = 0 \u2228 n \u2264 padicValNat p 0\n\ncase inr\np n : \u2115\nhp : Fact (Nat.Prime p)\na : \u2115\nha : a \u2260 0\n\u22a2 p ^ n \u2223 a \u2194 a = 0 \u2228 n \u2264 padicValNat p a"
      },
      {
        "tactic": "exact iff_of_true (dvd_zero _) (Or.inl rfl)",
        "annotated_tactic": [
          "exact <a>iff_of_true</a> (<a>dvd_zero</a> _) (<a>Or.inl</a> <a>rfl</a>)",
          [
            {
              "full_name": "iff_of_true",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1353,
                9
              ],
              "def_end_pos": [
                1353,
                20
              ]
            },
            {
              "full_name": "dvd_zero",
              "def_path": "Mathlib/Algebra/GroupWithZero/Divisibility.lean",
              "def_pos": [
                41,
                9
              ],
              "def_end_pos": [
                41,
                17
              ]
            },
            {
              "full_name": "Or.inl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                534,
                5
              ],
              "def_end_pos": [
                534,
                8
              ]
            },
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "case inl\np n : \u2115\nhp : Fact (Nat.Prime p)\n\u22a2 p ^ n \u2223 0 \u2194 0 = 0 \u2228 n \u2264 padicValNat p 0",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [padicValNat_dvd_iff_le ha, or_iff_right ha]",
        "annotated_tactic": [
          "rw [<a>padicValNat_dvd_iff_le</a> ha, <a>or_iff_right</a> ha]",
          [
            {
              "full_name": "padicValNat_dvd_iff_le",
              "def_path": "Mathlib/NumberTheory/Padics/PadicVal.lean",
              "def_pos": [
                576,
                9
              ],
              "def_end_pos": [
                576,
                31
              ]
            },
            {
              "full_name": "or_iff_right",
              "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean",
              "def_pos": [
                92,
                9
              ],
              "def_end_pos": [
                92,
                21
              ]
            }
          ]
        ],
        "state_before": "case inr\np n : \u2115\nhp : Fact (Nat.Prime p)\na : \u2115\nha : a \u2260 0\n\u22a2 p ^ n \u2223 a \u2194 a = 0 \u2228 n \u2264 padicValNat p a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.658548102946952,
    "entry_failed": false
  },
  "11350": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Squarefree.lean",
    "full_name": "Nat.minSqFac_prime",
    "start": [
      223,
      1
    ],
    "end": [
      226,
      15
    ],
    "traced_tactics": [
      {
        "tactic": "have := minSqFac_has_prop n",
        "annotated_tactic": [
          "have := <a>minSqFac_has_prop</a> n",
          [
            {
              "full_name": "Nat.minSqFac_has_prop",
              "def_path": "Mathlib/Data/Nat/Squarefree.lean",
              "def_pos": [
                203,
                9
              ],
              "def_end_pos": [
                203,
                26
              ]
            }
          ]
        ],
        "state_before": "s : Finset \u2115\nm n\u271d p n d : \u2115\nh : n.minSqFac = some d\n\u22a2 Prime d",
        "state_after": "s : Finset \u2115\nm n\u271d p n d : \u2115\nh : n.minSqFac = some d\nthis : n.MinSqFacProp n.minSqFac\n\u22a2 Prime d"
      },
      {
        "tactic": "rw [h] at this",
        "annotated_tactic": [
          "rw [h] at this",
          []
        ],
        "state_before": "s : Finset \u2115\nm n\u271d p n d : \u2115\nh : n.minSqFac = some d\nthis : n.MinSqFacProp n.minSqFac\n\u22a2 Prime d",
        "state_after": "s : Finset \u2115\nm n\u271d p n d : \u2115\nh : n.minSqFac = some d\nthis : n.MinSqFacProp (some d)\n\u22a2 Prime d"
      },
      {
        "tactic": "exact this.1",
        "annotated_tactic": [
          "exact this.1",
          []
        ],
        "state_before": "s : Finset \u2115\nm n\u271d p n d : \u2115\nh : n.minSqFac = some d\nthis : n.MinSqFacProp (some d)\n\u22a2 Prime d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.274512468022294,
    "entry_failed": false
  },
  "11382": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Metric.lean",
    "full_name": "SimpleGraph.dist_comm_aux",
    "start": [
      113,
      9
    ],
    "end": [
      116,
      16
    ],
    "traced_tactics": [
      {
        "tactic": "obtain \u27e8p, hp\u27e9 := h.symm.exists_walk_of_dist",
        "annotated_tactic": [
          "obtain \u27e8p, hp\u27e9 := h.symm.exists_walk_of_dist",
          []
        ],
        "state_before": "V : Type u_1\nG : SimpleGraph V\nu v : V\nh : G.Reachable u v\n\u22a2 G.dist u v \u2264 G.dist v u",
        "state_after": "case intro\nV : Type u_1\nG : SimpleGraph V\nu v : V\nh : G.Reachable u v\np : G.Walk v u\nhp : p.length = G.dist v u\n\u22a2 G.dist u v \u2264 G.dist v u"
      },
      {
        "tactic": "rw [\u2190 hp, \u2190 Walk.length_reverse]",
        "annotated_tactic": [
          "rw [\u2190 hp, \u2190 <a>Walk.length_reverse</a>]",
          [
            {
              "full_name": "SimpleGraph.Walk.length_reverse",
              "def_path": "Mathlib/Combinatorics/SimpleGraph/Connectivity.lean",
              "def_pos": [
                413,
                9
              ],
              "def_end_pos": [
                413,
                23
              ]
            }
          ]
        ],
        "state_before": "case intro\nV : Type u_1\nG : SimpleGraph V\nu v : V\nh : G.Reachable u v\np : G.Walk v u\nhp : p.length = G.dist v u\n\u22a2 G.dist u v \u2264 G.dist v u",
        "state_after": "case intro\nV : Type u_1\nG : SimpleGraph V\nu v : V\nh : G.Reachable u v\np : G.Walk v u\nhp : p.length = G.dist v u\n\u22a2 G.dist u v \u2264 p.reverse.length"
      },
      {
        "tactic": "apply dist_le",
        "annotated_tactic": [
          "apply <a>dist_le</a>",
          [
            {
              "full_name": "SimpleGraph.dist_le",
              "def_path": "Mathlib/Combinatorics/SimpleGraph/Metric.lean",
              "def_pos": [
                65,
                9
              ],
              "def_end_pos": [
                65,
                16
              ]
            }
          ]
        ],
        "state_before": "case intro\nV : Type u_1\nG : SimpleGraph V\nu v : V\nh : G.Reachable u v\np : G.Walk v u\nhp : p.length = G.dist v u\n\u22a2 G.dist u v \u2264 p.reverse.length",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4143201869446784,
    "entry_failed": false
  },
  "11436": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Tactic/NormNum/Basic.lean",
    "full_name": "Mathlib.Meta.NormNum.isNat_intCast",
    "start": [
      119,
      1
    ],
    "end": [
      120,
      67
    ],
    "traced_tactics": [
      {
        "tactic": "rintro \u27e8\u27e8\u27e9\u27e9",
        "annotated_tactic": [
          "rintro \u27e8\u27e8\u27e9\u27e9",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d : Ring R\nn : \u2124\nm : \u2115\n\u22a2 IsNat n m \u2192 IsNat (\u2191n) m",
        "state_after": "case mk.refl\nR : Type u_1\ninst\u271d : Ring R\nm : \u2115\n\u22a2 IsNat (\u2191\u2191m) m"
      },
      {
        "tactic": "exact \u27e8by simp\u27e9",
        "annotated_tactic": [
          "exact \u27e8by simp\u27e9",
          []
        ],
        "state_before": "case mk.refl\nR : Type u_1\ninst\u271d : Ring R\nm : \u2115\n\u22a2 IsNat (\u2191\u2191m) m",
        "state_after": "no goals"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d : Ring R\nm : \u2115\n\u22a2 \u2191\u2191m = \u2191m",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.6925946559058502,
    "entry_failed": false
  },
  "11514": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Polynomial/Derivative.lean",
    "full_name": "Polynomial.natDegree_derivative_le",
    "start": [
      207,
      1
    ],
    "end": [
      210,
      60
    ],
    "traced_tactics": [
      {
        "tactic": "by_cases p0 : p.natDegree = 0",
        "annotated_tactic": [
          "by_cases p0 : p.natDegree = 0",
          []
        ],
        "state_before": "R : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\np : R[X]\n\u22a2 (derivative p).natDegree \u2264 p.natDegree - 1",
        "state_after": "case pos\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\np : R[X]\np0 : p.natDegree = 0\n\u22a2 (derivative p).natDegree \u2264 p.natDegree - 1\n\ncase neg\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\np : R[X]\np0 : \u00acp.natDegree = 0\n\u22a2 (derivative p).natDegree \u2264 p.natDegree - 1"
      },
      {
        "tactic": "simp [p0, derivative_of_natDegree_zero]",
        "annotated_tactic": [
          "simp [p0, <a>derivative_of_natDegree_zero</a>]",
          [
            {
              "full_name": "Polynomial.derivative_of_natDegree_zero",
              "def_path": "Mathlib/Algebra/Polynomial/Derivative.lean",
              "def_pos": [
                125,
                9
              ],
              "def_end_pos": [
                125,
                37
              ]
            }
          ]
        ],
        "state_before": "case pos\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\np : R[X]\np0 : p.natDegree = 0\n\u22a2 (derivative p).natDegree \u2264 p.natDegree - 1",
        "state_after": "no goals"
      },
      {
        "tactic": "exact Nat.le_sub_one_of_lt (natDegree_derivative_lt p0)",
        "annotated_tactic": [
          "exact <a>Nat.le_sub_one_of_lt</a> (<a>natDegree_derivative_lt</a> p0)",
          [
            {
              "full_name": "Nat.le_sub_one_of_lt",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean",
              "def_pos": [
                682,
                9
              ],
              "def_end_pos": [
                682,
                25
              ]
            },
            {
              "full_name": "Polynomial.natDegree_derivative_lt",
              "def_path": "Mathlib/Algebra/Polynomial/Derivative.lean",
              "def_pos": [
                198,
                9
              ],
              "def_end_pos": [
                198,
                32
              ]
            }
          ]
        ],
        "state_before": "case neg\nR : Type u\nS : Type v\nT : Type w\n\u03b9 : Type y\nA : Type z\na b : R\nn : \u2115\ninst\u271d : Semiring R\np : R[X]\np0 : \u00acp.natDegree = 0\n\u22a2 (derivative p).natDegree \u2264 p.natDegree - 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.037237853044644,
    "entry_failed": false
  },
  "11517": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Cardinal/Ordinal.lean",
    "full_name": "Cardinal.max_aleph_eq",
    "start": [
      262,
      1
    ],
    "end": [
      265,
      51
    ],
    "traced_tactics": [
      {
        "tactic": "rcases le_total (aleph o\u2081) (aleph o\u2082) with h | h",
        "annotated_tactic": [
          "rcases <a>le_total</a> (<a>aleph</a> o\u2081) (<a>aleph</a> o\u2082) with h | h",
          [
            {
              "full_name": "le_total",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                297,
                9
              ],
              "def_end_pos": [
                297,
                17
              ]
            },
            {
              "full_name": "Cardinal.aleph",
              "def_path": "Mathlib/SetTheory/Cardinal/Ordinal.lean",
              "def_pos": [
                247,
                5
              ],
              "def_end_pos": [
                247,
                10
              ]
            },
            {
              "full_name": "Cardinal.aleph",
              "def_path": "Mathlib/SetTheory/Cardinal/Ordinal.lean",
              "def_pos": [
                247,
                5
              ],
              "def_end_pos": [
                247,
                10
              ]
            }
          ]
        ],
        "state_before": "o\u2081 o\u2082 : Ordinal.{u_1}\n\u22a2 max (aleph o\u2081) (aleph o\u2082) = aleph (max o\u2081 o\u2082)",
        "state_after": "case inl\no\u2081 o\u2082 : Ordinal.{u_1}\nh : aleph o\u2081 \u2264 aleph o\u2082\n\u22a2 max (aleph o\u2081) (aleph o\u2082) = aleph (max o\u2081 o\u2082)\n\ncase inr\no\u2081 o\u2082 : Ordinal.{u_1}\nh : aleph o\u2082 \u2264 aleph o\u2081\n\u22a2 max (aleph o\u2081) (aleph o\u2082) = aleph (max o\u2081 o\u2082)"
      },
      {
        "tactic": "rw [max_eq_right h, max_eq_right (aleph_le.1 h)]",
        "annotated_tactic": [
          "rw [<a>max_eq_right</a> h, <a>max_eq_right</a> (<a>aleph_le</a>.1 h)]",
          [
            {
              "full_name": "max_eq_right",
              "def_path": "Mathlib/Init/Order/LinearOrder.lean",
              "def_pos": [
                137,
                9
              ],
              "def_end_pos": [
                137,
                21
              ]
            },
            {
              "full_name": "max_eq_right",
              "def_path": "Mathlib/Init/Order/LinearOrder.lean",
              "def_pos": [
                137,
                9
              ],
              "def_end_pos": [
                137,
                21
              ]
            },
            {
              "full_name": "Cardinal.aleph_le",
              "def_path": "Mathlib/SetTheory/Cardinal/Ordinal.lean",
              "def_pos": [
                257,
                9
              ],
              "def_end_pos": [
                257,
                17
              ]
            }
          ]
        ],
        "state_before": "case inl\no\u2081 o\u2082 : Ordinal.{u_1}\nh : aleph o\u2081 \u2264 aleph o\u2082\n\u22a2 max (aleph o\u2081) (aleph o\u2082) = aleph (max o\u2081 o\u2082)",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [max_eq_left h, max_eq_left (aleph_le.1 h)]",
        "annotated_tactic": [
          "rw [<a>max_eq_left</a> h, <a>max_eq_left</a> (<a>aleph_le</a>.1 h)]",
          [
            {
              "full_name": "max_eq_left",
              "def_path": "Mathlib/Init/Order/LinearOrder.lean",
              "def_pos": [
                133,
                9
              ],
              "def_end_pos": [
                133,
                20
              ]
            },
            {
              "full_name": "max_eq_left",
              "def_path": "Mathlib/Init/Order/LinearOrder.lean",
              "def_pos": [
                133,
                9
              ],
              "def_end_pos": [
                133,
                20
              ]
            },
            {
              "full_name": "Cardinal.aleph_le",
              "def_path": "Mathlib/SetTheory/Cardinal/Ordinal.lean",
              "def_pos": [
                257,
                9
              ],
              "def_end_pos": [
                257,
                17
              ]
            }
          ]
        ],
        "state_before": "case inr\no\u2081 o\u2082 : Ordinal.{u_1}\nh : aleph o\u2082 \u2264 aleph o\u2081\n\u22a2 max (aleph o\u2081) (aleph o\u2082) = aleph (max o\u2081 o\u2082)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.600754073006101,
    "entry_failed": false
  },
  "11538": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Game/Domineering.lean",
    "full_name": "SetTheory.PGame.Domineering.fst_pred_mem_erase_of_mem_right",
    "start": [
      79,
      1
    ],
    "end": [
      83,
      51
    ],
    "traced_tactics": [
      {
        "tactic": "rw [mem_right] at h",
        "annotated_tactic": [
          "rw [<a>mem_right</a>] at h",
          [
            {
              "full_name": "SetTheory.PGame.Domineering.mem_right",
              "def_path": "Mathlib/SetTheory/Game/Domineering.lean",
              "def_pos": [
                65,
                9
              ],
              "def_end_pos": [
                65,
                18
              ]
            }
          ]
        ],
        "state_before": "b : Board\nm : \u2124 \u00d7 \u2124\nh : m \u2208 right b\n\u22a2 (m.1 - 1, m.2) \u2208 Finset.erase b m",
        "state_after": "b : Board\nm : \u2124 \u00d7 \u2124\nh : m \u2208 b \u2227 (m.1 - 1, m.2) \u2208 b\n\u22a2 (m.1 - 1, m.2) \u2208 Finset.erase b m"
      },
      {
        "tactic": "apply Finset.mem_erase_of_ne_of_mem _ h.2",
        "annotated_tactic": [
          "apply <a>Finset.mem_erase_of_ne_of_mem</a> _ h.2",
          [
            {
              "full_name": "Finset.mem_erase_of_ne_of_mem",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                1931,
                9
              ],
              "def_end_pos": [
                1931,
                31
              ]
            }
          ]
        ],
        "state_before": "b : Board\nm : \u2124 \u00d7 \u2124\nh : m \u2208 b \u2227 (m.1 - 1, m.2) \u2208 b\n\u22a2 (m.1 - 1, m.2) \u2208 Finset.erase b m",
        "state_after": "b : Board\nm : \u2124 \u00d7 \u2124\nh : m \u2208 b \u2227 (m.1 - 1, m.2) \u2208 b\n\u22a2 (m.1 - 1, m.2) \u2260 m"
      },
      {
        "tactic": "exact ne_of_apply_ne Prod.fst (pred_ne_self m.1)",
        "annotated_tactic": [
          "exact <a>ne_of_apply_ne</a> <a>Prod.fst</a> (<a>pred_ne_self</a> m.1)",
          [
            {
              "full_name": "ne_of_apply_ne",
              "def_path": ".lake/packages/batteries/Batteries/Logic.lean",
              "def_pos": [
                66,
                9
              ],
              "def_end_pos": [
                66,
                23
              ]
            },
            {
              "full_name": "Prod.fst",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                483,
                3
              ],
              "def_end_pos": [
                483,
                6
              ]
            },
            {
              "full_name": "pred_ne_self",
              "def_path": "Mathlib/Algebra/Ring/Basic.lean",
              "def_pos": [
                144,
                9
              ],
              "def_end_pos": [
                144,
                21
              ]
            }
          ]
        ],
        "state_before": "b : Board\nm : \u2124 \u00d7 \u2124\nh : m \u2208 b \u2227 (m.1 - 1, m.2) \u2208 b\n\u22a2 (m.1 - 1, m.2) \u2260 m",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4621324320323765,
    "entry_failed": false
  },
  "11543": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Coxeter/Inversion.lean",
    "full_name": "CoxeterSystem.length_rightInvSeq",
    "start": [
      235,
      9
    ],
    "end": [
      238,
      24
    ],
    "traced_tactics": [
      {
        "tactic": "induction' \u03c9 with i \u03c9 ih",
        "annotated_tactic": [
          "induction' \u03c9 with i \u03c9 ih",
          []
        ],
        "state_before": "B : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\n\u03c9 : List B\n\u22a2 (cs.rightInvSeq \u03c9).length = \u03c9.length",
        "state_after": "case nil\nB : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\n\u22a2 (cs.rightInvSeq []).length = [].length\n\ncase cons\nB : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni : B\n\u03c9 : List B\nih : (cs.rightInvSeq \u03c9).length = \u03c9.length\n\u22a2 (cs.rightInvSeq (i :: \u03c9)).length = (i :: \u03c9).length"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case nil\nB : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\n\u22a2 (cs.rightInvSeq []).length = [].length",
        "state_after": "no goals"
      },
      {
        "tactic": "simpa [rightInvSeq]",
        "annotated_tactic": [
          "simpa [<a>rightInvSeq</a>]",
          [
            {
              "full_name": "CoxeterSystem.rightInvSeq",
              "def_path": "Mathlib/GroupTheory/Coxeter/Inversion.lean",
              "def_pos": [
                180,
                5
              ],
              "def_end_pos": [
                180,
                16
              ]
            }
          ]
        ],
        "state_before": "case cons\nB : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\ni : B\n\u03c9 : List B\nih : (cs.rightInvSeq \u03c9).length = \u03c9.length\n\u22a2 (cs.rightInvSeq (i :: \u03c9)).length = (i :: \u03c9).length",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.243840220035054,
    "entry_failed": false
  },
  "11563": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Probability/Kernel/Disintegration/CondCdf.lean",
    "full_name": "MeasureTheory.Measure.IicSnd_le_fst",
    "start": [
      72,
      1
    ],
    "end": [
      75,
      52
    ],
    "traced_tactics": [
      {
        "tactic": "refine Measure.le_iff.2 fun s hs \u21a6 ?_",
        "annotated_tactic": [
          "refine <a>Measure.le_iff</a>.2 fun s hs \u21a6 ?_",
          [
            {
              "full_name": "MeasureTheory.Measure.le_iff",
              "def_path": "Mathlib/MeasureTheory/Measure/MeasureSpace.lean",
              "def_pos": [
                1022,
                9
              ],
              "def_end_pos": [
                1022,
                15
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\n\u03c1 : Measure (\u03b1 \u00d7 \u211d)\nr : \u211d\n\u22a2 \u03c1.IicSnd r \u2264 \u03c1.fst",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\n\u03c1 : Measure (\u03b1 \u00d7 \u211d)\nr : \u211d\ns : Set \u03b1\nhs : MeasurableSet s\n\u22a2 (\u03c1.IicSnd r) s \u2264 \u03c1.fst s"
      },
      {
        "tactic": "simp_rw [fst_apply hs, IicSnd_apply \u03c1 r hs]",
        "annotated_tactic": [
          "simp_rw [<a>fst_apply</a> hs, <a>IicSnd_apply</a> \u03c1 r hs]",
          [
            {
              "full_name": "MeasureTheory.Measure.fst_apply",
              "def_path": "Mathlib/MeasureTheory/Constructions/Prod/Basic.lean",
              "def_pos": [
                1032,
                9
              ],
              "def_end_pos": [
                1032,
                18
              ]
            },
            {
              "full_name": "MeasureTheory.Measure.IicSnd_apply",
              "def_path": "Mathlib/Probability/Kernel/Disintegration/CondCdf.lean",
              "def_pos": [
                54,
                9
              ],
              "def_end_pos": [
                54,
                21
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\n\u03c1 : Measure (\u03b1 \u00d7 \u211d)\nr : \u211d\ns : Set \u03b1\nhs : MeasurableSet s\n\u22a2 (\u03c1.IicSnd r) s \u2264 \u03c1.fst s",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\n\u03c1 : Measure (\u03b1 \u00d7 \u211d)\nr : \u211d\ns : Set \u03b1\nhs : MeasurableSet s\n\u22a2 \u03c1 (s \u00d7\u02e2 Iic r) \u2264 \u03c1 (Prod.fst \u207b\u00b9' s)"
      },
      {
        "tactic": "exact measure_mono (prod_subset_preimage_fst _ _)",
        "annotated_tactic": [
          "exact <a>measure_mono</a> (<a>prod_subset_preimage_fst</a> _ _)",
          [
            {
              "full_name": "MeasureTheory.measure_mono",
              "def_path": "Mathlib/MeasureTheory/OuterMeasure/Basic.lean",
              "def_pos": [
                52,
                9
              ],
              "def_end_pos": [
                52,
                21
              ]
            },
            {
              "full_name": "Set.prod_subset_preimage_fst",
              "def_path": "Mathlib/Data/Set/Prod.lean",
              "def_pos": [
                350,
                9
              ],
              "def_end_pos": [
                350,
                33
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm\u03b1 : MeasurableSpace \u03b1\n\u03c1 : Measure (\u03b1 \u00d7 \u211d)\nr : \u211d\ns : Set \u03b1\nhs : MeasurableSet s\n\u22a2 \u03c1 (s \u00d7\u02e2 Iic r) \u2264 \u03c1 (Prod.fst \u207b\u00b9' s)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.248958947020583,
    "entry_failed": false
  },
  "11625": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/Harmonic/EulerMascheroni.lean",
    "full_name": "Real.tendsto_harmonic_sub_log",
    "start": [
      152,
      1
    ],
    "end": [
      156,
      46
    ],
    "traced_tactics": [
      {
        "tactic": "apply tendsto_eulerMascheroniSeq'.congr'",
        "annotated_tactic": [
          "apply tendsto_eulerMascheroniSeq'.congr'",
          []
        ],
        "state_before": "\u22a2 Tendsto (fun n => \u2191(harmonic n) - log \u2191n) atTop (\ud835\udcdd eulerMascheroniConstant)",
        "state_after": "\u22a2 eulerMascheroniSeq' =\u1da0[atTop] fun n => \u2191(harmonic n) - log \u2191n"
      },
      {
        "tactic": "filter_upwards [eventually_ne_atTop 0] with n hn",
        "annotated_tactic": [
          "filter_upwards [<a>eventually_ne_atTop</a> 0] with n hn",
          [
            {
              "full_name": "Filter.eventually_ne_atTop",
              "def_path": "Mathlib/Order/Filter/AtTopBot.lean",
              "def_pos": [
                205,
                9
              ],
              "def_end_pos": [
                205,
                28
              ]
            }
          ]
        ],
        "state_before": "\u22a2 eulerMascheroniSeq' =\u1da0[atTop] fun n => \u2191(harmonic n) - log \u2191n",
        "state_after": "case h\nn : \u2115\nhn : n \u2260 0\n\u22a2 eulerMascheroniSeq' n = \u2191(harmonic n) - log \u2191n"
      },
      {
        "tactic": "simp_rw [eulerMascheroniSeq', hn, if_false]",
        "annotated_tactic": [
          "simp_rw [<a>eulerMascheroniSeq'</a>, hn, <a>if_false</a>]",
          [
            {
              "full_name": "Real.eulerMascheroniSeq'",
              "def_path": "Mathlib/NumberTheory/Harmonic/EulerMascheroni.lean",
              "def_pos": [
                77,
                19
              ],
              "def_end_pos": [
                77,
                38
              ]
            },
            {
              "full_name": "if_false",
              "def_path": ".lake/packages/lean4/src/lean/Init/ByCases.lean",
              "def_pos": [
                26,
                17
              ],
              "def_end_pos": [
                26,
                25
              ]
            }
          ]
        ],
        "state_before": "case h\nn : \u2115\nhn : n \u2260 0\n\u22a2 eulerMascheroniSeq' n = \u2191(harmonic n) - log \u2191n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.181143433903344,
    "entry_failed": false
  },
  "11685": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean",
    "full_name": "Polynomial.int_cyclotomic_rw",
    "start": [
      258,
      1
    ],
    "end": [
      262,
      49
    ],
    "traced_tactics": [
      {
        "tactic": "simp only [cyclotomic, h, dif_neg, not_false_iff]",
        "annotated_tactic": [
          "simp only [<a>cyclotomic</a>, h, <a>dif_neg</a>, <a>not_false_iff</a>]",
          [
            {
              "full_name": "Polynomial.cyclotomic",
              "def_path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean",
              "def_pos": [
                253,
                5
              ],
              "def_end_pos": [
                253,
                15
              ]
            },
            {
              "full_name": "dif_neg",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                954,
                9
              ],
              "def_end_pos": [
                954,
                16
              ]
            },
            {
              "full_name": "not_false_iff",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1371,
                9
              ],
              "def_end_pos": [
                1371,
                22
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\nh : n \u2260 0\n\u22a2 cyclotomic n \u2124 = \u22ef.choose",
        "state_after": "n : \u2115\nh : n \u2260 0\n\u22a2 map (Int.castRingHom \u2124) \u22ef.choose = \u22ef.choose"
      },
      {
        "tactic": "ext i",
        "annotated_tactic": [
          "ext i",
          []
        ],
        "state_before": "n : \u2115\nh : n \u2260 0\n\u22a2 map (Int.castRingHom \u2124) \u22ef.choose = \u22ef.choose",
        "state_after": "case a\nn : \u2115\nh : n \u2260 0\ni : \u2115\n\u22a2 (map (Int.castRingHom \u2124) \u22ef.choose).coeff i = \u22ef.choose.coeff i"
      },
      {
        "tactic": "simp only [coeff_map, Int.cast_id, eq_intCast]",
        "annotated_tactic": [
          "simp only [<a>coeff_map</a>, <a>Int.cast_id</a>, <a>eq_intCast</a>]",
          [
            {
              "full_name": "Polynomial.coeff_map",
              "def_path": "Mathlib/Algebra/Polynomial/Eval.lean",
              "def_pos": [
                803,
                9
              ],
              "def_end_pos": [
                803,
                18
              ]
            },
            {
              "full_name": "Int.cast_id",
              "def_path": "Mathlib/Data/Int/Defs.lean",
              "def_pos": [
                163,
                26
              ],
              "def_end_pos": [
                163,
                33
              ]
            },
            {
              "full_name": "eq_intCast",
              "def_path": "Mathlib/Data/Int/Cast/Lemmas.lean",
              "def_pos": [
                412,
                9
              ],
              "def_end_pos": [
                412,
                19
              ]
            }
          ]
        ],
        "state_before": "case a\nn : \u2115\nh : n \u2260 0\ni : \u2115\n\u22a2 (map (Int.castRingHom \u2124) \u22ef.choose).coeff i = \u22ef.choose.coeff i",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.969812041032128,
    "entry_failed": false
  },
  "11701": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Fintype/Fin.lean",
    "full_name": "Fin.Iio_castSucc",
    "start": [
      55,
      1
    ],
    "end": [
      58,
      42
    ],
    "traced_tactics": [
      {
        "tactic": "apply Finset.map_injective Fin.valEmbedding",
        "annotated_tactic": [
          "apply <a>Finset.map_injective</a> <a>Fin.valEmbedding</a>",
          [
            {
              "full_name": "Finset.map_injective",
              "def_path": "Mathlib/Data/Finset/Image.lean",
              "def_pos": [
                197,
                9
              ],
              "def_end_pos": [
                197,
                22
              ]
            },
            {
              "full_name": "Fin.valEmbedding",
              "def_path": "Mathlib/Data/Fin/Basic.lean",
              "def_pos": [
                267,
                5
              ],
              "def_end_pos": [
                267,
                17
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : \u2115\ni : Fin n\n\u22a2 Iio i.castSucc = map castSuccEmb (Iio i)",
        "state_after": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : \u2115\ni : Fin n\n\u22a2 map valEmbedding (Iio i.castSucc) = map valEmbedding (map castSuccEmb (Iio i))"
      },
      {
        "tactic": "rw [Finset.map_map, Fin.map_valEmbedding_Iio]",
        "annotated_tactic": [
          "rw [<a>Finset.map_map</a>, <a>Fin.map_valEmbedding_Iio</a>]",
          [
            {
              "full_name": "Finset.map_map",
              "def_path": "Mathlib/Data/Finset/Image.lean",
              "def_pos": [
                147,
                9
              ],
              "def_end_pos": [
                147,
                16
              ]
            },
            {
              "full_name": "Fin.map_valEmbedding_Iio",
              "def_path": "Mathlib/Order/Interval/Finset/Fin.lean",
              "def_pos": [
                210,
                9
              ],
              "def_end_pos": [
                210,
                29
              ]
            }
          ]
        ],
        "state_before": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : \u2115\ni : Fin n\n\u22a2 map valEmbedding (Iio i.castSucc) = map valEmbedding (map castSuccEmb (Iio i))",
        "state_after": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : \u2115\ni : Fin n\n\u22a2 Iio \u2191i.castSucc = map (castSuccEmb.trans valEmbedding) (Iio i)"
      },
      {
        "tactic": "exact (Fin.map_valEmbedding_Iio i).symm",
        "annotated_tactic": [
          "exact (<a>Fin.map_valEmbedding_Iio</a> i).<a>symm</a>",
          [
            {
              "full_name": "Fin.map_valEmbedding_Iio",
              "def_path": "Mathlib/Order/Interval/Finset/Fin.lean",
              "def_pos": [
                210,
                9
              ],
              "def_end_pos": [
                210,
                29
              ]
            },
            {
              "full_name": "Eq.symm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                323,
                9
              ],
              "def_end_pos": [
                323,
                16
              ]
            }
          ]
        ],
        "state_before": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : \u2115\ni : Fin n\n\u22a2 Iio \u2191i.castSucc = map (castSuccEmb.trans valEmbedding) (Iio i)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4339645269792527,
    "entry_failed": false
  },
  "11707": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Category/Compactum.lean",
    "full_name": "Compactum.str_incl",
    "start": [
      142,
      1
    ],
    "end": [
      145,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "change ((\u03b2 ).\u03b7.app _ \u226b X.a) _ = _",
        "annotated_tactic": [
          "change ((\u03b2 ).\u03b7.app _ \u226b X.a) _ = _",
          []
        ],
        "state_before": "X : Compactum\nx : X.A\n\u22a2 X.str (X.incl x) = x",
        "state_after": "X : Compactum\nx : X.A\n\u22a2 (\u03b2.\u03b7.app X.A \u226b X.a) x = x"
      },
      {
        "tactic": "rw [Monad.Algebra.unit]",
        "annotated_tactic": [
          "rw [<a>Monad.Algebra.unit</a>]",
          [
            {
              "full_name": "CategoryTheory.Monad.Algebra.unit",
              "def_path": "Mathlib/CategoryTheory/Monad/Algebra.lean",
              "def_pos": [
                46,
                3
              ],
              "def_end_pos": [
                46,
                7
              ]
            }
          ]
        ],
        "state_before": "X : Compactum\nx : X.A\n\u22a2 (\u03b2.\u03b7.app X.A \u226b X.a) x = x",
        "state_after": "X : Compactum\nx : X.A\n\u22a2 \ud835\udfd9 X.A x = x"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "X : Compactum\nx : X.A\n\u22a2 \ud835\udfd9 X.A x = x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.1786319100065157,
    "entry_failed": false
  },
  "11726": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/ModEq.lean",
    "full_name": "Nat.ModEq.dvd_iff",
    "start": [
      256,
      1
    ],
    "end": [
      259,
      32
    ],
    "traced_tactics": [
      {
        "tactic": "simp only [\u2190 modEq_zero_iff_dvd]",
        "annotated_tactic": [
          "simp only [\u2190 <a>modEq_zero_iff_dvd</a>]",
          [
            {
              "full_name": "Nat.modEq_zero_iff_dvd",
              "def_path": "Mathlib/Data/Nat/ModEq.lean",
              "def_pos": [
                78,
                9
              ],
              "def_end_pos": [
                78,
                27
              ]
            }
          ]
        ],
        "state_before": "m n a b c d : \u2115\nh : a \u2261 b [MOD m]\nhdm : d \u2223 m\n\u22a2 d \u2223 a \u2194 d \u2223 b",
        "state_after": "m n a b c d : \u2115\nh : a \u2261 b [MOD m]\nhdm : d \u2223 m\n\u22a2 a \u2261 0 [MOD d] \u2194 b \u2261 0 [MOD d]"
      },
      {
        "tactic": "replace h := h.of_dvd hdm",
        "annotated_tactic": [
          "replace h := h.of_dvd hdm",
          []
        ],
        "state_before": "m n a b c d : \u2115\nh : a \u2261 b [MOD m]\nhdm : d \u2223 m\n\u22a2 a \u2261 0 [MOD d] \u2194 b \u2261 0 [MOD d]",
        "state_after": "m n a b c d : \u2115\nhdm : d \u2223 m\nh : a \u2261 b [MOD d]\n\u22a2 a \u2261 0 [MOD d] \u2194 b \u2261 0 [MOD d]"
      },
      {
        "tactic": "exact \u27e8h.symm.trans, h.trans\u27e9",
        "annotated_tactic": [
          "exact \u27e8h.symm.trans, h.trans\u27e9",
          []
        ],
        "state_before": "m n a b c d : \u2115\nhdm : d \u2223 m\nh : a \u2261 b [MOD d]\n\u22a2 a \u2261 0 [MOD d] \u2194 b \u2261 0 [MOD d]",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.3892692860681564,
    "entry_failed": false
  },
  "11733": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Complex/Circle.lean",
    "full_name": "isLocalHomeomorph_expMapCircle",
    "start": [
      235,
      1
    ],
    "end": [
      237,
      81
    ],
    "traced_tactics": [
      {
        "tactic": "have : Fact (0 < 2 * \u03c0) := \u27e8by positivity\u27e9",
        "annotated_tactic": [
          "have : <a>Fact</a> (0 < 2 * \u03c0) := \u27e8by positivity\u27e9",
          [
            {
              "full_name": "Fact",
              "def_path": "Mathlib/Logic/Basic.lean",
              "def_pos": [
                114,
                7
              ],
              "def_end_pos": [
                114,
                11
              ]
            }
          ]
        ],
        "state_before": "\u22a2 IsLocalHomeomorph \u21d1expMapCircle",
        "state_after": "this : Fact (0 < 2 * \u03c0)\n\u22a2 IsLocalHomeomorph \u21d1expMapCircle"
      },
      {
        "tactic": "exact homeomorphCircle'.isLocalHomeomorph.comp (isLocalHomeomorph_coe (2 * \u03c0))",
        "annotated_tactic": [
          "exact homeomorphCircle'.isLocalHomeomorph.comp (<a>isLocalHomeomorph_coe</a> (2 * \u03c0))",
          [
            {
              "full_name": "AddCircle.isLocalHomeomorph_coe",
              "def_path": "Mathlib/Topology/Instances/AddCircle.lean",
              "def_pos": [
                304,
                7
              ],
              "def_end_pos": [
                304,
                28
              ]
            }
          ]
        ],
        "state_before": "this : Fact (0 < 2 * \u03c0)\n\u22a2 IsLocalHomeomorph \u21d1expMapCircle",
        "state_after": "no goals"
      },
      {
        "tactic": "positivity",
        "annotated_tactic": [
          "positivity",
          []
        ],
        "state_before": "\u22a2 0 < 2 * \u03c0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.0194053100422025,
    "entry_failed": false
  },
  "11741": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/LinearAlgebra/Projectivization/Subspace.lean",
    "full_name": "Projectivization.Subspace.span_univ",
    "start": [
      155,
      1
    ],
    "end": [
      158,
      39
    ],
    "traced_tactics": [
      {
        "tactic": "rw [eq_top_iff, SetLike.le_def]",
        "annotated_tactic": [
          "rw [<a>eq_top_iff</a>, <a>SetLike.le_def</a>]",
          [
            {
              "full_name": "eq_top_iff",
              "def_path": "Mathlib/Order/BoundedOrder.lean",
              "def_pos": [
                133,
                9
              ],
              "def_end_pos": [
                133,
                19
              ]
            },
            {
              "full_name": "SetLike.le_def",
              "def_path": "Mathlib/Data/SetLike/Basic.lean",
              "def_pos": [
                208,
                9
              ],
              "def_end_pos": [
                208,
                15
              ]
            }
          ]
        ],
        "state_before": "K : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\n\u22a2 span Set.univ = \u22a4",
        "state_after": "K : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\n\u22a2 \u2200 \u2983x : \u2119 K V\u2984, x \u2208 \u22a4 \u2192 x \u2208 span Set.univ"
      },
      {
        "tactic": "intro x _hx",
        "annotated_tactic": [
          "intro x _hx",
          []
        ],
        "state_before": "K : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\n\u22a2 \u2200 \u2983x : \u2119 K V\u2984, x \u2208 \u22a4 \u2192 x \u2208 span Set.univ",
        "state_after": "K : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nx : \u2119 K V\n_hx : x \u2208 \u22a4\n\u22a2 x \u2208 span Set.univ"
      },
      {
        "tactic": "exact subset_span _ (Set.mem_univ x)",
        "annotated_tactic": [
          "exact <a>subset_span</a> _ (<a>Set.mem_univ</a> x)",
          [
            {
              "full_name": "Projectivization.Subspace.subset_span",
              "def_path": "Mathlib/LinearAlgebra/Projectivization/Subspace.lean",
              "def_pos": [
                92,
                9
              ],
              "def_end_pos": [
                92,
                20
              ]
            },
            {
              "full_name": "Set.mem_univ",
              "def_path": "Mathlib/Data/Set/Defs.lean",
              "def_pos": [
                82,
                29
              ],
              "def_end_pos": [
                82,
                37
              ]
            }
          ]
        ],
        "state_before": "K : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nx : \u2119 K V\n_hx : x \u2208 \u22a4\n\u22a2 x \u2208 span Set.univ",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.8208256629295647,
    "entry_failed": false
  },
  "11816": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Fib/Basic.lean",
    "full_name": "Nat.fib_add_two_strictMono",
    "start": [
      120,
      1
    ],
    "end": [
      123,
      47
    ],
    "traced_tactics": [
      {
        "tactic": "refine strictMono_nat_of_lt_succ fun n => ?_",
        "annotated_tactic": [
          "refine <a>strictMono_nat_of_lt_succ</a> fun n => ?_",
          [
            {
              "full_name": "strictMono_nat_of_lt_succ",
              "def_path": "Mathlib/Order/Monotone/Basic.lean",
              "def_pos": [
                1064,
                9
              ],
              "def_end_pos": [
                1064,
                34
              ]
            }
          ]
        ],
        "state_before": "\u22a2 StrictMono fun n => fib (n + 2)",
        "state_after": "n : \u2115\n\u22a2 fib (n + 2) < fib (n + 1 + 2)"
      },
      {
        "tactic": "rw [add_right_comm]",
        "annotated_tactic": [
          "rw [<a>add_right_comm</a>]",
          [
            {
              "full_name": "add_right_comm",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                189,
                3
              ],
              "def_end_pos": [
                189,
                14
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\n\u22a2 fib (n + 2) < fib (n + 1 + 2)",
        "state_after": "n : \u2115\n\u22a2 fib (n + 2) < fib (n + 2 + 1)"
      },
      {
        "tactic": "exact fib_lt_fib_succ (self_le_add_left _ _)",
        "annotated_tactic": [
          "exact <a>fib_lt_fib_succ</a> (<a>self_le_add_left</a> _ _)",
          [
            {
              "full_name": "Nat.fib_lt_fib_succ",
              "def_path": "Mathlib/Data/Nat/Fib/Basic.lean",
              "def_pos": [
                113,
                9
              ],
              "def_end_pos": [
                113,
                24
              ]
            },
            {
              "full_name": "self_le_add_left",
              "def_path": "Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean",
              "def_pos": [
                160,
                3
              ],
              "def_end_pos": [
                160,
                14
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\n\u22a2 fib (n + 2) < fib (n + 2 + 1)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.620508524007164,
    "entry_failed": false
  },
  "11867": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Algebra/ValuedField.lean",
    "full_name": "Valued.extension_extends",
    "start": [
      276,
      1
    ],
    "end": [
      279,
      49
    ],
    "traced_tactics": [
      {
        "tactic": "refine Completion.denseInducing_coe.extend_eq_of_tendsto ?_",
        "annotated_tactic": [
          "refine Completion.denseInducing_coe.extend_eq_of_tendsto ?_",
          []
        ],
        "state_before": "K : Type u_1\ninst\u271d\u00b9 : Field K\n\u0393\u2080 : Type u_2\ninst\u271d : LinearOrderedCommGroupWithZero \u0393\u2080\nhv : Valued K \u0393\u2080\nx : K\n\u22a2 extension (\u2191K x) = v x",
        "state_after": "K : Type u_1\ninst\u271d\u00b9 : Field K\n\u0393\u2080 : Type u_2\ninst\u271d : LinearOrderedCommGroupWithZero \u0393\u2080\nhv : Valued K \u0393\u2080\nx : K\n\u22a2 Tendsto (\u21d1v) (Filter.comap (\u2191K) (\ud835\udcdd (\u2191K x))) (\ud835\udcdd (v x))"
      },
      {
        "tactic": "rw [\u2190 Completion.denseInducing_coe.nhds_eq_comap]",
        "annotated_tactic": [
          "rw [\u2190 Completion.denseInducing_coe.nhds_eq_comap]",
          []
        ],
        "state_before": "K : Type u_1\ninst\u271d\u00b9 : Field K\n\u0393\u2080 : Type u_2\ninst\u271d : LinearOrderedCommGroupWithZero \u0393\u2080\nhv : Valued K \u0393\u2080\nx : K\n\u22a2 Tendsto (\u21d1v) (Filter.comap (\u2191K) (\ud835\udcdd (\u2191K x))) (\ud835\udcdd (v x))",
        "state_after": "K : Type u_1\ninst\u271d\u00b9 : Field K\n\u0393\u2080 : Type u_2\ninst\u271d : LinearOrderedCommGroupWithZero \u0393\u2080\nhv : Valued K \u0393\u2080\nx : K\n\u22a2 Tendsto (\u21d1v) (\ud835\udcdd x) (\ud835\udcdd (v x))"
      },
      {
        "tactic": "exact Valued.continuous_valuation.continuousAt",
        "annotated_tactic": [
          "exact Valued.continuous_valuation.continuousAt",
          []
        ],
        "state_before": "K : Type u_1\ninst\u271d\u00b9 : Field K\n\u0393\u2080 : Type u_2\ninst\u271d : LinearOrderedCommGroupWithZero \u0393\u2080\nhv : Valued K \u0393\u2080\nx : K\n\u22a2 Tendsto (\u21d1v) (\ud835\udcdd x) (\ud835\udcdd (v x))",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.514655041042715,
    "entry_failed": false
  },
  "11887": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Exponent.lean",
    "full_name": "Monoid.exponent_eq_zero_iff_forall",
    "start": [
      143,
      1
    ],
    "end": [
      146,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "rw [exponent_eq_zero_iff, ExponentExists]",
        "annotated_tactic": [
          "rw [<a>exponent_eq_zero_iff</a>, <a>ExponentExists</a>]",
          [
            {
              "full_name": "Monoid.exponent_eq_zero_iff",
              "def_path": "Mathlib/GroupTheory/Exponent.lean",
              "def_pos": [
                129,
                9
              ],
              "def_end_pos": [
                129,
                29
              ]
            },
            {
              "full_name": "Monoid.ExponentExists",
              "def_path": "Mathlib/GroupTheory/Exponent.lean",
              "def_pos": [
                65,
                5
              ],
              "def_end_pos": [
                65,
                19
              ]
            }
          ]
        ],
        "state_before": "G : Type u\ninst\u271d : Monoid G\n\u22a2 exponent G = 0 \u2194 \u2200 n > 0, \u2203 g, g ^ n \u2260 1",
        "state_after": "G : Type u\ninst\u271d : Monoid G\n\u22a2 (\u00ac\u2203 n, 0 < n \u2227 \u2200 (g : G), g ^ n = 1) \u2194 \u2200 n > 0, \u2203 g, g ^ n \u2260 1"
      },
      {
        "tactic": "push_neg",
        "annotated_tactic": [
          "push_neg",
          []
        ],
        "state_before": "G : Type u\ninst\u271d : Monoid G\n\u22a2 (\u00ac\u2203 n, 0 < n \u2227 \u2200 (g : G), g ^ n = 1) \u2194 \u2200 n > 0, \u2203 g, g ^ n \u2260 1",
        "state_after": "G : Type u\ninst\u271d : Monoid G\n\u22a2 (\u2200 (n : \u2115), 0 < n \u2192 \u2203 g, g ^ n \u2260 1) \u2194 \u2200 n > 0, \u2203 g, g ^ n \u2260 1"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "G : Type u\ninst\u271d : Monoid G\n\u22a2 (\u2200 (n : \u2115), 0 < n \u2192 \u2203 g, g ^ n \u2260 1) \u2194 \u2200 n > 0, \u2203 g, g ^ n \u2260 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.20306874695234,
    "entry_failed": false
  },
  "11911": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Ring/Rat.lean",
    "full_name": "Rat.le_def",
    "start": [
      186,
      1
    ],
    "end": [
      189,
      63
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 num_divInt_den q, \u2190 num_divInt_den p]",
        "annotated_tactic": [
          "rw [\u2190 <a>num_divInt_den</a> q, \u2190 <a>num_divInt_den</a> p]",
          [
            {
              "full_name": "Rat.num_divInt_den",
              "def_path": "Mathlib/Data/Rat/Defs.lean",
              "def_pos": [
                146,
                7
              ],
              "def_end_pos": [
                146,
                21
              ]
            },
            {
              "full_name": "Rat.num_divInt_den",
              "def_path": "Mathlib/Data/Rat/Defs.lean",
              "def_pos": [
                146,
                7
              ],
              "def_end_pos": [
                146,
                21
              ]
            }
          ]
        ],
        "state_before": "a b c p q : \u211a\n\u22a2 p \u2264 q \u2194 p.num * \u2191q.den \u2264 q.num * \u2191p.den",
        "state_after": "a b c p q : \u211a\n\u22a2 p.num /. \u2191p.den \u2264 q.num /. \u2191q.den \u2194\n    (p.num /. \u2191p.den).num * \u2191(q.num /. \u2191q.den).den \u2264 (q.num /. \u2191q.den).num * \u2191(p.num /. \u2191p.den).den"
      },
      {
        "tactic": "conv_rhs => simp only [num_divInt_den]",
        "annotated_tactic": [
          "conv_rhs => simp only [<a>num_divInt_den</a>]",
          [
            {
              "full_name": "Rat.num_divInt_den",
              "def_path": "Mathlib/Data/Rat/Defs.lean",
              "def_pos": [
                146,
                7
              ],
              "def_end_pos": [
                146,
                21
              ]
            }
          ]
        ],
        "state_before": "a b c p q : \u211a\n\u22a2 p.num /. \u2191p.den \u2264 q.num /. \u2191q.den \u2194\n    (p.num /. \u2191p.den).num * \u2191(q.num /. \u2191q.den).den \u2264 (q.num /. \u2191q.den).num * \u2191(p.num /. \u2191p.den).den",
        "state_after": "a b c p q : \u211a\n\u22a2 p.num /. \u2191p.den \u2264 q.num /. \u2191q.den \u2194 p.num * \u2191q.den \u2264 q.num * \u2191p.den"
      },
      {
        "tactic": "exact Rat.divInt_le_divInt (mod_cast p.pos) (mod_cast q.pos)",
        "annotated_tactic": [
          "exact <a>Rat.divInt_le_divInt</a> (mod_cast p.pos) (mod_cast q.pos)",
          [
            {
              "full_name": "Rat.divInt_le_divInt",
              "def_path": "Mathlib/Algebra/Order/Ring/Rat.lean",
              "def_pos": [
                133,
                17
              ],
              "def_end_pos": [
                133,
                33
              ]
            }
          ]
        ],
        "state_before": "a b c p q : \u211a\n\u22a2 p.num /. \u2191p.den \u2264 q.num /. \u2191q.den \u2194 p.num * \u2191q.den \u2264 q.num * \u2191p.den",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.32564217899926,
    "entry_failed": false
  },
  "11930": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Cycle.lean",
    "full_name": "List.prev_cons_cons_of_ne'",
    "start": [
      228,
      1
    ],
    "end": [
      232,
      37
    ],
    "traced_tactics": [
      {
        "tactic": "cases l",
        "annotated_tactic": [
          "cases l",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx y z : \u03b1\nh : x \u2208 y :: z :: l\nhy : x \u2260 y\nhz : x = z\n\u22a2 (y :: z :: l).prev x h = y",
        "state_after": "case nil\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx y z : \u03b1\nhy : x \u2260 y\nhz : x = z\nh : x \u2208 [y, z]\n\u22a2 [y, z].prev x h = y\n\ncase cons\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx y z : \u03b1\nhy : x \u2260 y\nhz : x = z\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\nh : x \u2208 y :: z :: head\u271d :: tail\u271d\n\u22a2 (y :: z :: head\u271d :: tail\u271d).prev x h = y"
      },
      {
        "tactic": "simp [prev, hy, hz]",
        "annotated_tactic": [
          "simp [<a>prev</a>, hy, hz]",
          [
            {
              "full_name": "List.prev",
              "def_path": "Mathlib/Data/List/Cycle.lean",
              "def_pos": [
                134,
                5
              ],
              "def_end_pos": [
                134,
                9
              ]
            }
          ]
        ],
        "state_before": "case nil\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx y z : \u03b1\nhy : x \u2260 y\nhz : x = z\nh : x \u2208 [y, z]\n\u22a2 [y, z].prev x h = y",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [prev, dif_neg hy, if_pos hz]",
        "annotated_tactic": [
          "rw [<a>prev</a>, <a>dif_neg</a> hy, <a>if_pos</a> hz]",
          [
            {
              "full_name": "List.prev",
              "def_path": "Mathlib/Data/List/Cycle.lean",
              "def_pos": [
                134,
                5
              ],
              "def_end_pos": [
                134,
                9
              ]
            },
            {
              "full_name": "dif_neg",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                954,
                9
              ],
              "def_end_pos": [
                954,
                16
              ]
            },
            {
              "full_name": "if_pos",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                932,
                9
              ],
              "def_end_pos": [
                932,
                15
              ]
            }
          ]
        ],
        "state_before": "case cons\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx y z : \u03b1\nhy : x \u2260 y\nhz : x = z\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\nh : x \u2208 y :: z :: head\u271d :: tail\u271d\n\u22a2 (y :: z :: head\u271d :: tail\u271d).prev x h = y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.3290678310440853,
    "entry_failed": false
  },
  "12088": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/TypeVec.lean",
    "full_name": "TypeVec.Arrow.ext",
    "start": [
      60,
      1
    ],
    "end": [
      62,
      29
    ],
    "traced_tactics": [
      {
        "tactic": "intro h",
        "annotated_tactic": [
          "intro h",
          []
        ],
        "state_before": "n : \u2115\n\u03b1 : TypeVec.{u_1} n\n\u03b2 : TypeVec.{u_2} n\nf g : \u03b1 \u27f9 \u03b2\n\u22a2 (\u2200 (i : Fin2 n), f i = g i) \u2192 f = g",
        "state_after": "n : \u2115\n\u03b1 : TypeVec.{u_1} n\n\u03b2 : TypeVec.{u_2} n\nf g : \u03b1 \u27f9 \u03b2\nh : \u2200 (i : Fin2 n), f i = g i\n\u22a2 f = g"
      },
      {
        "tactic": "funext i",
        "annotated_tactic": [
          "funext i",
          []
        ],
        "state_before": "n : \u2115\n\u03b1 : TypeVec.{u_1} n\n\u03b2 : TypeVec.{u_2} n\nf g : \u03b1 \u27f9 \u03b2\nh : \u2200 (i : Fin2 n), f i = g i\n\u22a2 f = g",
        "state_after": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} n\n\u03b2 : TypeVec.{u_2} n\nf g : \u03b1 \u27f9 \u03b2\nh : \u2200 (i : Fin2 n), f i = g i\ni : Fin2 n\n\u22a2 f i = g i"
      },
      {
        "tactic": "apply h",
        "annotated_tactic": [
          "apply h",
          []
        ],
        "state_before": "case h\nn : \u2115\n\u03b1 : TypeVec.{u_1} n\n\u03b2 : TypeVec.{u_2} n\nf g : \u03b1 \u27f9 \u03b2\nh : \u2200 (i : Fin2 n), f i = g i\ni : Fin2 n\n\u22a2 f i = g i",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8481115699978545,
    "entry_failed": false
  },
  "12107": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/FermatPsp.lean",
    "full_name": "Nat.coprime_of_fermatPsp",
    "start": [
      120,
      1
    ],
    "end": [
      122,
      50
    ],
    "traced_tactics": [
      {
        "tactic": "rcases h with \u27e8hp, _, hn\u2082\u27e9",
        "annotated_tactic": [
          "rcases h with \u27e8hp, _, hn\u2082\u27e9",
          []
        ],
        "state_before": "n b : \u2115\nh : n.FermatPsp b\nh\u2081 : 1 \u2264 b\n\u22a2 n.Coprime b",
        "state_after": "case intro.intro\nn b : \u2115\nh\u2081 : 1 \u2264 b\nhp : n.ProbablePrime b\nleft\u271d : \u00acPrime n\nhn\u2082 : 1 < n\n\u22a2 n.Coprime b"
      },
      {
        "tactic": "exact coprime_of_probablePrime hp (by omega) h\u2081",
        "annotated_tactic": [
          "exact <a>coprime_of_probablePrime</a> hp (by omega) h\u2081",
          [
            {
              "full_name": "Nat.coprime_of_probablePrime",
              "def_path": "Mathlib/NumberTheory/FermatPsp.lean",
              "def_pos": [
                75,
                9
              ],
              "def_end_pos": [
                75,
                33
              ]
            }
          ]
        ],
        "state_before": "case intro.intro\nn b : \u2115\nh\u2081 : 1 \u2264 b\nhp : n.ProbablePrime b\nleft\u271d : \u00acPrime n\nhn\u2082 : 1 < n\n\u22a2 n.Coprime b",
        "state_after": "no goals"
      },
      {
        "tactic": "omega",
        "annotated_tactic": [
          "omega",
          []
        ],
        "state_before": "n b : \u2115\nh\u2081 : 1 \u2264 b\nhp : n.ProbablePrime b\nleft\u271d : \u00acPrime n\nhn\u2082 : 1 < n\n\u22a2 1 \u2264 n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9140798039734364,
    "entry_failed": false
  },
  "12154": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/ENNReal/Real.lean",
    "full_name": "ENNReal.toReal_eq_toReal",
    "start": [
      456,
      1
    ],
    "end": [
      459,
      50
    ],
    "traced_tactics": [
      {
        "tactic": "lift a to \u211d\u22650 using ha",
        "annotated_tactic": [
          "lift a to \u211d\u22650 using ha",
          []
        ],
        "state_before": "a b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nha : a \u2260 \u22a4\nhb : b \u2260 \u22a4\n\u22a2 a.toReal = b.toReal \u2194 a = b",
        "state_after": "case intro\nb c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nhb : b \u2260 \u22a4\na : \u211d\u22650\n\u22a2 (\u2191a).toReal = b.toReal \u2194 \u2191a = b"
      },
      {
        "tactic": "lift b to \u211d\u22650 using hb",
        "annotated_tactic": [
          "lift b to \u211d\u22650 using hb",
          []
        ],
        "state_before": "case intro\nb c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nhb : b \u2260 \u22a4\na : \u211d\u22650\n\u22a2 (\u2191a).toReal = b.toReal \u2194 \u2191a = b",
        "state_after": "case intro.intro\nc d : \u211d\u22650\u221e\nr p q a b : \u211d\u22650\n\u22a2 (\u2191a).toReal = (\u2191b).toReal \u2194 \u2191a = \u2191b"
      },
      {
        "tactic": "simp only [coe_inj, NNReal.coe_inj, coe_toReal]",
        "annotated_tactic": [
          "simp only [<a>coe_inj</a>, <a>NNReal.coe_inj</a>, <a>coe_toReal</a>]",
          [
            {
              "full_name": "ENNReal.coe_inj",
              "def_path": "Mathlib/Data/ENNReal/Basic.lean",
              "def_pos": [
                181,
                26
              ],
              "def_end_pos": [
                181,
                33
              ]
            },
            {
              "full_name": "NNReal.coe_inj",
              "def_path": "Mathlib/Data/NNReal/Basic.lean",
              "def_pos": [
                167,
                26
              ],
              "def_end_pos": [
                167,
                33
              ]
            },
            {
              "full_name": "ENNReal.coe_toReal",
              "def_path": "Mathlib/Data/ENNReal/Basic.lean",
              "def_pos": [
                262,
                17
              ],
              "def_end_pos": [
                262,
                27
              ]
            }
          ]
        ],
        "state_before": "case intro.intro\nc d : \u211d\u22650\u221e\nr p q a b : \u211d\u22650\n\u22a2 (\u2191a).toReal = (\u2191b).toReal \u2194 \u2191a = \u2191b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.555286640999839,
    "entry_failed": false
  },
  "12177": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Rotate.lean",
    "full_name": "List.IsRotated.map",
    "start": [
      546,
      1
    ],
    "end": [
      550,
      8
    ],
    "traced_tactics": [
      {
        "tactic": "obtain \u27e8n, rfl\u27e9 := h",
        "annotated_tactic": [
          "obtain \u27e8n, rfl\u27e9 := h",
          []
        ],
        "state_before": "\u03b1 : Type u\nl l' : List \u03b1\n\u03b2 : Type u_1\nl\u2081 l\u2082 : List \u03b1\nh : l\u2081 ~r l\u2082\nf : \u03b1 \u2192 \u03b2\n\u22a2 List.map f l\u2081 ~r List.map f l\u2082",
        "state_after": "case intro\n\u03b1 : Type u\nl l' : List \u03b1\n\u03b2 : Type u_1\nl\u2081 : List \u03b1\nf : \u03b1 \u2192 \u03b2\nn : \u2115\n\u22a2 List.map f l\u2081 ~r List.map f (l\u2081.rotate n)"
      },
      {
        "tactic": "rw [map_rotate]",
        "annotated_tactic": [
          "rw [<a>map_rotate</a>]",
          [
            {
              "full_name": "List.map_rotate",
              "def_path": "Mathlib/Data/List/Rotate.lean",
              "def_pos": [
                388,
                9
              ],
              "def_end_pos": [
                388,
                19
              ]
            }
          ]
        ],
        "state_before": "case intro\n\u03b1 : Type u\nl l' : List \u03b1\n\u03b2 : Type u_1\nl\u2081 : List \u03b1\nf : \u03b1 \u2192 \u03b2\nn : \u2115\n\u22a2 List.map f l\u2081 ~r List.map f (l\u2081.rotate n)",
        "state_after": "case intro\n\u03b1 : Type u\nl l' : List \u03b1\n\u03b2 : Type u_1\nl\u2081 : List \u03b1\nf : \u03b1 \u2192 \u03b2\nn : \u2115\n\u22a2 List.map f l\u2081 ~r (List.map f l\u2081).rotate n"
      },
      {
        "tactic": "use n",
        "annotated_tactic": [
          "use n",
          []
        ],
        "state_before": "case intro\n\u03b1 : Type u\nl l' : List \u03b1\n\u03b2 : Type u_1\nl\u2081 : List \u03b1\nf : \u03b1 \u2192 \u03b2\nn : \u2115\n\u22a2 List.map f l\u2081 ~r (List.map f l\u2081).rotate n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.250466441968456,
    "entry_failed": false
  },
  "12189": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/DList/Defs.lean",
    "full_name": "Batteries.DList.toList_push",
    "start": [
      84,
      1
    ],
    "end": [
      85,
      54
    ],
    "traced_tactics": [
      {
        "tactic": "cases' l with _ l_invariant",
        "annotated_tactic": [
          "cases' l with _ l_invariant",
          []
        ],
        "state_before": "\u03b1 : Type u\nx : \u03b1\nl : DList \u03b1\n\u22a2 (l.push x).toList = l.toList ++ [x]",
        "state_after": "case mk\n\u03b1 : Type u\nx : \u03b1\napply\u271d : List \u03b1 \u2192 List \u03b1\nl_invariant : \u2200 (l : List \u03b1), apply\u271d l = apply\u271d [] ++ l\n\u22a2 ({ apply := apply\u271d, invariant := l_invariant }.push x).toList =\n    { apply := apply\u271d, invariant := l_invariant }.toList ++ [x]"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case mk\n\u03b1 : Type u\nx : \u03b1\napply\u271d : List \u03b1 \u2192 List \u03b1\nl_invariant : \u2200 (l : List \u03b1), apply\u271d l = apply\u271d [] ++ l\n\u22a2 ({ apply := apply\u271d, invariant := l_invariant }.push x).toList =\n    { apply := apply\u271d, invariant := l_invariant }.toList ++ [x]",
        "state_after": "case mk\n\u03b1 : Type u\nx : \u03b1\napply\u271d : List \u03b1 \u2192 List \u03b1\nl_invariant : \u2200 (l : List \u03b1), apply\u271d l = apply\u271d [] ++ l\n\u22a2 apply\u271d [x] = apply\u271d [] ++ [x]"
      },
      {
        "tactic": "rw [l_invariant]",
        "annotated_tactic": [
          "rw [l_invariant]",
          []
        ],
        "state_before": "case mk\n\u03b1 : Type u\nx : \u03b1\napply\u271d : List \u03b1 \u2192 List \u03b1\nl_invariant : \u2200 (l : List \u03b1), apply\u271d l = apply\u271d [] ++ l\n\u22a2 apply\u271d [x] = apply\u271d [] ++ [x]",
        "state_after": "no goals"
      }
    ],
    "entry_time": 0.7586100769694895,
    "entry_failed": false
  },
  "12230": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/ZMod/Basic.lean",
    "full_name": "Prod.snd_zmod_cast",
    "start": [
      199,
      1
    ],
    "end": [
      202,
      21
    ],
    "traced_tactics": [
      {
        "tactic": "cases n",
        "annotated_tactic": [
          "cases n",
          []
        ],
        "state_before": "n : \u2115\nR : Type u_1\ninst\u271d\u00b9 : AddGroupWithOne R\nS : Type u_2\ninst\u271d : AddGroupWithOne S\na : ZMod n\n\u22a2 a.cast.2 = a.cast",
        "state_after": "case zero\nR : Type u_1\ninst\u271d\u00b9 : AddGroupWithOne R\nS : Type u_2\ninst\u271d : AddGroupWithOne S\na : ZMod 0\n\u22a2 a.cast.2 = a.cast\n\ncase succ\nR : Type u_1\ninst\u271d\u00b9 : AddGroupWithOne R\nS : Type u_2\ninst\u271d : AddGroupWithOne S\nn\u271d : \u2115\na : ZMod (n\u271d + 1)\n\u22a2 a.cast.2 = a.cast"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case zero\nR : Type u_1\ninst\u271d\u00b9 : AddGroupWithOne R\nS : Type u_2\ninst\u271d : AddGroupWithOne S\na : ZMod 0\n\u22a2 a.cast.2 = a.cast",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [ZMod.cast]",
        "annotated_tactic": [
          "simp [<a>ZMod.cast</a>]",
          [
            {
              "full_name": "ZMod.cast",
              "def_path": "Mathlib/Data/ZMod/Basic.lean",
              "def_pos": [
                169,
                5
              ],
              "def_end_pos": [
                169,
                9
              ]
            }
          ]
        ],
        "state_before": "case succ\nR : Type u_1\ninst\u271d\u00b9 : AddGroupWithOne R\nS : Type u_2\ninst\u271d : AddGroupWithOne S\nn\u271d : \u2115\na : ZMod (n\u271d + 1)\n\u22a2 a.cast.2 = a.cast",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.6820705729769543,
    "entry_failed": false
  },
  "12331": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": ".lake/packages/batteries/Batteries/Data/HashMap/WF.lean",
    "full_name": "Batteries.HashMap.Imp.Buckets.mk_size",
    "start": [
      38,
      1
    ],
    "end": [
      40,
      49
    ],
    "traced_tactics": [
      {
        "tactic": "simp only [mk, mkArray, size_eq]",
        "annotated_tactic": [
          "simp only [<a>mk</a>, <a>mkArray</a>, <a>size_eq</a>]",
          [
            {
              "full_name": "Batteries.HashMap.Imp.Buckets.mk",
              "def_path": ".lake/packages/batteries/Batteries/Data/HashMap/Basic.lean",
              "def_pos": [
                29,
                5
              ],
              "def_end_pos": [
                29,
                7
              ]
            },
            {
              "full_name": "Array.mkArray",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Basic.lean",
              "def_pos": [
                20,
                5
              ],
              "def_end_pos": [
                20,
                12
              ]
            },
            {
              "full_name": "Batteries.HashMap.Imp.Buckets.size_eq",
              "def_path": ".lake/packages/batteries/Batteries/Data/HashMap/WF.lean",
              "def_pos": [
                35,
                9
              ],
              "def_end_pos": [
                35,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : Nat\nh : 0 < n\n\u22a2 (mk n h).size = 0",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : Nat\nh : 0 < n\n\u22a2 Nat.sum (List.map (fun x => x.toList.length) (List.replicate n AssocList.nil)) = 0"
      },
      {
        "tactic": "clear h",
        "annotated_tactic": [
          "clear h",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : Nat\nh : 0 < n\n\u22a2 Nat.sum (List.map (fun x => x.toList.length) (List.replicate n AssocList.nil)) = 0",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : Nat\n\u22a2 Nat.sum (List.map (fun x => x.toList.length) (List.replicate n AssocList.nil)) = 0"
      },
      {
        "tactic": "induction n <;> simp_all [List.replicate_succ]",
        "annotated_tactic": [
          "induction n <;> simp_all [<a>List.replicate_succ</a>]",
          [
            {
              "full_name": "List.replicate_succ",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean",
              "def_pos": [
                573,
                9
              ],
              "def_end_pos": [
                573,
                23
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : Nat\n\u22a2 Nat.sum (List.map (fun x => x.toList.length) (List.replicate n AssocList.nil)) = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.1155444990145043,
    "entry_failed": false
  },
  "12347": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Choose/Basic.lean",
    "full_name": "Nat.choose_le_add",
    "start": [
      336,
      1
    ],
    "end": [
      339,
      51
    ],
    "traced_tactics": [
      {
        "tactic": "induction' b with b_n b_ih",
        "annotated_tactic": [
          "induction' b with b_n b_ih",
          []
        ],
        "state_before": "a b c : \u2115\n\u22a2 a.choose c \u2264 (a + b).choose c",
        "state_after": "case zero\na c : \u2115\n\u22a2 a.choose c \u2264 (a + 0).choose c\n\ncase succ\na c b_n : \u2115\nb_ih : a.choose c \u2264 (a + b_n).choose c\n\u22a2 a.choose c \u2264 (a + (b_n + 1)).choose c"
      },
      {
        "tactic": "exact le_trans b_ih (choose_le_succ (a + b_n) c)",
        "annotated_tactic": [
          "exact <a>le_trans</a> b_ih (<a>choose_le_succ</a> (a + b_n) c)",
          [
            {
              "full_name": "le_trans",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                56,
                9
              ],
              "def_end_pos": [
                56,
                17
              ]
            },
            {
              "full_name": "Nat.choose_le_succ",
              "def_path": "Mathlib/Data/Nat/Choose/Basic.lean",
              "def_pos": [
                332,
                9
              ],
              "def_end_pos": [
                332,
                23
              ]
            }
          ]
        ],
        "state_before": "case succ\na c b_n : \u2115\nb_ih : a.choose c \u2264 (a + b_n).choose c\n\u22a2 a.choose c \u2264 (a + (b_n + 1)).choose c",
        "state_after": "no goals"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case zero\na c : \u2115\n\u22a2 a.choose c \u2264 (a + 0).choose c",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.214315306977369,
    "entry_failed": false
  },
  "12419": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/JordanHolder.lean",
    "full_name": "CompositionSeries.eq_snoc_eraseLast",
    "start": [
      317,
      1
    ],
    "end": [
      321,
      51
    ],
    "traced_tactics": [
      {
        "tactic": "ext x",
        "annotated_tactic": [
          "ext x",
          []
        ],
        "state_before": "X : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\ns : CompositionSeries X\nh : 0 < s.length\n\u22a2 s = (eraseLast s).snoc (last s) \u22ef",
        "state_after": "case h\nX : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\ns : CompositionSeries X\nh : 0 < s.length\nx : X\n\u22a2 x \u2208 s \u2194 x \u2208 (eraseLast s).snoc (last s) \u22ef"
      },
      {
        "tactic": "simp only [mem_snoc, mem_eraseLast h, ne_eq]",
        "annotated_tactic": [
          "simp only [<a>mem_snoc</a>, <a>mem_eraseLast</a> h, <a>ne_eq</a>]",
          [
            {
              "full_name": "RelSeries.mem_snoc",
              "def_path": "Mathlib/Order/RelSeries.lean",
              "def_pos": [
                427,
                7
              ],
              "def_end_pos": [
                427,
                15
              ]
            },
            {
              "full_name": "CompositionSeries.mem_eraseLast",
              "def_path": "Mathlib/Order/JordanHolder.lean",
              "def_pos": [
                268,
                9
              ],
              "def_end_pos": [
                268,
                22
              ]
            },
            {
              "full_name": "ne_eq",
              "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean",
              "def_pos": [
                89,
                17
              ],
              "def_end_pos": [
                89,
                22
              ]
            }
          ]
        ],
        "state_before": "case h\nX : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\ns : CompositionSeries X\nh : 0 < s.length\nx : X\n\u22a2 x \u2208 s \u2194 x \u2208 (eraseLast s).snoc (last s) \u22ef",
        "state_after": "case h\nX : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\ns : CompositionSeries X\nh : 0 < s.length\nx : X\n\u22a2 x \u2208 s \u2194 \u00acx = last s \u2227 x \u2208 s \u2228 x = last s"
      },
      {
        "tactic": "by_cases h : x = s.last <;> simp [*, s.last_mem]",
        "annotated_tactic": [
          "by_cases h : x = s.last <;> simp [*, s.last_mem]",
          []
        ],
        "state_before": "case h\nX : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\ns : CompositionSeries X\nh : 0 < s.length\nx : X\n\u22a2 x \u2208 s \u2194 \u00acx = last s \u2227 x \u2208 s \u2228 x = last s",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.4368886769516394,
    "entry_failed": false
  },
  "12449": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Perm/Fin.lean",
    "full_name": "isCycle_finRotate_of_le",
    "start": [
      139,
      1
    ],
    "end": [
      142,
      26
    ],
    "traced_tactics": [
      {
        "tactic": "obtain \u27e8m, rfl\u27e9 := exists_add_of_le h",
        "annotated_tactic": [
          "obtain \u27e8m, rfl\u27e9 := <a>exists_add_of_le</a> h",
          [
            {
              "full_name": "ExistsAddOfLE.exists_add_of_le",
              "def_path": "Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean",
              "def_pos": [
                34,
                3
              ],
              "def_end_pos": [
                34,
                19
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\nh : 2 \u2264 n\n\u22a2 (finRotate n).IsCycle",
        "state_after": "case intro\nm : \u2115\nh : 2 \u2264 2 + m\n\u22a2 (finRotate (2 + m)).IsCycle"
      },
      {
        "tactic": "rw [add_comm]",
        "annotated_tactic": [
          "rw [<a>add_comm</a>]",
          [
            {
              "full_name": "add_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                331,
                3
              ],
              "def_end_pos": [
                331,
                14
              ]
            }
          ]
        ],
        "state_before": "case intro\nm : \u2115\nh : 2 \u2264 2 + m\n\u22a2 (finRotate (2 + m)).IsCycle",
        "state_after": "case intro\nm : \u2115\nh : 2 \u2264 2 + m\n\u22a2 (finRotate (m + 2)).IsCycle"
      },
      {
        "tactic": "exact isCycle_finRotate",
        "annotated_tactic": [
          "exact <a>isCycle_finRotate</a>",
          [
            {
              "full_name": "isCycle_finRotate",
              "def_path": "Mathlib/GroupTheory/Perm/Fin.lean",
              "def_pos": [
                128,
                9
              ],
              "def_end_pos": [
                128,
                26
              ]
            }
          ]
        ],
        "state_before": "case intro\nm : \u2115\nh : 2 \u2264 2 + m\n\u22a2 (finRotate (m + 2)).IsCycle",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.2713758159661666,
    "entry_failed": false
  },
  "12513": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/NormedSpace/Real.lean",
    "full_name": "interior_closedBall'",
    "start": [
      147,
      1
    ],
    "end": [
      150,
      35
    ],
    "traced_tactics": [
      {
        "tactic": "rcases eq_or_ne r 0 with (rfl | hr)",
        "annotated_tactic": [
          "rcases <a>eq_or_ne</a> r 0 with (rfl | hr)",
          [
            {
              "full_name": "eq_or_ne",
              "def_path": "Mathlib/Logic/Basic.lean",
              "def_pos": [
                212,
                9
              ],
              "def_end_pos": [
                212,
                17
              ]
            }
          ]
        ],
        "state_before": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : Nontrivial E\nx : E\nr : \u211d\n\u22a2 interior (closedBall x r) = ball x r",
        "state_after": "case inl\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : Nontrivial E\nx : E\n\u22a2 interior (closedBall x 0) = ball x 0\n\ncase inr\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : Nontrivial E\nx : E\nr : \u211d\nhr : r \u2260 0\n\u22a2 interior (closedBall x r) = ball x r"
      },
      {
        "tactic": "rw [closedBall_zero, ball_zero, interior_singleton]",
        "annotated_tactic": [
          "rw [<a>closedBall_zero</a>, <a>ball_zero</a>, <a>interior_singleton</a>]",
          [
            {
              "full_name": "Metric.closedBall_zero",
              "def_path": "Mathlib/Topology/MetricSpace/Basic.lean",
              "def_pos": [
                115,
                17
              ],
              "def_end_pos": [
                115,
                32
              ]
            },
            {
              "full_name": "Metric.ball_zero",
              "def_path": "Mathlib/Topology/MetricSpace/Pseudo/Defs.lean",
              "def_pos": [
                430,
                9
              ],
              "def_end_pos": [
                430,
                18
              ]
            },
            {
              "full_name": "interior_singleton",
              "def_path": "Mathlib/Topology/Basic.lean",
              "def_pos": [
                1301,
                9
              ],
              "def_end_pos": [
                1301,
                27
              ]
            }
          ]
        ],
        "state_before": "case inl\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : Nontrivial E\nx : E\n\u22a2 interior (closedBall x 0) = ball x 0",
        "state_after": "no goals"
      },
      {
        "tactic": "exact interior_closedBall x hr",
        "annotated_tactic": [
          "exact <a>interior_closedBall</a> x hr",
          [
            {
              "full_name": "interior_closedBall",
              "def_path": "Mathlib/Analysis/NormedSpace/Real.lean",
              "def_pos": [
                81,
                9
              ],
              "def_end_pos": [
                81,
                28
              ]
            }
          ]
        ],
        "state_before": "case inr\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : Nontrivial E\nx : E\nr : \u211d\nhr : r \u2260 0\n\u22a2 interior (closedBall x r) = ball x r",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.237479799077846,
    "entry_failed": false
  },
  "12514": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Polynomial/Opposites.lean",
    "full_name": "Polynomial.coeff_opRingEquiv",
    "start": [
      95,
      1
    ],
    "end": [
      99,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "induction' p with p",
        "annotated_tactic": [
          "induction' p with p",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d : Semiring R\np : R[X]\u1d50\u1d52\u1d56\nn : \u2115\n\u22a2 ((opRingEquiv R) p).coeff n = op ((unop p).coeff n)",
        "state_after": "case h\nR : Type u_1\ninst\u271d : Semiring R\nn : \u2115\np : R[X]\n\u22a2 ((opRingEquiv R) (op p)).coeff n = op ((unop (op p)).coeff n)"
      },
      {
        "tactic": "cases p",
        "annotated_tactic": [
          "cases p",
          []
        ],
        "state_before": "case h\nR : Type u_1\ninst\u271d : Semiring R\nn : \u2115\np : R[X]\n\u22a2 ((opRingEquiv R) (op p)).coeff n = op ((unop (op p)).coeff n)",
        "state_after": "case h.ofFinsupp\nR : Type u_1\ninst\u271d : Semiring R\nn : \u2115\ntoFinsupp\u271d : AddMonoidAlgebra R \u2115\n\u22a2 ((opRingEquiv R) (op { toFinsupp := toFinsupp\u271d })).coeff n = op ((unop (op { toFinsupp := toFinsupp\u271d })).coeff n)"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case h.ofFinsupp\nR : Type u_1\ninst\u271d : Semiring R\nn : \u2115\ntoFinsupp\u271d : AddMonoidAlgebra R \u2115\n\u22a2 ((opRingEquiv R) (op { toFinsupp := toFinsupp\u271d })).coeff n = op ((unop (op { toFinsupp := toFinsupp\u271d })).coeff n)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7084397099679336,
    "entry_failed": false
  },
  "12575": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Ordinal/Exponential.lean",
    "full_name": "Ordinal.opow_zero",
    "start": [
      51,
      1
    ],
    "end": [
      54,
      52
    ],
    "traced_tactics": [
      {
        "tactic": "by_cases h : a = 0",
        "annotated_tactic": [
          "by_cases h : a = 0",
          []
        ],
        "state_before": "a : Ordinal.{u_1}\n\u22a2 a ^ 0 = 1",
        "state_after": "case pos\na : Ordinal.{u_1}\nh : a = 0\n\u22a2 a ^ 0 = 1\n\ncase neg\na : Ordinal.{u_1}\nh : \u00aca = 0\n\u22a2 a ^ 0 = 1"
      },
      {
        "tactic": "simp only [opow_def, if_pos h, sub_zero]",
        "annotated_tactic": [
          "simp only [<a>opow_def</a>, <a>if_pos</a> h, <a>sub_zero</a>]",
          [
            {
              "full_name": "Ordinal.opow_def",
              "def_path": "Mathlib/SetTheory/Ordinal/Exponential.lean",
              "def_pos": [
                36,
                9
              ],
              "def_end_pos": [
                36,
                17
              ]
            },
            {
              "full_name": "if_pos",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                932,
                9
              ],
              "def_end_pos": [
                932,
                15
              ]
            },
            {
              "full_name": "Ordinal.sub_zero",
              "def_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean",
              "def_pos": [
                582,
                9
              ],
              "def_end_pos": [
                582,
                17
              ]
            }
          ]
        ],
        "state_before": "case pos\na : Ordinal.{u_1}\nh : a = 0\n\u22a2 a ^ 0 = 1",
        "state_after": "no goals"
      },
      {
        "tactic": "simp only [opow_def, if_neg h, limitRecOn_zero]",
        "annotated_tactic": [
          "simp only [<a>opow_def</a>, <a>if_neg</a> h, <a>limitRecOn_zero</a>]",
          [
            {
              "full_name": "Ordinal.opow_def",
              "def_path": "Mathlib/SetTheory/Ordinal/Exponential.lean",
              "def_pos": [
                36,
                9
              ],
              "def_end_pos": [
                36,
                17
              ]
            },
            {
              "full_name": "if_neg",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                937,
                9
              ],
              "def_end_pos": [
                937,
                15
              ]
            },
            {
              "full_name": "Ordinal.limitRecOn_zero",
              "def_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean",
              "def_pos": [
                323,
                9
              ],
              "def_end_pos": [
                323,
                24
              ]
            }
          ]
        ],
        "state_before": "case neg\na : Ordinal.{u_1}\nh : \u00aca = 0\n\u22a2 a ^ 0 = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6353971640346572,
    "entry_failed": false
  },
  "12615": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/Measure/WithDensity.lean",
    "full_name": "MeasureTheory.withDensity_zero_left",
    "start": [
      77,
      1
    ],
    "end": [
      81,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "ext s hs",
        "annotated_tactic": [
          "ext s hs",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\n\u22a2 withDensity 0 f = 0",
        "state_after": "case h\n\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\ns : Set \u03b1\nhs : MeasurableSet s\n\u22a2 (withDensity 0 f) s = 0 s"
      },
      {
        "tactic": "rw [withDensity_apply _ hs]",
        "annotated_tactic": [
          "rw [<a>withDensity_apply</a> _ hs]",
          [
            {
              "full_name": "MeasureTheory.withDensity_apply",
              "def_path": "Mathlib/MeasureTheory/Measure/WithDensity.lean",
              "def_pos": [
                39,
                9
              ],
              "def_end_pos": [
                39,
                26
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\ns : Set \u03b1\nhs : MeasurableSet s\n\u22a2 (withDensity 0 f) s = 0 s",
        "state_after": "case h\n\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\ns : Set \u03b1\nhs : MeasurableSet s\n\u22a2 \u222b\u207b (a : \u03b1) in s, f a \u22020 = 0 s"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case h\n\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\ns : Set \u03b1\nhs : MeasurableSet s\n\u22a2 \u222b\u207b (a : \u03b1) in s, f a \u22020 = 0 s",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.5169260449474677,
    "entry_failed": false
  },
  "12665": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/MeasurableSpace/CountablyGenerated.lean",
    "full_name": "MeasurableSpace.CountablyGenerated.comap",
    "start": [
      96,
      1
    ],
    "end": [
      101,
      30
    ],
    "traced_tactics": [
      {
        "tactic": "rcases h with \u27e8\u27e8b, hbc, rfl\u27e9\u27e9",
        "annotated_tactic": [
          "rcases h with \u27e8\u27e8b, hbc, rfl\u27e9\u27e9",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b2\nh : CountablyGenerated \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 CountablyGenerated \u03b1",
        "state_after": "case mk.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nb : Set (Set \u03b2)\nhbc : b.Countable\n\u22a2 CountablyGenerated \u03b1"
      },
      {
        "tactic": "letI := generateFrom (preimage f '' b)",
        "annotated_tactic": [
          "letI := <a>generateFrom</a> (<a>preimage</a> f '' b)",
          [
            {
              "full_name": "MeasurableSpace.generateFrom",
              "def_path": "Mathlib/MeasureTheory/MeasurableSpace/Defs.lean",
              "def_pos": [
                369,
                5
              ],
              "def_end_pos": [
                369,
                17
              ]
            },
            {
              "full_name": "Set.preimage",
              "def_path": "Mathlib/Data/Set/Defs.lean",
              "def_pos": [
                113,
                5
              ],
              "def_end_pos": [
                113,
                13
              ]
            }
          ]
        ],
        "state_before": "case mk.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nb : Set (Set \u03b2)\nhbc : b.Countable\n\u22a2 CountablyGenerated \u03b1",
        "state_after": "case mk.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nb : Set (Set \u03b2)\nhbc : b.Countable\nthis : MeasurableSpace \u03b1 := generateFrom (preimage f '' b)\n\u22a2 CountablyGenerated \u03b1"
      },
      {
        "tactic": "exact \u27e8_, hbc.image _, rfl\u27e9",
        "annotated_tactic": [
          "exact \u27e8_, hbc.image _, <a>rfl</a>\u27e9",
          [
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "case mk.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nb : Set (Set \u03b2)\nhbc : b.Countable\nthis : MeasurableSpace \u03b1 := generateFrom (preimage f '' b)\n\u22a2 CountablyGenerated \u03b1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8595020599896088,
    "entry_failed": false
  },
  "12766": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/LinearAlgebra/Dimension/Finrank.lean",
    "full_name": "FiniteDimensional.finrank_eq_of_rank_eq",
    "start": [
      58,
      1
    ],
    "end": [
      61,
      19
    ],
    "traced_tactics": [
      {
        "tactic": "apply_fun toNat at h",
        "annotated_tactic": [
          "apply_fun <a>toNat</a> at h",
          [
            {
              "full_name": "Cardinal.toNat",
              "def_path": "Mathlib/SetTheory/Cardinal/ToNat.lean",
              "def_pos": [
                27,
                19
              ],
              "def_end_pos": [
                27,
                24
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nM : Type v\nN : Type w\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module R N\nn : \u2115\nh : Module.rank R M = \u2191n\n\u22a2 finrank R M = n",
        "state_after": "R : Type u\nM : Type v\nN : Type w\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module R N\nn : \u2115\nh : toNat (Module.rank R M) = toNat \u2191n\n\u22a2 finrank R M = n"
      },
      {
        "tactic": "rw [toNat_natCast] at h",
        "annotated_tactic": [
          "rw [<a>toNat_natCast</a>] at h",
          [
            {
              "full_name": "Cardinal.toNat_natCast",
              "def_path": "Mathlib/SetTheory/Cardinal/ToNat.lean",
              "def_pos": [
                38,
                28
              ],
              "def_end_pos": [
                38,
                41
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nM : Type v\nN : Type w\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module R N\nn : \u2115\nh : toNat (Module.rank R M) = toNat \u2191n\n\u22a2 finrank R M = n",
        "state_after": "R : Type u\nM : Type v\nN : Type w\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module R N\nn : \u2115\nh : toNat (Module.rank R M) = n\n\u22a2 finrank R M = n"
      },
      {
        "tactic": "exact mod_cast h",
        "annotated_tactic": [
          "exact mod_cast h",
          []
        ],
        "state_before": "R : Type u\nM : Type v\nN : Type w\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module R N\nn : \u2115\nh : toNat (Module.rank R M) = n\n\u22a2 finrank R M = n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5968030471121892,
    "entry_failed": false
  },
  "12784": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/FixedPointFree.lean",
    "full_name": "MonoidHom.FixedPointFree.coe_eq_inv_of_sq_eq_one",
    "start": [
      57,
      1
    ],
    "end": [
      60,
      57
    ],
    "traced_tactics": [
      {
        "tactic": "ext g",
        "annotated_tactic": [
          "ext g",
          []
        ],
        "state_before": "G : Type u_1\ninst\u271d\u00b9 : Group G\n\u03c6 : G \u2192* G\nh\u03c6 : FixedPointFree \u21d1\u03c6\ninst\u271d : Finite G\nh2 : (\u21d1\u03c6)^[2] = _root_.id\n\u22a2 \u21d1\u03c6 = fun x => x\u207b\u00b9",
        "state_after": "case h\nG : Type u_1\ninst\u271d\u00b9 : Group G\n\u03c6 : G \u2192* G\nh\u03c6 : FixedPointFree \u21d1\u03c6\ninst\u271d : Finite G\nh2 : (\u21d1\u03c6)^[2] = _root_.id\ng : G\n\u22a2 \u03c6 g = g\u207b\u00b9"
      },
      {
        "tactic": "have key : 1 * g * \u03c6 g = 1 := h\u03c6.prod_pow_eq_one h2 g",
        "annotated_tactic": [
          "have key : 1 * g * \u03c6 g = 1 := h\u03c6.prod_pow_eq_one h2 g",
          []
        ],
        "state_before": "case h\nG : Type u_1\ninst\u271d\u00b9 : Group G\n\u03c6 : G \u2192* G\nh\u03c6 : FixedPointFree \u21d1\u03c6\ninst\u271d : Finite G\nh2 : (\u21d1\u03c6)^[2] = _root_.id\ng : G\n\u22a2 \u03c6 g = g\u207b\u00b9",
        "state_after": "case h\nG : Type u_1\ninst\u271d\u00b9 : Group G\n\u03c6 : G \u2192* G\nh\u03c6 : FixedPointFree \u21d1\u03c6\ninst\u271d : Finite G\nh2 : (\u21d1\u03c6)^[2] = _root_.id\ng : G\nkey : 1 * g * \u03c6 g = 1\n\u22a2 \u03c6 g = g\u207b\u00b9"
      },
      {
        "tactic": "rwa [one_mul, \u2190 inv_eq_iff_mul_eq_one, eq_comm] at key",
        "annotated_tactic": [
          "rwa [<a>one_mul</a>, \u2190 <a>inv_eq_iff_mul_eq_one</a>, <a>eq_comm</a>] at key",
          [
            {
              "full_name": "one_mul",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                477,
                9
              ],
              "def_end_pos": [
                477,
                16
              ]
            },
            {
              "full_name": "inv_eq_iff_mul_eq_one",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                938,
                9
              ],
              "def_end_pos": [
                938,
                30
              ]
            },
            {
              "full_name": "eq_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                811,
                9
              ],
              "def_end_pos": [
                811,
                16
              ]
            }
          ]
        ],
        "state_before": "case h\nG : Type u_1\ninst\u271d\u00b9 : Group G\n\u03c6 : G \u2192* G\nh\u03c6 : FixedPointFree \u21d1\u03c6\ninst\u271d : Finite G\nh2 : (\u21d1\u03c6)^[2] = _root_.id\ng : G\nkey : 1 * g * \u03c6 g = 1\n\u22a2 \u03c6 g = g\u207b\u00b9",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5154233180219308,
    "entry_failed": false
  },
  "12805": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/AlgebraicTopology/DoldKan/Projections.lean",
    "full_name": "AlgebraicTopology.DoldKan.P_f_idem",
    "start": [
      152,
      1
    ],
    "end": [
      155,
      54
    ],
    "traced_tactics": [
      {
        "tactic": "rcases n with (_|n)",
        "annotated_tactic": [
          "rcases n with (_|n)",
          []
        ],
        "state_before": "C : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nq n : \u2115\n\u22a2 (P q).f n \u226b (P q).f n = (P q).f n",
        "state_after": "case zero\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nq : \u2115\n\u22a2 (P q).f 0 \u226b (P q).f 0 = (P q).f 0\n\ncase succ\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nq n : \u2115\n\u22a2 (P q).f (n + 1) \u226b (P q).f (n + 1) = (P q).f (n + 1)"
      },
      {
        "tactic": "rw [P_f_0_eq q, comp_id]",
        "annotated_tactic": [
          "rw [<a>P_f_0_eq</a> q, <a>comp_id</a>]",
          [
            {
              "full_name": "AlgebraicTopology.DoldKan.P_f_0_eq",
              "def_path": "Mathlib/AlgebraicTopology/DoldKan/Projections.lean",
              "def_pos": [
                61,
                9
              ],
              "def_end_pos": [
                61,
                17
              ]
            },
            {
              "full_name": "CategoryTheory.Category.comp_id",
              "def_path": "Mathlib/CategoryTheory/Category/Basic.lean",
              "def_pos": [
                179,
                3
              ],
              "def_end_pos": [
                179,
                10
              ]
            }
          ]
        ],
        "state_before": "case zero\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nq : \u2115\n\u22a2 (P q).f 0 \u226b (P q).f 0 = (P q).f 0",
        "state_after": "no goals"
      },
      {
        "tactic": "exact (HigherFacesVanish.of_P q n).comp_P_eq_self",
        "annotated_tactic": [
          "exact (<a>HigherFacesVanish.of_P</a> q n).<a>comp_P_eq_self</a>",
          [
            {
              "full_name": "AlgebraicTopology.DoldKan.HigherFacesVanish.of_P",
              "def_path": "Mathlib/AlgebraicTopology/DoldKan/Projections.lean",
              "def_pos": [
                109,
                9
              ],
              "def_end_pos": [
                109,
                13
              ]
            },
            {
              "full_name": "AlgebraicTopology.DoldKan.HigherFacesVanish.comp_P_eq_self",
              "def_path": "Mathlib/AlgebraicTopology/DoldKan/Projections.lean",
              "def_pos": [
                118,
                9
              ],
              "def_end_pos": [
                118,
                23
              ]
            }
          ]
        ],
        "state_before": "case succ\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nq n : \u2115\n\u22a2 (P q).f (n + 1) \u226b (P q).f (n + 1) = (P q).f (n + 1)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.6820748490281403,
    "entry_failed": false
  },
  "12820": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/FieldTheory/IsPerfectClosure.lean",
    "full_name": "pNilradical_le_nilradical",
    "start": [
      75,
      1
    ],
    "end": [
      79,
      43
    ],
    "traced_tactics": [
      {
        "tactic": "by_cases hp : 1 < p",
        "annotated_tactic": [
          "by_cases hp : 1 < p",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d : CommSemiring R\np : \u2115\n\u22a2 pNilradical R p \u2264 nilradical R",
        "state_after": "case pos\nR : Type u_1\ninst\u271d : CommSemiring R\np : \u2115\nhp : 1 < p\n\u22a2 pNilradical R p \u2264 nilradical R\n\ncase neg\nR : Type u_1\ninst\u271d : CommSemiring R\np : \u2115\nhp : \u00ac1 < p\n\u22a2 pNilradical R p \u2264 nilradical R"
      },
      {
        "tactic": "simp_rw [pNilradical, if_neg hp, bot_le]",
        "annotated_tactic": [
          "simp_rw [<a>pNilradical</a>, <a>if_neg</a> hp, <a>bot_le</a>]",
          [
            {
              "full_name": "pNilradical",
              "def_path": "Mathlib/FieldTheory/IsPerfectClosure.lean",
              "def_pos": [
                73,
                5
              ],
              "def_end_pos": [
                73,
                16
              ]
            },
            {
              "full_name": "if_neg",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                937,
                9
              ],
              "def_end_pos": [
                937,
                15
              ]
            },
            {
              "full_name": "bot_le",
              "def_path": "Mathlib/Order/BoundedOrder.lean",
              "def_pos": [
                224,
                9
              ],
              "def_end_pos": [
                224,
                15
              ]
            }
          ]
        ],
        "state_before": "case neg\nR : Type u_1\ninst\u271d : CommSemiring R\np : \u2115\nhp : \u00ac1 < p\n\u22a2 pNilradical R p \u2264 nilradical R",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [pNilradical, if_pos hp]",
        "annotated_tactic": [
          "rw [<a>pNilradical</a>, <a>if_pos</a> hp]",
          [
            {
              "full_name": "pNilradical",
              "def_path": "Mathlib/FieldTheory/IsPerfectClosure.lean",
              "def_pos": [
                73,
                5
              ],
              "def_end_pos": [
                73,
                16
              ]
            },
            {
              "full_name": "if_pos",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                932,
                9
              ],
              "def_end_pos": [
                932,
                15
              ]
            }
          ]
        ],
        "state_before": "case pos\nR : Type u_1\ninst\u271d : CommSemiring R\np : \u2115\nhp : 1 < p\n\u22a2 pNilradical R p \u2264 nilradical R",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8597270200261846,
    "entry_failed": false
  },
  "12826": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/SpecialFunctions/JapaneseBracket.lean",
    "full_name": "sqrt_one_add_norm_sq_le",
    "start": [
      36,
      1
    ],
    "end": [
      38,
      16
    ],
    "traced_tactics": [
      {
        "tactic": "rw [sqrt_le_left (by positivity)]",
        "annotated_tactic": [
          "rw [<a>sqrt_le_left</a> (by positivity)]",
          [
            {
              "full_name": "Real.sqrt_le_left",
              "def_path": "Mathlib/Data/Real/Sqrt.lean",
              "def_pos": [
                252,
                9
              ],
              "def_end_pos": [
                252,
                21
              ]
            }
          ]
        ],
        "state_before": "E : Type u_1\ninst\u271d : NormedAddCommGroup E\nx : E\n\u22a2 \u221a(1 + \u2016x\u2016 ^ 2) \u2264 1 + \u2016x\u2016",
        "state_after": "E : Type u_1\ninst\u271d : NormedAddCommGroup E\nx : E\n\u22a2 1 + \u2016x\u2016 ^ 2 \u2264 (1 + \u2016x\u2016) ^ 2"
      },
      {
        "tactic": "simp [add_sq]",
        "annotated_tactic": [
          "simp [<a>add_sq</a>]",
          [
            {
              "full_name": "add_sq",
              "def_path": "Mathlib/Algebra/Ring/Defs.lean",
              "def_pos": [
                287,
                7
              ],
              "def_end_pos": [
                287,
                13
              ]
            }
          ]
        ],
        "state_before": "E : Type u_1\ninst\u271d : NormedAddCommGroup E\nx : E\n\u22a2 1 + \u2016x\u2016 ^ 2 \u2264 (1 + \u2016x\u2016) ^ 2",
        "state_after": "no goals"
      },
      {
        "tactic": "positivity",
        "annotated_tactic": [
          "positivity",
          []
        ],
        "state_before": "E : Type u_1\ninst\u271d : NormedAddCommGroup E\nx : E\n\u22a2 0 \u2264 1 + \u2016x\u2016",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8525166080798954,
    "entry_failed": false
  },
  "12842": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean",
    "full_name": "Polynomial.cyclotomic'_splits",
    "start": [
      152,
      1
    ],
    "end": [
      155,
      44
    ],
    "traced_tactics": [
      {
        "tactic": "apply splits_prod (RingHom.id K)",
        "annotated_tactic": [
          "apply <a>splits_prod</a> (<a>RingHom.id</a> K)",
          [
            {
              "full_name": "Polynomial.splits_prod",
              "def_path": "Mathlib/Algebra/Polynomial/Splits.lean",
              "def_pos": [
                146,
                9
              ],
              "def_end_pos": [
                146,
                20
              ]
            },
            {
              "full_name": "RingHom.id",
              "def_path": "Mathlib/Algebra/Ring/Hom/Defs.lean",
              "def_pos": [
                626,
                5
              ],
              "def_end_pos": [
                626,
                7
              ]
            }
          ]
        ],
        "state_before": "K : Type u_1\ninst\u271d : Field K\nn : \u2115\n\u22a2 Splits (RingHom.id K) (cyclotomic' n K)",
        "state_after": "K : Type u_1\ninst\u271d : Field K\nn : \u2115\n\u22a2 \u2200 j \u2208 primitiveRoots n K, Splits (RingHom.id K) (X - C j)"
      },
      {
        "tactic": "intro z _",
        "annotated_tactic": [
          "intro z _",
          []
        ],
        "state_before": "K : Type u_1\ninst\u271d : Field K\nn : \u2115\n\u22a2 \u2200 j \u2208 primitiveRoots n K, Splits (RingHom.id K) (X - C j)",
        "state_after": "K : Type u_1\ninst\u271d : Field K\nn : \u2115\nz : K\na\u271d : z \u2208 primitiveRoots n K\n\u22a2 Splits (RingHom.id K) (X - C z)"
      },
      {
        "tactic": "simp only [splits_X_sub_C (RingHom.id K)]",
        "annotated_tactic": [
          "simp only [<a>splits_X_sub_C</a> (<a>RingHom.id</a> K)]",
          [
            {
              "full_name": "Polynomial.splits_X_sub_C",
              "def_path": "Mathlib/Algebra/Polynomial/Splits.lean",
              "def_pos": [
                136,
                9
              ],
              "def_end_pos": [
                136,
                23
              ]
            },
            {
              "full_name": "RingHom.id",
              "def_path": "Mathlib/Algebra/Ring/Hom/Defs.lean",
              "def_pos": [
                626,
                5
              ],
              "def_end_pos": [
                626,
                7
              ]
            }
          ]
        ],
        "state_before": "K : Type u_1\ninst\u271d : Field K\nn : \u2115\nz : K\na\u271d : z \u2208 primitiveRoots n K\n\u22a2 Splits (RingHom.id K) (X - C z)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.0445142938988283,
    "entry_failed": false
  },
  "12964": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/NormedSpace/Connected.lean",
    "full_name": "isPreconnected_sphere",
    "start": [
      164,
      1
    ],
    "end": [
      168,
      42
    ],
    "traced_tactics": [
      {
        "tactic": "rcases le_or_lt 0 r with hr|hr",
        "annotated_tactic": [
          "rcases <a>le_or_lt</a> 0 r with hr|hr",
          [
            {
              "full_name": "le_or_lt",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                342,
                9
              ],
              "def_end_pos": [
                342,
                17
              ]
            }
          ]
        ],
        "state_before": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nh : 1 < Module.rank \u211d E\nx : E\nr : \u211d\n\u22a2 IsPreconnected (sphere x r)",
        "state_after": "case inl\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nh : 1 < Module.rank \u211d E\nx : E\nr : \u211d\nhr : 0 \u2264 r\n\u22a2 IsPreconnected (sphere x r)\n\ncase inr\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nh : 1 < Module.rank \u211d E\nx : E\nr : \u211d\nhr : r < 0\n\u22a2 IsPreconnected (sphere x r)"
      },
      {
        "tactic": "exact (isConnected_sphere h x hr).isPreconnected",
        "annotated_tactic": [
          "exact (<a>isConnected_sphere</a> h x hr).<a>isPreconnected</a>",
          [
            {
              "full_name": "isConnected_sphere",
              "def_path": "Mathlib/Analysis/NormedSpace/Connected.lean",
              "def_pos": [
                159,
                9
              ],
              "def_end_pos": [
                159,
                27
              ]
            },
            {
              "full_name": "IsConnected.isPreconnected",
              "def_path": "Mathlib/Topology/Connected/Basic.lean",
              "def_pos": [
                66,
                9
              ],
              "def_end_pos": [
                66,
                35
              ]
            }
          ]
        ],
        "state_before": "case inl\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nh : 1 < Module.rank \u211d E\nx : E\nr : \u211d\nhr : 0 \u2264 r\n\u22a2 IsPreconnected (sphere x r)",
        "state_after": "no goals"
      },
      {
        "tactic": "simpa [hr] using isPreconnected_empty",
        "annotated_tactic": [
          "simpa [hr] using <a>isPreconnected_empty</a>",
          [
            {
              "full_name": "isPreconnected_empty",
              "def_path": "Mathlib/Topology/Connected/Basic.lean",
              "def_pos": [
                78,
                9
              ],
              "def_end_pos": [
                78,
                29
              ]
            }
          ]
        ],
        "state_before": "case inr\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nh : 1 < Module.rank \u211d E\nx : E\nr : \u211d\nhr : r < 0\n\u22a2 IsPreconnected (sphere x r)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.64752051292453,
    "entry_failed": false
  },
  "12986": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Real/EReal.lean",
    "full_name": "EReal.mul_comm",
    "start": [
      219,
      11
    ],
    "end": [
      222,
      38
    ],
    "traced_tactics": [
      {
        "tactic": "induction x <;> induction y  <;>\n  try { rfl }",
        "annotated_tactic": [
          "induction x <;> induction y  <;>\n    try { rfl }",
          []
        ],
        "state_before": "x y : EReal\n\u22a2 x * y = y * x",
        "state_after": "case h_real.h_real\na\u271d\u00b9 a\u271d : \u211d\n\u22a2 \u2191a\u271d\u00b9 * \u2191a\u271d = \u2191a\u271d * \u2191a\u271d\u00b9"
      },
      {
        "tactic": "rw [\u2190 coe_mul, \u2190 coe_mul, mul_comm]",
        "annotated_tactic": [
          "rw [\u2190 <a>coe_mul</a>, \u2190 <a>coe_mul</a>, <a>mul_comm</a>]",
          [
            {
              "full_name": "EReal.coe_mul",
              "def_path": "Mathlib/Data/Real/EReal.lean",
              "def_pos": [
                168,
                9
              ],
              "def_end_pos": [
                168,
                16
              ]
            },
            {
              "full_name": "EReal.coe_mul",
              "def_path": "Mathlib/Data/Real/EReal.lean",
              "def_pos": [
                168,
                9
              ],
              "def_end_pos": [
                168,
                16
              ]
            },
            {
              "full_name": "mul_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                332,
                9
              ],
              "def_end_pos": [
                332,
                17
              ]
            }
          ]
        ],
        "state_before": "case h_real.h_real\na\u271d\u00b9 a\u271d : \u211d\n\u22a2 \u2191a\u271d\u00b9 * \u2191a\u271d = \u2191a\u271d * \u2191a\u271d\u00b9",
        "state_after": "no goals"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case h_top.h_top\n\n\u22a2 \u22a4 * \u22a4 = \u22a4 * \u22a4",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.0637270050356165,
    "entry_failed": false
  },
  "12995": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/CharP/ExpChar.lean",
    "full_name": "expChar_one_of_char_zero",
    "start": [
      86,
      1
    ],
    "end": [
      89,
      61
    ],
    "traced_tactics": [
      {
        "tactic": "cases' hq with q hq_one hq_prime hq_hchar",
        "annotated_tactic": [
          "cases' hq with q hq_one hq_prime hq_hchar",
          []
        ],
        "state_before": "R : Type u\ninst\u271d : Semiring R\nq : \u2115\nhp : CharP R 0\nhq : ExpChar R q\n\u22a2 q = 1",
        "state_after": "case zero\nR : Type u\ninst\u271d : Semiring R\nhp : CharP R 0\nq : CharZero R\n\u22a2 1 = 1\n\ncase prime\nR : Type u\ninst\u271d : Semiring R\nq : \u2115\nhp : CharP R 0\nhq_prime : Nat.Prime q\nhq_hchar : CharP R q\n\u22a2 q = 1"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case zero\nR : Type u\ninst\u271d : Semiring R\nhp : CharP R 0\nq : CharZero R\n\u22a2 1 = 1",
        "state_after": "no goals"
      },
      {
        "tactic": "exact False.elim <| hq_prime.ne_zero <| hq_hchar.eq R hp",
        "annotated_tactic": [
          "exact <a>False.elim</a> <| hq_prime.ne_zero <| hq_hchar.eq R hp",
          [
            {
              "full_name": "False.elim",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                236,
                21
              ],
              "def_end_pos": [
                236,
                31
              ]
            }
          ]
        ],
        "state_before": "case prime\nR : Type u\ninst\u271d : Semiring R\nq : \u2115\nhp : CharP R 0\nhq_prime : Nat.Prime q\nhq_hchar : CharP R q\n\u22a2 q = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8612483659526333,
    "entry_failed": false
  },
  "13122": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/AlgebraicGeometry/Morphisms/Separated.lean",
    "full_name": "AlgebraicGeometry.IsSeparated.respectsIso",
    "start": [
      57,
      1
    ],
    "end": [
      60,
      38
    ],
    "traced_tactics": [
      {
        "tactic": "rw [isSeparated_eq_diagonal_isClosedImmersion]",
        "annotated_tactic": [
          "rw [<a>isSeparated_eq_diagonal_isClosedImmersion</a>]",
          [
            {
              "full_name": "AlgebraicGeometry.IsSeparated.isSeparated_eq_diagonal_isClosedImmersion",
              "def_path": "Mathlib/AlgebraicGeometry/Morphisms/Separated.lean",
              "def_pos": [
                49,
                9
              ],
              "def_end_pos": [
                49,
                50
              ]
            }
          ]
        ],
        "state_before": "X Y : Scheme\nf : X \u27f6 Y\n\u22a2 MorphismProperty.RespectsIso @IsSeparated",
        "state_after": "X Y : Scheme\nf : X \u27f6 Y\n\u22a2 (MorphismProperty.diagonal @IsClosedImmersion).RespectsIso"
      },
      {
        "tactic": "apply MorphismProperty.RespectsIso.diagonal",
        "annotated_tactic": [
          "apply <a>MorphismProperty.RespectsIso.diagonal</a>",
          [
            {
              "full_name": "CategoryTheory.MorphismProperty.RespectsIso.diagonal",
              "def_path": "Mathlib/CategoryTheory/MorphismProperty/Limits.lean",
              "def_pos": [
                219,
                9
              ],
              "def_end_pos": [
                219,
                29
              ]
            }
          ]
        ],
        "state_before": "X Y : Scheme\nf : X \u27f6 Y\n\u22a2 (MorphismProperty.diagonal @IsClosedImmersion).RespectsIso",
        "state_after": "case hP\nX Y : Scheme\nf : X \u27f6 Y\n\u22a2 MorphismProperty.RespectsIso @IsClosedImmersion"
      },
      {
        "tactic": "exact IsClosedImmersion.respectsIso",
        "annotated_tactic": [
          "exact <a>IsClosedImmersion.respectsIso</a>",
          [
            {
              "full_name": "AlgebraicGeometry.IsClosedImmersion.respectsIso",
              "def_path": "Mathlib/AlgebraicGeometry/Morphisms/ClosedImmersion.lean",
              "def_pos": [
                73,
                7
              ],
              "def_end_pos": [
                73,
                18
              ]
            }
          ]
        ],
        "state_before": "case hP\nX Y : Scheme\nf : X \u27f6 Y\n\u22a2 MorphismProperty.RespectsIso @IsClosedImmersion",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7305198350222781,
    "entry_failed": false
  },
  "13148": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/WithBot.lean",
    "full_name": "WithBot.unbot'_lt_iff",
    "start": [
      342,
      1
    ],
    "end": [
      346,
      9
    ],
    "traced_tactics": [
      {
        "tactic": "induction a",
        "annotated_tactic": [
          "induction a",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\na\u271d b\u271d : \u03b1\ninst\u271d : LT \u03b1\na : WithBot \u03b1\nb c : \u03b1\nh : a = \u22a5 \u2192 b < c\n\u22a2 unbot' b a < c \u2194 a < \u2191c",
        "state_after": "case bot\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\na b\u271d : \u03b1\ninst\u271d : LT \u03b1\nb c : \u03b1\nh : \u22a5 = \u22a5 \u2192 b < c\n\u22a2 unbot' b \u22a5 < c \u2194 \u22a5 < \u2191c\n\ncase coe\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\na b\u271d : \u03b1\ninst\u271d : LT \u03b1\nb c a\u271d : \u03b1\nh : \u2191a\u271d = \u22a5 \u2192 b < c\n\u22a2 unbot' b \u2191a\u271d < c \u2194 \u2191a\u271d < \u2191c"
      },
      {
        "tactic": "simpa [bot_lt_coe] using h rfl",
        "annotated_tactic": [
          "simpa [<a>bot_lt_coe</a>] using h <a>rfl</a>",
          [
            {
              "full_name": "WithBot.bot_lt_coe",
              "def_path": "Mathlib/Order/WithBot.lean",
              "def_pos": [
                304,
                9
              ],
              "def_end_pos": [
                304,
                19
              ]
            },
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "case bot\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\na b\u271d : \u03b1\ninst\u271d : LT \u03b1\nb c : \u03b1\nh : \u22a5 = \u22a5 \u2192 b < c\n\u22a2 unbot' b \u22a5 < c \u2194 \u22a5 < \u2191c",
        "state_after": "no goals"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case coe\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\na b\u271d : \u03b1\ninst\u271d : LT \u03b1\nb c a\u271d : \u03b1\nh : \u2191a\u271d = \u22a5 \u2192 b < c\n\u22a2 unbot' b \u2191a\u271d < c \u2194 \u2191a\u271d < \u2191c",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.42275059199892,
    "entry_failed": false
  },
  "13251": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Tropical/BigOperators.lean",
    "full_name": "List.trop_sum",
    "start": [
      40,
      1
    ],
    "end": [
      43,
      16
    ],
    "traced_tactics": [
      {
        "tactic": "induction' l with hd tl IH",
        "annotated_tactic": [
          "induction' l with hd tl IH",
          []
        ],
        "state_before": "R : Type u_1\nS : Type u_2\ninst\u271d : AddMonoid R\nl : List R\n\u22a2 trop l.sum = (map trop l).prod",
        "state_after": "case nil\nR : Type u_1\nS : Type u_2\ninst\u271d : AddMonoid R\n\u22a2 trop [].sum = (map trop []).prod\n\ncase cons\nR : Type u_1\nS : Type u_2\ninst\u271d : AddMonoid R\nhd : R\ntl : List R\nIH : trop tl.sum = (map trop tl).prod\n\u22a2 trop (hd :: tl).sum = (map trop (hd :: tl)).prod"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case nil\nR : Type u_1\nS : Type u_2\ninst\u271d : AddMonoid R\n\u22a2 trop [].sum = (map trop []).prod",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [\u2190 IH]",
        "annotated_tactic": [
          "simp [\u2190 IH]",
          []
        ],
        "state_before": "case cons\nR : Type u_1\nS : Type u_2\ninst\u271d : AddMonoid R\nhd : R\ntl : List R\nIH : trop tl.sum = (map trop tl).prod\n\u22a2 trop (hd :: tl).sum = (map trop (hd :: tl)).prod",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.232582672033459,
    "entry_failed": false
  },
  "13256": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Intervals.lean",
    "full_name": "List.Ico.pred_singleton",
    "start": [
      136,
      1
    ],
    "end": [
      139,
      32
    ],
    "traced_tactics": [
      {
        "tactic": "dsimp [Ico]",
        "annotated_tactic": [
          "dsimp [<a>Ico</a>]",
          [
            {
              "full_name": "List.Ico",
              "def_path": "Mathlib/Data/List/Intervals.lean",
              "def_pos": [
                36,
                5
              ],
              "def_end_pos": [
                36,
                8
              ]
            }
          ]
        ],
        "state_before": "m : \u2115\nh : 0 < m\n\u22a2 Ico (m - 1) m = [m - 1]",
        "state_after": "m : \u2115\nh : 0 < m\n\u22a2 range' (m - 1) (m - (m - 1)) = [m - 1]"
      },
      {
        "tactic": "rw [Nat.sub_sub_self (succ_le_of_lt h)]",
        "annotated_tactic": [
          "rw [<a>Nat.sub_sub_self</a> (<a>succ_le_of_lt</a> h)]",
          [
            {
              "full_name": "Nat.sub_sub_self",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean",
              "def_pos": [
                122,
                19
              ],
              "def_end_pos": [
                122,
                31
              ]
            },
            {
              "full_name": "Nat.succ_le_of_lt",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean",
              "def_pos": [
                348,
                9
              ],
              "def_end_pos": [
                348,
                22
              ]
            }
          ]
        ],
        "state_before": "m : \u2115\nh : 0 < m\n\u22a2 range' (m - 1) (m - (m - 1)) = [m - 1]",
        "state_after": "m : \u2115\nh : 0 < m\n\u22a2 range' (m - 1) (succ 0) = [m - 1]"
      },
      {
        "tactic": "simp [\u2190 Nat.one_eq_succ_zero]",
        "annotated_tactic": [
          "simp [\u2190 <a>Nat.one_eq_succ_zero</a>]",
          [
            {
              "full_name": "Nat.one_eq_succ_zero",
              "def_path": "Mathlib/Init/Data/Nat/Lemmas.lean",
              "def_pos": [
                365,
                9
              ],
              "def_end_pos": [
                365,
                25
              ]
            }
          ]
        ],
        "state_before": "m : \u2115\nh : 0 < m\n\u22a2 range' (m - 1) (succ 0) = [m - 1]",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4745357950450853,
    "entry_failed": false
  },
  "13330": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Zip.lean",
    "full_name": "List.map_prod_left_eq_zip",
    "start": [
      148,
      1
    ],
    "end": [
      152,
      17
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 zip_map']",
        "annotated_tactic": [
          "rw [\u2190 <a>zip_map'</a>]",
          [
            {
              "full_name": "List.zip_map'",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean",
              "def_pos": [
                2176,
                9
              ],
              "def_end_pos": [
                2176,
                17
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 map (fun x => (x, f x)) l = l.zip (map f l)",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 (map (fun x => x) l).zip (map f l) = l.zip (map f l)"
      },
      {
        "tactic": "congr",
        "annotated_tactic": [
          "congr",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 (map (fun x => x) l).zip (map f l) = l.zip (map f l)",
        "state_after": "case e_a\n\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 map (fun x => x) l = l"
      },
      {
        "tactic": "exact map_id _",
        "annotated_tactic": [
          "exact <a>map_id</a> _",
          [
            {
              "full_name": "List.map_id",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean",
              "def_pos": [
                716,
                17
              ],
              "def_end_pos": [
                716,
                23
              ]
            }
          ]
        ],
        "state_before": "case e_a\n\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 map (fun x => x) l = l",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5299790039425716,
    "entry_failed": false
  },
  "13384": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/PEquiv.lean",
    "full_name": "PEquiv.refl_trans",
    "start": [
      169,
      1
    ],
    "end": [
      170,
      33
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type x\nf : \u03b1 \u2243. \u03b2\n\u22a2 (PEquiv.refl \u03b1).trans f = f",
        "state_after": "case h.a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type x\nf : \u03b1 \u2243. \u03b2\nx\u271d : \u03b1\na\u271d : \u03b2\n\u22a2 a\u271d \u2208 ((PEquiv.refl \u03b1).trans f) x\u271d \u2194 a\u271d \u2208 f x\u271d"
      },
      {
        "tactic": "dsimp [PEquiv.trans]",
        "annotated_tactic": [
          "dsimp [<a>PEquiv.trans</a>]",
          [
            {
              "full_name": "PEquiv.trans",
              "def_path": "Mathlib/Data/PEquiv.lean",
              "def_pos": [
                118,
                15
              ],
              "def_end_pos": [
                118,
                20
              ]
            }
          ]
        ],
        "state_before": "case h.a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type x\nf : \u03b1 \u2243. \u03b2\nx\u271d : \u03b1\na\u271d : \u03b2\n\u22a2 a\u271d \u2208 ((PEquiv.refl \u03b1).trans f) x\u271d \u2194 a\u271d \u2208 f x\u271d",
        "state_after": "case h.a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type x\nf : \u03b1 \u2243. \u03b2\nx\u271d : \u03b1\na\u271d : \u03b2\n\u22a2 a\u271d \u2208 f x\u271d \u2194 a\u271d \u2208 f x\u271d"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case h.a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type x\nf : \u03b1 \u2243. \u03b2\nx\u271d : \u03b1\na\u271d : \u03b2\n\u22a2 a\u271d \u2208 f x\u271d \u2194 a\u271d \u2208 f x\u271d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.591201434028335,
    "entry_failed": false
  },
  "13440": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/NNRat/Defs.lean",
    "full_name": "NNRat.divNat_inj",
    "start": [
      406,
      1
    ],
    "end": [
      407,
      61
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 coe_inj]",
        "annotated_tactic": [
          "rw [\u2190 <a>coe_inj</a>]",
          [
            {
              "full_name": "NNRat.coe_inj",
              "def_path": "Mathlib/Data/NNRat/Defs.lean",
              "def_pos": [
                67,
                9
              ],
              "def_end_pos": [
                67,
                16
              ]
            }
          ]
        ],
        "state_before": "p q : \u211a\u22650\nn\u2081 n\u2082 d\u2081 d\u2082 d : \u2115\nh\u2081 : d\u2081 \u2260 0\nh\u2082 : d\u2082 \u2260 0\n\u22a2 divNat n\u2081 d\u2081 = divNat n\u2082 d\u2082 \u2194 n\u2081 * d\u2082 = n\u2082 * d\u2081",
        "state_after": "p q : \u211a\u22650\nn\u2081 n\u2082 d\u2081 d\u2082 d : \u2115\nh\u2081 : d\u2081 \u2260 0\nh\u2082 : d\u2082 \u2260 0\n\u22a2 \u2191(divNat n\u2081 d\u2081) = \u2191(divNat n\u2082 d\u2082) \u2194 n\u2081 * d\u2082 = n\u2082 * d\u2081"
      },
      {
        "tactic": "simp [Rat.mkRat_eq_iff, h\u2081, h\u2082]",
        "annotated_tactic": [
          "simp [<a>Rat.mkRat_eq_iff</a>, h\u2081, h\u2082]",
          [
            {
              "full_name": "Rat.mkRat_eq_iff",
              "def_path": ".lake/packages/batteries/Batteries/Data/Rat/Lemmas.lean",
              "def_pos": [
                128,
                9
              ],
              "def_end_pos": [
                128,
                21
              ]
            }
          ]
        ],
        "state_before": "p q : \u211a\u22650\nn\u2081 n\u2082 d\u2081 d\u2082 d : \u2115\nh\u2081 : d\u2081 \u2260 0\nh\u2082 : d\u2082 \u2260 0\n\u22a2 \u2191(divNat n\u2081 d\u2081) = \u2191(divNat n\u2082 d\u2082) \u2194 n\u2081 * d\u2082 = n\u2082 * d\u2081",
        "state_after": "p q : \u211a\u22650\nn\u2081 n\u2082 d\u2081 d\u2082 d : \u2115\nh\u2081 : d\u2081 \u2260 0\nh\u2082 : d\u2082 \u2260 0\n\u22a2 \u2191n\u2081 * \u2191d\u2082 = \u2191n\u2082 * \u2191d\u2081 \u2194 n\u2081 * d\u2082 = n\u2082 * d\u2081"
      },
      {
        "tactic": "norm_cast",
        "annotated_tactic": [
          "norm_cast",
          []
        ],
        "state_before": "p q : \u211a\u22650\nn\u2081 n\u2082 d\u2081 d\u2082 d : \u2115\nh\u2081 : d\u2081 \u2260 0\nh\u2082 : d\u2082 \u2260 0\n\u22a2 \u2191n\u2081 * \u2191d\u2082 = \u2191n\u2082 * \u2191d\u2081 \u2194 n\u2081 * d\u2082 = n\u2082 * d\u2081",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.356769284931943,
    "entry_failed": false
  },
  "13464": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": ".lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "full_name": "Batteries.RBNode.reverse_balance2",
    "start": [
      60,
      9
    ],
    "end": [
      62,
      70
    ],
    "traced_tactics": [
      {
        "tactic": "refine Eq.trans ?_ (reverse_reverse _)",
        "annotated_tactic": [
          "refine <a>Eq.trans</a> ?_ (<a>reverse_reverse</a> _)",
          [
            {
              "full_name": "Eq.trans",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                335,
                9
              ],
              "def_end_pos": [
                335,
                17
              ]
            },
            {
              "full_name": "Batteries.RBNode.reverse_reverse",
              "def_path": ".lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
              "def_pos": [
                48,
                17
              ],
              "def_end_pos": [
                48,
                32
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nl : RBNode \u03b1\nv : \u03b1\nr : RBNode \u03b1\n\u22a2 (l.balance2 v r).reverse = r.reverse.balance1 v l.reverse",
        "state_after": "\u03b1 : Type u_1\nl : RBNode \u03b1\nv : \u03b1\nr : RBNode \u03b1\n\u22a2 (l.balance2 v r).reverse = (r.reverse.balance1 v l.reverse).reverse.reverse"
      },
      {
        "tactic": "rw [reverse_balance1]",
        "annotated_tactic": [
          "rw [<a>reverse_balance1</a>]",
          [
            {
              "full_name": "Batteries.RBNode.reverse_balance1",
              "def_path": ".lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
              "def_pos": [
                54,
                17
              ],
              "def_end_pos": [
                54,
                33
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nl : RBNode \u03b1\nv : \u03b1\nr : RBNode \u03b1\n\u22a2 (l.balance2 v r).reverse = (r.reverse.balance1 v l.reverse).reverse.reverse",
        "state_after": "\u03b1 : Type u_1\nl : RBNode \u03b1\nv : \u03b1\nr : RBNode \u03b1\n\u22a2 (l.balance2 v r).reverse = (l.reverse.reverse.balance2 v r.reverse.reverse).reverse"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nl : RBNode \u03b1\nv : \u03b1\nr : RBNode \u03b1\n\u22a2 (l.balance2 v r).reverse = (l.reverse.reverse.balance2 v r.reverse.reverse).reverse",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7162004350684583,
    "entry_failed": false
  },
  "13481": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/Padics/PadicNorm.lean",
    "full_name": "padicNorm.not_int_of_not_padic_int",
    "start": [
      307,
      1
    ],
    "end": [
      311,
      25
    ],
    "traced_tactics": [
      {
        "tactic": "contrapose! H",
        "annotated_tactic": [
          "contrapose! H",
          []
        ],
        "state_before": "p\u271d : \u2115\nhp\u271d : Fact (Nat.Prime p\u271d)\np : \u2115\na : \u211a\nhp : Fact (Nat.Prime p)\nH : 1 < padicNorm p a\n\u22a2 \u00aca.isInt = true",
        "state_after": "p\u271d : \u2115\nhp\u271d : Fact (Nat.Prime p\u271d)\np : \u2115\na : \u211a\nhp : Fact (Nat.Prime p)\nH : a.isInt = true\n\u22a2 padicNorm p a \u2264 1"
      },
      {
        "tactic": "rw [Rat.eq_num_of_isInt H]",
        "annotated_tactic": [
          "rw [<a>Rat.eq_num_of_isInt</a> H]",
          [
            {
              "full_name": "Rat.eq_num_of_isInt",
              "def_path": "Mathlib/Data/Rat/Defs.lean",
              "def_pos": [
                543,
                7
              ],
              "def_end_pos": [
                543,
                22
              ]
            }
          ]
        ],
        "state_before": "p\u271d : \u2115\nhp\u271d : Fact (Nat.Prime p\u271d)\np : \u2115\na : \u211a\nhp : Fact (Nat.Prime p)\nH : a.isInt = true\n\u22a2 padicNorm p a \u2264 1",
        "state_after": "p\u271d : \u2115\nhp\u271d : Fact (Nat.Prime p\u271d)\np : \u2115\na : \u211a\nhp : Fact (Nat.Prime p)\nH : a.isInt = true\n\u22a2 padicNorm p \u2191a.num \u2264 1"
      },
      {
        "tactic": "apply padicNorm.of_int",
        "annotated_tactic": [
          "apply <a>padicNorm.of_int</a>",
          [
            {
              "full_name": "padicNorm.of_int",
              "def_path": "Mathlib/NumberTheory/Padics/PadicNorm.lean",
              "def_pos": [
                164,
                19
              ],
              "def_end_pos": [
                164,
                25
              ]
            }
          ]
        ],
        "state_before": "p\u271d : \u2115\nhp\u271d : Fact (Nat.Prime p\u271d)\np : \u2115\na : \u211a\nhp : Fact (Nat.Prime p)\nH : a.isInt = true\n\u22a2 padicNorm p \u2191a.num \u2264 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.4171299890149385,
    "entry_failed": false
  },
  "13539": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/Pell.lean",
    "full_name": "Pell.Solution\u2081.d_pos_of_one_lt_x",
    "start": [
      234,
      1
    ],
    "end": [
      237,
      34
    ],
    "traced_tactics": [
      {
        "tactic": "refine pos_of_mul_pos_left ?_ (sq_nonneg a.y)",
        "annotated_tactic": [
          "refine <a>pos_of_mul_pos_left</a> ?_ (<a>sq_nonneg</a> a.y)",
          [
            {
              "full_name": "pos_of_mul_pos_left",
              "def_path": "Mathlib/Algebra/Order/GroupWithZero/Unbundled.lean",
              "def_pos": [
                457,
                9
              ],
              "def_end_pos": [
                457,
                28
              ]
            },
            {
              "full_name": "sq_nonneg",
              "def_path": "Mathlib/Algebra/Order/Ring/Defs.lean",
              "def_pos": [
                1160,
                7
              ],
              "def_end_pos": [
                1160,
                16
              ]
            }
          ]
        ],
        "state_before": "d : \u2124\na : Solution\u2081 d\nha : 1 < a.x\n\u22a2 0 < d",
        "state_after": "d : \u2124\na : Solution\u2081 d\nha : 1 < a.x\n\u22a2 0 < d * a.y ^ 2"
      },
      {
        "tactic": "rw [a.prop_y, sub_pos]",
        "annotated_tactic": [
          "rw [a.prop_y, <a>sub_pos</a>]",
          [
            {
              "full_name": "sub_pos",
              "def_path": "Mathlib/Algebra/Order/Group/Defs.lean",
              "def_pos": [
                886,
                30
              ],
              "def_end_pos": [
                886,
                37
              ]
            }
          ]
        ],
        "state_before": "d : \u2124\na : Solution\u2081 d\nha : 1 < a.x\n\u22a2 0 < d * a.y ^ 2",
        "state_after": "d : \u2124\na : Solution\u2081 d\nha : 1 < a.x\n\u22a2 1 < a.x ^ 2"
      },
      {
        "tactic": "exact one_lt_pow ha two_ne_zero",
        "annotated_tactic": [
          "exact <a>one_lt_pow</a> ha <a>two_ne_zero</a>",
          [
            {
              "full_name": "one_lt_pow",
              "def_path": "Mathlib/Algebra/Order/Ring/Basic.lean",
              "def_pos": [
                112,
                9
              ],
              "def_end_pos": [
                112,
                19
              ]
            },
            {
              "full_name": "two_ne_zero",
              "def_path": "Mathlib/Algebra/NeZero.lean",
              "def_pos": [
                65,
                7
              ],
              "def_end_pos": [
                65,
                18
              ]
            }
          ]
        ],
        "state_before": "d : \u2124\na : Solution\u2081 d\nha : 1 < a.x\n\u22a2 1 < a.x ^ 2",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.1456440730253235,
    "entry_failed": false
  },
  "13597": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/Measure/WithDensity.lean",
    "full_name": "MeasureTheory.withDensity_absolutelyContinuous",
    "start": [
      150,
      1
    ],
    "end": [
      154,
      42
    ],
    "traced_tactics": [
      {
        "tactic": "refine AbsolutelyContinuous.mk fun s hs\u2081 hs\u2082 => ?_",
        "annotated_tactic": [
          "refine <a>AbsolutelyContinuous.mk</a> fun s hs\u2081 hs\u2082 => ?_",
          [
            {
              "full_name": "MeasureTheory.Measure.AbsolutelyContinuous.mk",
              "def_path": "Mathlib/MeasureTheory/Measure/MeasureSpace.lean",
              "def_pos": [
                1629,
                9
              ],
              "def_end_pos": [
                1629,
                11
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc\u271d : Measure \u03b1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\n\u22a2 \u03bc.withDensity f \u226a \u03bc",
        "state_after": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc\u271d : Measure \u03b1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\ns : Set \u03b1\nhs\u2081 : MeasurableSet s\nhs\u2082 : \u03bc s = 0\n\u22a2 (\u03bc.withDensity f) s = 0"
      },
      {
        "tactic": "rw [withDensity_apply _ hs\u2081]",
        "annotated_tactic": [
          "rw [<a>withDensity_apply</a> _ hs\u2081]",
          [
            {
              "full_name": "MeasureTheory.withDensity_apply",
              "def_path": "Mathlib/MeasureTheory/Measure/WithDensity.lean",
              "def_pos": [
                39,
                9
              ],
              "def_end_pos": [
                39,
                26
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc\u271d : Measure \u03b1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\ns : Set \u03b1\nhs\u2081 : MeasurableSet s\nhs\u2082 : \u03bc s = 0\n\u22a2 (\u03bc.withDensity f) s = 0",
        "state_after": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc\u271d : Measure \u03b1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\ns : Set \u03b1\nhs\u2081 : MeasurableSet s\nhs\u2082 : \u03bc s = 0\n\u22a2 \u222b\u207b (a : \u03b1) in s, f a \u2202\u03bc = 0"
      },
      {
        "tactic": "exact setLIntegral_measure_zero _ _ hs\u2082",
        "annotated_tactic": [
          "exact <a>setLIntegral_measure_zero</a> _ _ hs\u2082",
          [
            {
              "full_name": "MeasureTheory.setLIntegral_measure_zero",
              "def_path": "Mathlib/MeasureTheory/Integral/Lebesgue.lean",
              "def_pos": [
                691,
                9
              ],
              "def_end_pos": [
                691,
                34
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc\u271d : Measure \u03b1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\u22650\u221e\ns : Set \u03b1\nhs\u2081 : MeasurableSet s\nhs\u2082 : \u03bc s = 0\n\u22a2 \u222b\u207b (a : \u03b1) in s, f a \u2202\u03bc = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.0836783919949085,
    "entry_failed": false
  },
  "13672": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Regular/Pow.lean",
    "full_name": "IsLeftRegular.pow_iff",
    "start": [
      47,
      1
    ],
    "end": [
      50,
      29
    ],
    "traced_tactics": [
      {
        "tactic": "refine \u27e8?_, IsLeftRegular.pow n\u27e9",
        "annotated_tactic": [
          "refine \u27e8?_, <a>IsLeftRegular.pow</a> n\u27e9",
          [
            {
              "full_name": "IsLeftRegular.pow",
              "def_path": "Mathlib/Algebra/Regular/Pow.lean",
              "def_pos": [
                31,
                9
              ],
              "def_end_pos": [
                31,
                26
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\na b : R\ninst\u271d : Monoid R\nn : \u2115\nn0 : 0 < n\n\u22a2 IsLeftRegular (a ^ n) \u2194 IsLeftRegular a",
        "state_after": "R : Type u_1\na b : R\ninst\u271d : Monoid R\nn : \u2115\nn0 : 0 < n\n\u22a2 IsLeftRegular (a ^ n) \u2192 IsLeftRegular a"
      },
      {
        "tactic": "rw [\u2190 Nat.succ_pred_eq_of_pos n0, pow_succ]",
        "annotated_tactic": [
          "rw [\u2190 <a>Nat.succ_pred_eq_of_pos</a> n0, <a>pow_succ</a>]",
          [
            {
              "full_name": "Nat.succ_pred_eq_of_pos",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean",
              "def_pos": [
                830,
                9
              ],
              "def_end_pos": [
                830,
                28
              ]
            },
            {
              "full_name": "pow_succ",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                657,
                9
              ],
              "def_end_pos": [
                657,
                17
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\na b : R\ninst\u271d : Monoid R\nn : \u2115\nn0 : 0 < n\n\u22a2 IsLeftRegular (a ^ n) \u2192 IsLeftRegular a",
        "state_after": "R : Type u_1\na b : R\ninst\u271d : Monoid R\nn : \u2115\nn0 : 0 < n\n\u22a2 IsLeftRegular (a ^ n.pred * a) \u2192 IsLeftRegular a"
      },
      {
        "tactic": "exact IsLeftRegular.of_mul",
        "annotated_tactic": [
          "exact <a>IsLeftRegular.of_mul</a>",
          [
            {
              "full_name": "IsLeftRegular.of_mul",
              "def_path": "Mathlib/Algebra/Regular/Basic.lean",
              "def_pos": [
                140,
                9
              ],
              "def_end_pos": [
                140,
                29
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\na b : R\ninst\u271d : Monoid R\nn : \u2115\nn0 : 0 < n\n\u22a2 IsLeftRegular (a ^ n.pred * a) \u2192 IsLeftRegular a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2120900980662555,
    "entry_failed": false
  },
  "13680": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/Simple.lean",
    "full_name": "CategoryTheory.epi_from_simple_zero_of_not_iso",
    "start": [
      178,
      1
    ],
    "end": [
      182,
      40
    ],
    "traced_tactics": [
      {
        "tactic": "classical\n  by_contra h\n  exact w (isIso_of_epi_of_nonzero h)",
        "annotated_tactic": [
          "classical\n    by_contra h\n    exact w (<a>isIso_of_epi_of_nonzero</a> h)",
          [
            {
              "full_name": "CategoryTheory.isIso_of_epi_of_nonzero",
              "def_path": "Mathlib/CategoryTheory/Simple.lean",
              "def_pos": [
                163,
                9
              ],
              "def_end_pos": [
                163,
                32
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Abelian C\nX Y : C\ninst\u271d\u00b9 : Simple X\nf : X \u27f6 Y\ninst\u271d : Epi f\nw : IsIso f \u2192 False\n\u22a2 f = 0",
        "state_after": "no goals"
      },
      {
        "tactic": "by_contra h",
        "annotated_tactic": [
          "by_contra h",
          []
        ],
        "state_before": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Abelian C\nX Y : C\ninst\u271d\u00b9 : Simple X\nf : X \u27f6 Y\ninst\u271d : Epi f\nw : IsIso f \u2192 False\n\u22a2 f = 0",
        "state_after": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Abelian C\nX Y : C\ninst\u271d\u00b9 : Simple X\nf : X \u27f6 Y\ninst\u271d : Epi f\nw : IsIso f \u2192 False\nh : \u00acf = 0\n\u22a2 False"
      },
      {
        "tactic": "exact w (isIso_of_epi_of_nonzero h)",
        "annotated_tactic": [
          "exact w (<a>isIso_of_epi_of_nonzero</a> h)",
          [
            {
              "full_name": "CategoryTheory.isIso_of_epi_of_nonzero",
              "def_path": "Mathlib/CategoryTheory/Simple.lean",
              "def_pos": [
                163,
                9
              ],
              "def_end_pos": [
                163,
                32
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\ninst\u271d\u00b2 : Abelian C\nX Y : C\ninst\u271d\u00b9 : Simple X\nf : X \u27f6 Y\ninst\u271d : Epi f\nw : IsIso f \u2192 False\nh : \u00acf = 0\n\u22a2 False",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.763628804939799,
    "entry_failed": false
  },
  "13778": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Compactness/Lindelof.lean",
    "full_name": "IsLindelof.union",
    "start": [
      374,
      1
    ],
    "end": [
      375,
      83
    ],
    "traced_tactics": [
      {
        "tactic": "rw [union_eq_iUnion]",
        "annotated_tactic": [
          "rw [<a>union_eq_iUnion</a>]",
          [
            {
              "full_name": "Set.union_eq_iUnion",
              "def_path": "Mathlib/Data/Set/Lattice.lean",
              "def_pos": [
                1330,
                9
              ],
              "def_end_pos": [
                1330,
                24
              ]
            }
          ]
        ],
        "state_before": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns t : Set X\nhs : IsLindelof s\nht : IsLindelof t\n\u22a2 IsLindelof (s \u222a t)",
        "state_after": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns t : Set X\nhs : IsLindelof s\nht : IsLindelof t\n\u22a2 IsLindelof (\u22c3 b, bif b then s else t)"
      },
      {
        "tactic": "exact isLindelof_iUnion fun b => by cases b <;> assumption",
        "annotated_tactic": [
          "exact <a>isLindelof_iUnion</a> fun b => by cases b <;> assumption",
          [
            {
              "full_name": "isLindelof_iUnion",
              "def_path": "Mathlib/Topology/Compactness/Lindelof.lean",
              "def_pos": [
                355,
                9
              ],
              "def_end_pos": [
                355,
                26
              ]
            }
          ]
        ],
        "state_before": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns t : Set X\nhs : IsLindelof s\nht : IsLindelof t\n\u22a2 IsLindelof (\u22c3 b, bif b then s else t)",
        "state_after": "no goals"
      },
      {
        "tactic": "cases b <;> assumption",
        "annotated_tactic": [
          "cases b <;> assumption",
          []
        ],
        "state_before": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns t : Set X\nhs : IsLindelof s\nht : IsLindelof t\nb : Bool\n\u22a2 IsLindelof (bif b then s else t)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.0787728159921244,
    "entry_failed": false
  },
  "13789": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Tropical/BigOperators.lean",
    "full_name": "List.trop_minimum",
    "start": [
      78,
      1
    ],
    "end": [
      82,
      35
    ],
    "traced_tactics": [
      {
        "tactic": "induction' l with hd tl IH",
        "annotated_tactic": [
          "induction' l with hd tl IH",
          []
        ],
        "state_before": "R : Type u_1\nS : Type u_2\ninst\u271d : LinearOrder R\nl : List R\n\u22a2 trop l.minimum = (map (trop \u2218 WithTop.some) l).sum",
        "state_after": "case nil\nR : Type u_1\nS : Type u_2\ninst\u271d : LinearOrder R\n\u22a2 trop [].minimum = (map (trop \u2218 WithTop.some) []).sum\n\ncase cons\nR : Type u_1\nS : Type u_2\ninst\u271d : LinearOrder R\nhd : R\ntl : List R\nIH : trop tl.minimum = (map (trop \u2218 WithTop.some) tl).sum\n\u22a2 trop (hd :: tl).minimum = (map (trop \u2218 WithTop.some) (hd :: tl)).sum"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case nil\nR : Type u_1\nS : Type u_2\ninst\u271d : LinearOrder R\n\u22a2 trop [].minimum = (map (trop \u2218 WithTop.some) []).sum",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [List.minimum_cons, \u2190 IH]",
        "annotated_tactic": [
          "simp [<a>List.minimum_cons</a>, \u2190 IH]",
          [
            {
              "full_name": "List.minimum_cons",
              "def_path": "Mathlib/Data/List/MinMax.lean",
              "def_pos": [
                385,
                9
              ],
              "def_end_pos": [
                385,
                21
              ]
            }
          ]
        ],
        "state_before": "case cons\nR : Type u_1\nS : Type u_2\ninst\u271d : LinearOrder R\nhd : R\ntl : List R\nIH : trop tl.minimum = (map (trop \u2218 WithTop.some) tl).sum\n\u22a2 trop (hd :: tl).minimum = (map (trop \u2218 WithTop.some) (hd :: tl)).sum",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.626795817981474,
    "entry_failed": false
  },
  "13835": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Multiset/Fintype.lean",
    "full_name": "Multiset.toEnumFinset_mono",
    "start": [
      122,
      1
    ],
    "end": [
      126,
      56
    ],
    "traced_tactics": [
      {
        "tactic": "intro p",
        "annotated_tactic": [
          "intro p",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nm m\u2081 m\u2082 : Multiset \u03b1\nh : m\u2081 \u2264 m\u2082\n\u22a2 m\u2081.toEnumFinset \u2286 m\u2082.toEnumFinset",
        "state_after": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nm m\u2081 m\u2082 : Multiset \u03b1\nh : m\u2081 \u2264 m\u2082\np : \u03b1 \u00d7 \u2115\n\u22a2 p \u2208 m\u2081.toEnumFinset \u2192 p \u2208 m\u2082.toEnumFinset"
      },
      {
        "tactic": "simp only [Multiset.mem_toEnumFinset]",
        "annotated_tactic": [
          "simp only [<a>Multiset.mem_toEnumFinset</a>]",
          [
            {
              "full_name": "Multiset.mem_toEnumFinset",
              "def_path": "Mathlib/Data/Multiset/Fintype.lean",
              "def_pos": [
                112,
                9
              ],
              "def_end_pos": [
                112,
                34
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nm m\u2081 m\u2082 : Multiset \u03b1\nh : m\u2081 \u2264 m\u2082\np : \u03b1 \u00d7 \u2115\n\u22a2 p \u2208 m\u2081.toEnumFinset \u2192 p \u2208 m\u2082.toEnumFinset",
        "state_after": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nm m\u2081 m\u2082 : Multiset \u03b1\nh : m\u2081 \u2264 m\u2082\np : \u03b1 \u00d7 \u2115\n\u22a2 p.2 < count p.1 m\u2081 \u2192 p.2 < count p.1 m\u2082"
      },
      {
        "tactic": "exact gt_of_ge_of_gt (Multiset.le_iff_count.mp h p.1)",
        "annotated_tactic": [
          "exact <a>gt_of_ge_of_gt</a> (Multiset.le_iff_count.mp h p.1)",
          [
            {
              "full_name": "gt_of_ge_of_gt",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                134,
                9
              ],
              "def_end_pos": [
                134,
                23
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nm m\u2081 m\u2082 : Multiset \u03b1\nh : m\u2081 \u2264 m\u2082\np : \u03b1 \u00d7 \u2115\n\u22a2 p.2 < count p.1 m\u2081 \u2192 p.2 < count p.1 m\u2082",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4292383539723232,
    "entry_failed": false
  },
  "13989": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Ordinal/CantorNormalForm.lean",
    "full_name": "Ordinal.CNF_of_le_one",
    "start": [
      101,
      1
    ],
    "end": [
      104,
      21
    ],
    "traced_tactics": [
      {
        "tactic": "rcases le_one_iff.1 hb with (rfl | rfl)",
        "annotated_tactic": [
          "rcases <a>le_one_iff</a>.1 hb with (rfl | rfl)",
          [
            {
              "full_name": "Ordinal.le_one_iff",
              "def_path": "Mathlib/SetTheory/Ordinal/Basic.lean",
              "def_pos": [
                1082,
                9
              ],
              "def_end_pos": [
                1082,
                19
              ]
            }
          ]
        ],
        "state_before": "b o : Ordinal.{u_1}\nhb : b \u2264 1\nho : o \u2260 0\n\u22a2 CNF b o = [(0, o)]",
        "state_after": "case inl\no : Ordinal.{u_1}\nho : o \u2260 0\nhb : 0 \u2264 1\n\u22a2 CNF 0 o = [(0, o)]\n\ncase inr\no : Ordinal.{u_1}\nho : o \u2260 0\nhb : 1 \u2264 1\n\u22a2 CNF 1 o = [(0, o)]"
      },
      {
        "tactic": "exact zero_CNF ho",
        "annotated_tactic": [
          "exact <a>zero_CNF</a> ho",
          [
            {
              "full_name": "Ordinal.zero_CNF",
              "def_path": "Mathlib/SetTheory/Ordinal/CantorNormalForm.lean",
              "def_pos": [
                93,
                9
              ],
              "def_end_pos": [
                93,
                17
              ]
            }
          ]
        ],
        "state_before": "case inl\no : Ordinal.{u_1}\nho : o \u2260 0\nhb : 0 \u2264 1\n\u22a2 CNF 0 o = [(0, o)]",
        "state_after": "no goals"
      },
      {
        "tactic": "exact one_CNF ho",
        "annotated_tactic": [
          "exact <a>one_CNF</a> ho",
          [
            {
              "full_name": "Ordinal.one_CNF",
              "def_path": "Mathlib/SetTheory/Ordinal/CantorNormalForm.lean",
              "def_pos": [
                97,
                9
              ],
              "def_end_pos": [
                97,
                16
              ]
            }
          ]
        ],
        "state_before": "case inr\no : Ordinal.{u_1}\nho : o \u2260 0\nhb : 1 \u2264 1\n\u22a2 CNF 1 o = [(0, o)]",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.259796834900044,
    "entry_failed": false
  },
  "13991": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/SpecificGroups/Dihedral.lean",
    "full_name": "DihedralGroup.r_one_pow_n",
    "start": [
      146,
      1
    ],
    "end": [
      149,
      28
    ],
    "traced_tactics": [
      {
        "tactic": "rw [r_one_pow, one_def]",
        "annotated_tactic": [
          "rw [<a>r_one_pow</a>, <a>one_def</a>]",
          [
            {
              "full_name": "DihedralGroup.r_one_pow",
              "def_path": "Mathlib/GroupTheory/SpecificGroups/Dihedral.lean",
              "def_pos": [
                135,
                9
              ],
              "def_end_pos": [
                135,
                18
              ]
            },
            {
              "full_name": "DihedralGroup.one_def",
              "def_path": "Mathlib/GroupTheory/SpecificGroups/Dihedral.lean",
              "def_pos": [
                98,
                9
              ],
              "def_end_pos": [
                98,
                16
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\n\u22a2 r 1 ^ n = 1",
        "state_after": "n : \u2115\n\u22a2 r \u2191n = r 0"
      },
      {
        "tactic": "congr 1",
        "annotated_tactic": [
          "congr 1",
          []
        ],
        "state_before": "n : \u2115\n\u22a2 r \u2191n = r 0",
        "state_after": "case e_a\nn : \u2115\n\u22a2 \u2191n = 0"
      },
      {
        "tactic": "exact ZMod.natCast_self _",
        "annotated_tactic": [
          "exact <a>ZMod.natCast_self</a> _",
          [
            {
              "full_name": "ZMod.natCast_self",
              "def_path": "Mathlib/Data/ZMod/Basic.lean",
              "def_pos": [
                143,
                9
              ],
              "def_end_pos": [
                143,
                21
              ]
            }
          ]
        ],
        "state_before": "case e_a\nn : \u2115\n\u22a2 \u2191n = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.8194404039531946,
    "entry_failed": false
  },
  "13996": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Tactic/NormNum/Prime.lean",
    "full_name": "Mathlib.Meta.NormNum.minFacHelper_2",
    "start": [
      84,
      1
    ],
    "end": [
      88,
      40
    ],
    "traced_tactics": [
      {
        "tactic": "refine minFacHelper_1 e h \u03bb h2 \u21a6 ?_",
        "annotated_tactic": [
          "refine <a>minFacHelper_1</a> e h \u03bb h2 \u21a6 ?_",
          [
            {
              "full_name": "Mathlib.Meta.NormNum.minFacHelper_1",
              "def_path": "Mathlib/Tactic/NormNum/Prime.lean",
              "def_pos": [
                67,
                9
              ],
              "def_end_pos": [
                67,
                23
              ]
            }
          ]
        ],
        "state_before": "n k k' : \u2115\ne : k + 2 = k'\nnk : \u00acNat.Prime k\nh : MinFacHelper n k\n\u22a2 MinFacHelper n k'",
        "state_after": "n k k' : \u2115\ne : k + 2 = k'\nnk : \u00acNat.Prime k\nh : MinFacHelper n k\nh2 : n.minFac = k\n\u22a2 False"
      },
      {
        "tactic": "rw [\u2190 h2] at nk",
        "annotated_tactic": [
          "rw [\u2190 h2] at nk",
          []
        ],
        "state_before": "n k k' : \u2115\ne : k + 2 = k'\nnk : \u00acNat.Prime k\nh : MinFacHelper n k\nh2 : n.minFac = k\n\u22a2 False",
        "state_after": "n k k' : \u2115\ne : k + 2 = k'\nnk : \u00acNat.Prime n.minFac\nh : MinFacHelper n k\nh2 : n.minFac = k\n\u22a2 False"
      },
      {
        "tactic": "exact nk <| minFac_prime h.one_lt.ne'",
        "annotated_tactic": [
          "exact nk <| <a>minFac_prime</a> h.one_lt.ne'",
          [
            {
              "full_name": "Nat.minFac_prime",
              "def_path": "Mathlib/Data/Nat/Prime.lean",
              "def_pos": [
                342,
                9
              ],
              "def_end_pos": [
                342,
                21
              ]
            }
          ]
        ],
        "state_before": "n k k' : \u2115\ne : k + 2 = k'\nnk : \u00acNat.Prime n.minFac\nh : MinFacHelper n k\nh2 : n.minFac = k\n\u22a2 False",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2846977069275454,
    "entry_failed": false
  },
  "14087": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Finsupp/Fin.lean",
    "full_name": "Finsupp.cons_ne_zero_of_right",
    "start": [
      83,
      1
    ],
    "end": [
      86,
      30
    ],
    "traced_tactics": [
      {
        "tactic": "contrapose! h with c",
        "annotated_tactic": [
          "contrapose! h with c",
          []
        ],
        "state_before": "n : \u2115\ni : Fin n\nM : Type u_1\ninst\u271d : Zero M\ny : M\nt : Fin (n + 1) \u2192\u2080 M\ns : Fin n \u2192\u2080 M\nh : s \u2260 0\n\u22a2 cons y s \u2260 0",
        "state_after": "n : \u2115\ni : Fin n\nM : Type u_1\ninst\u271d : Zero M\ny : M\nt : Fin (n + 1) \u2192\u2080 M\ns : Fin n \u2192\u2080 M\nc : cons y s = 0\n\u22a2 s = 0"
      },
      {
        "tactic": "ext a",
        "annotated_tactic": [
          "ext a",
          []
        ],
        "state_before": "n : \u2115\ni : Fin n\nM : Type u_1\ninst\u271d : Zero M\ny : M\nt : Fin (n + 1) \u2192\u2080 M\ns : Fin n \u2192\u2080 M\nc : cons y s = 0\n\u22a2 s = 0",
        "state_after": "case h\nn : \u2115\ni : Fin n\nM : Type u_1\ninst\u271d : Zero M\ny : M\nt : Fin (n + 1) \u2192\u2080 M\ns : Fin n \u2192\u2080 M\nc : cons y s = 0\na : Fin n\n\u22a2 s a = 0 a"
      },
      {
        "tactic": "simp [\u2190 cons_succ a y s, c]",
        "annotated_tactic": [
          "simp [\u2190 <a>cons_succ</a> a y s, c]",
          [
            {
              "full_name": "Finsupp.cons_succ",
              "def_path": "Mathlib/Data/Finsupp/Fin.lean",
              "def_pos": [
                49,
                9
              ],
              "def_end_pos": [
                49,
                18
              ]
            }
          ]
        ],
        "state_before": "case h\nn : \u2115\ni : Fin n\nM : Type u_1\ninst\u271d : Zero M\ny : M\nt : Fin (n + 1) \u2192\u2080 M\ns : Fin n \u2192\u2080 M\nc : cons y s = 0\na : Fin n\n\u22a2 s a = 0 a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.3288208099547774,
    "entry_failed": false
  },
  "14114": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean",
    "full_name": "UniformFun.uniformContinuous_toFun",
    "start": [
      468,
      11
    ],
    "end": [
      472,
      35
    ],
    "traced_tactics": [
      {
        "tactic": "rw [uniformContinuous_pi]",
        "annotated_tactic": [
          "rw [<a>uniformContinuous_pi</a>]",
          [
            {
              "full_name": "uniformContinuous_pi",
              "def_path": "Mathlib/Topology/UniformSpace/Pi.lean",
              "def_pos": [
                46,
                9
              ],
              "def_end_pos": [
                46,
                29
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\ns s' : Set \u03b1\nx : \u03b1\np : Filter \u03b9\ng : \u03b9 \u2192 \u03b1\ninst\u271d : UniformSpace \u03b2\n\u22a2 UniformContinuous \u21d1toFun",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\ns s' : Set \u03b1\nx : \u03b1\np : Filter \u03b9\ng : \u03b9 \u2192 \u03b1\ninst\u271d : UniformSpace \u03b2\n\u22a2 \u2200 (i : \u03b1), UniformContinuous fun x => toFun x i"
      },
      {
        "tactic": "intro x",
        "annotated_tactic": [
          "intro x",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\ns s' : Set \u03b1\nx : \u03b1\np : Filter \u03b9\ng : \u03b9 \u2192 \u03b1\ninst\u271d : UniformSpace \u03b2\n\u22a2 \u2200 (i : \u03b1), UniformContinuous fun x => toFun x i",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\ns s' : Set \u03b1\nx\u271d : \u03b1\np : Filter \u03b9\ng : \u03b9 \u2192 \u03b1\ninst\u271d : UniformSpace \u03b2\nx : \u03b1\n\u22a2 UniformContinuous fun x_1 => toFun x_1 x"
      },
      {
        "tactic": "exact uniformContinuous_eval \u03b2 x",
        "annotated_tactic": [
          "exact <a>uniformContinuous_eval</a> \u03b2 x",
          [
            {
              "full_name": "UniformFun.uniformContinuous_eval",
              "def_path": "Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean",
              "def_pos": [
                345,
                9
              ],
              "def_end_pos": [
                345,
                31
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Type u_4\ns s' : Set \u03b1\nx\u271d : \u03b1\np : Filter \u03b9\ng : \u03b9 \u2192 \u03b1\ninst\u271d : UniformSpace \u03b2\nx : \u03b1\n\u22a2 UniformContinuous fun x_1 => toFun x_1 x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.6108662970364094,
    "entry_failed": false
  },
  "14136": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Factors.lean",
    "full_name": "Nat.mem_factors_mul_left",
    "start": [
      305,
      1
    ],
    "end": [
      309,
      47
    ],
    "traced_tactics": [
      {
        "tactic": "rcases eq_or_ne a 0 with (rfl | ha)",
        "annotated_tactic": [
          "rcases <a>eq_or_ne</a> a 0 with (rfl | ha)",
          [
            {
              "full_name": "eq_or_ne",
              "def_path": "Mathlib/Logic/Basic.lean",
              "def_pos": [
                212,
                9
              ],
              "def_end_pos": [
                212,
                17
              ]
            }
          ]
        ],
        "state_before": "p a b : \u2115\nhpa : p \u2208 a.factors\nhb : b \u2260 0\n\u22a2 p \u2208 (a * b).factors",
        "state_after": "case inl\np b : \u2115\nhb : b \u2260 0\nhpa : p \u2208 factors 0\n\u22a2 p \u2208 (0 * b).factors\n\ncase inr\np a b : \u2115\nhpa : p \u2208 a.factors\nhb : b \u2260 0\nha : a \u2260 0\n\u22a2 p \u2208 (a * b).factors"
      },
      {
        "tactic": "apply (mem_factors_mul ha hb).2 (Or.inl hpa)",
        "annotated_tactic": [
          "apply (<a>mem_factors_mul</a> ha hb).2 (<a>Or.inl</a> hpa)",
          [
            {
              "full_name": "Nat.mem_factors_mul",
              "def_path": "Mathlib/Data/Nat/Factors.lean",
              "def_pos": [
                278,
                9
              ],
              "def_end_pos": [
                278,
                24
              ]
            },
            {
              "full_name": "Or.inl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                534,
                5
              ],
              "def_end_pos": [
                534,
                8
              ]
            }
          ]
        ],
        "state_before": "case inr\np a b : \u2115\nhpa : p \u2208 a.factors\nhb : b \u2260 0\nha : a \u2260 0\n\u22a2 p \u2208 (a * b).factors",
        "state_after": "no goals"
      },
      {
        "tactic": "simp at hpa",
        "annotated_tactic": [
          "simp at hpa",
          []
        ],
        "state_before": "case inl\np b : \u2115\nhb : b \u2260 0\nhpa : p \u2208 factors 0\n\u22a2 p \u2208 (0 * b).factors",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.516138723003678,
    "entry_failed": false
  },
  "14153": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/ZMod/Basic.lean",
    "full_name": "ZMod.intCast_comp_cast",
    "start": [
      284,
      1
    ],
    "end": [
      288,
      27
    ],
    "traced_tactics": [
      {
        "tactic": "cases n",
        "annotated_tactic": [
          "cases n",
          []
        ],
        "state_before": "n : \u2115\nR : Type u_1\ninst\u271d : Ring R\n\u22a2 Int.cast \u2218 cast = cast",
        "state_after": "case zero\nR : Type u_1\ninst\u271d : Ring R\n\u22a2 Int.cast \u2218 cast = cast\n\ncase succ\nR : Type u_1\ninst\u271d : Ring R\nn\u271d : \u2115\n\u22a2 Int.cast \u2218 cast = cast"
      },
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "case succ\nR : Type u_1\ninst\u271d : Ring R\nn\u271d : \u2115\n\u22a2 Int.cast \u2218 cast = cast",
        "state_after": "case succ.h\nR : Type u_1\ninst\u271d : Ring R\nn\u271d : \u2115\nx\u271d : ZMod (n\u271d + 1)\n\u22a2 (Int.cast \u2218 cast) x\u271d = x\u271d.cast"
      },
      {
        "tactic": "simp [ZMod, ZMod.cast]",
        "annotated_tactic": [
          "simp [<a>ZMod</a>, <a>ZMod.cast</a>]",
          [
            {
              "full_name": "ZMod",
              "def_path": "Mathlib/Data/ZMod/Defs.lean",
              "def_pos": [
                95,
                5
              ],
              "def_end_pos": [
                95,
                9
              ]
            },
            {
              "full_name": "ZMod.cast",
              "def_path": "Mathlib/Data/ZMod/Basic.lean",
              "def_pos": [
                169,
                5
              ],
              "def_end_pos": [
                169,
                9
              ]
            }
          ]
        ],
        "state_before": "case succ.h\nR : Type u_1\ninst\u271d : Ring R\nn\u271d : \u2115\nx\u271d : ZMod (n\u271d + 1)\n\u22a2 (Int.cast \u2218 cast) x\u271d = x\u271d.cast",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.9413090319139883,
    "entry_failed": false
  },
  "14189": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Matroid/Basic.lean",
    "full_name": "Matroid.not_finiteRk",
    "start": [
      427,
      1
    ],
    "end": [
      428,
      71
    ],
    "traced_tactics": [
      {
        "tactic": "intro h",
        "annotated_tactic": [
          "intro h",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nM\u271d M : Matroid \u03b1\ninst\u271d : M.InfiniteRk\n\u22a2 \u00acM.FiniteRk",
        "state_after": "\u03b1 : Type u_1\nM\u271d M : Matroid \u03b1\ninst\u271d : M.InfiniteRk\nh : M.FiniteRk\n\u22a2 False"
      },
      {
        "tactic": "obtain \u27e8B,hB\u27e9 := M.exists_base",
        "annotated_tactic": [
          "obtain \u27e8B,hB\u27e9 := M.exists_base",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nM\u271d M : Matroid \u03b1\ninst\u271d : M.InfiniteRk\nh : M.FiniteRk\n\u22a2 False",
        "state_after": "case intro\n\u03b1 : Type u_1\nM\u271d M : Matroid \u03b1\ninst\u271d : M.InfiniteRk\nh : M.FiniteRk\nB : Set \u03b1\nhB : M.Base B\n\u22a2 False"
      },
      {
        "tactic": "exact hB.infinite hB.finite",
        "annotated_tactic": [
          "exact hB.infinite hB.finite",
          []
        ],
        "state_before": "case intro\n\u03b1 : Type u_1\nM\u271d M : Matroid \u03b1\ninst\u271d : M.InfiniteRk\nh : M.FiniteRk\nB : Set \u03b1\nhB : M.Base B\n\u22a2 False",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.138702688040212,
    "entry_failed": false
  },
  "14279": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Coloring.lean",
    "full_name": "SimpleGraph.colorable_of_chromaticNumber_ne_top",
    "start": [
      353,
      1
    ],
    "end": [
      357,
      37
    ],
    "traced_tactics": [
      {
        "tactic": "rw [chromaticNumber_ne_top_iff_exists] at h",
        "annotated_tactic": [
          "rw [<a>chromaticNumber_ne_top_iff_exists</a>] at h",
          [
            {
              "full_name": "SimpleGraph.chromaticNumber_ne_top_iff_exists",
              "def_path": "Mathlib/Combinatorics/SimpleGraph/Coloring.lean",
              "def_pos": [
                284,
                9
              ],
              "def_end_pos": [
                284,
                42
              ]
            }
          ]
        ],
        "state_before": "V : Type u\nG : SimpleGraph V\nn : \u2115\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nC : G.Coloring \u03b1\nh : G.chromaticNumber \u2260 \u22a4\n\u22a2 G.Colorable G.chromaticNumber.toNat",
        "state_after": "V : Type u\nG : SimpleGraph V\nn : \u2115\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nC : G.Coloring \u03b1\nh : \u2203 n, G.Colorable n\n\u22a2 G.Colorable G.chromaticNumber.toNat"
      },
      {
        "tactic": "obtain \u27e8n, hn\u27e9 := h",
        "annotated_tactic": [
          "obtain \u27e8n, hn\u27e9 := h",
          []
        ],
        "state_before": "V : Type u\nG : SimpleGraph V\nn : \u2115\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nC : G.Coloring \u03b1\nh : \u2203 n, G.Colorable n\n\u22a2 G.Colorable G.chromaticNumber.toNat",
        "state_after": "case intro\nV : Type u\nG : SimpleGraph V\nn\u271d : \u2115\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nC : G.Coloring \u03b1\nn : \u2115\nhn : G.Colorable n\n\u22a2 G.Colorable G.chromaticNumber.toNat"
      },
      {
        "tactic": "exact colorable_chromaticNumber hn",
        "annotated_tactic": [
          "exact <a>colorable_chromaticNumber</a> hn",
          [
            {
              "full_name": "SimpleGraph.colorable_chromaticNumber",
              "def_path": "Mathlib/Combinatorics/SimpleGraph/Coloring.lean",
              "def_pos": [
                306,
                9
              ],
              "def_end_pos": [
                306,
                34
              ]
            }
          ]
        ],
        "state_before": "case intro\nV : Type u\nG : SimpleGraph V\nn\u271d : \u2115\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nC : G.Coloring \u03b1\nn : \u2115\nhn : G.Colorable n\n\u22a2 G.Colorable G.chromaticNumber.toNat",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.8292594000231475,
    "entry_failed": false
  },
  "14318": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/OfFn.lean",
    "full_name": "List.get_ofFn",
    "start": [
      65,
      1
    ],
    "end": [
      66,
      14
    ],
    "traced_tactics": [
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "\u03b1 : Type u\nn : \u2115\nf : Fin n \u2192 \u03b1\ni : Fin (ofFn f).length\n\u22a2 (ofFn f).length = n",
        "state_after": "no goals"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "\u03b1 : Type u\nn : \u2115\nf : Fin n \u2192 \u03b1\ni : Fin (ofFn f).length\n\u22a2 (ofFn f).get i = f (Fin.cast \u22ef i)",
        "state_after": "\u03b1 : Type u\nn : \u2115\nf : Fin n \u2192 \u03b1\ni : Fin (ofFn f).length\n\u22a2 f \u27e8\u2191i, \u22ef\u27e9 = f (Fin.cast \u22ef i)"
      },
      {
        "tactic": "congr",
        "annotated_tactic": [
          "congr",
          []
        ],
        "state_before": "\u03b1 : Type u\nn : \u2115\nf : Fin n \u2192 \u03b1\ni : Fin (ofFn f).length\n\u22a2 f \u27e8\u2191i, \u22ef\u27e9 = f (Fin.cast \u22ef i)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6982595620211214,
    "entry_failed": false
  },
  "14410": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/NNRat/Defs.lean",
    "full_name": "NNRat.divNat_mul_right",
    "start": [
      423,
      1
    ],
    "end": [
      424,
      59
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "p q : \u211a\u22650\nn\u2081 n\u2082 d\u2081 d\u2082 d\u271d a : \u2115\nha : a \u2260 0\nn d : \u2115\n\u22a2 divNat (n * a) (d * a) = divNat n d",
        "state_after": "case a\np q : \u211a\u22650\nn\u2081 n\u2082 d\u2081 d\u2082 d\u271d a : \u2115\nha : a \u2260 0\nn d : \u2115\n\u22a2 \u2191(divNat (n * a) (d * a)) = \u2191(divNat n d)"
      },
      {
        "tactic": "push_cast",
        "annotated_tactic": [
          "push_cast",
          []
        ],
        "state_before": "case a\np q : \u211a\u22650\nn\u2081 n\u2082 d\u2081 d\u2082 d\u271d a : \u2115\nha : a \u2260 0\nn d : \u2115\n\u22a2 \u2191(divNat (n * a) (d * a)) = \u2191(divNat n d)",
        "state_after": "case a\np q : \u211a\u22650\nn\u2081 n\u2082 d\u2081 d\u2082 d\u271d a : \u2115\nha : a \u2260 0\nn d : \u2115\n\u22a2 Rat.divInt (\u2191n * \u2191a) (\u2191d * \u2191a) = Rat.divInt \u2191n \u2191d"
      },
      {
        "tactic": "exact Rat.divInt_mul_right (mod_cast ha)",
        "annotated_tactic": [
          "exact <a>Rat.divInt_mul_right</a> (mod_cast ha)",
          [
            {
              "full_name": "Rat.divInt_mul_right",
              "def_path": ".lake/packages/batteries/Batteries/Data/Rat/Lemmas.lean",
              "def_pos": [
                167,
                9
              ],
              "def_end_pos": [
                167,
                25
              ]
            }
          ]
        ],
        "state_before": "case a\np q : \u211a\u22650\nn\u2081 n\u2082 d\u2081 d\u2082 d\u271d a : \u2115\nha : a \u2260 0\nn d : \u2115\n\u22a2 Rat.divInt (\u2191n * \u2191a) (\u2191d * \u2191a) = Rat.divInt \u2191n \u2191d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.4772625099867582,
    "entry_failed": false
  },
  "14465": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Field/Basic.lean",
    "full_name": "div_le_of_nonneg_of_le_mul",
    "start": [
      152,
      1
    ],
    "end": [
      155,
      25
    ],
    "traced_tactics": [
      {
        "tactic": "rcases eq_or_lt_of_le hb with (rfl | hb')",
        "annotated_tactic": [
          "rcases <a>eq_or_lt_of_le</a> hb with (rfl | hb')",
          [
            {
              "full_name": "eq_or_lt_of_le",
              "def_path": "Mathlib/Order/Basic.lean",
              "def_pos": [
                381,
                9
              ],
              "def_end_pos": [
                381,
                23
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nhb : 0 \u2264 b\nhc : 0 \u2264 c\nh : a \u2264 c * b\n\u22a2 a / b \u2264 c",
        "state_after": "case inl\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na c d e : \u03b1\nm n : \u2124\nhc : 0 \u2264 c\nhb : 0 \u2264 0\nh : a \u2264 c * 0\n\u22a2 a / 0 \u2264 c\n\ncase inr\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nhb : 0 \u2264 b\nhc : 0 \u2264 c\nh : a \u2264 c * b\nhb' : 0 < b\n\u22a2 a / b \u2264 c"
      },
      {
        "tactic": "simp only [div_zero, hc]",
        "annotated_tactic": [
          "simp only [<a>div_zero</a>, hc]",
          [
            {
              "full_name": "div_zero",
              "def_path": "Mathlib/Algebra/GroupWithZero/Basic.lean",
              "def_pos": [
                351,
                9
              ],
              "def_end_pos": [
                351,
                17
              ]
            }
          ]
        ],
        "state_before": "case inl\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na c d e : \u03b1\nm n : \u2124\nhc : 0 \u2264 c\nhb : 0 \u2264 0\nh : a \u2264 c * 0\n\u22a2 a / 0 \u2264 c",
        "state_after": "no goals"
      },
      {
        "tactic": "rwa [div_le_iff hb']",
        "annotated_tactic": [
          "rwa [<a>div_le_iff</a> hb']",
          [
            {
              "full_name": "div_le_iff",
              "def_path": "Mathlib/Algebra/Order/Field/Basic.lean",
              "def_pos": [
                61,
                9
              ],
              "def_end_pos": [
                61,
                19
              ]
            }
          ]
        ],
        "state_before": "case inr\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nhb : 0 \u2264 b\nhc : 0 \u2264 c\nh : a \u2264 c * b\nhb' : 0 < b\n\u22a2 a / b \u2264 c",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.7361741419881582,
    "entry_failed": false
  },
  "14499": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/Order/UpperLower.lean",
    "full_name": "IsAntichain.volume_eq_zero",
    "start": [
      156,
      1
    ],
    "end": [
      159,
      23
    ],
    "traced_tactics": [
      {
        "tactic": "refine measure_mono_null ?_ hs.ordConnected.null_frontier",
        "annotated_tactic": [
          "refine <a>measure_mono_null</a> ?_ hs.ordConnected.null_frontier",
          [
            {
              "full_name": "MeasureTheory.measure_mono_null",
              "def_path": "Mathlib/MeasureTheory/OuterMeasure/Basic.lean",
              "def_pos": [
                56,
                9
              ],
              "def_end_pos": [
                56,
                26
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b9\ns : Set (\u03b9 \u2192 \u211d)\nx y : \u03b9 \u2192 \u211d\n\u03b4 : \u211d\ninst\u271d : Nonempty \u03b9\nhs : IsAntichain (fun x x_1 => x \u2264 x_1) s\n\u22a2 volume s = 0",
        "state_after": "\u03b9 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b9\ns : Set (\u03b9 \u2192 \u211d)\nx y : \u03b9 \u2192 \u211d\n\u03b4 : \u211d\ninst\u271d : Nonempty \u03b9\nhs : IsAntichain (fun x x_1 => x \u2264 x_1) s\n\u22a2 s \u2286 frontier s"
      },
      {
        "tactic": "rw [\u2190 closure_diff_interior, hs.interior_eq_empty, diff_empty]",
        "annotated_tactic": [
          "rw [\u2190 <a>closure_diff_interior</a>, hs.interior_eq_empty, <a>diff_empty</a>]",
          [
            {
              "full_name": "closure_diff_interior",
              "def_path": "Mathlib/Topology/Basic.lean",
              "def_pos": [
                676,
                9
              ],
              "def_end_pos": [
                676,
                30
              ]
            },
            {
              "full_name": "Set.diff_empty",
              "def_path": "Mathlib/Data/Set/Basic.lean",
              "def_pos": [
                1872,
                9
              ],
              "def_end_pos": [
                1872,
                19
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b9\ns : Set (\u03b9 \u2192 \u211d)\nx y : \u03b9 \u2192 \u211d\n\u03b4 : \u211d\ninst\u271d : Nonempty \u03b9\nhs : IsAntichain (fun x x_1 => x \u2264 x_1) s\n\u22a2 s \u2286 frontier s",
        "state_after": "\u03b9 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b9\ns : Set (\u03b9 \u2192 \u211d)\nx y : \u03b9 \u2192 \u211d\n\u03b4 : \u211d\ninst\u271d : Nonempty \u03b9\nhs : IsAntichain (fun x x_1 => x \u2264 x_1) s\n\u22a2 s \u2286 closure s"
      },
      {
        "tactic": "exact subset_closure",
        "annotated_tactic": [
          "exact <a>subset_closure</a>",
          [
            {
              "full_name": "subset_closure",
              "def_path": "Mathlib/Topology/Basic.lean",
              "def_pos": [
                403,
                9
              ],
              "def_end_pos": [
                403,
                23
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b9\ns : Set (\u03b9 \u2192 \u211d)\nx y : \u03b9 \u2192 \u211d\n\u03b4 : \u211d\ninst\u271d : Nonempty \u03b9\nhs : IsAntichain (fun x x_1 => x \u2264 x_1) s\n\u22a2 s \u2286 closure s",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.738771163974889,
    "entry_failed": false
  },
  "14594": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/FreeMonoid/Count.lean",
    "full_name": "FreeMonoid.countP_of'",
    "start": [
      61,
      1
    ],
    "end": [
      64,
      54
    ],
    "traced_tactics": [
      {
        "tactic": "erw [FreeAddMonoid.countP_of]",
        "annotated_tactic": [
          "erw [<a>FreeAddMonoid.countP_of</a>]",
          [
            {
              "full_name": "FreeAddMonoid.countP_of",
              "def_path": "Mathlib/Algebra/FreeMonoid/Count.lean",
              "def_pos": [
                31,
                9
              ],
              "def_end_pos": [
                31,
                18
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nx : \u03b1\n\u22a2 (countP p) (of x) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0",
        "state_after": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nx : \u03b1\n\u22a2 (if p x = (true = true) then 1 else 0) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0"
      },
      {
        "tactic": "simp only [eq_iff_iff, iff_true, ofAdd_zero]",
        "annotated_tactic": [
          "simp only [<a>eq_iff_iff</a>, <a>iff_true</a>, <a>ofAdd_zero</a>]",
          [
            {
              "full_name": "eq_iff_iff",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1378,
                17
              ],
              "def_end_pos": [
                1378,
                27
              ]
            },
            {
              "full_name": "iff_true",
              "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean",
              "def_pos": [
                127,
                17
              ],
              "def_end_pos": [
                127,
                25
              ]
            },
            {
              "full_name": "ofAdd_zero",
              "def_path": "Mathlib/Algebra/Group/TypeTags.lean",
              "def_pos": [
                261,
                9
              ],
              "def_end_pos": [
                261,
                19
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nx : \u03b1\n\u22a2 (if p x = (true = true) then 1 else 0) = if p x then Multiplicative.ofAdd 1 else Multiplicative.ofAdd 0",
        "state_after": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nx : \u03b1\n\u22a2 (if p x then 1 else 0) = if p x then Multiplicative.ofAdd 1 else 1"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nx : \u03b1\n\u22a2 (if p x then 1 else 0) = if p x then Multiplicative.ofAdd 1 else 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.1654280659276992,
    "entry_failed": false
  },
  "14647": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/CharP/ExpChar.lean",
    "full_name": "char_prime_of_ne_zero",
    "start": [
      133,
      1
    ],
    "end": [
      136,
      18
    ],
    "traced_tactics": [
      {
        "tactic": "cases' CharP.char_is_prime_or_zero R p with h h",
        "annotated_tactic": [
          "cases' <a>CharP.char_is_prime_or_zero</a> R p with h h",
          [
            {
              "full_name": "CharP.char_is_prime_or_zero",
              "def_path": "Mathlib/Algebra/CharP/Defs.lean",
              "def_pos": [
                285,
                7
              ],
              "def_end_pos": [
                285,
                28
              ]
            }
          ]
        ],
        "state_before": "R : Type u\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : NoZeroDivisors R\np : \u2115\nhp : CharP R p\np_ne_zero : p \u2260 0\n\u22a2 Nat.Prime p",
        "state_after": "case inl\nR : Type u\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : NoZeroDivisors R\np : \u2115\nhp : CharP R p\np_ne_zero : p \u2260 0\nh : Nat.Prime p\n\u22a2 Nat.Prime p\n\ncase inr\nR : Type u\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : NoZeroDivisors R\np : \u2115\nhp : CharP R p\np_ne_zero : p \u2260 0\nh : p = 0\n\u22a2 Nat.Prime p"
      },
      {
        "tactic": "exact h",
        "annotated_tactic": [
          "exact h",
          []
        ],
        "state_before": "case inl\nR : Type u\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : NoZeroDivisors R\np : \u2115\nhp : CharP R p\np_ne_zero : p \u2260 0\nh : Nat.Prime p\n\u22a2 Nat.Prime p",
        "state_after": "no goals"
      },
      {
        "tactic": "contradiction",
        "annotated_tactic": [
          "contradiction",
          []
        ],
        "state_before": "case inr\nR : Type u\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : NoZeroDivisors R\np : \u2115\nhp : CharP R p\np_ne_zero : p \u2260 0\nh : p = 0\n\u22a2 Nat.Prime p",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.05710277101025,
    "entry_failed": false
  },
  "14649": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/Enumerative/Composition.lean",
    "full_name": "Composition.length_pos_of_pos",
    "start": [
      192,
      1
    ],
    "end": [
      195,
      21
    ],
    "traced_tactics": [
      {
        "tactic": "apply length_pos_of_sum_pos",
        "annotated_tactic": [
          "apply <a>length_pos_of_sum_pos</a>",
          [
            {
              "full_name": "List.length_pos_of_sum_pos",
              "def_path": "Mathlib/Algebra/BigOperators/Group/List.lean",
              "def_pos": [
                257,
                15
              ],
              "def_end_pos": [
                257,
                36
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\nc : Composition n\nh : 0 < n\n\u22a2 0 < c.length",
        "state_after": "case h\nn : \u2115\nc : Composition n\nh : 0 < n\n\u22a2 0 < c.blocks.sum"
      },
      {
        "tactic": "convert h",
        "annotated_tactic": [
          "convert h",
          []
        ],
        "state_before": "case h\nn : \u2115\nc : Composition n\nh : 0 < n\n\u22a2 0 < c.blocks.sum",
        "state_after": "case h.e'_4\nn : \u2115\nc : Composition n\nh : 0 < n\n\u22a2 c.blocks.sum = n"
      },
      {
        "tactic": "exact c.blocks_sum",
        "annotated_tactic": [
          "exact c.blocks_sum",
          []
        ],
        "state_before": "case h.e'_4\nn : \u2115\nc : Composition n\nh : 0 < n\n\u22a2 c.blocks.sum = n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.020063483971171,
    "entry_failed": false
  },
  "14666": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/SuccPred/Basic.lean",
    "full_name": "WCovBy.pred_le",
    "start": [
      824,
      1
    ],
    "end": [
      827,
      20
    ],
    "traced_tactics": [
      {
        "tactic": "obtain h | rfl := h.covBy_or_eq",
        "annotated_tactic": [
          "obtain h | rfl := h.covBy_or_eq",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PredOrder \u03b1\na b : \u03b1\nh : a \u2a7f b\n\u22a2 pred b \u2264 a",
        "state_after": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PredOrder \u03b1\na b : \u03b1\nh\u271d : a \u2a7f b\nh : a \u22d6 b\n\u22a2 pred b \u2264 a\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PredOrder \u03b1\na : \u03b1\nh : a \u2a7f a\n\u22a2 pred a \u2264 a"
      },
      {
        "tactic": "exact (CovBy.pred_eq h).le",
        "annotated_tactic": [
          "exact (<a>CovBy.pred_eq</a> h).<a>le</a>",
          [
            {
              "full_name": "CovBy.pred_eq",
              "def_path": "Mathlib/Order/SuccPred/Basic.lean",
              "def_pos": [
                820,
                9
              ],
              "def_end_pos": [
                820,
                29
              ]
            },
            {
              "full_name": "Eq.le",
              "def_path": "Mathlib/Order/Basic.lean",
              "def_pos": [
                154,
                7
              ],
              "def_end_pos": [
                154,
                12
              ]
            }
          ]
        ],
        "state_before": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PredOrder \u03b1\na b : \u03b1\nh\u271d : a \u2a7f b\nh : a \u22d6 b\n\u22a2 pred b \u2264 a",
        "state_after": "no goals"
      },
      {
        "tactic": "exact pred_le _",
        "annotated_tactic": [
          "exact <a>pred_le</a> _",
          [
            {
              "full_name": "Order.pred_le",
              "def_path": "Mathlib/Order/SuccPred/Basic.lean",
              "def_pos": [
                619,
                9
              ],
              "def_end_pos": [
                619,
                16
              ]
            }
          ]
        ],
        "state_before": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PredOrder \u03b1\na : \u03b1\nh : a \u2a7f a\n\u22a2 pred a \u2264 a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.582514876034111,
    "entry_failed": false
  },
  "14675": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Surreal/Dyadic.lean",
    "full_name": "SetTheory.PGame.powHalf_le_one",
    "start": [
      106,
      1
    ],
    "end": [
      109,
      47
    ],
    "traced_tactics": [
      {
        "tactic": "induction' n with n hn",
        "annotated_tactic": [
          "induction' n with n hn",
          []
        ],
        "state_before": "n : \u2115\n\u22a2 powHalf n \u2264 1",
        "state_after": "case zero\n\n\u22a2 powHalf 0 \u2264 1\n\ncase succ\nn : \u2115\nhn : powHalf n \u2264 1\n\u22a2 powHalf (n + 1) \u2264 1"
      },
      {
        "tactic": "exact le_rfl",
        "annotated_tactic": [
          "exact <a>le_rfl</a>",
          [
            {
              "full_name": "le_rfl",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                50,
                9
              ],
              "def_end_pos": [
                50,
                15
              ]
            }
          ]
        ],
        "state_before": "case zero\n\n\u22a2 powHalf 0 \u2264 1",
        "state_after": "no goals"
      },
      {
        "tactic": "exact (powHalf_succ_le_powHalf n).trans hn",
        "annotated_tactic": [
          "exact (<a>powHalf_succ_le_powHalf</a> n).<a>trans</a> hn",
          [
            {
              "full_name": "SetTheory.PGame.powHalf_succ_le_powHalf",
              "def_path": "Mathlib/SetTheory/Surreal/Dyadic.lean",
              "def_pos": [
                102,
                9
              ],
              "def_end_pos": [
                102,
                32
              ]
            },
            {
              "full_name": "LE.le.trans",
              "def_path": "Mathlib/Order/Basic.lean",
              "def_pos": [
                115,
                7
              ],
              "def_end_pos": [
                115,
                18
              ]
            }
          ]
        ],
        "state_before": "case succ\nn : \u2115\nhn : powHalf n \u2264 1\n\u22a2 powHalf (n + 1) \u2264 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7354424019576982,
    "entry_failed": false
  },
  "14701": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/MaxPowDiv.lean",
    "full_name": "Nat.maxPowDiv.zero_base",
    "start": [
      57,
      1
    ],
    "end": [
      60,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "dsimp [maxPowDiv]",
        "annotated_tactic": [
          "dsimp [<a>maxPowDiv</a>]",
          [
            {
              "full_name": "Nat.maxPowDiv",
              "def_path": "Mathlib/Data/Nat/MaxPowDiv.lean",
              "def_pos": [
                30,
                5
              ],
              "def_end_pos": [
                30,
                14
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\n\u22a2 maxPowDiv 0 n = 0",
        "state_after": "n : \u2115\n\u22a2 go 0 0 n = 0"
      },
      {
        "tactic": "rw [maxPowDiv.go]",
        "annotated_tactic": [
          "rw [<a>maxPowDiv.go</a>]",
          [
            {
              "full_name": "Nat.maxPowDiv.go",
              "def_path": "Mathlib/Data/Nat/MaxPowDiv.lean",
              "def_pos": [
                32,
                7
              ],
              "def_end_pos": [
                32,
                9
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\n\u22a2 go 0 0 n = 0",
        "state_after": "n : \u2115\n\u22a2 (if 1 < 0 \u2227 0 < n \u2227 n % 0 = 0 then go (0 + 1) 0 (n / 0) else 0) = 0"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "n : \u2115\n\u22a2 (if 1 < 0 \u2227 0 < n \u2227 n % 0 = 0 then go (0 + 1) 0 (n / 0) else 0) = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.123323684092611,
    "entry_failed": false
  },
  "14702": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/FreeAbelianGroupFinsupp.lean",
    "full_name": "FreeAbelianGroup.support_zsmul",
    "start": [
      175,
      1
    ],
    "end": [
      179,
      62
    ],
    "traced_tactics": [
      {
        "tactic": "ext x",
        "annotated_tactic": [
          "ext x",
          []
        ],
        "state_before": "X : Type u_1\nk : \u2124\nh : k \u2260 0\na : FreeAbelianGroup X\n\u22a2 (k \u2022 a).support = a.support",
        "state_after": "case a\nX : Type u_1\nk : \u2124\nh : k \u2260 0\na : FreeAbelianGroup X\nx : X\n\u22a2 x \u2208 (k \u2022 a).support \u2194 x \u2208 a.support"
      },
      {
        "tactic": "simp only [mem_support_iff, AddMonoidHom.map_zsmul]",
        "annotated_tactic": [
          "simp only [<a>mem_support_iff</a>, <a>AddMonoidHom.map_zsmul</a>]",
          [
            {
              "full_name": "FreeAbelianGroup.mem_support_iff",
              "def_path": "Mathlib/GroupTheory/FreeAbelianGroupFinsupp.lean",
              "def_pos": [
                149,
                9
              ],
              "def_end_pos": [
                149,
                24
              ]
            },
            {
              "full_name": "AddMonoidHom.map_zsmul",
              "def_path": "Mathlib/Algebra/Group/Hom/Defs.lean",
              "def_pos": [
                1189,
                3
              ],
              "def_end_pos": [
                1189,
                14
              ]
            }
          ]
        ],
        "state_before": "case a\nX : Type u_1\nk : \u2124\nh : k \u2260 0\na : FreeAbelianGroup X\nx : X\n\u22a2 x \u2208 (k \u2022 a).support \u2194 x \u2208 a.support",
        "state_after": "case a\nX : Type u_1\nk : \u2124\nh : k \u2260 0\na : FreeAbelianGroup X\nx : X\n\u22a2 k \u2022 (coeff x) a \u2260 0 \u2194 (coeff x) a \u2260 0"
      },
      {
        "tactic": "simp only [h, zsmul_int_int, false_or_iff, Ne, mul_eq_zero]",
        "annotated_tactic": [
          "simp only [h, <a>zsmul_int_int</a>, <a>false_or_iff</a>, <a>Ne</a>, <a>mul_eq_zero</a>]",
          [
            {
              "full_name": "zsmul_int_int",
              "def_path": "Mathlib/Algebra/Group/Int.lean",
              "def_pos": [
                272,
                7
              ],
              "def_end_pos": [
                272,
                20
              ]
            },
            {
              "full_name": "false_or_iff",
              "def_path": "Mathlib/Init/Logic.lean",
              "def_pos": [
                154,
                9
              ],
              "def_end_pos": [
                154,
                21
              ]
            },
            {
              "full_name": "Ne",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                689,
                18
              ],
              "def_end_pos": [
                689,
                20
              ]
            },
            {
              "full_name": "mul_eq_zero",
              "def_path": "Mathlib/Algebra/GroupWithZero/Defs.lean",
              "def_pos": [
                282,
                9
              ],
              "def_end_pos": [
                282,
                20
              ]
            }
          ]
        ],
        "state_before": "case a\nX : Type u_1\nk : \u2124\nh : k \u2260 0\na : FreeAbelianGroup X\nx : X\n\u22a2 k \u2022 (coeff x) a \u2260 0 \u2194 (coeff x) a \u2260 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.2444361509988084,
    "entry_failed": false
  },
  "14825": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Real/Sqrt.lean",
    "full_name": "Real.div_sqrt",
    "start": [
      404,
      1
    ],
    "end": [
      407,
      62
    ],
    "traced_tactics": [
      {
        "tactic": "rcases le_or_lt x 0 with h | h",
        "annotated_tactic": [
          "rcases <a>le_or_lt</a> x 0 with h | h",
          [
            {
              "full_name": "le_or_lt",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                342,
                9
              ],
              "def_end_pos": [
                342,
                17
              ]
            }
          ]
        ],
        "state_before": "x\u271d y\u271d x y : \u211d\n\u22a2 x / \u221ax = \u221ax",
        "state_after": "case inl\nx\u271d y\u271d x y : \u211d\nh : x \u2264 0\n\u22a2 x / \u221ax = \u221ax\n\ncase inr\nx\u271d y\u271d x y : \u211d\nh : 0 < x\n\u22a2 x / \u221ax = \u221ax"
      },
      {
        "tactic": "rw [sqrt_eq_zero'.mpr h, div_zero]",
        "annotated_tactic": [
          "rw [sqrt_eq_zero'.mpr h, <a>div_zero</a>]",
          [
            {
              "full_name": "div_zero",
              "def_path": "Mathlib/Algebra/GroupWithZero/Basic.lean",
              "def_pos": [
                351,
                9
              ],
              "def_end_pos": [
                351,
                17
              ]
            }
          ]
        ],
        "state_before": "case inl\nx\u271d y\u271d x y : \u211d\nh : x \u2264 0\n\u22a2 x / \u221ax = \u221ax",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [div_eq_iff (sqrt_ne_zero'.mpr h), mul_self_sqrt h.le]",
        "annotated_tactic": [
          "rw [<a>div_eq_iff</a> (sqrt_ne_zero'.mpr h), <a>mul_self_sqrt</a> h.le]",
          [
            {
              "full_name": "div_eq_iff",
              "def_path": "Mathlib/Algebra/GroupWithZero/Units/Basic.lean",
              "def_pos": [
                354,
                22
              ],
              "def_end_pos": [
                354,
                32
              ]
            },
            {
              "full_name": "Real.mul_self_sqrt",
              "def_path": "Mathlib/Data/Real/Sqrt.lean",
              "def_pos": [
                166,
                9
              ],
              "def_end_pos": [
                166,
                22
              ]
            }
          ]
        ],
        "state_before": "case inr\nx\u271d y\u271d x y : \u211d\nh : 0 < x\n\u22a2 x / \u221ax = \u221ax",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.761164378025569,
    "entry_failed": false
  },
  "14840": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Tropical/BigOperators.lean",
    "full_name": "Finset.untrop_sum'",
    "start": [
      119,
      1
    ],
    "end": [
      123,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "convert Multiset.untrop_sum (s.val.map f)",
        "annotated_tactic": [
          "convert <a>Multiset.untrop_sum</a> (s.val.map f)",
          [
            {
              "full_name": "Multiset.untrop_sum",
              "def_path": "Mathlib/Algebra/Tropical/BigOperators.lean",
              "def_pos": [
                111,
                9
              ],
              "def_end_pos": [
                111,
                28
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : Finset S\nf : S \u2192 Tropical R\n\u22a2 untrop (\u2211 i \u2208 s, f i) = s.inf (untrop \u2218 f)",
        "state_after": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : Finset S\nf : S \u2192 Tropical R\n\u22a2 s.inf (untrop \u2218 f) = (Multiset.map untrop (Multiset.map f s.val)).inf"
      },
      {
        "tactic": "simp only [Multiset.map_map, Function.comp_apply]",
        "annotated_tactic": [
          "simp only [<a>Multiset.map_map</a>, <a>Function.comp_apply</a>]",
          [
            {
              "full_name": "Multiset.map_map",
              "def_path": "Mathlib/Data/Multiset/Basic.lean",
              "def_pos": [
                1332,
                9
              ],
              "def_end_pos": [
                1332,
                16
              ]
            },
            {
              "full_name": "Function.comp_apply",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                35,
                17
              ],
              "def_end_pos": [
                35,
                36
              ]
            }
          ]
        ],
        "state_before": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : Finset S\nf : S \u2192 Tropical R\n\u22a2 s.inf (untrop \u2218 f) = (Multiset.map untrop (Multiset.map f s.val)).inf",
        "state_after": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : Finset S\nf : S \u2192 Tropical R\n\u22a2 s.inf (untrop \u2218 f) = (Multiset.map (fun x => untrop (f x)) s.val).inf"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : Finset S\nf : S \u2192 Tropical R\n\u22a2 s.inf (untrop \u2218 f) = (Multiset.map (fun x => untrop (f x)) s.val).inf",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.3530694079818204,
    "entry_failed": false
  },
  "14842": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/DList/Defs.lean",
    "full_name": "Batteries.DList.toList_ofList",
    "start": [
      58,
      1
    ],
    "end": [
      59,
      90
    ],
    "traced_tactics": [
      {
        "tactic": "cases l",
        "annotated_tactic": [
          "cases l",
          []
        ],
        "state_before": "\u03b1 : Type u\nl : List \u03b1\n\u22a2 (ofList l).toList = l",
        "state_after": "case nil\n\u03b1 : Type u\n\u22a2 (ofList []).toList = []\n\ncase cons\n\u03b1 : Type u\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\n\u22a2 (ofList (head\u271d :: tail\u271d)).toList = head\u271d :: tail\u271d"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case nil\n\u03b1 : Type u\n\u22a2 (ofList []).toList = []\n\ncase cons\n\u03b1 : Type u\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\n\u22a2 (ofList (head\u271d :: tail\u271d)).toList = head\u271d :: tail\u271d",
        "state_after": "case cons\n\u03b1 : Type u\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\n\u22a2 (ofList (head\u271d :: tail\u271d)).toList = head\u271d :: tail\u271d"
      },
      {
        "tactic": "simp only [DList.toList, DList.ofList, List.cons_append, List.append_nil]",
        "annotated_tactic": [
          "simp only [<a>DList.toList</a>, <a>DList.ofList</a>, <a>List.cons_append</a>, <a>List.append_nil</a>]",
          [
            {
              "full_name": "Batteries.DList.toList",
              "def_path": ".lake/packages/batteries/Batteries/Data/DList.lean",
              "def_pos": [
                34,
                5
              ],
              "def_end_pos": [
                34,
                11
              ]
            },
            {
              "full_name": "Batteries.DList.ofList",
              "def_path": ".lake/packages/batteries/Batteries/Data/DList.lean",
              "def_pos": [
                24,
                5
              ],
              "def_end_pos": [
                24,
                11
              ]
            },
            {
              "full_name": "List.cons_append",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean",
              "def_pos": [
                484,
                17
              ],
              "def_end_pos": [
                484,
                28
              ]
            },
            {
              "full_name": "List.append_nil",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean",
              "def_pos": [
                486,
                17
              ],
              "def_end_pos": [
                486,
                27
              ]
            }
          ]
        ],
        "state_before": "case cons\n\u03b1 : Type u\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\n\u22a2 (ofList (head\u271d :: tail\u271d)).toList = head\u271d :: tail\u271d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 0.6497665290953591,
    "entry_failed": false
  },
  "14897": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Fintype/Card.lean",
    "full_name": "Fintype.card_congr",
    "start": [
      151,
      1
    ],
    "end": [
      152,
      56
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 ofEquiv_card f]",
        "annotated_tactic": [
          "rw [\u2190 <a>ofEquiv_card</a> f]",
          [
            {
              "full_name": "Fintype.ofEquiv_card",
              "def_path": "Mathlib/Data/Fintype/Card.lean",
              "def_pos": [
                147,
                9
              ],
              "def_end_pos": [
                147,
                21
              ]
            }
          ]
        ],
        "state_before": "\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : \u03b1 \u2243 \u03b2\n\u22a2 card \u03b1 = card \u03b2",
        "state_after": "\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : \u03b1 \u2243 \u03b2\n\u22a2 card \u03b2 = card \u03b2"
      },
      {
        "tactic": "congr",
        "annotated_tactic": [
          "congr",
          []
        ],
        "state_before": "\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : \u03b1 \u2243 \u03b2\n\u22a2 card \u03b2 = card \u03b2",
        "state_after": "case h.e_2.h\n\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : \u03b1 \u2243 \u03b2\n\u22a2 ofEquiv \u03b1 f = inst\u271d"
      },
      {
        "tactic": "apply Subsingleton.elim",
        "annotated_tactic": [
          "apply <a>Subsingleton.elim</a>",
          [
            {
              "full_name": "Subsingleton.elim",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1015,
                19
              ],
              "def_end_pos": [
                1015,
                36
              ]
            }
          ]
        ],
        "state_before": "case h.e_2.h\n\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : \u03b1 \u2243 \u03b2\n\u22a2 ofEquiv \u03b1 f = inst\u271d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.532142782001756,
    "entry_failed": false
  },
  "14979": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Group/Abs.lean",
    "full_name": "mabs_mul_eq_mul_mabs_iff",
    "start": [
      364,
      1
    ],
    "end": [
      368,
      69
    ],
    "traced_tactics": [
      {
        "tactic": "obtain ab | ab := le_total a b",
        "annotated_tactic": [
          "obtain ab | ab := <a>le_total</a> a b",
          [
            {
              "full_name": "le_total",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                297,
                9
              ],
              "def_end_pos": [
                297,
                17
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedCommGroup \u03b1\na\u271d b\u271d a b : \u03b1\n\u22a2 mabs (a * b) = mabs a * mabs b \u2194 1 \u2264 a \u2227 1 \u2264 b \u2228 a \u2264 1 \u2227 b \u2264 1",
        "state_after": "case inl\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedCommGroup \u03b1\na\u271d b\u271d a b : \u03b1\nab : a \u2264 b\n\u22a2 mabs (a * b) = mabs a * mabs b \u2194 1 \u2264 a \u2227 1 \u2264 b \u2228 a \u2264 1 \u2227 b \u2264 1\n\ncase inr\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedCommGroup \u03b1\na\u271d b\u271d a b : \u03b1\nab : b \u2264 a\n\u22a2 mabs (a * b) = mabs a * mabs b \u2194 1 \u2264 a \u2227 1 \u2264 b \u2228 a \u2264 1 \u2227 b \u2264 1"
      },
      {
        "tactic": "exact mabs_mul_eq_mul_mabs_le ab",
        "annotated_tactic": [
          "exact <a>mabs_mul_eq_mul_mabs_le</a> ab",
          [
            {
              "full_name": "_private.Mathlib.Algebra.Order.Group.Abs.0.mabs_mul_eq_mul_mabs_le",
              "def_path": "Mathlib/Algebra/Order/Group/Abs.lean",
              "def_pos": [
                345,
                30
              ],
              "def_end_pos": [
                345,
                53
              ]
            }
          ]
        ],
        "state_before": "case inl\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedCommGroup \u03b1\na\u271d b\u271d a b : \u03b1\nab : a \u2264 b\n\u22a2 mabs (a * b) = mabs a * mabs b \u2194 1 \u2264 a \u2227 1 \u2264 b \u2228 a \u2264 1 \u2227 b \u2264 1",
        "state_after": "no goals"
      },
      {
        "tactic": "simpa only [mul_comm, and_comm] using mabs_mul_eq_mul_mabs_le ab",
        "annotated_tactic": [
          "simpa only [<a>mul_comm</a>, <a>and_comm</a>] using <a>mabs_mul_eq_mul_mabs_le</a> ab",
          [
            {
              "full_name": "mul_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                332,
                9
              ],
              "def_end_pos": [
                332,
                17
              ]
            },
            {
              "full_name": "and_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                819,
                9
              ],
              "def_end_pos": [
                819,
                17
              ]
            },
            {
              "full_name": "_private.Mathlib.Algebra.Order.Group.Abs.0.mabs_mul_eq_mul_mabs_le",
              "def_path": "Mathlib/Algebra/Order/Group/Abs.lean",
              "def_pos": [
                345,
                30
              ],
              "def_end_pos": [
                345,
                53
              ]
            }
          ]
        ],
        "state_before": "case inr\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedCommGroup \u03b1\na\u271d b\u271d a b : \u03b1\nab : b \u2264 a\n\u22a2 mabs (a * b) = mabs a * mabs b \u2194 1 \u2264 a \u2227 1 \u2264 b \u2228 a \u2264 1 \u2227 b \u2264 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.7374995679128915,
    "entry_failed": false
  },
  "14987": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Lattice.lean",
    "full_name": "Nat.sInf_empty",
    "start": [
      59,
      1
    ],
    "end": [
      62,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "rw [sInf_eq_zero]",
        "annotated_tactic": [
          "rw [<a>sInf_eq_zero</a>]",
          [
            {
              "full_name": "Nat.sInf_eq_zero",
              "def_path": "Mathlib/Data/Nat/Lattice.lean",
              "def_pos": [
                50,
                9
              ],
              "def_end_pos": [
                50,
                21
              ]
            }
          ]
        ],
        "state_before": "\u22a2 sInf \u2205 = 0",
        "state_after": "\u22a2 0 \u2208 \u2205 \u2228 \u2205 = \u2205"
      },
      {
        "tactic": "right",
        "annotated_tactic": [
          "right",
          []
        ],
        "state_before": "\u22a2 0 \u2208 \u2205 \u2228 \u2205 = \u2205",
        "state_after": "case h\n\n\u22a2 \u2205 = \u2205"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case h\n\n\u22a2 \u2205 = \u2205",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2944410539930686,
    "entry_failed": false
  },
  "15092": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Real/Archimedean.lean",
    "full_name": "Real.ciSup_const_zero",
    "start": [
      196,
      1
    ],
    "end": [
      199,
      22
    ],
    "traced_tactics": [
      {
        "tactic": "cases isEmpty_or_nonempty \u03b1",
        "annotated_tactic": [
          "cases <a>isEmpty_or_nonempty</a> \u03b1",
          [
            {
              "full_name": "isEmpty_or_nonempty",
              "def_path": "Mathlib/Logic/IsEmpty.lean",
              "def_pos": [
                221,
                9
              ],
              "def_end_pos": [
                221,
                28
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Sort u_1\n\u22a2 \u2a06 x, 0 = 0",
        "state_after": "case inl\n\u03b1 : Sort u_1\nh\u271d : IsEmpty \u03b1\n\u22a2 \u2a06 x, 0 = 0\n\ncase inr\n\u03b1 : Sort u_1\nh\u271d : Nonempty \u03b1\n\u22a2 \u2a06 x, 0 = 0"
      },
      {
        "tactic": "exact Real.iSup_of_isEmpty _",
        "annotated_tactic": [
          "exact <a>Real.iSup_of_isEmpty</a> _",
          [
            {
              "full_name": "Real.iSup_of_isEmpty",
              "def_path": "Mathlib/Data/Real/Archimedean.lean",
              "def_pos": [
                188,
                15
              ],
              "def_end_pos": [
                188,
                30
              ]
            }
          ]
        ],
        "state_before": "case inl\n\u03b1 : Sort u_1\nh\u271d : IsEmpty \u03b1\n\u22a2 \u2a06 x, 0 = 0",
        "state_after": "no goals"
      },
      {
        "tactic": "exact ciSup_const",
        "annotated_tactic": [
          "exact <a>ciSup_const</a>",
          [
            {
              "full_name": "ciSup_const",
              "def_path": "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean",
              "def_pos": [
                848,
                9
              ],
              "def_end_pos": [
                848,
                20
              ]
            }
          ]
        ],
        "state_before": "case inr\n\u03b1 : Sort u_1\nh\u271d : Nonempty \u03b1\n\u22a2 \u2a06 x, 0 = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.869176361011341,
    "entry_failed": false
  },
  "15126": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/SpecificGroups/Dihedral.lean",
    "full_name": "DihedralGroup.nat_card",
    "start": [
      129,
      1
    ],
    "end": [
      132,
      40
    ],
    "traced_tactics": [
      {
        "tactic": "cases n",
        "annotated_tactic": [
          "cases n",
          []
        ],
        "state_before": "n : \u2115\n\u22a2 Nat.card (DihedralGroup n) = 2 * n",
        "state_after": "case zero\n\n\u22a2 Nat.card (DihedralGroup 0) = 2 * 0\n\ncase succ\nn\u271d : \u2115\n\u22a2 Nat.card (DihedralGroup (n\u271d + 1)) = 2 * (n\u271d + 1)"
      },
      {
        "tactic": "rw [Nat.card_eq_zero_of_infinite]",
        "annotated_tactic": [
          "rw [<a>Nat.card_eq_zero_of_infinite</a>]",
          [
            {
              "full_name": "Nat.card_eq_zero_of_infinite",
              "def_path": "Mathlib/SetTheory/Cardinal/Finite.lean",
              "def_pos": [
                61,
                15
              ],
              "def_end_pos": [
                61,
                39
              ]
            }
          ]
        ],
        "state_before": "case zero\n\n\u22a2 Nat.card (DihedralGroup 0) = 2 * 0",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [Nat.card_eq_fintype_card, card]",
        "annotated_tactic": [
          "rw [<a>Nat.card_eq_fintype_card</a>, <a>card</a>]",
          [
            {
              "full_name": "Nat.card_eq_fintype_card",
              "def_path": "Mathlib/SetTheory/Cardinal/Finite.lean",
              "def_pos": [
                40,
                9
              ],
              "def_end_pos": [
                40,
                29
              ]
            },
            {
              "full_name": "DihedralGroup.card",
              "def_path": "Mathlib/GroupTheory/SpecificGroups/Dihedral.lean",
              "def_pos": [
                125,
                9
              ],
              "def_end_pos": [
                125,
                13
              ]
            }
          ]
        ],
        "state_before": "case succ\nn\u271d : \u2115\n\u22a2 Nat.card (DihedralGroup (n\u271d + 1)) = 2 * (n\u271d + 1)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.6922563980333507,
    "entry_failed": false
  },
  "15162": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Polynomial/Monic.lean",
    "full_name": "Polynomial.Monic.of_mul_monic_right",
    "start": [
      149,
      1
    ],
    "end": [
      152,
      34
    ],
    "traced_tactics": [
      {
        "tactic": "contrapose! hpq",
        "annotated_tactic": [
          "contrapose! hpq",
          []
        ],
        "state_before": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhq : q.Monic\nhpq : (p * q).Monic\n\u22a2 p.Monic",
        "state_after": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhq : q.Monic\nhpq : \u00acp.Monic\n\u22a2 \u00ac(p * q).Monic"
      },
      {
        "tactic": "rw [Monic.def] at hpq \u22a2",
        "annotated_tactic": [
          "rw [<a>Monic.def</a>] at hpq \u22a2",
          [
            {
              "full_name": "Polynomial.Monic.def",
              "def_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
              "def_pos": [
                86,
                9
              ],
              "def_end_pos": [
                86,
                18
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhq : q.Monic\nhpq : \u00acp.Monic\n\u22a2 \u00ac(p * q).Monic",
        "state_after": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhq : q.Monic\nhpq : \u00acp.leadingCoeff = 1\n\u22a2 \u00ac(p * q).leadingCoeff = 1"
      },
      {
        "tactic": "rwa [leadingCoeff_mul_monic hq]",
        "annotated_tactic": [
          "rwa [<a>leadingCoeff_mul_monic</a> hq]",
          [
            {
              "full_name": "Polynomial.leadingCoeff_mul_monic",
              "def_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
              "def_pos": [
                1075,
                9
              ],
              "def_end_pos": [
                1075,
                31
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhq : q.Monic\nhpq : \u00acp.leadingCoeff = 1\n\u22a2 \u00ac(p * q).leadingCoeff = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.661440446972847,
    "entry_failed": false
  },
  "15164": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean",
    "full_name": "Mathlib.Meta.Positivity.log_pos_of_isNat",
    "start": [
      500,
      1
    ],
    "end": [
      504,
      16
    ],
    "traced_tactics": [
      {
        "tactic": "rw [NormNum.IsNat.to_eq h rfl]",
        "annotated_tactic": [
          "rw [<a>NormNum.IsNat.to_eq</a> h <a>rfl</a>]",
          [
            {
              "full_name": "Mathlib.Meta.NormNum.IsNat.to_eq",
              "def_path": "Mathlib/Tactic/NormNum/Result.lean",
              "def_pos": [
                136,
                9
              ],
              "def_end_pos": [
                136,
                20
              ]
            },
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "e : \u211d\nd n : \u2115\nh : NormNum.IsNat e n\nw : Nat.blt 1 n = true\n\u22a2 0 < Real.log e",
        "state_after": "e : \u211d\nd n : \u2115\nh : NormNum.IsNat e n\nw : Nat.blt 1 n = true\n\u22a2 0 < Real.log \u2191n"
      },
      {
        "tactic": "apply Real.log_pos",
        "annotated_tactic": [
          "apply <a>Real.log_pos</a>",
          [
            {
              "full_name": "Real.log_pos",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean",
              "def_pos": [
                176,
                9
              ],
              "def_end_pos": [
                176,
                16
              ]
            }
          ]
        ],
        "state_before": "e : \u211d\nd n : \u2115\nh : NormNum.IsNat e n\nw : Nat.blt 1 n = true\n\u22a2 0 < Real.log \u2191n",
        "state_after": "case hx\ne : \u211d\nd n : \u2115\nh : NormNum.IsNat e n\nw : Nat.blt 1 n = true\n\u22a2 1 < \u2191n"
      },
      {
        "tactic": "simpa using w",
        "annotated_tactic": [
          "simpa using w",
          []
        ],
        "state_before": "case hx\ne : \u211d\nd n : \u2115\nh : NormNum.IsNat e n\nw : Nat.blt 1 n = true\n\u22a2 1 < \u2191n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.786122187040746,
    "entry_failed": false
  },
  "15229": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Duplicate.lean",
    "full_name": "List.Duplicate.ne_singleton",
    "start": [
      70,
      1
    ],
    "end": [
      73,
      31
    ],
    "traced_tactics": [
      {
        "tactic": "induction' h with l' h z l' h _",
        "annotated_tactic": [
          "induction' h with l' h z l' h _",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nl : List \u03b1\nx : \u03b1\nh : x \u2208+ l\ny : \u03b1\n\u22a2 l \u2260 [y]",
        "state_after": "case cons_mem\n\u03b1 : Type u_1\nl : List \u03b1\nx y : \u03b1\nl' : List \u03b1\nh : x \u2208 l'\n\u22a2 x :: l' \u2260 [y]\n\ncase cons_duplicate\n\u03b1 : Type u_1\nl : List \u03b1\nx y z : \u03b1\nl' : List \u03b1\nh : x \u2208+ l'\na_ih\u271d : l' \u2260 [y]\n\u22a2 z :: l' \u2260 [y]"
      },
      {
        "tactic": "simp [ne_nil_of_mem h]",
        "annotated_tactic": [
          "simp [<a>ne_nil_of_mem</a> h]",
          [
            {
              "full_name": "List.ne_nil_of_mem",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean",
              "def_pos": [
                330,
                9
              ],
              "def_end_pos": [
                330,
                22
              ]
            }
          ]
        ],
        "state_before": "case cons_mem\n\u03b1 : Type u_1\nl : List \u03b1\nx y : \u03b1\nl' : List \u03b1\nh : x \u2208 l'\n\u22a2 x :: l' \u2260 [y]",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [ne_nil_of_mem h.mem]",
        "annotated_tactic": [
          "simp [<a>ne_nil_of_mem</a> h.mem]",
          [
            {
              "full_name": "List.ne_nil_of_mem",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean",
              "def_pos": [
                330,
                9
              ],
              "def_end_pos": [
                330,
                22
              ]
            }
          ]
        ],
        "state_before": "case cons_duplicate\n\u03b1 : Type u_1\nl : List \u03b1\nx y z : \u03b1\nl' : List \u03b1\nh : x \u2208+ l'\na_ih\u271d : l' \u2260 [y]\n\u22a2 z :: l' \u2260 [y]",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2522951079299673,
    "entry_failed": false
  },
  "15323": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Setoid/Basic.lean",
    "full_name": "Setoid.sup_eq_eqvGen",
    "start": [
      231,
      1
    ],
    "end": [
      235,
      43
    ],
    "traced_tactics": [
      {
        "tactic": "rw [eqvGen_eq]",
        "annotated_tactic": [
          "rw [<a>eqvGen_eq</a>]",
          [
            {
              "full_name": "Setoid.eqvGen_eq",
              "def_path": "Mathlib/Data/Setoid/Basic.lean",
              "def_pos": [
                220,
                9
              ],
              "def_end_pos": [
                220,
                18
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr s : Setoid \u03b1\n\u22a2 r \u2294 s = EqvGen.Setoid fun x y => r.Rel x y \u2228 s.Rel x y",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr s : Setoid \u03b1\n\u22a2 r \u2294 s = sInf {s_1 | \u2200 \u2983x y : \u03b1\u2984, r.Rel x y \u2228 s.Rel x y \u2192 s_1.Rel x y}"
      },
      {
        "tactic": "apply congr_arg sInf",
        "annotated_tactic": [
          "apply <a>congr_arg</a> <a>sInf</a>",
          [
            {
              "full_name": "congr_arg",
              "def_path": ".lake/packages/batteries/Batteries/Logic.lean",
              "def_pos": [
                76,
                7
              ],
              "def_end_pos": [
                76,
                16
              ]
            },
            {
              "full_name": "InfSet.sInf",
              "def_path": "Mathlib/Order/SetNotation.lean",
              "def_pos": [
                50,
                3
              ],
              "def_end_pos": [
                50,
                7
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr s : Setoid \u03b1\n\u22a2 r \u2294 s = sInf {s_1 | \u2200 \u2983x y : \u03b1\u2984, r.Rel x y \u2228 s.Rel x y \u2192 s_1.Rel x y}",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr s : Setoid \u03b1\n\u22a2 {x | r \u2264 x \u2227 s \u2264 x} = {s_1 | \u2200 \u2983x y : \u03b1\u2984, r.Rel x y \u2228 s.Rel x y \u2192 s_1.Rel x y}"
      },
      {
        "tactic": "simp only [le_def, or_imp, \u2190 forall_and]",
        "annotated_tactic": [
          "simp only [<a>le_def</a>, <a>or_imp</a>, \u2190 <a>forall_and</a>]",
          [
            {
              "full_name": "Setoid.le_def",
              "def_path": "Mathlib/Data/Setoid/Basic.lean",
              "def_pos": [
                74,
                9
              ],
              "def_end_pos": [
                74,
                15
              ]
            },
            {
              "full_name": "or_imp",
              "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean",
              "def_pos": [
                120,
                9
              ],
              "def_end_pos": [
                120,
                15
              ]
            },
            {
              "full_name": "forall_and",
              "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean",
              "def_pos": [
                256,
                9
              ],
              "def_end_pos": [
                256,
                19
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr s : Setoid \u03b1\n\u22a2 {x | r \u2264 x \u2227 s \u2264 x} = {s_1 | \u2200 \u2983x y : \u03b1\u2984, r.Rel x y \u2228 s.Rel x y \u2192 s_1.Rel x y}",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.550898924935609,
    "entry_failed": false
  },
  "15330": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Order/LowerUpperTopology.lean",
    "full_name": "Topology.isUpper_orderDual",
    "start": [
      455,
      1
    ],
    "end": [
      458,
      32
    ],
    "traced_tactics": [
      {
        "tactic": "constructor",
        "annotated_tactic": [
          "constructor",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : ?m.39958\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 IsUpper \u03b1\u1d52\u1d48 \u2194 IsLower \u03b1",
        "state_after": "case mp\n\u03b1 : Type u_1\n\u03b2 : ?m.39958\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 IsUpper \u03b1\u1d52\u1d48 \u2192 IsLower \u03b1\n\ncase mpr\n\u03b1 : Type u_1\n\u03b2 : ?m.39958\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 IsLower \u03b1 \u2192 IsUpper \u03b1\u1d52\u1d48"
      },
      {
        "tactic": "apply OrderDual.instIsLower",
        "annotated_tactic": [
          "apply <a>OrderDual.instIsLower</a>",
          [
            {
              "full_name": "OrderDual.instIsLower",
              "def_path": "Mathlib/Topology/Order/LowerUpperTopology.lean",
              "def_pos": [
                335,
                10
              ],
              "def_end_pos": [
                335,
                38
              ]
            }
          ]
        ],
        "state_before": "case mp\n\u03b1 : Type u_1\n\u03b2 : ?m.39958\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 IsUpper \u03b1\u1d52\u1d48 \u2192 IsLower \u03b1",
        "state_after": "no goals"
      },
      {
        "tactic": "apply OrderDual.instIsUpper",
        "annotated_tactic": [
          "apply <a>OrderDual.instIsUpper</a>",
          [
            {
              "full_name": "OrderDual.instIsUpper",
              "def_path": "Mathlib/Topology/Order/LowerUpperTopology.lean",
              "def_pos": [
                224,
                10
              ],
              "def_end_pos": [
                224,
                38
              ]
            }
          ]
        ],
        "state_before": "case mpr\n\u03b1 : Type u_1\n\u03b2 : ?m.39958\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 IsLower \u03b1 \u2192 IsUpper \u03b1\u1d52\u1d48",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.956408936996013,
    "entry_failed": false
  },
  "15360": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/JordanHolder.lean",
    "full_name": "JordanHolderLattice.isMaximal_of_eq_inf",
    "start": [
      109,
      1
    ],
    "end": [
      113,
      53
    ],
    "traced_tactics": [
      {
        "tactic": "have hb : x \u2294 y = b := sup_eq_of_isMaximal hxb hyb hxy",
        "annotated_tactic": [
          "have hb : x \u2294 y = b := <a>sup_eq_of_isMaximal</a> hxb hyb hxy",
          [
            {
              "full_name": "JordanHolderLattice.sup_eq_of_isMaximal",
              "def_path": "Mathlib/Order/JordanHolder.lean",
              "def_pos": [
                89,
                3
              ],
              "def_end_pos": [
                89,
                22
              ]
            }
          ]
        ],
        "state_before": "X : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\nx b a y : X\nha : x \u2293 y = a\nhxy : x \u2260 y\nhxb : IsMaximal x b\nhyb : IsMaximal y b\n\u22a2 IsMaximal a y",
        "state_after": "X : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\nx b a y : X\nha : x \u2293 y = a\nhxy : x \u2260 y\nhxb : IsMaximal x b\nhyb : IsMaximal y b\nhb : x \u2294 y = b\n\u22a2 IsMaximal a y"
      },
      {
        "tactic": "substs a b",
        "annotated_tactic": [
          "substs a b",
          []
        ],
        "state_before": "X : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\nx b a y : X\nha : x \u2293 y = a\nhxy : x \u2260 y\nhxb : IsMaximal x b\nhyb : IsMaximal y b\nhb : x \u2294 y = b\n\u22a2 IsMaximal a y",
        "state_after": "X : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\nx y : X\nhxy : x \u2260 y\nhxb : IsMaximal x (x \u2294 y)\nhyb : IsMaximal y (x \u2294 y)\n\u22a2 IsMaximal (x \u2293 y) y"
      },
      {
        "tactic": "exact isMaximal_inf_right_of_isMaximal_sup hxb hyb",
        "annotated_tactic": [
          "exact <a>isMaximal_inf_right_of_isMaximal_sup</a> hxb hyb",
          [
            {
              "full_name": "JordanHolderLattice.isMaximal_inf_right_of_isMaximal_sup",
              "def_path": "Mathlib/Order/JordanHolder.lean",
              "def_pos": [
                102,
                9
              ],
              "def_end_pos": [
                102,
                45
              ]
            }
          ]
        ],
        "state_before": "X : Type u\ninst\u271d\u00b9 : Lattice X\ninst\u271d : JordanHolderLattice X\nx y : X\nhxy : x \u2260 y\nhxb : IsMaximal x (x \u2294 y)\nhyb : IsMaximal y (x \u2294 y)\n\u22a2 IsMaximal (x \u2293 y) y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4304587519727647,
    "entry_failed": false
  },
  "15416": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Matroid/Basic.lean",
    "full_name": "Matroid.Base.nonempty",
    "start": [
      412,
      1
    ],
    "end": [
      413,
      68
    ],
    "traced_tactics": [
      {
        "tactic": "rw [nonempty_iff_ne_empty]",
        "annotated_tactic": [
          "rw [<a>nonempty_iff_ne_empty</a>]",
          [
            {
              "full_name": "Set.nonempty_iff_ne_empty",
              "def_path": "Mathlib/Data/Set/Basic.lean",
              "def_pos": [
                580,
                9
              ],
              "def_end_pos": [
                580,
                30
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nM : Matroid \u03b1\nB : Set \u03b1\ninst\u271d : M.RkPos\nhB : M.Base B\n\u22a2 B.Nonempty",
        "state_after": "\u03b1 : Type u_1\nM : Matroid \u03b1\nB : Set \u03b1\ninst\u271d : M.RkPos\nhB : M.Base B\n\u22a2 B \u2260 \u2205"
      },
      {
        "tactic": "rintro rfl",
        "annotated_tactic": [
          "rintro rfl",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nM : Matroid \u03b1\nB : Set \u03b1\ninst\u271d : M.RkPos\nhB : M.Base B\n\u22a2 B \u2260 \u2205",
        "state_after": "\u03b1 : Type u_1\nM : Matroid \u03b1\ninst\u271d : M.RkPos\nhB : M.Base \u2205\n\u22a2 False"
      },
      {
        "tactic": "exact M.empty_not_base hB",
        "annotated_tactic": [
          "exact M.empty_not_base hB",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nM : Matroid \u03b1\ninst\u271d : M.RkPos\nhB : M.Base \u2205\n\u22a2 False",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.1786439679563046,
    "entry_failed": false
  },
  "15447": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/Asymptotics/SpecificAsymptotics.lean",
    "full_name": "pow_div_pow_eventuallyEq_atTop",
    "start": [
      42,
      1
    ],
    "end": [
      46,
      26
    ],
    "traced_tactics": [
      {
        "tactic": "apply (eventually_gt_atTop (0 : \ud835\udd5c)).mono fun x hx => _",
        "annotated_tactic": [
          "apply (<a>eventually_gt_atTop</a> (0 : \ud835\udd5c)).<a>mono</a> fun x hx => _",
          [
            {
              "full_name": "Filter.eventually_gt_atTop",
              "def_path": "Mathlib/Order/Filter/AtTopBot.lean",
              "def_pos": [
                201,
                9
              ],
              "def_end_pos": [
                201,
                28
              ]
            },
            {
              "full_name": "Filter.Eventually.mono",
              "def_path": "Mathlib/Order/Filter/Basic.lean",
              "def_pos": [
                1158,
                9
              ],
              "def_end_pos": [
                1158,
                24
              ]
            }
          ]
        ],
        "state_before": "\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\np q : \u2115\n\u22a2 (fun x => x ^ p / x ^ q) =\u1da0[atTop] fun x => x ^ (\u2191p - \u2191q)",
        "state_after": "\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\np q : \u2115\n\u22a2 \u2200 (x : \ud835\udd5c), 0 < x \u2192 (fun x => x ^ p / x ^ q) x = (fun x => x ^ (\u2191p - \u2191q)) x"
      },
      {
        "tactic": "intro x hx",
        "annotated_tactic": [
          "intro x hx",
          []
        ],
        "state_before": "\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\np q : \u2115\n\u22a2 \u2200 (x : \ud835\udd5c), 0 < x \u2192 (fun x => x ^ p / x ^ q) x = (fun x => x ^ (\u2191p - \u2191q)) x",
        "state_after": "\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\np q : \u2115\nx : \ud835\udd5c\nhx : 0 < x\n\u22a2 (fun x => x ^ p / x ^ q) x = (fun x => x ^ (\u2191p - \u2191q)) x"
      },
      {
        "tactic": "simp [zpow_sub\u2080 hx.ne']",
        "annotated_tactic": [
          "simp [<a>zpow_sub\u2080</a> hx.ne']",
          [
            {
              "full_name": "zpow_sub\u2080",
              "def_path": "Mathlib/Algebra/GroupWithZero/Units/Basic.lean",
              "def_pos": [
                431,
                7
              ],
              "def_end_pos": [
                431,
                16
              ]
            }
          ]
        ],
        "state_before": "\ud835\udd5c : Type u_1\ninst\u271d : LinearOrderedField \ud835\udd5c\np q : \u2115\nx : \ud835\udd5c\nhx : 0 < x\n\u22a2 (fun x => x ^ p / x ^ q) x = (fun x => x ^ (\u2191p - \u2191q)) x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6750619629165158,
    "entry_failed": false
  },
  "15452": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/MetricSpace/PiNat.lean",
    "full_name": "PiNat.dist_nonneg",
    "start": [
      285,
      11
    ],
    "end": [
      288,
      32
    ],
    "traced_tactics": [
      {
        "tactic": "rcases eq_or_ne x y with (rfl | h)",
        "annotated_tactic": [
          "rcases <a>eq_or_ne</a> x y with (rfl | h)",
          [
            {
              "full_name": "eq_or_ne",
              "def_path": "Mathlib/Logic/Basic.lean",
              "def_pos": [
                212,
                9
              ],
              "def_end_pos": [
                212,
                17
              ]
            }
          ]
        ],
        "state_before": "E : \u2115 \u2192 Type u_1\nx y : (n : \u2115) \u2192 E n\n\u22a2 0 \u2264 dist x y",
        "state_after": "case inl\nE : \u2115 \u2192 Type u_1\nx : (n : \u2115) \u2192 E n\n\u22a2 0 \u2264 dist x x\n\ncase inr\nE : \u2115 \u2192 Type u_1\nx y : (n : \u2115) \u2192 E n\nh : x \u2260 y\n\u22a2 0 \u2264 dist x y"
      },
      {
        "tactic": "simp [dist]",
        "annotated_tactic": [
          "simp [<a>dist</a>]",
          [
            {
              "full_name": "Dist.dist",
              "def_path": "Mathlib/Topology/MetricSpace/Pseudo/Defs.lean",
              "def_pos": [
                82,
                3
              ],
              "def_end_pos": [
                82,
                7
              ]
            }
          ]
        ],
        "state_before": "case inl\nE : \u2115 \u2192 Type u_1\nx : (n : \u2115) \u2192 E n\n\u22a2 0 \u2264 dist x x",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [dist, h, zero_le_two]",
        "annotated_tactic": [
          "simp [<a>dist</a>, h, <a>zero_le_two</a>]",
          [
            {
              "full_name": "Dist.dist",
              "def_path": "Mathlib/Topology/MetricSpace/Pseudo/Defs.lean",
              "def_pos": [
                82,
                3
              ],
              "def_end_pos": [
                82,
                7
              ]
            },
            {
              "full_name": "zero_le_two",
              "def_path": "Mathlib/Algebra/Order/Monoid/NatCast.lean",
              "def_pos": [
                32,
                7
              ],
              "def_end_pos": [
                32,
                18
              ]
            }
          ]
        ],
        "state_before": "case inr\nE : \u2115 \u2192 Type u_1\nx y : (n : \u2115) \u2192 E n\nh : x \u2260 y\n\u22a2 0 \u2264 dist x y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.514311501989141,
    "entry_failed": false
  },
  "15458": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/LinearAlgebra/Matrix/ZPow.lean",
    "full_name": "IsUnit.det_zpow",
    "start": [
      120,
      1
    ],
    "end": [
      123,
      29
    ],
    "traced_tactics": [
      {
        "tactic": "cases' n with n n",
        "annotated_tactic": [
          "cases' n with n n",
          []
        ],
        "state_before": "n' : Type u_1\ninst\u271d\u00b2 : DecidableEq n'\ninst\u271d\u00b9 : Fintype n'\nR : Type u_2\ninst\u271d : CommRing R\nA : M\nh : IsUnit A.det\nn : \u2124\n\u22a2 IsUnit (A ^ n).det",
        "state_after": "case ofNat\nn' : Type u_1\ninst\u271d\u00b2 : DecidableEq n'\ninst\u271d\u00b9 : Fintype n'\nR : Type u_2\ninst\u271d : CommRing R\nA : M\nh : IsUnit A.det\nn : \u2115\n\u22a2 IsUnit (A ^ ofNat n).det\n\ncase negSucc\nn' : Type u_1\ninst\u271d\u00b2 : DecidableEq n'\ninst\u271d\u00b9 : Fintype n'\nR : Type u_2\ninst\u271d : CommRing R\nA : M\nh : IsUnit A.det\nn : \u2115\n\u22a2 IsUnit (A ^ -[n+1]).det"
      },
      {
        "tactic": "simpa using h.pow n",
        "annotated_tactic": [
          "simpa using h.pow n",
          []
        ],
        "state_before": "case ofNat\nn' : Type u_1\ninst\u271d\u00b2 : DecidableEq n'\ninst\u271d\u00b9 : Fintype n'\nR : Type u_2\ninst\u271d : CommRing R\nA : M\nh : IsUnit A.det\nn : \u2115\n\u22a2 IsUnit (A ^ ofNat n).det",
        "state_after": "no goals"
      },
      {
        "tactic": "simpa using h.pow n.succ",
        "annotated_tactic": [
          "simpa using h.pow n.succ",
          []
        ],
        "state_before": "case negSucc\nn' : Type u_1\ninst\u271d\u00b2 : DecidableEq n'\ninst\u271d\u00b9 : Fintype n'\nR : Type u_2\ninst\u271d : CommRing R\nA : M\nh : IsUnit A.det\nn : \u2115\n\u22a2 IsUnit (A ^ -[n+1]).det",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.007527899928391,
    "entry_failed": false
  },
  "15537": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Ordinal/FixedPoint.lean",
    "full_name": "Ordinal.IsNormal.le_iff_deriv",
    "start": [
      539,
      1
    ],
    "end": [
      542,
      45
    ],
    "traced_tactics": [
      {
        "tactic": "unfold deriv",
        "annotated_tactic": [
          "unfold <a>deriv</a>",
          [
            {
              "full_name": "Ordinal.deriv",
              "def_path": "Mathlib/SetTheory/Ordinal/FixedPoint.lean",
              "def_pos": [
                505,
                5
              ],
              "def_end_pos": [
                505,
                10
              ]
            }
          ]
        ],
        "state_before": "f\u271d : Ordinal.{u} \u2192 Ordinal.{u}\nf : Ordinal.{u_1} \u2192 Ordinal.{u_1}\nH : IsNormal f\na : Ordinal.{u_1}\n\u22a2 f a \u2264 a \u2194 \u2203 o, deriv f o = a",
        "state_after": "f\u271d : Ordinal.{u} \u2192 Ordinal.{u}\nf : Ordinal.{u_1} \u2192 Ordinal.{u_1}\nH : IsNormal f\na : Ordinal.{u_1}\n\u22a2 f a \u2264 a \u2194 \u2203 o, derivFamily (fun x => f) o = a"
      },
      {
        "tactic": "rw [\u2190 le_iff_derivFamily fun _ : Unit => H]",
        "annotated_tactic": [
          "rw [\u2190 <a>le_iff_derivFamily</a> fun _ : <a>Unit</a> => H]",
          [
            {
              "full_name": "Ordinal.le_iff_derivFamily",
              "def_path": "Mathlib/SetTheory/Ordinal/FixedPoint.lean",
              "def_pos": [
                196,
                9
              ],
              "def_end_pos": [
                196,
                27
              ]
            },
            {
              "full_name": "Unit",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                142,
                8
              ],
              "def_end_pos": [
                142,
                12
              ]
            }
          ]
        ],
        "state_before": "f\u271d : Ordinal.{u} \u2192 Ordinal.{u}\nf : Ordinal.{u_1} \u2192 Ordinal.{u_1}\nH : IsNormal f\na : Ordinal.{u_1}\n\u22a2 f a \u2264 a \u2194 \u2203 o, derivFamily (fun x => f) o = a",
        "state_after": "f\u271d : Ordinal.{u} \u2192 Ordinal.{u}\nf : Ordinal.{u_1} \u2192 Ordinal.{u_1}\nH : IsNormal f\na : Ordinal.{u_1}\n\u22a2 f a \u2264 a \u2194 Unit \u2192 f a \u2264 a"
      },
      {
        "tactic": "exact \u27e8fun h _ => h, fun h => h Unit.unit\u27e9",
        "annotated_tactic": [
          "exact \u27e8fun h _ => h, fun h => h <a>Unit.unit</a>\u27e9",
          [
            {
              "full_name": "Unit.unit",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                148,
                25
              ],
              "def_end_pos": [
                148,
                34
              ]
            }
          ]
        ],
        "state_before": "f\u271d : Ordinal.{u} \u2192 Ordinal.{u}\nf : Ordinal.{u_1} \u2192 Ordinal.{u_1}\nH : IsNormal f\na : Ordinal.{u_1}\n\u22a2 f a \u2264 a \u2194 Unit \u2192 f a \u2264 a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.077494047000073,
    "entry_failed": false
  },
  "15543": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Prime.lean",
    "full_name": "Prime.abs",
    "start": [
      70,
      1
    ],
    "end": [
      73,
      17
    ],
    "traced_tactics": [
      {
        "tactic": "obtain h | h := abs_choice p <;> rw [h]",
        "annotated_tactic": [
          "obtain h | h := <a>abs_choice</a> p <;> rw [h]",
          [
            {
              "full_name": "abs_choice",
              "def_path": "Mathlib/Algebra/Order/Group/Abs.lean",
              "def_pos": [
                235,
                3
              ],
              "def_end_pos": [
                235,
                14
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : LinearOrder \u03b1\np : \u03b1\nhp : Prime p\n\u22a2 Prime |p|",
        "state_after": "case inl\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : LinearOrder \u03b1\np : \u03b1\nhp : Prime p\nh : |p| = p\n\u22a2 Prime p\n\ncase inr\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : LinearOrder \u03b1\np : \u03b1\nhp : Prime p\nh : |p| = -p\n\u22a2 Prime (-p)"
      },
      {
        "tactic": "exact hp",
        "annotated_tactic": [
          "exact hp",
          []
        ],
        "state_before": "case inl\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : LinearOrder \u03b1\np : \u03b1\nhp : Prime p\nh : |p| = p\n\u22a2 Prime p",
        "state_after": "no goals"
      },
      {
        "tactic": "exact hp.neg",
        "annotated_tactic": [
          "exact hp.neg",
          []
        ],
        "state_before": "case inr\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : LinearOrder \u03b1\np : \u03b1\nhp : Prime p\nh : |p| = -p\n\u22a2 Prime (-p)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.1206651219399646,
    "entry_failed": false
  },
  "15562": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Finite/Card.lean",
    "full_name": "Finite.card_sum",
    "start": [
      166,
      1
    ],
    "end": [
      169,
      57
    ],
    "traced_tactics": [
      {
        "tactic": "haveI := Fintype.ofFinite \u03b1",
        "annotated_tactic": [
          "haveI := <a>Fintype.ofFinite</a> \u03b1",
          [
            {
              "full_name": "Fintype.ofFinite",
              "def_path": "Mathlib/Data/Fintype/Card.lean",
              "def_pos": [
                449,
                19
              ],
              "def_end_pos": [
                449,
                35
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\n\u22a2 Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis : Fintype \u03b1\n\u22a2 Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2"
      },
      {
        "tactic": "haveI := Fintype.ofFinite \u03b2",
        "annotated_tactic": [
          "haveI := <a>Fintype.ofFinite</a> \u03b2",
          [
            {
              "full_name": "Fintype.ofFinite",
              "def_path": "Mathlib/Data/Fintype/Card.lean",
              "def_pos": [
                449,
                19
              ],
              "def_end_pos": [
                449,
                35
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis : Fintype \u03b1\n\u22a2 Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis\u271d : Fintype \u03b1\nthis : Fintype \u03b2\n\u22a2 Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2"
      },
      {
        "tactic": "simp only [Nat.card_eq_fintype_card, Fintype.card_sum]",
        "annotated_tactic": [
          "simp only [<a>Nat.card_eq_fintype_card</a>, <a>Fintype.card_sum</a>]",
          [
            {
              "full_name": "Nat.card_eq_fintype_card",
              "def_path": "Mathlib/SetTheory/Cardinal/Finite.lean",
              "def_pos": [
                40,
                9
              ],
              "def_end_pos": [
                40,
                29
              ]
            },
            {
              "full_name": "Fintype.card_sum",
              "def_path": "Mathlib/Data/Fintype/Sum.lean",
              "def_pos": [
                36,
                9
              ],
              "def_end_pos": [
                36,
                25
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis\u271d : Fintype \u03b1\nthis : Fintype \u03b2\n\u22a2 Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5422319769859314,
    "entry_failed": false
  },
  "15622": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Stream/Init.lean",
    "full_name": "Stream'.tail_even",
    "start": [
      467,
      1
    ],
    "end": [
      470,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "unfold even",
        "annotated_tactic": [
          "unfold <a>even</a>",
          [
            {
              "full_name": "Stream'.even",
              "def_path": "Mathlib/Data/Stream/Defs.lean",
              "def_pos": [
                120,
                5
              ],
              "def_end_pos": [
                120,
                9
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\ns : Stream' \u03b1\n\u22a2 s.even.tail = s.tail.tail.even",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\ns : Stream' \u03b1\n\u22a2 (corec (fun s => s.head) (fun s => s.tail.tail) s).tail = corec (fun s => s.head) (fun s => s.tail.tail) s.tail.tail"
      },
      {
        "tactic": "rw [corec_eq]",
        "annotated_tactic": [
          "rw [<a>corec_eq</a>]",
          [
            {
              "full_name": "Stream'.corec_eq",
              "def_path": "Mathlib/Data/Stream/Init.lean",
              "def_pos": [
                377,
                9
              ],
              "def_end_pos": [
                377,
                17
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\ns : Stream' \u03b1\n\u22a2 (corec (fun s => s.head) (fun s => s.tail.tail) s).tail = corec (fun s => s.head) (fun s => s.tail.tail) s.tail.tail",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\ns : Stream' \u03b1\n\u22a2 (s.head :: corec (fun s => s.head) (fun s => s.tail.tail) s.tail.tail).tail =\n    corec (fun s => s.head) (fun s => s.tail.tail) s.tail.tail"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\ns : Stream' \u03b1\n\u22a2 (s.head :: corec (fun s => s.head) (fun s => s.tail.tail) s.tail.tail).tail =\n    corec (fun s => s.head) (fun s => s.tail.tail) s.tail.tail",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.458247183007188,
    "entry_failed": false
  },
  "15626": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Factorization/Basic.lean",
    "full_name": "Nat.ord_proj_pos",
    "start": [
      353,
      1
    ],
    "end": [
      354,
      60
    ],
    "traced_tactics": [
      {
        "tactic": "if pp : p.Prime then simp [pow_pos pp.pos] else simp [pp]",
        "annotated_tactic": [
          "if pp : p.Prime then simp [<a>pow_pos</a> pp.pos] else simp [pp]",
          [
            {
              "full_name": "pow_pos",
              "def_path": "Mathlib/Algebra/Order/Ring/Defs.lean",
              "def_pos": [
                552,
                9
              ],
              "def_end_pos": [
                552,
                16
              ]
            }
          ]
        ],
        "state_before": "a b m n\u271d p\u271d n p : \u2115\n\u22a2 0 < p ^ n.factorization p",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [pow_pos pp.pos]",
        "annotated_tactic": [
          "simp [<a>pow_pos</a> pp.pos]",
          [
            {
              "full_name": "pow_pos",
              "def_path": "Mathlib/Algebra/Order/Ring/Defs.lean",
              "def_pos": [
                552,
                9
              ],
              "def_end_pos": [
                552,
                16
              ]
            }
          ]
        ],
        "state_before": "a b m n\u271d p\u271d n p : \u2115\npp : Prime p\n\u22a2 0 < p ^ n.factorization p",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [pp]",
        "annotated_tactic": [
          "simp [pp]",
          []
        ],
        "state_before": "a b m n\u271d p\u271d n p : \u2115\npp : \u00acPrime p\n\u22a2 0 < p ^ n.factorization p",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.089901451021433,
    "entry_failed": false
  },
  "15684": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Lattice.lean",
    "full_name": "sup_eq_maxDefault",
    "start": [
      853,
      1
    ],
    "end": [
      859,
      88
    ],
    "traced_tactics": [
      {
        "tactic": "ext x y",
        "annotated_tactic": [
          "ext x y",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : DecidableRel fun x x_1 => x \u2264 x_1\ninst\u271d : IsTotal \u03b1 fun x x_1 => x \u2264 x_1\n\u22a2 (fun x x_1 => x \u2294 x_1) = maxDefault",
        "state_after": "case h.h\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : DecidableRel fun x x_1 => x \u2264 x_1\ninst\u271d : IsTotal \u03b1 fun x x_1 => x \u2264 x_1\nx y : \u03b1\n\u22a2 x \u2294 y = maxDefault x y"
      },
      {
        "tactic": "unfold maxDefault",
        "annotated_tactic": [
          "unfold <a>maxDefault</a>",
          [
            {
              "full_name": "maxDefault",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                247,
                5
              ],
              "def_end_pos": [
                247,
                15
              ]
            }
          ]
        ],
        "state_before": "case h.h\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : DecidableRel fun x x_1 => x \u2264 x_1\ninst\u271d : IsTotal \u03b1 fun x x_1 => x \u2264 x_1\nx y : \u03b1\n\u22a2 x \u2294 y = maxDefault x y",
        "state_after": "case h.h\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : DecidableRel fun x x_1 => x \u2264 x_1\ninst\u271d : IsTotal \u03b1 fun x x_1 => x \u2264 x_1\nx y : \u03b1\n\u22a2 x \u2294 y = if x \u2264 y then y else x"
      },
      {
        "tactic": "split_ifs with h'",
        "annotated_tactic": [
          "split_ifs with h'",
          []
        ],
        "state_before": "case h.h\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : DecidableRel fun x x_1 => x \u2264 x_1\ninst\u271d : IsTotal \u03b1 fun x x_1 => x \u2264 x_1\nx y : \u03b1\n\u22a2 x \u2294 y = if x \u2264 y then y else x",
        "state_after": "case pos\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : DecidableRel fun x x_1 => x \u2264 x_1\ninst\u271d : IsTotal \u03b1 fun x x_1 => x \u2264 x_1\nx y : \u03b1\nh' : x \u2264 y\n\u22a2 x \u2294 y = y\n\ncase neg\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : SemilatticeSup \u03b1\ninst\u271d\u00b9 : DecidableRel fun x x_1 => x \u2264 x_1\ninst\u271d : IsTotal \u03b1 fun x x_1 => x \u2264 x_1\nx y : \u03b1\nh' : \u00acx \u2264 y\n\u22a2 x \u2294 y = x"
      }
    ],
    "entry_time": 4.4928090600296855,
    "entry_failed": false
  },
  "15724": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Polynomial/Reverse.lean",
    "full_name": "Polynomial.reverse_mul_X_pow",
    "start": [
      358,
      1
    ],
    "end": [
      361,
      48
    ],
    "traced_tactics": [
      {
        "tactic": "induction' n with n ih",
        "annotated_tactic": [
          "induction' n with n ih",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d : Semiring R\nf p : R[X]\nn : \u2115\n\u22a2 (p * X ^ n).reverse = p.reverse",
        "state_after": "case zero\nR : Type u_1\ninst\u271d : Semiring R\nf p : R[X]\n\u22a2 (p * X ^ 0).reverse = p.reverse\n\ncase succ\nR : Type u_1\ninst\u271d : Semiring R\nf p : R[X]\nn : \u2115\nih : (p * X ^ n).reverse = p.reverse\n\u22a2 (p * X ^ (n + 1)).reverse = p.reverse"
      },
      {
        "tactic": "rw [pow_succ, \u2190 mul_assoc, reverse_mul_X, ih]",
        "annotated_tactic": [
          "rw [<a>pow_succ</a>, \u2190 <a>mul_assoc</a>, <a>reverse_mul_X</a>, ih]",
          [
            {
              "full_name": "pow_succ",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                657,
                9
              ],
              "def_end_pos": [
                657,
                17
              ]
            },
            {
              "full_name": "mul_assoc",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                289,
                9
              ],
              "def_end_pos": [
                289,
                18
              ]
            },
            {
              "full_name": "Polynomial.reverse_mul_X",
              "def_path": "Mathlib/Algebra/Polynomial/Reverse.lean",
              "def_pos": [
                349,
                15
              ],
              "def_end_pos": [
                349,
                28
              ]
            }
          ]
        ],
        "state_before": "case succ\nR : Type u_1\ninst\u271d : Semiring R\nf p : R[X]\nn : \u2115\nih : (p * X ^ n).reverse = p.reverse\n\u22a2 (p * X ^ (n + 1)).reverse = p.reverse",
        "state_after": "no goals"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case zero\nR : Type u_1\ninst\u271d : Semiring R\nf p : R[X]\n\u22a2 (p * X ^ 0).reverse = p.reverse",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.857779590995051,
    "entry_failed": false
  },
  "15824": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Field/Basic.lean",
    "full_name": "inv_lt_one_iff",
    "start": [
      247,
      1
    ],
    "end": [
      250,
      66
    ],
    "traced_tactics": [
      {
        "tactic": "rcases le_or_lt a 0 with ha | ha",
        "annotated_tactic": [
          "rcases <a>le_or_lt</a> a 0 with ha | ha",
          [
            {
              "full_name": "le_or_lt",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                342,
                9
              ],
              "def_end_pos": [
                342,
                17
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\n\u22a2 a\u207b\u00b9 < 1 \u2194 a \u2264 0 \u2228 1 < a",
        "state_after": "case inl\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nha : a \u2264 0\n\u22a2 a\u207b\u00b9 < 1 \u2194 a \u2264 0 \u2228 1 < a\n\ncase inr\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nha : 0 < a\n\u22a2 a\u207b\u00b9 < 1 \u2194 a \u2264 0 \u2228 1 < a"
      },
      {
        "tactic": "simp [ha, (inv_nonpos.2 ha).trans_lt zero_lt_one]",
        "annotated_tactic": [
          "simp [ha, (<a>inv_nonpos</a>.2 ha).<a>trans_lt</a> <a>zero_lt_one</a>]",
          [
            {
              "full_name": "inv_nonpos",
              "def_path": "Mathlib/Algebra/Order/Field/Defs.lean",
              "def_pos": [
                64,
                15
              ],
              "def_end_pos": [
                64,
                25
              ]
            },
            {
              "full_name": "LE.le.trans_lt",
              "def_path": "Mathlib/Order/Basic.lean",
              "def_pos": [
                119,
                7
              ],
              "def_end_pos": [
                119,
                21
              ]
            },
            {
              "full_name": "zero_lt_one",
              "def_path": "Mathlib/Algebra/Order/ZeroLEOne.lean",
              "def_pos": [
                39,
                15
              ],
              "def_end_pos": [
                39,
                26
              ]
            }
          ]
        ],
        "state_before": "case inl\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nha : a \u2264 0\n\u22a2 a\u207b\u00b9 < 1 \u2194 a \u2264 0 \u2228 1 < a",
        "state_after": "no goals"
      },
      {
        "tactic": "simp only [ha.not_le, false_or_iff, inv_lt_one_iff_of_pos ha]",
        "annotated_tactic": [
          "simp only [ha.not_le, <a>false_or_iff</a>, <a>inv_lt_one_iff_of_pos</a> ha]",
          [
            {
              "full_name": "false_or_iff",
              "def_path": "Mathlib/Init/Logic.lean",
              "def_pos": [
                154,
                9
              ],
              "def_end_pos": [
                154,
                21
              ]
            },
            {
              "full_name": "inv_lt_one_iff_of_pos",
              "def_path": "Mathlib/Algebra/Order/Field/Basic.lean",
              "def_pos": [
                243,
                9
              ],
              "def_end_pos": [
                243,
                30
              ]
            }
          ]
        ],
        "state_before": "case inr\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nha : 0 < a\n\u22a2 a\u207b\u00b9 < 1 \u2194 a \u2264 0 \u2228 1 < a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.4531338569941,
    "entry_failed": false
  },
  "15843": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Setoid/Partition.lean",
    "full_name": "Setoid.classes_ker_subset_fiber_set",
    "start": [
      67,
      1
    ],
    "end": [
      71,
      19
    ],
    "traced_tactics": [
      {
        "tactic": "rintro s \u27e8x, rfl\u27e9",
        "annotated_tactic": [
          "rintro s \u27e8x, rfl\u27e9",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\n\u22a2 (ker f).classes \u2286 Set.range fun y => {x | f x = y}",
        "state_after": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\n\u22a2 {x_1 | (ker f).Rel x_1 x} \u2208 Set.range fun y => {x | f x = y}"
      },
      {
        "tactic": "rw [Set.mem_range]",
        "annotated_tactic": [
          "rw [<a>Set.mem_range</a>]",
          [
            {
              "full_name": "Set.mem_range",
              "def_path": "Mathlib/Data/Set/Defs.lean",
              "def_pos": [
                160,
                17
              ],
              "def_end_pos": [
                160,
                26
              ]
            }
          ]
        ],
        "state_before": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\n\u22a2 {x_1 | (ker f).Rel x_1 x} \u2208 Set.range fun y => {x | f x = y}",
        "state_after": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\n\u22a2 \u2203 y, {x | f x = y} = {x_1 | (ker f).Rel x_1 x}"
      },
      {
        "tactic": "exact \u27e8f x, rfl\u27e9",
        "annotated_tactic": [
          "exact \u27e8f x, <a>rfl</a>\u27e9",
          [
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\n\u22a2 \u2203 y, {x | f x = y} = {x_1 | (ker f).Rel x_1 x}",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4566159340320155,
    "entry_failed": false
  },
  "15870": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Polynomial/Hermite/Basic.lean",
    "full_name": "Polynomial.coeff_hermite",
    "start": [
      209,
      1
    ],
    "end": [
      214,
      64
    ],
    "traced_tactics": [
      {
        "tactic": "split_ifs with h",
        "annotated_tactic": [
          "split_ifs with h",
          []
        ],
        "state_before": "n k : \u2115\n\u22a2 (hermite n).coeff k = if Even (n + k) then (-1) ^ ((n - k) / 2) * \u2191(n - k - 1)\u203c * \u2191(n.choose k) else 0",
        "state_after": "case pos\nn k : \u2115\nh : Even (n + k)\n\u22a2 (hermite n).coeff k = (-1) ^ ((n - k) / 2) * \u2191(n - k - 1)\u203c * \u2191(n.choose k)\n\ncase neg\nn k : \u2115\nh : \u00acEven (n + k)\n\u22a2 (hermite n).coeff k = 0"
      },
      {
        "tactic": "exact coeff_hermite_of_even_add h",
        "annotated_tactic": [
          "exact <a>coeff_hermite_of_even_add</a> h",
          [
            {
              "full_name": "Polynomial.coeff_hermite_of_even_add",
              "def_path": "Mathlib/RingTheory/Polynomial/Hermite/Basic.lean",
              "def_pos": [
                198,
                9
              ],
              "def_end_pos": [
                198,
                34
              ]
            }
          ]
        ],
        "state_before": "case pos\nn k : \u2115\nh : Even (n + k)\n\u22a2 (hermite n).coeff k = (-1) ^ ((n - k) / 2) * \u2191(n - k - 1)\u203c * \u2191(n.choose k)",
        "state_after": "no goals"
      },
      {
        "tactic": "exact coeff_hermite_of_odd_add (Nat.odd_iff_not_even.mpr h)",
        "annotated_tactic": [
          "exact <a>coeff_hermite_of_odd_add</a> (Nat.odd_iff_not_even.mpr h)",
          [
            {
              "full_name": "Polynomial.coeff_hermite_of_odd_add",
              "def_path": "Mathlib/RingTheory/Polynomial/Hermite/Basic.lean",
              "def_pos": [
                133,
                9
              ],
              "def_end_pos": [
                133,
                33
              ]
            }
          ]
        ],
        "state_before": "case neg\nn k : \u2115\nh : \u00acEven (n + k)\n\u22a2 (hermite n).coeff k = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.1495687309652567,
    "entry_failed": false
  },
  "15908": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Finsupp/Indicator.lean",
    "full_name": "Finsupp.single_eq_indicator",
    "start": [
      73,
      1
    ],
    "end": [
      76,
      53
    ],
    "traced_tactics": [
      {
        "tactic": "classical\next j\nsimp [single_apply, indicator_apply, @eq_comm _ j]",
        "annotated_tactic": [
          "classical\n  ext j\n  simp [<a>single_apply</a>, <a>indicator_apply</a>, @<a>eq_comm</a> _ j]",
          [
            {
              "full_name": "Finsupp.single_apply",
              "def_path": "Mathlib/Data/Finsupp/Defs.lean",
              "def_pos": [
                287,
                9
              ],
              "def_end_pos": [
                287,
                21
              ]
            },
            {
              "full_name": "Finsupp.indicator_apply",
              "def_path": "Mathlib/Data/Finsupp/Indicator.lean",
              "def_pos": [
                54,
                9
              ],
              "def_end_pos": [
                54,
                24
              ]
            },
            {
              "full_name": "eq_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                811,
                9
              ],
              "def_end_pos": [
                811,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d : Zero \u03b1\ns : Finset \u03b9\nf : (i : \u03b9) \u2192 i \u2208 s \u2192 \u03b1\ni : \u03b9\nb : \u03b1\n\u22a2 single i b = indicator {i} fun x x => b",
        "state_after": "no goals"
      },
      {
        "tactic": "ext j",
        "annotated_tactic": [
          "ext j",
          []
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d : Zero \u03b1\ns : Finset \u03b9\nf : (i : \u03b9) \u2192 i \u2208 s \u2192 \u03b1\ni : \u03b9\nb : \u03b1\n\u22a2 single i b = indicator {i} fun x x => b",
        "state_after": "case h\n\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d : Zero \u03b1\ns : Finset \u03b9\nf : (i : \u03b9) \u2192 i \u2208 s \u2192 \u03b1\ni : \u03b9\nb : \u03b1\nj : \u03b9\n\u22a2 (single i b) j = (indicator {i} fun x x => b) j"
      },
      {
        "tactic": "simp [single_apply, indicator_apply, @eq_comm _ j]",
        "annotated_tactic": [
          "simp [<a>single_apply</a>, <a>indicator_apply</a>, @<a>eq_comm</a> _ j]",
          [
            {
              "full_name": "Finsupp.single_apply",
              "def_path": "Mathlib/Data/Finsupp/Defs.lean",
              "def_pos": [
                287,
                9
              ],
              "def_end_pos": [
                287,
                21
              ]
            },
            {
              "full_name": "Finsupp.indicator_apply",
              "def_path": "Mathlib/Data/Finsupp/Indicator.lean",
              "def_pos": [
                54,
                9
              ],
              "def_end_pos": [
                54,
                24
              ]
            },
            {
              "full_name": "eq_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                811,
                9
              ],
              "def_end_pos": [
                811,
                16
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d : Zero \u03b1\ns : Finset \u03b9\nf : (i : \u03b9) \u2192 i \u2208 s \u2192 \u03b1\ni : \u03b9\nb : \u03b1\nj : \u03b9\n\u22a2 (single i b) j = (indicator {i} fun x x => b) j",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5208304170519114,
    "entry_failed": false
  },
  "15909": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/ZMod/Basic.lean",
    "full_name": "ZMod.natCast_zmod_val",
    "start": [
      209,
      1
    ],
    "end": [
      212,
      31
    ],
    "traced_tactics": [
      {
        "tactic": "cases n",
        "annotated_tactic": [
          "cases n",
          []
        ],
        "state_before": "n\u271d : \u2115\nR : Type u_1\nn : \u2115\ninst\u271d : NeZero n\na : ZMod n\n\u22a2 \u2191a.val = a",
        "state_after": "case zero\nn : \u2115\nR : Type u_1\ninst\u271d : NeZero 0\na : ZMod 0\n\u22a2 \u2191a.val = a\n\ncase succ\nn : \u2115\nR : Type u_1\nn\u271d : \u2115\ninst\u271d : NeZero (n\u271d + 1)\na : ZMod (n\u271d + 1)\n\u22a2 \u2191a.val = a"
      },
      {
        "tactic": "cases NeZero.ne 0 rfl",
        "annotated_tactic": [
          "cases <a>NeZero.ne</a> 0 <a>rfl</a>",
          [
            {
              "full_name": "NeZero.ne",
              "def_path": "Mathlib/Algebra/NeZero.lean",
              "def_pos": [
                30,
                9
              ],
              "def_end_pos": [
                30,
                18
              ]
            },
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "case zero\nn : \u2115\nR : Type u_1\ninst\u271d : NeZero 0\na : ZMod 0\n\u22a2 \u2191a.val = a",
        "state_after": "no goals"
      },
      {
        "tactic": "apply Fin.cast_val_eq_self",
        "annotated_tactic": [
          "apply <a>Fin.cast_val_eq_self</a>",
          [
            {
              "full_name": "Fin.cast_val_eq_self",
              "def_path": "Mathlib/Data/Fin/Basic.lean",
              "def_pos": [
                573,
                17
              ],
              "def_end_pos": [
                573,
                33
              ]
            }
          ]
        ],
        "state_before": "case succ\nn : \u2115\nR : Type u_1\nn\u271d : \u2115\ninst\u271d : NeZero (n\u271d + 1)\na : ZMod (n\u271d + 1)\n\u22a2 \u2191a.val = a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.6992032889975235,
    "entry_failed": false
  },
  "16002": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Regular/Pow.lean",
    "full_name": "IsRightRegular.pow_iff",
    "start": [
      54,
      1
    ],
    "end": [
      58,
      30
    ],
    "traced_tactics": [
      {
        "tactic": "refine \u27e8?_, IsRightRegular.pow n\u27e9",
        "annotated_tactic": [
          "refine \u27e8?_, <a>IsRightRegular.pow</a> n\u27e9",
          [
            {
              "full_name": "IsRightRegular.pow",
              "def_path": "Mathlib/Algebra/Regular/Pow.lean",
              "def_pos": [
                36,
                9
              ],
              "def_end_pos": [
                36,
                27
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\na b : R\ninst\u271d : Monoid R\nn : \u2115\nn0 : 0 < n\n\u22a2 IsRightRegular (a ^ n) \u2194 IsRightRegular a",
        "state_after": "R : Type u_1\na b : R\ninst\u271d : Monoid R\nn : \u2115\nn0 : 0 < n\n\u22a2 IsRightRegular (a ^ n) \u2192 IsRightRegular a"
      },
      {
        "tactic": "rw [\u2190 Nat.succ_pred_eq_of_pos n0, pow_succ']",
        "annotated_tactic": [
          "rw [\u2190 <a>Nat.succ_pred_eq_of_pos</a> n0, <a>pow_succ'</a>]",
          [
            {
              "full_name": "Nat.succ_pred_eq_of_pos",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean",
              "def_pos": [
                830,
                9
              ],
              "def_end_pos": [
                830,
                28
              ]
            },
            {
              "full_name": "pow_succ'",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                667,
                34
              ],
              "def_end_pos": [
                667,
                43
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\na b : R\ninst\u271d : Monoid R\nn : \u2115\nn0 : 0 < n\n\u22a2 IsRightRegular (a ^ n) \u2192 IsRightRegular a",
        "state_after": "R : Type u_1\na b : R\ninst\u271d : Monoid R\nn : \u2115\nn0 : 0 < n\n\u22a2 IsRightRegular (a * a ^ n.pred) \u2192 IsRightRegular a"
      },
      {
        "tactic": "exact IsRightRegular.of_mul",
        "annotated_tactic": [
          "exact <a>IsRightRegular.of_mul</a>",
          [
            {
              "full_name": "IsRightRegular.of_mul",
              "def_path": "Mathlib/Algebra/Regular/Basic.lean",
              "def_pos": [
                159,
                9
              ],
              "def_end_pos": [
                159,
                30
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\na b : R\ninst\u271d : Monoid R\nn : \u2115\nn0 : 0 < n\n\u22a2 IsRightRegular (a * a ^ n.pred) \u2192 IsRightRegular a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2080556699074805,
    "entry_failed": false
  },
  "16010": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Rotate.lean",
    "full_name": "List.rotate_eq_drop_append_take_mod",
    "start": [
      147,
      1
    ],
    "end": [
      151,
      65
    ],
    "traced_tactics": [
      {
        "tactic": "rcases l.length.zero_le.eq_or_lt with hl | hl",
        "annotated_tactic": [
          "rcases l.length.zero_le.eq_or_lt with hl | hl",
          []
        ],
        "state_before": "\u03b1 : Type u\nl : List \u03b1\nn : \u2115\n\u22a2 l.rotate n = drop (n % l.length) l ++ take (n % l.length) l",
        "state_after": "case inl\n\u03b1 : Type u\nl : List \u03b1\nn : \u2115\nhl : 0 = l.length\n\u22a2 l.rotate n = drop (n % l.length) l ++ take (n % l.length) l\n\ncase inr\n\u03b1 : Type u\nl : List \u03b1\nn : \u2115\nhl : 0 < l.length\n\u22a2 l.rotate n = drop (n % l.length) l ++ take (n % l.length) l"
      },
      {
        "tactic": "rw [\u2190 rotate_eq_drop_append_take (n.mod_lt hl).le, rotate_mod]",
        "annotated_tactic": [
          "rw [\u2190 <a>rotate_eq_drop_append_take</a> (n.mod_lt hl).<a>le</a>, <a>rotate_mod</a>]",
          [
            {
              "full_name": "List.rotate_eq_drop_append_take",
              "def_path": "Mathlib/Data/List/Rotate.lean",
              "def_pos": [
                142,
                9
              ],
              "def_end_pos": [
                142,
                35
              ]
            },
            {
              "full_name": "LT.lt.le",
              "def_path": "Mathlib/Order/Basic.lean",
              "def_pos": [
                137,
                7
              ],
              "def_end_pos": [
                137,
                15
              ]
            },
            {
              "full_name": "List.rotate_mod",
              "def_path": "Mathlib/Data/List/Rotate.lean",
              "def_pos": [
                37,
                9
              ],
              "def_end_pos": [
                37,
                19
              ]
            }
          ]
        ],
        "state_before": "case inr\n\u03b1 : Type u\nl : List \u03b1\nn : \u2115\nhl : 0 < l.length\n\u22a2 l.rotate n = drop (n % l.length) l ++ take (n % l.length) l",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [eq_nil_of_length_eq_zero hl.symm]",
        "annotated_tactic": [
          "simp [<a>eq_nil_of_length_eq_zero</a> hl.symm]",
          [
            {
              "full_name": "List.eq_nil_of_length_eq_zero",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean",
              "def_pos": [
                93,
                9
              ],
              "def_end_pos": [
                93,
                33
              ]
            }
          ]
        ],
        "state_before": "case inl\n\u03b1 : Type u\nl : List \u03b1\nn : \u2115\nhl : 0 = l.length\n\u22a2 l.rotate n = drop (n % l.length) l ++ take (n % l.length) l",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9557302430039272,
    "entry_failed": false
  },
  "16048": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/PEquiv.lean",
    "full_name": "PEquiv.trans_bot",
    "start": [
      313,
      1
    ],
    "end": [
      314,
      34
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type x\nf : \u03b1 \u2243. \u03b2\n\u22a2 f.trans \u22a5 = \u22a5",
        "state_after": "case h.a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type x\nf : \u03b1 \u2243. \u03b2\nx\u271d : \u03b1\na\u271d : \u03b3\n\u22a2 a\u271d \u2208 (f.trans \u22a5) x\u271d \u2194 a\u271d \u2208 \u22a5 x\u271d"
      },
      {
        "tactic": "dsimp [PEquiv.trans]",
        "annotated_tactic": [
          "dsimp [<a>PEquiv.trans</a>]",
          [
            {
              "full_name": "PEquiv.trans",
              "def_path": "Mathlib/Data/PEquiv.lean",
              "def_pos": [
                118,
                15
              ],
              "def_end_pos": [
                118,
                20
              ]
            }
          ]
        ],
        "state_before": "case h.a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type x\nf : \u03b1 \u2243. \u03b2\nx\u271d : \u03b1\na\u271d : \u03b3\n\u22a2 a\u271d \u2208 (f.trans \u22a5) x\u271d \u2194 a\u271d \u2208 \u22a5 x\u271d",
        "state_after": "case h.a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type x\nf : \u03b1 \u2243. \u03b2\nx\u271d : \u03b1\na\u271d : \u03b3\n\u22a2 a\u271d \u2208 (f x\u271d).bind \u21d1\u22a5 \u2194 a\u271d \u2208 none"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case h.a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type x\nf : \u03b1 \u2243. \u03b2\nx\u271d : \u03b1\na\u271d : \u03b3\n\u22a2 a\u271d \u2208 (f x\u271d).bind \u21d1\u22a5 \u2194 a\u271d \u2208 none",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9190446219872683,
    "entry_failed": false
  },
  "16065": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Polynomial/Monic.lean",
    "full_name": "Polynomial.Monic.sub_of_left",
    "start": [
      415,
      1
    ],
    "end": [
      419,
      19
    ],
    "traced_tactics": [
      {
        "tactic": "rw [sub_eq_add_neg]",
        "annotated_tactic": [
          "rw [<a>sub_eq_add_neg</a>]",
          [
            {
              "full_name": "sub_eq_add_neg",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                1057,
                3
              ],
              "def_end_pos": [
                1057,
                14
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Ring R\np\u271d p q : R[X]\nhp : p.Monic\nhpq : q.degree < p.degree\n\u22a2 (p - q).Monic",
        "state_after": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Ring R\np\u271d p q : R[X]\nhp : p.Monic\nhpq : q.degree < p.degree\n\u22a2 (p + -q).Monic"
      },
      {
        "tactic": "apply hp.add_of_left",
        "annotated_tactic": [
          "apply hp.add_of_left",
          []
        ],
        "state_before": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Ring R\np\u271d p q : R[X]\nhp : p.Monic\nhpq : q.degree < p.degree\n\u22a2 (p + -q).Monic",
        "state_after": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Ring R\np\u271d p q : R[X]\nhp : p.Monic\nhpq : q.degree < p.degree\n\u22a2 (-q).degree < p.degree"
      },
      {
        "tactic": "rwa [degree_neg]",
        "annotated_tactic": [
          "rwa [<a>degree_neg</a>]",
          [
            {
              "full_name": "Polynomial.degree_neg",
              "def_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
              "def_pos": [
                542,
                9
              ],
              "def_end_pos": [
                542,
                19
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Ring R\np\u271d p q : R[X]\nhp : p.Monic\nhpq : q.degree < p.degree\n\u22a2 (-q).degree < p.degree",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.559900564025156,
    "entry_failed": false
  },
  "16106": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/SetFamily/Shatter.lean",
    "full_name": "Finset.mem_shatterer",
    "start": [
      77,
      1
    ],
    "end": [
      80,
      26
    ],
    "traced_tactics": [
      {
        "tactic": "refine mem_filter.trans <| and_iff_right_of_imp fun h \u21a6 ?_",
        "annotated_tactic": [
          "refine mem_filter.trans <| <a>and_iff_right_of_imp</a> fun h \u21a6 ?_",
          [
            {
              "full_name": "and_iff_right_of_imp",
              "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean",
              "def_pos": [
                162,
                9
              ],
              "def_end_pos": [
                162,
                29
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c \u212c : Finset (Finset \u03b1)\ns t : Finset \u03b1\na : \u03b1\nn : \u2115\n\u22a2 s \u2208 \ud835\udc9c.shatterer \u2194 \ud835\udc9c.Shatters s",
        "state_after": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c \u212c : Finset (Finset \u03b1)\ns t : Finset \u03b1\na : \u03b1\nn : \u2115\nh : \ud835\udc9c.Shatters s\n\u22a2 s \u2208 \ud835\udc9c.biUnion powerset"
      },
      {
        "tactic": "simp_rw [mem_biUnion, mem_powerset]",
        "annotated_tactic": [
          "simp_rw [<a>mem_biUnion</a>, <a>mem_powerset</a>]",
          [
            {
              "full_name": "Finset.mem_biUnion",
              "def_path": "Mathlib/Data/Finset/Union.lean",
              "def_pos": [
                129,
                15
              ],
              "def_end_pos": [
                129,
                26
              ]
            },
            {
              "full_name": "Finset.mem_powerset",
              "def_path": "Mathlib/Data/Finset/Powerset.lean",
              "def_pos": [
                34,
                9
              ],
              "def_end_pos": [
                34,
                21
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c \u212c : Finset (Finset \u03b1)\ns t : Finset \u03b1\na : \u03b1\nn : \u2115\nh : \ud835\udc9c.Shatters s\n\u22a2 s \u2208 \ud835\udc9c.biUnion powerset",
        "state_after": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c \u212c : Finset (Finset \u03b1)\ns t : Finset \u03b1\na : \u03b1\nn : \u2115\nh : \ud835\udc9c.Shatters s\n\u22a2 \u2203 a \u2208 \ud835\udc9c, s \u2286 a"
      },
      {
        "tactic": "exact h.exists_superset",
        "annotated_tactic": [
          "exact h.exists_superset",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c \u212c : Finset (Finset \u03b1)\ns t : Finset \u03b1\na : \u03b1\nn : \u2115\nh : \ud835\udc9c.Shatters s\n\u22a2 \u2203 a \u2208 \ud835\udc9c, s \u2286 a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4205165560124442,
    "entry_failed": false
  },
  "16115": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Quandle.lean",
    "full_name": "Quandle.dihedralAct.inv",
    "start": [
      481,
      1
    ],
    "end": [
      484,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "intro b",
        "annotated_tactic": [
          "intro b",
          []
        ],
        "state_before": "Q : Type u_1\ninst\u271d : Quandle Q\nn : \u2115\na : ZMod n\n\u22a2 Function.Involutive (dihedralAct n a)",
        "state_after": "Q : Type u_1\ninst\u271d : Quandle Q\nn : \u2115\na b : ZMod n\n\u22a2 dihedralAct n a (dihedralAct n a b) = b"
      },
      {
        "tactic": "dsimp only [dihedralAct]",
        "annotated_tactic": [
          "dsimp only [<a>dihedralAct</a>]",
          [
            {
              "full_name": "Quandle.dihedralAct",
              "def_path": "Mathlib/Algebra/Quandle.lean",
              "def_pos": [
                478,
                5
              ],
              "def_end_pos": [
                478,
                16
              ]
            }
          ]
        ],
        "state_before": "Q : Type u_1\ninst\u271d : Quandle Q\nn : \u2115\na b : ZMod n\n\u22a2 dihedralAct n a (dihedralAct n a b) = b",
        "state_after": "Q : Type u_1\ninst\u271d : Quandle Q\nn : \u2115\na b : ZMod n\n\u22a2 2 * a - (2 * a - b) = b"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "Q : Type u_1\ninst\u271d : Quandle Q\nn : \u2115\na b : ZMod n\n\u22a2 2 * a - (2 * a - b) = b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.209836288006045,
    "entry_failed": false
  },
  "16141": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Real/ConjExponents.lean",
    "full_name": "Real.IsConjExponent.conj_eq",
    "start": [
      85,
      1
    ],
    "end": [
      88,
      31
    ],
    "traced_tactics": [
      {
        "tactic": "have := h.inv_add_inv_conj",
        "annotated_tactic": [
          "have := h.inv_add_inv_conj",
          []
        ],
        "state_before": "a b p q : \u211d\nh : p.IsConjExponent q\n\u22a2 q = p / (p - 1)",
        "state_after": "a b p q : \u211d\nh : p.IsConjExponent q\nthis : p\u207b\u00b9 + q\u207b\u00b9 = 1\n\u22a2 q = p / (p - 1)"
      },
      {
        "tactic": "rw [\u2190 eq_sub_iff_add_eq', inv_eq_iff_eq_inv] at this",
        "annotated_tactic": [
          "rw [\u2190 <a>eq_sub_iff_add_eq'</a>, <a>inv_eq_iff_eq_inv</a>] at this",
          [
            {
              "full_name": "eq_sub_iff_add_eq'",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                1315,
                15
              ],
              "def_end_pos": [
                1315,
                33
              ]
            },
            {
              "full_name": "inv_eq_iff_eq_inv",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                413,
                9
              ],
              "def_end_pos": [
                413,
                26
              ]
            }
          ]
        ],
        "state_before": "a b p q : \u211d\nh : p.IsConjExponent q\nthis : p\u207b\u00b9 + q\u207b\u00b9 = 1\n\u22a2 q = p / (p - 1)",
        "state_after": "a b p q : \u211d\nh : p.IsConjExponent q\nthis : q = (1 - p\u207b\u00b9)\u207b\u00b9\n\u22a2 q = p / (p - 1)"
      },
      {
        "tactic": "field_simp [this, h.ne_zero]",
        "annotated_tactic": [
          "field_simp [this, h.ne_zero]",
          []
        ],
        "state_before": "a b p q : \u211d\nh : p.IsConjExponent q\nthis : q = (1 - p\u207b\u00b9)\u207b\u00b9\n\u22a2 q = p / (p - 1)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.502636404009536,
    "entry_failed": false
  },
  "16224": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/Measure/GiryMonad.lean",
    "full_name": "MeasureTheory.Measure.measurable_dirac",
    "start": [
      85,
      1
    ],
    "end": [
      88,
      36
    ],
    "traced_tactics": [
      {
        "tactic": "refine measurable_of_measurable_coe _ fun s hs => ?_",
        "annotated_tactic": [
          "refine <a>measurable_of_measurable_coe</a> _ fun s hs => ?_",
          [
            {
              "full_name": "MeasureTheory.Measure.measurable_of_measurable_coe",
              "def_path": "Mathlib/MeasureTheory/Measure/GiryMonad.lean",
              "def_pos": [
                58,
                9
              ],
              "def_end_pos": [
                58,
                37
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\n\u22a2 Measurable dirac",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\ns : Set \u03b1\nhs : MeasurableSet s\n\u22a2 Measurable fun b => (dirac b) s"
      },
      {
        "tactic": "simp_rw [dirac_apply' _ hs]",
        "annotated_tactic": [
          "simp_rw [<a>dirac_apply'</a> _ hs]",
          [
            {
              "full_name": "MeasureTheory.Measure.dirac_apply'",
              "def_path": "Mathlib/MeasureTheory/Measure/Dirac.lean",
              "def_pos": [
                40,
                9
              ],
              "def_end_pos": [
                40,
                21
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\ns : Set \u03b1\nhs : MeasurableSet s\n\u22a2 Measurable fun b => (dirac b) s",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\ns : Set \u03b1\nhs : MeasurableSet s\n\u22a2 Measurable fun b => s.indicator 1 b"
      },
      {
        "tactic": "exact measurable_one.indicator hs",
        "annotated_tactic": [
          "exact measurable_one.indicator hs",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\ns : Set \u03b1\nhs : MeasurableSet s\n\u22a2 Measurable fun b => s.indicator 1 b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.785868417005986,
    "entry_failed": false
  },
  "16242": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Choose/Basic.lean",
    "full_name": "Nat.choose_eq_asc_factorial_div_factorial",
    "start": [
      257,
      1
    ],
    "end": [
      261,
      69
    ],
    "traced_tactics": [
      {
        "tactic": "apply Nat.mul_left_cancel k.factorial_pos",
        "annotated_tactic": [
          "apply <a>Nat.mul_left_cancel</a> k.factorial_pos",
          [
            {
              "full_name": "Nat.mul_left_cancel",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean",
              "def_pos": [
                442,
                19
              ],
              "def_end_pos": [
                442,
                34
              ]
            }
          ]
        ],
        "state_before": "n k : \u2115\n\u22a2 (n + k).choose k = (n + 1).ascFactorial k / k !",
        "state_after": "n k : \u2115\n\u22a2 k ! * (n + k).choose k = k ! * ((n + 1).ascFactorial k / k !)"
      },
      {
        "tactic": "rw [\u2190 ascFactorial_eq_factorial_mul_choose]",
        "annotated_tactic": [
          "rw [\u2190 <a>ascFactorial_eq_factorial_mul_choose</a>]",
          [
            {
              "full_name": "Nat.ascFactorial_eq_factorial_mul_choose",
              "def_path": "Mathlib/Data/Nat/Choose/Basic.lean",
              "def_pos": [
                235,
                9
              ],
              "def_end_pos": [
                235,
                45
              ]
            }
          ]
        ],
        "state_before": "n k : \u2115\n\u22a2 k ! * (n + k).choose k = k ! * ((n + 1).ascFactorial k / k !)",
        "state_after": "n k : \u2115\n\u22a2 (n + 1).ascFactorial k = k ! * ((n + 1).ascFactorial k / k !)"
      },
      {
        "tactic": "exact (Nat.mul_div_cancel' <| factorial_dvd_ascFactorial _ _).symm",
        "annotated_tactic": [
          "exact (<a>Nat.mul_div_cancel'</a> <| <a>factorial_dvd_ascFactorial</a> _ _).<a>symm</a>",
          [
            {
              "full_name": "Nat.mul_div_cancel'",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Dvd.lean",
              "def_pos": [
                87,
                19
              ],
              "def_end_pos": [
                87,
                34
              ]
            },
            {
              "full_name": "Nat.factorial_dvd_ascFactorial",
              "def_path": "Mathlib/Data/Nat/Choose/Basic.lean",
              "def_pos": [
                253,
                9
              ],
              "def_end_pos": [
                253,
                35
              ]
            },
            {
              "full_name": "Eq.symm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                323,
                9
              ],
              "def_end_pos": [
                323,
                16
              ]
            }
          ]
        ],
        "state_before": "n k : \u2115\n\u22a2 (n + 1).ascFactorial k = k ! * ((n + 1).ascFactorial k / k !)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.069150844006799,
    "entry_failed": false
  },
  "16287": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Solvable.lean",
    "full_name": "derivedSeries_normal",
    "start": [
      56,
      1
    ],
    "end": [
      59,
      88
    ],
    "traced_tactics": [
      {
        "tactic": "induction' n with n ih",
        "annotated_tactic": [
          "induction' n with n ih",
          []
        ],
        "state_before": "G : Type u_1\nG' : Type u_2\ninst\u271d\u00b9 : Group G\ninst\u271d : Group G'\nf : G \u2192* G'\nn : \u2115\n\u22a2 (derivedSeries G n).Normal",
        "state_after": "case zero\nG : Type u_1\nG' : Type u_2\ninst\u271d\u00b9 : Group G\ninst\u271d : Group G'\nf : G \u2192* G'\n\u22a2 (derivedSeries G 0).Normal\n\ncase succ\nG : Type u_1\nG' : Type u_2\ninst\u271d\u00b9 : Group G\ninst\u271d : Group G'\nf : G \u2192* G'\nn : \u2115\nih : (derivedSeries G n).Normal\n\u22a2 (derivedSeries G (n + 1)).Normal"
      },
      {
        "tactic": "exact (\u22a4 : Subgroup G).normal_of_characteristic",
        "annotated_tactic": [
          "exact (\u22a4 : <a>Subgroup</a> G).<a>normal_of_characteristic</a>",
          [
            {
              "full_name": "Subgroup",
              "def_path": "Mathlib/Algebra/Group/Subgroup/Basic.lean",
              "def_pos": [
                354,
                11
              ],
              "def_end_pos": [
                354,
                19
              ]
            },
            {
              "full_name": "Subgroup.normal_of_characteristic",
              "def_path": "Mathlib/Algebra/Group/Subgroup/Basic.lean",
              "def_pos": [
                1979,
                28
              ],
              "def_end_pos": [
                1979,
                52
              ]
            }
          ]
        ],
        "state_before": "case zero\nG : Type u_1\nG' : Type u_2\ninst\u271d\u00b9 : Group G\ninst\u271d : Group G'\nf : G \u2192* G'\n\u22a2 (derivedSeries G 0).Normal",
        "state_after": "no goals"
      },
      {
        "tactic": "exact @Subgroup.commutator_normal G _ (derivedSeries G n) (derivedSeries G n) ih ih",
        "annotated_tactic": [
          "exact @<a>Subgroup.commutator_normal</a> G _ (<a>derivedSeries</a> G n) (<a>derivedSeries</a> G n) ih ih",
          [
            {
              "full_name": "Subgroup.commutator_normal",
              "def_path": "Mathlib/GroupTheory/Commutator.lean",
              "def_pos": [
                132,
                10
              ],
              "def_end_pos": [
                132,
                27
              ]
            },
            {
              "full_name": "derivedSeries",
              "def_path": "Mathlib/GroupTheory/Solvable.lean",
              "def_pos": [
                39,
                5
              ],
              "def_end_pos": [
                39,
                18
              ]
            },
            {
              "full_name": "derivedSeries",
              "def_path": "Mathlib/GroupTheory/Solvable.lean",
              "def_pos": [
                39,
                5
              ],
              "def_end_pos": [
                39,
                18
              ]
            }
          ]
        ],
        "state_before": "case succ\nG : Type u_1\nG' : Type u_2\ninst\u271d\u00b9 : Group G\ninst\u271d : Group G'\nf : G \u2192* G'\nn : \u2115\nih : (derivedSeries G n).Normal\n\u22a2 (derivedSeries G (n + 1)).Normal",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.529862887924537,
    "entry_failed": false
  },
  "16303": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Permutation.lean",
    "full_name": "List.map_permutationsAux2",
    "start": [
      104,
      1
    ],
    "end": [
      108,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "rw [map_permutationsAux2' id, map_id, map_id]",
        "annotated_tactic": [
          "rw [<a>map_permutationsAux2'</a> <a>id</a>, <a>map_id</a>, <a>map_id</a>]",
          [
            {
              "full_name": "List.map_permutationsAux2'",
              "def_path": "Mathlib/Data/List/Permutation.lean",
              "def_pos": [
                90,
                9
              ],
              "def_end_pos": [
                90,
                30
              ]
            },
            {
              "full_name": "id",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                33,
                15
              ],
              "def_end_pos": [
                33,
                17
              ]
            },
            {
              "full_name": "List.map_id",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean",
              "def_pos": [
                716,
                17
              ],
              "def_end_pos": [
                716,
                23
              ]
            },
            {
              "full_name": "List.map_id",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean",
              "def_pos": [
                716,
                17
              ],
              "def_end_pos": [
                716,
                23
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u03b1\nts ys : List \u03b1\nf : List \u03b1 \u2192 \u03b2\n\u22a2 map f (permutationsAux2 t ts [] ys id).2 = (permutationsAux2 t ts [] ys f).2",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u03b1\nts ys : List \u03b1\nf : List \u03b1 \u2192 \u03b2\n\u22a2 (permutationsAux2 (id t) ts (map f []) ys ?f').2 = (permutationsAux2 t ts [] ys f).2\n\ncase f'\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u03b1\nts ys : List \u03b1\nf : List \u03b1 \u2192 \u03b2\n\u22a2 List \u03b1 \u2192 \u03b2\n\ncase H\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u03b1\nts ys : List \u03b1\nf : List \u03b1 \u2192 \u03b2\n\u22a2 \u2200 (a : List \u03b1), f (id a) = ?f' (map id a)"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case H\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u03b1\nts ys : List \u03b1\nf : List \u03b1 \u2192 \u03b2\n\u22a2 \u2200 (a : List \u03b1), f (id a) = f (map id a)",
        "state_after": "no goals"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : \u03b1\nts ys : List \u03b1\nf : List \u03b1 \u2192 \u03b2\n\u22a2 (permutationsAux2 (id t) ts (map f []) ys ?f').2 = (permutationsAux2 t ts [] ys f).2",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2985668960027397,
    "entry_failed": false
  },
  "16306": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Base.lean",
    "full_name": "Real.logb_nonpos_iff'",
    "start": [
      262,
      1
    ],
    "end": [
      265,
      30
    ],
    "traced_tactics": [
      {
        "tactic": "rcases hx.eq_or_lt with (rfl | hx)",
        "annotated_tactic": [
          "rcases hx.eq_or_lt with (rfl | hx)",
          []
        ],
        "state_before": "b x y : \u211d\nhb : 1 < b\nhx : 0 \u2264 x\n\u22a2 logb b x \u2264 0 \u2194 x \u2264 1",
        "state_after": "case inl\nb y : \u211d\nhb : 1 < b\nhx : 0 \u2264 0\n\u22a2 logb b 0 \u2264 0 \u2194 0 \u2264 1\n\ncase inr\nb x y : \u211d\nhb : 1 < b\nhx\u271d : 0 \u2264 x\nhx : 0 < x\n\u22a2 logb b x \u2264 0 \u2194 x \u2264 1"
      },
      {
        "tactic": "exact logb_nonpos_iff hb hx",
        "annotated_tactic": [
          "exact <a>logb_nonpos_iff</a> hb hx",
          [
            {
              "full_name": "Real.logb_nonpos_iff",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Log/Base.lean",
              "def_pos": [
                258,
                9
              ],
              "def_end_pos": [
                258,
                24
              ]
            }
          ]
        ],
        "state_before": "case inr\nb x y : \u211d\nhb : 1 < b\nhx\u271d : 0 \u2264 x\nhx : 0 < x\n\u22a2 logb b x \u2264 0 \u2194 x \u2264 1",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [le_refl, zero_le_one]",
        "annotated_tactic": [
          "simp [<a>le_refl</a>, <a>zero_le_one</a>]",
          [
            {
              "full_name": "le_refl",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                45,
                9
              ],
              "def_end_pos": [
                45,
                16
              ]
            },
            {
              "full_name": "zero_le_one",
              "def_path": "Mathlib/Algebra/Order/ZeroLEOne.lean",
              "def_pos": [
                26,
                15
              ],
              "def_end_pos": [
                26,
                26
              ]
            }
          ]
        ],
        "state_before": "case inl\nb y : \u211d\nhb : 1 < b\nhx : 0 \u2264 0\n\u22a2 logb b 0 \u2264 0 \u2194 0 \u2264 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.160410118987784,
    "entry_failed": false
  },
  "16340": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Periodic.lean",
    "full_name": "Function.Periodic.zsmul",
    "start": [
      229,
      11
    ],
    "end": [
      232,
      59
    ],
    "traced_tactics": [
      {
        "tactic": "cases' n with n n",
        "annotated_tactic": [
          "cases' n with n n",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf g : \u03b1 \u2192 \u03b2\nc c\u2081 c\u2082 x : \u03b1\ninst\u271d : AddGroup \u03b1\nh : Periodic f c\nn : \u2124\n\u22a2 Periodic f (n \u2022 c)",
        "state_after": "case ofNat\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf g : \u03b1 \u2192 \u03b2\nc c\u2081 c\u2082 x : \u03b1\ninst\u271d : AddGroup \u03b1\nh : Periodic f c\nn : \u2115\n\u22a2 Periodic f (Int.ofNat n \u2022 c)\n\ncase negSucc\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf g : \u03b1 \u2192 \u03b2\nc c\u2081 c\u2082 x : \u03b1\ninst\u271d : AddGroup \u03b1\nh : Periodic f c\nn : \u2115\n\u22a2 Periodic f (Int.negSucc n \u2022 c)"
      },
      {
        "tactic": "simpa only [Int.ofNat_eq_coe, natCast_zsmul] using h.nsmul n",
        "annotated_tactic": [
          "simpa only [<a>Int.ofNat_eq_coe</a>, <a>natCast_zsmul</a>] using h.nsmul n",
          [
            {
              "full_name": "Int.ofNat_eq_coe",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Basic.lean",
              "def_pos": [
                71,
                17
              ],
              "def_end_pos": [
                71,
                29
              ]
            },
            {
              "full_name": "natCast_zsmul",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                1020,
                41
              ],
              "def_end_pos": [
                1020,
                54
              ]
            }
          ]
        ],
        "state_before": "case ofNat\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf g : \u03b1 \u2192 \u03b2\nc c\u2081 c\u2082 x : \u03b1\ninst\u271d : AddGroup \u03b1\nh : Periodic f c\nn : \u2115\n\u22a2 Periodic f (Int.ofNat n \u2022 c)",
        "state_after": "no goals"
      },
      {
        "tactic": "simpa only [negSucc_zsmul] using (h.nsmul (n + 1)).neg",
        "annotated_tactic": [
          "simpa only [<a>negSucc_zsmul</a>] using (h.nsmul (n + 1)).<a>neg</a>",
          [
            {
              "full_name": "negSucc_zsmul",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                1045,
                9
              ],
              "def_end_pos": [
                1045,
                22
              ]
            },
            {
              "full_name": "Function.Periodic.neg",
              "def_path": "Mathlib/Algebra/Periodic.lean",
              "def_pos": [
                168,
                19
              ],
              "def_end_pos": [
                168,
                31
              ]
            }
          ]
        ],
        "state_before": "case negSucc\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf g : \u03b1 \u2192 \u03b2\nc c\u2081 c\u2082 x : \u03b1\ninst\u271d : AddGroup \u03b1\nh : Periodic f c\nn : \u2115\n\u22a2 Periodic f (Int.negSucc n \u2022 c)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.502084136009216,
    "entry_failed": false
  },
  "16349": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Coloring.lean",
    "full_name": "SimpleGraph.colorable_chromaticNumber",
    "start": [
      306,
      1
    ],
    "end": [
      311,
      49
    ],
    "traced_tactics": [
      {
        "tactic": "rw [hc.chromaticNumber_eq_sInf, Nat.sInf_def]",
        "annotated_tactic": [
          "rw [hc.chromaticNumber_eq_sInf, <a>Nat.sInf_def</a>]",
          [
            {
              "full_name": "Nat.sInf_def",
              "def_path": "Mathlib/Data/Nat/Lattice.lean",
              "def_pos": [
                34,
                9
              ],
              "def_end_pos": [
                34,
                17
              ]
            }
          ]
        ],
        "state_before": "V : Type u\nG : SimpleGraph V\nn : \u2115\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nC : G.Coloring \u03b1\nm : \u2115\nhc : G.Colorable m\n\u22a2 G.Colorable G.chromaticNumber.toNat",
        "state_after": "V : Type u\nG : SimpleGraph V\nn : \u2115\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nC : G.Coloring \u03b1\nm : \u2115\nhc : G.Colorable m\n\u22a2 G.Colorable (\u2191(Nat.find ?m.31347)).toNat\n\nV : Type u\nG : SimpleGraph V\nn : \u2115\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nC : G.Coloring \u03b1\nm : \u2115\nhc : G.Colorable m\n\u22a2 {n' | G.Colorable n'}.Nonempty"
      },
      {
        "tactic": "apply Nat.find_spec",
        "annotated_tactic": [
          "apply <a>Nat.find_spec</a>",
          [
            {
              "full_name": "Nat.find_spec",
              "def_path": "Mathlib/Init/Data/Nat/Lemmas.lean",
              "def_pos": [
                707,
                19
              ],
              "def_end_pos": [
                707,
                28
              ]
            }
          ]
        ],
        "state_before": "V : Type u\nG : SimpleGraph V\nn : \u2115\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nC : G.Coloring \u03b1\nm : \u2115\nhc : G.Colorable m\n\u22a2 G.Colorable (\u2191(Nat.find ?m.31347)).toNat",
        "state_after": "no goals"
      },
      {
        "tactic": "exact colorable_set_nonempty_of_colorable hc",
        "annotated_tactic": [
          "exact <a>colorable_set_nonempty_of_colorable</a> hc",
          [
            {
              "full_name": "SimpleGraph.colorable_set_nonempty_of_colorable",
              "def_path": "Mathlib/Combinatorics/SimpleGraph/Coloring.lean",
              "def_pos": [
                268,
                9
              ],
              "def_end_pos": [
                268,
                44
              ]
            }
          ]
        ],
        "state_before": "V : Type u\nG : SimpleGraph V\nn : \u2115\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nC : G.Coloring \u03b1\nm : \u2115\nhc : G.Colorable m\n\u22a2 {n' | G.Colorable n'}.Nonempty",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.692375626997091,
    "entry_failed": false
  },
  "16367": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/Abelian/NonPreadditive.lean",
    "full_name": "CategoryTheory.NonPreadditiveAbelian.neg_neg",
    "start": [
      378,
      1
    ],
    "end": [
      382,
      49
    ],
    "traced_tactics": [
      {
        "tactic": "rw [neg_def, neg_def]",
        "annotated_tactic": [
          "rw [<a>neg_def</a>, <a>neg_def</a>]",
          [
            {
              "full_name": "CategoryTheory.NonPreadditiveAbelian.neg_def",
              "def_path": "Mathlib/CategoryTheory/Abelian/NonPreadditive.lean",
              "def_pos": [
                347,
                9
              ],
              "def_end_pos": [
                347,
                16
              ]
            },
            {
              "full_name": "CategoryTheory.NonPreadditiveAbelian.neg_def",
              "def_path": "Mathlib/CategoryTheory/Abelian/NonPreadditive.lean",
              "def_pos": [
                347,
                9
              ],
              "def_end_pos": [
                347,
                16
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : NonPreadditiveAbelian C\nX Y : C\na : X \u27f6 Y\n\u22a2 - -a = a",
        "state_after": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : NonPreadditiveAbelian C\nX Y : C\na : X \u27f6 Y\n\u22a2 0 - (0 - a) = a"
      },
      {
        "tactic": "conv_lhs =>\n  congr; rw [\u2190 sub_self a]",
        "annotated_tactic": [
          "conv_lhs =>\n    congr; rw [\u2190 <a>sub_self</a> a]",
          [
            {
              "full_name": "CategoryTheory.NonPreadditiveAbelian.sub_self",
              "def_path": "Mathlib/CategoryTheory/Abelian/NonPreadditive.lean",
              "def_pos": [
                358,
                9
              ],
              "def_end_pos": [
                358,
                17
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : NonPreadditiveAbelian C\nX Y : C\na : X \u27f6 Y\n\u22a2 0 - (0 - a) = a",
        "state_after": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : NonPreadditiveAbelian C\nX Y : C\na : X \u27f6 Y\n\u22a2 a - a - (0 - a) = a"
      },
      {
        "tactic": "rw [sub_sub_sub, sub_zero, sub_self, sub_zero]",
        "annotated_tactic": [
          "rw [<a>sub_sub_sub</a>, <a>sub_zero</a>, <a>sub_self</a>, <a>sub_zero</a>]",
          [
            {
              "full_name": "CategoryTheory.NonPreadditiveAbelian.sub_sub_sub",
              "def_path": "Mathlib/CategoryTheory/Abelian/NonPreadditive.lean",
              "def_pos": [
                370,
                9
              ],
              "def_end_pos": [
                370,
                20
              ]
            },
            {
              "full_name": "CategoryTheory.NonPreadditiveAbelian.sub_zero",
              "def_path": "Mathlib/CategoryTheory/Abelian/NonPreadditive.lean",
              "def_pos": [
                350,
                9
              ],
              "def_end_pos": [
                350,
                17
              ]
            },
            {
              "full_name": "CategoryTheory.NonPreadditiveAbelian.sub_self",
              "def_path": "Mathlib/CategoryTheory/Abelian/NonPreadditive.lean",
              "def_pos": [
                358,
                9
              ],
              "def_end_pos": [
                358,
                17
              ]
            },
            {
              "full_name": "CategoryTheory.NonPreadditiveAbelian.sub_zero",
              "def_path": "Mathlib/CategoryTheory/Abelian/NonPreadditive.lean",
              "def_pos": [
                350,
                9
              ],
              "def_end_pos": [
                350,
                17
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : NonPreadditiveAbelian C\nX Y : C\na : X \u27f6 Y\n\u22a2 a - a - (0 - a) = a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.707113852025941,
    "entry_failed": false
  },
  "16368": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Real/Irrational.lean",
    "full_name": "Irrational.mul_int",
    "start": [
      397,
      1
    ],
    "end": [
      400,
      25
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 cast_intCast]",
        "annotated_tactic": [
          "rw [\u2190 <a>cast_intCast</a>]",
          [
            {
              "full_name": "Rat.cast_intCast",
              "def_path": "Mathlib/Data/Rat/Cast/Defs.lean",
              "def_pos": [
                115,
                9
              ],
              "def_end_pos": [
                115,
                21
              ]
            }
          ]
        ],
        "state_before": "q : \u211a\nx y : \u211d\nh : Irrational x\nm : \u2124\nhm : m \u2260 0\n\u22a2 Irrational (x * \u2191m)",
        "state_after": "q : \u211a\nx y : \u211d\nh : Irrational x\nm : \u2124\nhm : m \u2260 0\n\u22a2 Irrational (x * \u2191\u2191m)"
      },
      {
        "tactic": "refine h.mul_rat ?_",
        "annotated_tactic": [
          "refine h.mul_rat ?_",
          []
        ],
        "state_before": "q : \u211a\nx y : \u211d\nh : Irrational x\nm : \u2124\nhm : m \u2260 0\n\u22a2 Irrational (x * \u2191\u2191m)",
        "state_after": "q : \u211a\nx y : \u211d\nh : Irrational x\nm : \u2124\nhm : m \u2260 0\n\u22a2 \u2191m \u2260 0"
      },
      {
        "tactic": "rwa [Int.cast_ne_zero]",
        "annotated_tactic": [
          "rwa [<a>Int.cast_ne_zero</a>]",
          [
            {
              "full_name": "Int.cast_ne_zero",
              "def_path": "Mathlib/Data/Int/Cast/Lemmas.lean",
              "def_pos": [
                82,
                7
              ],
              "def_end_pos": [
                82,
                19
              ]
            }
          ]
        ],
        "state_before": "q : \u211a\nx y : \u211d\nh : Irrational x\nm : \u2124\nhm : m \u2260 0\n\u22a2 \u2191m \u2260 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.283125707996078,
    "entry_failed": false
  },
  "16413": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Perfect.lean",
    "full_name": "Preperfect.open_inter",
    "start": [
      111,
      1
    ],
    "end": [
      115,
      23
    ],
    "traced_tactics": [
      {
        "tactic": "rintro x \u27e8xU, xC\u27e9",
        "annotated_tactic": [
          "rintro x \u27e8xU, xC\u27e9",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nC U : Set \u03b1\nhC : Preperfect C\nhU : IsOpen U\n\u22a2 Preperfect (U \u2229 C)",
        "state_after": "case intro\n\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nC U : Set \u03b1\nhC : Preperfect C\nhU : IsOpen U\nx : \u03b1\nxU : x \u2208 U\nxC : x \u2208 C\n\u22a2 AccPt x (\ud835\udcdf (U \u2229 C))"
      },
      {
        "tactic": "apply (hC _ xC).nhds_inter",
        "annotated_tactic": [
          "apply (hC _ xC).<a>nhds_inter</a>",
          [
            {
              "full_name": "AccPt.nhds_inter",
              "def_path": "Mathlib/Topology/Perfect.lean",
              "def_pos": [
                62,
                9
              ],
              "def_end_pos": [
                62,
                25
              ]
            }
          ]
        ],
        "state_before": "case intro\n\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nC U : Set \u03b1\nhC : Preperfect C\nhU : IsOpen U\nx : \u03b1\nxU : x \u2208 U\nxC : x \u2208 C\n\u22a2 AccPt x (\ud835\udcdf (U \u2229 C))",
        "state_after": "case intro\n\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nC U : Set \u03b1\nhC : Preperfect C\nhU : IsOpen U\nx : \u03b1\nxU : x \u2208 U\nxC : x \u2208 C\n\u22a2 U \u2208 \ud835\udcdd x"
      },
      {
        "tactic": "exact hU.mem_nhds xU",
        "annotated_tactic": [
          "exact hU.mem_nhds xU",
          []
        ],
        "state_before": "case intro\n\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nC U : Set \u03b1\nhC : Preperfect C\nhU : IsOpen U\nx : \u03b1\nxU : x \u2208 U\nxC : x \u2208 C\n\u22a2 U \u2208 \ud835\udcdd x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.3213361810194328,
    "entry_failed": false
  },
  "16536": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/DFinsupp/Multiset.lean",
    "full_name": "Multiset.toDFinsupp_replicate",
    "start": [
      67,
      1
    ],
    "end": [
      71,
      34
    ],
    "traced_tactics": [
      {
        "tactic": "ext i",
        "annotated_tactic": [
          "ext i",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : \u03b1 \u2192 Type u_2\ninst\u271d : DecidableEq \u03b1\ns t : Multiset \u03b1\na : \u03b1\nn : \u2115\n\u22a2 toDFinsupp (replicate n a) = DFinsupp.single a n",
        "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : \u03b1 \u2192 Type u_2\ninst\u271d : DecidableEq \u03b1\ns t : Multiset \u03b1\na : \u03b1\nn : \u2115\ni : \u03b1\n\u22a2 (toDFinsupp (replicate n a)) i = (DFinsupp.single a n) i"
      },
      {
        "tactic": "dsimp [toDFinsupp]",
        "annotated_tactic": [
          "dsimp [<a>toDFinsupp</a>]",
          [
            {
              "full_name": "Multiset.toDFinsupp",
              "def_path": "Mathlib/Data/DFinsupp/Multiset.lean",
              "def_pos": [
                48,
                5
              ],
              "def_end_pos": [
                48,
                15
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : \u03b1 \u2192 Type u_2\ninst\u271d : DecidableEq \u03b1\ns t : Multiset \u03b1\na : \u03b1\nn : \u2115\ni : \u03b1\n\u22a2 (toDFinsupp (replicate n a)) i = (DFinsupp.single a n) i",
        "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : \u03b1 \u2192 Type u_2\ninst\u271d : DecidableEq \u03b1\ns t : Multiset \u03b1\na : \u03b1\nn : \u2115\ni : \u03b1\n\u22a2 count i (replicate n a) = (DFinsupp.single a n) i"
      },
      {
        "tactic": "simp [count_replicate, eq_comm]",
        "annotated_tactic": [
          "simp [<a>count_replicate</a>, <a>eq_comm</a>]",
          [
            {
              "full_name": "Multiset.count_replicate",
              "def_path": "Mathlib/Data/Multiset/Basic.lean",
              "def_pos": [
                2542,
                9
              ],
              "def_end_pos": [
                2542,
                24
              ]
            },
            {
              "full_name": "eq_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                811,
                9
              ],
              "def_end_pos": [
                811,
                16
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : \u03b1 \u2192 Type u_2\ninst\u271d : DecidableEq \u03b1\ns t : Multiset \u03b1\na : \u03b1\nn : \u2115\ni : \u03b1\n\u22a2 count i (replicate n a) = (DFinsupp.single a n) i",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5220119220903143,
    "entry_failed": false
  },
  "16537": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/Groupoid/Subgroupoid.lean",
    "full_name": "CategoryTheory.Subgroupoid.IsWide.eqToHom_mem",
    "start": [
      328,
      1
    ],
    "end": [
      329,
      88
    ],
    "traced_tactics": [
      {
        "tactic": "cases h",
        "annotated_tactic": [
          "cases h",
          []
        ],
        "state_before": "C : Type u\ninst\u271d : Groupoid C\nS\u271d S : Subgroupoid C\nSw : S.IsWide\nc d : C\nh : c = d\n\u22a2 eqToHom h \u2208 S.arrows c d",
        "state_after": "case refl\nC : Type u\ninst\u271d : Groupoid C\nS\u271d S : Subgroupoid C\nSw : S.IsWide\nc : C\n\u22a2 eqToHom \u22ef \u2208 S.arrows c c"
      },
      {
        "tactic": "simp only [eqToHom_refl]",
        "annotated_tactic": [
          "simp only [<a>eqToHom_refl</a>]",
          [
            {
              "full_name": "CategoryTheory.eqToHom_refl",
              "def_path": "Mathlib/CategoryTheory/EqToHom.lean",
              "def_pos": [
                47,
                9
              ],
              "def_end_pos": [
                47,
                21
              ]
            }
          ]
        ],
        "state_before": "case refl\nC : Type u\ninst\u271d : Groupoid C\nS\u271d S : Subgroupoid C\nSw : S.IsWide\nc : C\n\u22a2 eqToHom \u22ef \u2208 S.arrows c c",
        "state_after": "case refl\nC : Type u\ninst\u271d : Groupoid C\nS\u271d S : Subgroupoid C\nSw : S.IsWide\nc : C\n\u22a2 \ud835\udfd9 c \u2208 S.arrows c c"
      },
      {
        "tactic": "apply Sw.id_mem c",
        "annotated_tactic": [
          "apply Sw.id_mem c",
          []
        ],
        "state_before": "case refl\nC : Type u\ninst\u271d : Groupoid C\nS\u271d S : Subgroupoid C\nSw : S.IsWide\nc : C\n\u22a2 \ud835\udfd9 c \u2208 S.arrows c c",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.022472660988569,
    "entry_failed": false
  },
  "16572": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Seq/Seq.lean",
    "full_name": "Stream'.Seq.dropn_tail",
    "start": [
      838,
      1
    ],
    "end": [
      839,
      43
    ],
    "traced_tactics": [
      {
        "tactic": "rw [Nat.add_comm]",
        "annotated_tactic": [
          "rw [<a>Nat.add_comm</a>]",
          [
            {
              "full_name": "Nat.add_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean",
              "def_pos": [
                160,
                19
              ],
              "def_end_pos": [
                160,
                27
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns : Seq \u03b1\nn : \u2115\n\u22a2 s.tail.drop n = s.drop (n + 1)",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns : Seq \u03b1\nn : \u2115\n\u22a2 s.tail.drop n = s.drop (1 + n)"
      },
      {
        "tactic": "symm",
        "annotated_tactic": [
          "symm",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns : Seq \u03b1\nn : \u2115\n\u22a2 s.tail.drop n = s.drop (1 + n)",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns : Seq \u03b1\nn : \u2115\n\u22a2 s.drop (1 + n) = s.tail.drop n"
      },
      {
        "tactic": "apply dropn_add",
        "annotated_tactic": [
          "apply <a>dropn_add</a>",
          [
            {
              "full_name": "Stream'.Seq.dropn_add",
              "def_path": "Mathlib/Data/Seq/Seq.lean",
              "def_pos": [
                833,
                9
              ],
              "def_end_pos": [
                833,
                18
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns : Seq \u03b1\nn : \u2115\n\u22a2 s.drop (1 + n) = s.tail.drop n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.5773963059764355,
    "entry_failed": false
  },
  "16585": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/Quiver/Path.lean",
    "full_name": "Quiver.Path.eq_of_length_zero",
    "start": [
      81,
      1
    ],
    "end": [
      84,
      35
    ],
    "traced_tactics": [
      {
        "tactic": "cases p",
        "annotated_tactic": [
          "cases p",
          []
        ],
        "state_before": "V : Type u\ninst\u271d : Quiver V\na b c d : V\np : Path a b\nhzero : p.length = 0\n\u22a2 a = b",
        "state_after": "case nil\nV : Type u\ninst\u271d : Quiver V\na c d : V\nhzero : nil.length = 0\n\u22a2 a = a\n\ncase cons\nV : Type u\ninst\u271d : Quiver V\na b c d b\u271d : V\na\u271d\u00b9 : Path a b\u271d\na\u271d : b\u271d \u27f6 b\nhzero : (a\u271d\u00b9.cons a\u271d).length = 0\n\u22a2 a = b"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case nil\nV : Type u\ninst\u271d : Quiver V\na c d : V\nhzero : nil.length = 0\n\u22a2 a = a",
        "state_after": "no goals"
      },
      {
        "tactic": "cases Nat.succ_ne_zero _ hzero",
        "annotated_tactic": [
          "cases <a>Nat.succ_ne_zero</a> _ hzero",
          [
            {
              "full_name": "Nat.succ_ne_zero",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean",
              "def_pos": [
                708,
                17
              ],
              "def_end_pos": [
                708,
                29
              ]
            }
          ]
        ],
        "state_before": "case cons\nV : Type u\ninst\u271d : Quiver V\na b c d b\u271d : V\na\u271d\u00b9 : Path a b\u271d\na\u271d : b\u271d \u27f6 b\nhzero : (a\u271d\u00b9.cons a\u271d).length = 0\n\u22a2 a = b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.0287714139558375,
    "entry_failed": false
  },
  "16656": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Solvable.lean",
    "full_name": "map_derivedSeries_le_derivedSeries",
    "start": [
      76,
      1
    ],
    "end": [
      80,
      72
    ],
    "traced_tactics": [
      {
        "tactic": "induction' n with n ih",
        "annotated_tactic": [
          "induction' n with n ih",
          []
        ],
        "state_before": "G : Type u_1\nG' : Type u_2\ninst\u271d\u00b9 : Group G\ninst\u271d : Group G'\nf : G \u2192* G'\nn : \u2115\n\u22a2 map f (derivedSeries G n) \u2264 derivedSeries G' n",
        "state_after": "case zero\nG : Type u_1\nG' : Type u_2\ninst\u271d\u00b9 : Group G\ninst\u271d : Group G'\nf : G \u2192* G'\n\u22a2 map f (derivedSeries G 0) \u2264 derivedSeries G' 0\n\ncase succ\nG : Type u_1\nG' : Type u_2\ninst\u271d\u00b9 : Group G\ninst\u271d : Group G'\nf : G \u2192* G'\nn : \u2115\nih : map f (derivedSeries G n) \u2264 derivedSeries G' n\n\u22a2 map f (derivedSeries G (n + 1)) \u2264 derivedSeries G' (n + 1)"
      },
      {
        "tactic": "exact le_top",
        "annotated_tactic": [
          "exact <a>le_top</a>",
          [
            {
              "full_name": "le_top",
              "def_path": "Mathlib/Order/BoundedOrder.lean",
              "def_pos": [
                66,
                9
              ],
              "def_end_pos": [
                66,
                15
              ]
            }
          ]
        ],
        "state_before": "case zero\nG : Type u_1\nG' : Type u_2\ninst\u271d\u00b9 : Group G\ninst\u271d : Group G'\nf : G \u2192* G'\n\u22a2 map f (derivedSeries G 0) \u2264 derivedSeries G' 0",
        "state_after": "no goals"
      },
      {
        "tactic": "simp only [derivedSeries_succ, map_commutator, commutator_mono, ih]",
        "annotated_tactic": [
          "simp only [<a>derivedSeries_succ</a>, <a>map_commutator</a>, <a>commutator_mono</a>, ih]",
          [
            {
              "full_name": "derivedSeries_succ",
              "def_path": "Mathlib/GroupTheory/Solvable.lean",
              "def_pos": [
                50,
                9
              ],
              "def_end_pos": [
                50,
                27
              ]
            },
            {
              "full_name": "Subgroup.map_commutator",
              "def_path": "Mathlib/GroupTheory/Commutator.lean",
              "def_pos": [
                173,
                9
              ],
              "def_end_pos": [
                173,
                23
              ]
            },
            {
              "full_name": "Subgroup.commutator_mono",
              "def_path": "Mathlib/GroupTheory/Commutator.lean",
              "def_pos": [
                96,
                9
              ],
              "def_end_pos": [
                96,
                24
              ]
            }
          ]
        ],
        "state_before": "case succ\nG : Type u_1\nG' : Type u_2\ninst\u271d\u00b9 : Group G\ninst\u271d : Group G'\nf : G \u2192* G'\nn : \u2115\nih : map f (derivedSeries G n) \u2264 derivedSeries G' n\n\u22a2 map f (derivedSeries G (n + 1)) \u2264 derivedSeries G' (n + 1)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.576018637046218,
    "entry_failed": false
  },
  "16776": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/BigOperators/Ring/Multiset.lean",
    "full_name": "CanonicallyOrderedCommSemiring.multiset_prod_pos",
    "start": [
      32,
      1
    ],
    "end": [
      37,
      53
    ],
    "traced_tactics": [
      {
        "tactic": "rcases m with \u27e8l\u27e9",
        "annotated_tactic": [
          "rcases m with \u27e8l\u27e9",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d\u00b9 : CanonicallyOrderedCommSemiring R\ninst\u271d : Nontrivial R\nm : Multiset R\n\u22a2 0 < m.prod \u2194 \u2200 x \u2208 m, 0 < x",
        "state_after": "case mk\nR : Type u_1\ninst\u271d\u00b9 : CanonicallyOrderedCommSemiring R\ninst\u271d : Nontrivial R\nm : Multiset R\nl : List R\n\u22a2 0 < prod (Quot.mk Setoid.r l) \u2194 \u2200 x \u2208 Quot.mk Setoid.r l, 0 < x"
      },
      {
        "tactic": "rw [Multiset.quot_mk_to_coe'', Multiset.prod_coe]",
        "annotated_tactic": [
          "rw [<a>Multiset.quot_mk_to_coe''</a>, <a>Multiset.prod_coe</a>]",
          [
            {
              "full_name": "Multiset.quot_mk_to_coe''",
              "def_path": "Mathlib/Data/Multiset/Basic.lean",
              "def_pos": [
                56,
                9
              ],
              "def_end_pos": [
                56,
                25
              ]
            },
            {
              "full_name": "Multiset.prod_coe",
              "def_path": "Mathlib/Algebra/BigOperators/Group/Multiset.lean",
              "def_pos": [
                60,
                9
              ],
              "def_end_pos": [
                60,
                17
              ]
            }
          ]
        ],
        "state_before": "case mk\nR : Type u_1\ninst\u271d\u00b9 : CanonicallyOrderedCommSemiring R\ninst\u271d : Nontrivial R\nm : Multiset R\nl : List R\n\u22a2 0 < prod (Quot.mk Setoid.r l) \u2194 \u2200 x \u2208 Quot.mk Setoid.r l, 0 < x",
        "state_after": "case mk\nR : Type u_1\ninst\u271d\u00b9 : CanonicallyOrderedCommSemiring R\ninst\u271d : Nontrivial R\nm : Multiset R\nl : List R\n\u22a2 0 < l.prod \u2194 \u2200 x \u2208 \u2191l, 0 < x"
      },
      {
        "tactic": "exact CanonicallyOrderedCommSemiring.list_prod_pos",
        "annotated_tactic": [
          "exact <a>CanonicallyOrderedCommSemiring.list_prod_pos</a>",
          [
            {
              "full_name": "CanonicallyOrderedCommSemiring.list_prod_pos",
              "def_path": "Mathlib/Algebra/Order/BigOperators/Ring/List.lean",
              "def_pos": [
                30,
                15
              ],
              "def_end_pos": [
                30,
                66
              ]
            }
          ]
        ],
        "state_before": "case mk\nR : Type u_1\ninst\u271d\u00b9 : CanonicallyOrderedCommSemiring R\ninst\u271d : Nontrivial R\nm : Multiset R\nl : List R\n\u22a2 0 < l.prod \u2194 \u2200 x \u2208 \u2191l, 0 < x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.1260450729168952,
    "entry_failed": false
  },
  "17006": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/PartENat.lean",
    "full_name": "PartENat.toWithTop_ofENat",
    "start": [
      706,
      1
    ],
    "end": [
      709,
      18
    ],
    "traced_tactics": [
      {
        "tactic": "cases n with\n| top => simp\n| coe n => simp",
        "annotated_tactic": [
          "cases n with\n  | top => simp\n  | coe n => simp",
          []
        ],
        "state_before": "n : \u2115\u221e\nx\u271d : Decidable (\u2191n).Dom\n\u22a2 (\u2191n).toWithTop = n",
        "state_after": "no goals"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case top\nx\u271d : Decidable (\u2191\u22a4).Dom\n\u22a2 (\u2191\u22a4).toWithTop = \u22a4",
        "state_after": "no goals"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case coe\nn : \u2115\nx\u271d : Decidable (\u2191\u2191n).Dom\n\u22a2 (\u2191\u2191n).toWithTop = \u2191n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.750148624065332,
    "entry_failed": false
  },
  "17020": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Init/Order/Defs.lean",
    "full_name": "compare_ge_iff_ge",
    "start": [
      445,
      1
    ],
    "end": [
      449,
      44
    ],
    "traced_tactics": [
      {
        "tactic": "cases h : compare a b <;> simp",
        "annotated_tactic": [
          "cases h : <a>compare</a> a b <;> simp",
          [
            {
              "full_name": "Ord.compare",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Ord.lean",
              "def_pos": [
                129,
                3
              ],
              "def_end_pos": [
                129,
                10
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\n\u22a2 compare a b \u2260 Ordering.lt \u2194 a \u2265 b",
        "state_after": "case lt\n\u03b1 : Type u\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nh : compare a b = Ordering.lt\n\u22a2 a < b\n\ncase eq\n\u03b1 : Type u\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nh : compare a b = Ordering.eq\n\u22a2 b \u2264 a\n\ncase gt\n\u03b1 : Type u\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nh : compare a b = Ordering.gt\n\u22a2 b \u2264 a"
      },
      {
        "tactic": "exact compare_lt_iff_lt.1 h",
        "annotated_tactic": [
          "exact <a>compare_lt_iff_lt</a>.1 h",
          [
            {
              "full_name": "compare_lt_iff_lt",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                421,
                9
              ],
              "def_end_pos": [
                421,
                26
              ]
            }
          ]
        ],
        "state_before": "case lt\n\u03b1 : Type u\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nh : compare a b = Ordering.lt\n\u22a2 a < b",
        "state_after": "no goals"
      },
      {
        "tactic": "exact le_of_lt <| compare_gt_iff_gt.1 h",
        "annotated_tactic": [
          "exact <a>le_of_lt</a> <| <a>compare_gt_iff_gt</a>.1 h",
          [
            {
              "full_name": "le_of_lt",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                110,
                9
              ],
              "def_end_pos": [
                110,
                17
              ]
            },
            {
              "full_name": "compare_gt_iff_gt",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                425,
                9
              ],
              "def_end_pos": [
                425,
                26
              ]
            }
          ]
        ],
        "state_before": "case gt\n\u03b1 : Type u\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\nh : compare a b = Ordering.gt\n\u22a2 b \u2264 a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7169220669893548,
    "entry_failed": false
  },
  "17037": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Prod/Basic.lean",
    "full_name": "Prod.map_bijective",
    "start": [
      388,
      1
    ],
    "end": [
      392,
      66
    ],
    "traced_tactics": [
      {
        "tactic": "haveI := Nonempty.map f \u2039_\u203a",
        "annotated_tactic": [
          "haveI := <a>Nonempty.map</a> f \u2039_\u203a",
          [
            {
              "full_name": "Nonempty.map",
              "def_path": "Mathlib/Logic/Nonempty.lean",
              "def_pos": [
                105,
                9
              ],
              "def_end_pos": [
                105,
                21
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : Nonempty \u03b2\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b4\n\u22a2 Bijective (map f g) \u2194 Bijective f \u2227 Bijective g",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : Nonempty \u03b2\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b4\nthis : Nonempty \u03b3\n\u22a2 Bijective (map f g) \u2194 Bijective f \u2227 Bijective g"
      },
      {
        "tactic": "haveI := Nonempty.map g \u2039_\u203a",
        "annotated_tactic": [
          "haveI := <a>Nonempty.map</a> g \u2039_\u203a",
          [
            {
              "full_name": "Nonempty.map",
              "def_path": "Mathlib/Logic/Nonempty.lean",
              "def_pos": [
                105,
                9
              ],
              "def_end_pos": [
                105,
                21
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : Nonempty \u03b2\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b4\nthis : Nonempty \u03b3\n\u22a2 Bijective (map f g) \u2194 Bijective f \u2227 Bijective g",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : Nonempty \u03b2\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b4\nthis\u271d : Nonempty \u03b3\nthis : Nonempty \u03b4\n\u22a2 Bijective (map f g) \u2194 Bijective f \u2227 Bijective g"
      },
      {
        "tactic": "exact (map_injective.and map_surjective).trans and_and_and_comm",
        "annotated_tactic": [
          "exact (map_injective.and <a>map_surjective</a>).<a>trans</a> <a>and_and_and_comm</a>",
          [
            {
              "full_name": "Prod.map_surjective",
              "def_path": "Mathlib/Data/Prod/Basic.lean",
              "def_pos": [
                373,
                9
              ],
              "def_end_pos": [
                373,
                23
              ]
            },
            {
              "full_name": "Iff.trans",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                803,
                9
              ],
              "def_end_pos": [
                803,
                18
              ]
            },
            {
              "full_name": "and_and_and_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean",
              "def_pos": [
                65,
                9
              ],
              "def_end_pos": [
                65,
                25
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : Nonempty \u03b2\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b4\nthis\u271d : Nonempty \u03b3\nthis : Nonempty \u03b4\n\u22a2 Bijective (map f g) \u2194 Bijective f \u2227 Bijective g",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7625788529403508,
    "entry_failed": false
  },
  "17047": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": ".lake/packages/batteries/Batteries/Data/RBMap/Lemmas.lean",
    "full_name": "Batteries.RBNode.Stream.foldr_cons",
    "start": [
      197,
      1
    ],
    "end": [
      198,
      83
    ],
    "traced_tactics": [
      {
        "tactic": "unfold toList",
        "annotated_tactic": [
          "unfold <a>toList</a>",
          [
            {
              "full_name": "Batteries.RBNode.Stream.toList",
              "def_path": ".lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
              "def_pos": [
                151,
                5
              ],
              "def_end_pos": [
                151,
                11
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nt : RBNode.Stream \u03b1\nl : List \u03b1\n\u22a2 foldr (fun x x_1 => x :: x_1) t l = t.toList ++ l",
        "state_after": "\u03b1 : Type u_1\nt : RBNode.Stream \u03b1\nl : List \u03b1\n\u22a2 foldr (fun x x_1 => x :: x_1) t l = foldr (fun x x_1 => x :: x_1) t [] ++ l"
      },
      {
        "tactic": "apply Eq.symm",
        "annotated_tactic": [
          "apply <a>Eq.symm</a>",
          [
            {
              "full_name": "Eq.symm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                323,
                9
              ],
              "def_end_pos": [
                323,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nt : RBNode.Stream \u03b1\nl : List \u03b1\n\u22a2 foldr (fun x x_1 => x :: x_1) t l = foldr (fun x x_1 => x :: x_1) t [] ++ l",
        "state_after": "case h\n\u03b1 : Type u_1\nt : RBNode.Stream \u03b1\nl : List \u03b1\n\u22a2 foldr (fun x x_1 => x :: x_1) t [] ++ l = foldr (fun x x_1 => x :: x_1) t l"
      },
      {
        "tactic": "induction t <;> simp [*, foldr, RBNode.foldr_cons]",
        "annotated_tactic": [
          "induction t <;> simp [*, <a>foldr</a>, <a>RBNode.foldr_cons</a>]",
          [
            {
              "full_name": "Batteries.RBNode.Stream.foldr",
              "def_path": ".lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
              "def_pos": [
                146,
                19
              ],
              "def_end_pos": [
                146,
                24
              ]
            },
            {
              "full_name": "Batteries.RBNode.foldr_cons",
              "def_path": ".lake/packages/batteries/Batteries/Data/RBMap/Lemmas.lean",
              "def_pos": [
                131,
                9
              ],
              "def_end_pos": [
                131,
                19
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u_1\nt : RBNode.Stream \u03b1\nl : List \u03b1\n\u22a2 foldr (fun x x_1 => x :: x_1) t [] ++ l = foldr (fun x x_1 => x :: x_1) t l",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.452045148005709,
    "entry_failed": false
  },
  "17076": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/CharP/Reduced.lean",
    "full_name": "ExpChar.pow_prime_pow_mul_eq_one_iff",
    "start": [
      46,
      1
    ],
    "end": [
      50,
      16
    ],
    "traced_tactics": [
      {
        "tactic": "rw [pow_mul']",
        "annotated_tactic": [
          "rw [<a>pow_mul'</a>]",
          [
            {
              "full_name": "pow_mul'",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                722,
                7
              ],
              "def_end_pos": [
                722,
                15
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsReduced R\np k m : \u2115\ninst\u271d : ExpChar R p\nx : R\n\u22a2 x ^ (p ^ k * m) = 1 \u2194 x ^ m = 1",
        "state_after": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsReduced R\np k m : \u2115\ninst\u271d : ExpChar R p\nx : R\n\u22a2 (x ^ m) ^ p ^ k = 1 \u2194 x ^ m = 1"
      },
      {
        "tactic": "convert \u2190 (iterateFrobenius_inj R p k).eq_iff",
        "annotated_tactic": [
          "convert \u2190 (<a>iterateFrobenius_inj</a> R p k).<a>eq_iff</a>",
          [
            {
              "full_name": "iterateFrobenius_inj",
              "def_path": "Mathlib/Algebra/CharP/Reduced.lean",
              "def_pos": [
                22,
                9
              ],
              "def_end_pos": [
                22,
                29
              ]
            },
            {
              "full_name": "Function.Injective.eq_iff",
              "def_path": "Mathlib/Logic/Function/Basic.lean",
              "def_pos": [
                85,
                9
              ],
              "def_end_pos": [
                85,
                25
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsReduced R\np k m : \u2115\ninst\u271d : ExpChar R p\nx : R\n\u22a2 (x ^ m) ^ p ^ k = 1 \u2194 x ^ m = 1",
        "state_after": "case h.e'_1.h.e'_3\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsReduced R\np k m : \u2115\ninst\u271d : ExpChar R p\nx : R\n\u22a2 (iterateFrobenius R p k) 1 = 1"
      },
      {
        "tactic": "apply map_one",
        "annotated_tactic": [
          "apply <a>map_one</a>",
          [
            {
              "full_name": "map_one",
              "def_path": "Mathlib/Algebra/Group/Hom/Defs.lean",
              "def_pos": [
                204,
                9
              ],
              "def_end_pos": [
                204,
                16
              ]
            }
          ]
        ],
        "state_before": "case h.e'_1.h.e'_3\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsReduced R\np k m : \u2115\ninst\u271d : ExpChar R p\nx : R\n\u22a2 (iterateFrobenius R p k) 1 = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5983555000275373,
    "entry_failed": false
  },
  "17078": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/SuccPred/Basic.lean",
    "full_name": "WCovBy.le_succ",
    "start": [
      452,
      1
    ],
    "end": [
      455,
      20
    ],
    "traced_tactics": [
      {
        "tactic": "obtain h | rfl := h.covBy_or_eq",
        "annotated_tactic": [
          "obtain h | rfl := h.covBy_or_eq",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nh : a \u2a7f b\n\u22a2 b \u2264 succ a",
        "state_after": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nh\u271d : a \u2a7f b\nh : a \u22d6 b\n\u22a2 b \u2264 succ a\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na : \u03b1\nh : a \u2a7f a\n\u22a2 a \u2264 succ a"
      },
      {
        "tactic": "exact (CovBy.succ_eq h).ge",
        "annotated_tactic": [
          "exact (<a>CovBy.succ_eq</a> h).<a>ge</a>",
          [
            {
              "full_name": "CovBy.succ_eq",
              "def_path": "Mathlib/Order/SuccPred/Basic.lean",
              "def_pos": [
                448,
                9
              ],
              "def_end_pos": [
                448,
                29
              ]
            },
            {
              "full_name": "Eq.ge",
              "def_path": "Mathlib/Order/Basic.lean",
              "def_pos": [
                218,
                19
              ],
              "def_end_pos": [
                218,
                21
              ]
            }
          ]
        ],
        "state_before": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na b : \u03b1\nh\u271d : a \u2a7f b\nh : a \u22d6 b\n\u22a2 b \u2264 succ a",
        "state_after": "no goals"
      },
      {
        "tactic": "exact le_succ _",
        "annotated_tactic": [
          "exact <a>le_succ</a> _",
          [
            {
              "full_name": "Order.le_succ",
              "def_path": "Mathlib/Order/SuccPred/Basic.lean",
              "def_pos": [
                231,
                9
              ],
              "def_end_pos": [
                231,
                16
              ]
            }
          ]
        ],
        "state_before": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : SuccOrder \u03b1\na : \u03b1\nh : a \u2a7f a\n\u22a2 a \u2264 succ a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.7887710659997538,
    "entry_failed": false
  },
  "17101": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/LinearAlgebra/UnitaryGroup.lean",
    "full_name": "Matrix.det_of_mem_unitary",
    "start": [
      76,
      1
    ],
    "end": [
      80,
      57
    ],
    "traced_tactics": [
      {
        "tactic": "constructor",
        "annotated_tactic": [
          "constructor",
          []
        ],
        "state_before": "n : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\n\u03b1 : Type v\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : StarRing \u03b1\nA\u271d A : Matrix n n \u03b1\nhA : A \u2208 unitaryGroup n \u03b1\n\u22a2 A.det \u2208 unitary \u03b1",
        "state_after": "case left\nn : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\n\u03b1 : Type v\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : StarRing \u03b1\nA\u271d A : Matrix n n \u03b1\nhA : A \u2208 unitaryGroup n \u03b1\n\u22a2 star A.det * A.det = 1\n\ncase right\nn : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\n\u03b1 : Type v\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : StarRing \u03b1\nA\u271d A : Matrix n n \u03b1\nhA : A \u2208 unitaryGroup n \u03b1\n\u22a2 A.det * star A.det = 1"
      },
      {
        "tactic": "simpa [star, det_transpose] using congr_arg det hA.1",
        "annotated_tactic": [
          "simpa [<a>star</a>, <a>det_transpose</a>] using <a>congr_arg</a> <a>det</a> hA.1",
          [
            {
              "full_name": "Star.star",
              "def_path": "Mathlib/Algebra/Star/Basic.lean",
              "def_pos": [
                47,
                3
              ],
              "def_end_pos": [
                47,
                7
              ]
            },
            {
              "full_name": "Matrix.det_transpose",
              "def_path": "Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean",
              "def_pos": [
                222,
                9
              ],
              "def_end_pos": [
                222,
                22
              ]
            },
            {
              "full_name": "congr_arg",
              "def_path": ".lake/packages/batteries/Batteries/Logic.lean",
              "def_pos": [
                76,
                7
              ],
              "def_end_pos": [
                76,
                16
              ]
            },
            {
              "full_name": "Matrix.det",
              "def_path": "Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean",
              "def_pos": [
                59,
                8
              ],
              "def_end_pos": [
                59,
                11
              ]
            }
          ]
        ],
        "state_before": "case left\nn : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\n\u03b1 : Type v\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : StarRing \u03b1\nA\u271d A : Matrix n n \u03b1\nhA : A \u2208 unitaryGroup n \u03b1\n\u22a2 star A.det * A.det = 1",
        "state_after": "no goals"
      },
      {
        "tactic": "simpa [star, det_transpose] using congr_arg det hA.2",
        "annotated_tactic": [
          "simpa [<a>star</a>, <a>det_transpose</a>] using <a>congr_arg</a> <a>det</a> hA.2",
          [
            {
              "full_name": "Star.star",
              "def_path": "Mathlib/Algebra/Star/Basic.lean",
              "def_pos": [
                47,
                3
              ],
              "def_end_pos": [
                47,
                7
              ]
            },
            {
              "full_name": "Matrix.det_transpose",
              "def_path": "Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean",
              "def_pos": [
                222,
                9
              ],
              "def_end_pos": [
                222,
                22
              ]
            },
            {
              "full_name": "congr_arg",
              "def_path": ".lake/packages/batteries/Batteries/Logic.lean",
              "def_pos": [
                76,
                7
              ],
              "def_end_pos": [
                76,
                16
              ]
            },
            {
              "full_name": "Matrix.det",
              "def_path": "Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean",
              "def_pos": [
                59,
                8
              ],
              "def_end_pos": [
                59,
                11
              ]
            }
          ]
        ],
        "state_before": "case right\nn : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\n\u03b1 : Type v\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : StarRing \u03b1\nA\u271d A : Matrix n n \u03b1\nhA : A \u2208 unitaryGroup n \u03b1\n\u22a2 A.det * star A.det = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.870708932983689,
    "entry_failed": false
  },
  "17112": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Choose/Basic.lean",
    "full_name": "Nat.multichoose_one_right",
    "start": [
      404,
      1
    ],
    "end": [
      406,
      39
    ],
    "traced_tactics": [
      {
        "tactic": "induction' n with n IH",
        "annotated_tactic": [
          "induction' n with n IH",
          []
        ],
        "state_before": "n : \u2115\n\u22a2 n.multichoose 1 = n",
        "state_after": "case zero\n\n\u22a2 multichoose 0 1 = 0\n\ncase succ\nn : \u2115\nIH : n.multichoose 1 = n\n\u22a2 (n + 1).multichoose 1 = n + 1"
      },
      {
        "tactic": "simp [multichoose_succ_succ n 0, IH]",
        "annotated_tactic": [
          "simp [<a>multichoose_succ_succ</a> n 0, IH]",
          [
            {
              "full_name": "Nat.multichoose_succ_succ",
              "def_path": "Mathlib/Data/Nat/Choose/Basic.lean",
              "def_pos": [
                385,
                9
              ],
              "def_end_pos": [
                385,
                30
              ]
            }
          ]
        ],
        "state_before": "case succ\nn : \u2115\nIH : n.multichoose 1 = n\n\u22a2 (n + 1).multichoose 1 = n + 1",
        "state_after": "no goals"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case zero\n\n\u22a2 multichoose 0 1 = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.473420545924455,
    "entry_failed": false
  },
  "17172": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/MetricSpace/CantorScheme.lean",
    "full_name": "CantorScheme.map_mem",
    "start": [
      83,
      1
    ],
    "end": [
      86,
      15
    ],
    "traced_tactics": [
      {
        "tactic": "have := x.property.some_mem",
        "annotated_tactic": [
          "have := x.property.some_mem",
          []
        ],
        "state_before": "\u03b2 : Type u_1\n\u03b1 : Type u_2\nA : List \u03b2 \u2192 Set \u03b1\nx : \u2191(inducedMap A).fst\nn : \u2115\n\u22a2 (inducedMap A).snd x \u2208 A (res (\u2191x) n)",
        "state_after": "\u03b2 : Type u_1\n\u03b1 : Type u_2\nA : List \u03b2 \u2192 Set \u03b1\nx : \u2191(inducedMap A).fst\nn : \u2115\nthis : Set.Nonempty.some \u22ef \u2208 \u22c2 n, A (res (\u2191x) n)\n\u22a2 (inducedMap A).snd x \u2208 A (res (\u2191x) n)"
      },
      {
        "tactic": "rw [mem_iInter] at this",
        "annotated_tactic": [
          "rw [<a>mem_iInter</a>] at this",
          [
            {
              "full_name": "Set.mem_iInter",
              "def_path": "Mathlib/Order/SetNotation.lean",
              "def_pos": [
                274,
                9
              ],
              "def_end_pos": [
                274,
                19
              ]
            }
          ]
        ],
        "state_before": "\u03b2 : Type u_1\n\u03b1 : Type u_2\nA : List \u03b2 \u2192 Set \u03b1\nx : \u2191(inducedMap A).fst\nn : \u2115\nthis : Set.Nonempty.some \u22ef \u2208 \u22c2 n, A (res (\u2191x) n)\n\u22a2 (inducedMap A).snd x \u2208 A (res (\u2191x) n)",
        "state_after": "\u03b2 : Type u_1\n\u03b1 : Type u_2\nA : List \u03b2 \u2192 Set \u03b1\nx : \u2191(inducedMap A).fst\nn : \u2115\nthis : \u2200 (i : \u2115), Set.Nonempty.some \u22ef \u2208 A (res (\u2191x) i)\n\u22a2 (inducedMap A).snd x \u2208 A (res (\u2191x) n)"
      },
      {
        "tactic": "exact this n",
        "annotated_tactic": [
          "exact this n",
          []
        ],
        "state_before": "\u03b2 : Type u_1\n\u03b1 : Type u_2\nA : List \u03b2 \u2192 Set \u03b1\nx : \u2191(inducedMap A).fst\nn : \u2115\nthis : \u2200 (i : \u2115), Set.Nonempty.some \u22ef \u2208 A (res (\u2191x) i)\n\u22a2 (inducedMap A).snd x \u2208 A (res (\u2191x) n)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6392868550028652,
    "entry_failed": false
  },
  "17177": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/Zsqrtd/GaussianInt.lean",
    "full_name": "GaussianInt.toComplex_inj",
    "start": [
      141,
      1
    ],
    "end": [
      142,
      42
    ],
    "traced_tactics": [
      {
        "tactic": "cases x",
        "annotated_tactic": [
          "cases x",
          []
        ],
        "state_before": "x y : \u2124[i]\n\u22a2 toComplex x = toComplex y \u2194 x = y",
        "state_after": "case mk\ny : \u2124[i]\nre\u271d im\u271d : \u2124\n\u22a2 toComplex { re := re\u271d, im := im\u271d } = toComplex y \u2194 { re := re\u271d, im := im\u271d } = y"
      },
      {
        "tactic": "cases y",
        "annotated_tactic": [
          "cases y",
          []
        ],
        "state_before": "case mk\ny : \u2124[i]\nre\u271d im\u271d : \u2124\n\u22a2 toComplex { re := re\u271d, im := im\u271d } = toComplex y \u2194 { re := re\u271d, im := im\u271d } = y",
        "state_after": "case mk.mk\nre\u271d\u00b9 im\u271d\u00b9 re\u271d im\u271d : \u2124\n\u22a2 toComplex { re := re\u271d\u00b9, im := im\u271d\u00b9 } = toComplex { re := re\u271d, im := im\u271d } \u2194\n    { re := re\u271d\u00b9, im := im\u271d\u00b9 } = { re := re\u271d, im := im\u271d }"
      },
      {
        "tactic": "simp [toComplex_def\u2082]",
        "annotated_tactic": [
          "simp [<a>toComplex_def\u2082</a>]",
          [
            {
              "full_name": "GaussianInt.toComplex_def\u2082",
              "def_path": "Mathlib/NumberTheory/Zsqrtd/GaussianInt.lean",
              "def_pos": [
                84,
                9
              ],
              "def_end_pos": [
                84,
                23
              ]
            }
          ]
        ],
        "state_before": "case mk.mk\nre\u271d\u00b9 im\u271d\u00b9 re\u271d im\u271d : \u2124\n\u22a2 toComplex { re := re\u271d\u00b9, im := im\u271d\u00b9 } = toComplex { re := re\u271d, im := im\u271d } \u2194\n    { re := re\u271d\u00b9, im := im\u271d\u00b9 } = { re := re\u271d, im := im\u271d }",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.074018995044753,
    "entry_failed": false
  },
  "17180": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean",
    "full_name": "Real.log_le_sub_one_of_pos",
    "start": [
      320,
      1
    ],
    "end": [
      323,
      18
    ],
    "traced_tactics": [
      {
        "tactic": "rw [le_sub_iff_add_le]",
        "annotated_tactic": [
          "rw [<a>le_sub_iff_add_le</a>]",
          [
            {
              "full_name": "le_sub_iff_add_le",
              "def_path": "Mathlib/Algebra/Order/Group/Defs.lean",
              "def_pos": [
                740,
                3
              ],
              "def_end_pos": [
                740,
                14
              ]
            }
          ]
        ],
        "state_before": "x\u271d y x : \u211d\nhx : 0 < x\n\u22a2 log x \u2264 x - 1",
        "state_after": "x\u271d y x : \u211d\nhx : 0 < x\n\u22a2 log x + 1 \u2264 x"
      },
      {
        "tactic": "convert add_one_le_exp (log x)",
        "annotated_tactic": [
          "convert <a>add_one_le_exp</a> (<a>log</a> x)",
          [
            {
              "full_name": "Real.add_one_le_exp",
              "def_path": "Mathlib/Data/Complex/Exponential.lean",
              "def_pos": [
                1671,
                9
              ],
              "def_end_pos": [
                1671,
                23
              ]
            },
            {
              "full_name": "Real.log",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean",
              "def_pos": [
                41,
                19
              ],
              "def_end_pos": [
                41,
                22
              ]
            }
          ]
        ],
        "state_before": "x\u271d y x : \u211d\nhx : 0 < x\n\u22a2 log x + 1 \u2264 x",
        "state_after": "case h.e'_4\nx\u271d y x : \u211d\nhx : 0 < x\n\u22a2 x = rexp (log x)"
      },
      {
        "tactic": "rw [exp_log hx]",
        "annotated_tactic": [
          "rw [<a>exp_log</a> hx]",
          [
            {
              "full_name": "Real.exp_log",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean",
              "def_pos": [
                59,
                9
              ],
              "def_end_pos": [
                59,
                16
              ]
            }
          ]
        ],
        "state_before": "case h.e'_4\nx\u271d y x : \u211d\nhx : 0 < x\n\u22a2 x = rexp (log x)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.617785889073275,
    "entry_failed": false
  },
  "17182": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Sub/Canonical.lean",
    "full_name": "tsub_min",
    "start": [
      512,
      1
    ],
    "end": [
      515,
      24
    ],
    "traced_tactics": [
      {
        "tactic": "rcases le_total a b with h | h",
        "annotated_tactic": [
          "rcases <a>le_total</a> a b with h | h",
          [
            {
              "full_name": "le_total",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                297,
                9
              ],
              "def_end_pos": [
                297,
                17
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CanonicallyLinearOrderedAddCommMonoid \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\n\u22a2 a - min a b = a - b",
        "state_after": "case inl\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CanonicallyLinearOrderedAddCommMonoid \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\nh : a \u2264 b\n\u22a2 a - min a b = a - b\n\ncase inr\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CanonicallyLinearOrderedAddCommMonoid \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\nh : b \u2264 a\n\u22a2 a - min a b = a - b"
      },
      {
        "tactic": "rw [min_eq_left h, tsub_self, tsub_eq_zero_of_le h]",
        "annotated_tactic": [
          "rw [<a>min_eq_left</a> h, <a>tsub_self</a>, <a>tsub_eq_zero_of_le</a> h]",
          [
            {
              "full_name": "min_eq_left",
              "def_path": "Mathlib/Init/Order/LinearOrder.lean",
              "def_pos": [
                100,
                9
              ],
              "def_end_pos": [
                100,
                20
              ]
            },
            {
              "full_name": "tsub_self",
              "def_path": "Mathlib/Algebra/Order/Sub/Canonical.lean",
              "def_pos": [
                342,
                9
              ],
              "def_end_pos": [
                342,
                18
              ]
            },
            {
              "full_name": "tsub_eq_zero_of_le",
              "def_path": "Mathlib/Algebra/Order/Sub/Canonical.lean",
              "def_pos": [
                337,
                11
              ],
              "def_end_pos": [
                337,
                29
              ]
            }
          ]
        ],
        "state_before": "case inl\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CanonicallyLinearOrderedAddCommMonoid \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\nh : a \u2264 b\n\u22a2 a - min a b = a - b",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [min_eq_right h]",
        "annotated_tactic": [
          "rw [<a>min_eq_right</a> h]",
          [
            {
              "full_name": "min_eq_right",
              "def_path": "Mathlib/Init/Order/LinearOrder.lean",
              "def_pos": [
                104,
                9
              ],
              "def_end_pos": [
                104,
                21
              ]
            }
          ]
        ],
        "state_before": "case inr\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CanonicallyLinearOrderedAddCommMonoid \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na b c d : \u03b1\nh : b \u2264 a\n\u22a2 a - min a b = a - b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.4178971940418705,
    "entry_failed": false
  },
  "17213": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Int/Bitwise.lean",
    "full_name": "Int.bit_val",
    "start": [
      228,
      1
    ],
    "end": [
      231,
      19
    ],
    "traced_tactics": [
      {
        "tactic": "cases b",
        "annotated_tactic": [
          "cases b",
          []
        ],
        "state_before": "b : Bool\nn : \u2124\n\u22a2 bit b n = 2 * n + bif b then 1 else 0",
        "state_after": "case false\nn : \u2124\n\u22a2 bit false n = 2 * n + bif false then 1 else 0\n\ncase true\nn : \u2124\n\u22a2 bit true n = 2 * n + bif true then 1 else 0"
      },
      {
        "tactic": "apply (bit0_val n).trans (add_zero _).symm",
        "annotated_tactic": [
          "apply (<a>bit0_val</a> n).<a>trans</a> (<a>add_zero</a> _).<a>symm</a>",
          [
            {
              "full_name": "Int.bit0_val",
              "def_path": "Mathlib/Data/Int/Bitwise.lean",
              "def_pos": [
                219,
                9
              ],
              "def_end_pos": [
                219,
                17
              ]
            },
            {
              "full_name": "Eq.trans",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                335,
                9
              ],
              "def_end_pos": [
                335,
                17
              ]
            },
            {
              "full_name": "add_zero",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                482,
                3
              ],
              "def_end_pos": [
                482,
                14
              ]
            },
            {
              "full_name": "Eq.symm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                323,
                9
              ],
              "def_end_pos": [
                323,
                16
              ]
            }
          ]
        ],
        "state_before": "case false\nn : \u2124\n\u22a2 bit false n = 2 * n + bif false then 1 else 0",
        "state_after": "no goals"
      },
      {
        "tactic": "apply bit1_val",
        "annotated_tactic": [
          "apply <a>bit1_val</a>",
          [
            {
              "full_name": "Int.bit1_val",
              "def_path": "Mathlib/Data/Int/Bitwise.lean",
              "def_pos": [
                224,
                9
              ],
              "def_end_pos": [
                224,
                17
              ]
            }
          ]
        ],
        "state_before": "case true\nn : \u2124\n\u22a2 bit true n = 2 * n + bif true then 1 else 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9176525939255953,
    "entry_failed": false
  },
  "17233": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/Abelian/Projective.lean",
    "full_name": "CategoryTheory.projective_of_preservesFiniteColimits_preadditiveCoyonedaObj",
    "start": [
      37,
      1
    ],
    "end": [
      42,
      17
    ],
    "traced_tactics": [
      {
        "tactic": "rw [projective_iff_preservesEpimorphisms_preadditiveCoyoneda_obj']",
        "annotated_tactic": [
          "rw [<a>projective_iff_preservesEpimorphisms_preadditiveCoyoneda_obj'</a>]",
          [
            {
              "full_name": "CategoryTheory.Projective.projective_iff_preservesEpimorphisms_preadditiveCoyoneda_obj'",
              "def_path": "Mathlib/CategoryTheory/Preadditive/Yoneda/Projective.lean",
              "def_pos": [
                42,
                9
              ],
              "def_end_pos": [
                42,
                70
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Abelian C\nP : C\nhP : PreservesFiniteColimits (preadditiveCoyonedaObj { unop := P })\n\u22a2 Projective P",
        "state_after": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Abelian C\nP : C\nhP : PreservesFiniteColimits (preadditiveCoyonedaObj { unop := P })\n\u22a2 (preadditiveCoyoneda.obj { unop := P }).PreservesEpimorphisms"
      },
      {
        "tactic": "dsimp only [preadditiveCoyoneda]",
        "annotated_tactic": [
          "dsimp only [<a>preadditiveCoyoneda</a>]",
          [
            {
              "full_name": "CategoryTheory.preadditiveCoyoneda",
              "def_path": "Mathlib/CategoryTheory/Preadditive/Yoneda/Basic.lean",
              "def_pos": [
                84,
                5
              ],
              "def_end_pos": [
                84,
                24
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Abelian C\nP : C\nhP : PreservesFiniteColimits (preadditiveCoyonedaObj { unop := P })\n\u22a2 (preadditiveCoyoneda.obj { unop := P }).PreservesEpimorphisms",
        "state_after": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Abelian C\nP : C\nhP : PreservesFiniteColimits (preadditiveCoyonedaObj { unop := P })\n\u22a2 (preadditiveCoyonedaObj { unop := P } \u22d9 forget\u2082 (ModuleCat (End { unop := P })) AddCommGrp).PreservesEpimorphisms"
      },
      {
        "tactic": "infer_instance",
        "annotated_tactic": [
          "infer_instance",
          []
        ],
        "state_before": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Abelian C\nP : C\nhP : PreservesFiniteColimits (preadditiveCoyonedaObj { unop := P })\n\u22a2 (preadditiveCoyonedaObj { unop := P } \u22d9 forget\u2082 (ModuleCat (End { unop := P })) AddCommGrp).PreservesEpimorphisms",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7348346670623869,
    "entry_failed": false
  },
  "17269": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/PNat/Factors.lean",
    "full_name": "PrimeMultiset.prod_dvd_iff",
    "start": [
      344,
      1
    ],
    "end": [
      347,
      15
    ],
    "traced_tactics": [
      {
        "tactic": "let h := @PNat.factorMultiset_le_iff' u.prod v",
        "annotated_tactic": [
          "let h := @<a>PNat.factorMultiset_le_iff'</a> u.prod v",
          [
            {
              "full_name": "PNat.factorMultiset_le_iff'",
              "def_path": "Mathlib/Data/PNat/Factors.lean",
              "def_pos": [
                333,
                9
              ],
              "def_end_pos": [
                333,
                31
              ]
            }
          ]
        ],
        "state_before": "u v : PrimeMultiset\n\u22a2 u.prod \u2223 v.prod \u2194 u \u2264 v",
        "state_after": "u v : PrimeMultiset\nh : u.prod.factorMultiset \u2264 v \u2194 u.prod \u2223 v.prod := PNat.factorMultiset_le_iff'\n\u22a2 u.prod \u2223 v.prod \u2194 u \u2264 v"
      },
      {
        "tactic": "rw [u.factorMultiset_prod] at h",
        "annotated_tactic": [
          "rw [u.factorMultiset_prod] at h",
          []
        ],
        "state_before": "u v : PrimeMultiset\nh : u.prod.factorMultiset \u2264 v \u2194 u.prod \u2223 v.prod := PNat.factorMultiset_le_iff'\n\u22a2 u.prod \u2223 v.prod \u2194 u \u2264 v",
        "state_after": "u v : PrimeMultiset\nh : u \u2264 v \u2194 u.prod \u2223 v.prod\n\u22a2 u.prod \u2223 v.prod \u2194 u \u2264 v"
      },
      {
        "tactic": "exact h.symm",
        "annotated_tactic": [
          "exact h.symm",
          []
        ],
        "state_before": "u v : PrimeMultiset\nh : u \u2264 v \u2194 u.prod \u2223 v.prod\n\u22a2 u.prod \u2223 v.prod \u2194 u \u2264 v",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.521214379929006,
    "entry_failed": false
  },
  "17299": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Init/Data/Nat/Lemmas.lean",
    "full_name": "Nat.cond_decide_mod_two",
    "start": [
      541,
      1
    ],
    "end": [
      545,
      66
    ],
    "traced_tactics": [
      {
        "tactic": "by_cases h : x % 2 = 1",
        "annotated_tactic": [
          "by_cases h : x % 2 = 1",
          []
        ],
        "state_before": "x : \u2115\nd : Decidable (x % 2 = 1)\n\u22a2 (bif decide (x % 2 = 1) then 1 else 0) = x % 2",
        "state_after": "case pos\nx : \u2115\nd : Decidable (x % 2 = 1)\nh : x % 2 = 1\n\u22a2 (bif decide (x % 2 = 1) then 1 else 0) = x % 2\n\ncase neg\nx : \u2115\nd : Decidable (x % 2 = 1)\nh : \u00acx % 2 = 1\n\u22a2 (bif decide (x % 2 = 1) then 1 else 0) = x % 2"
      },
      {
        "tactic": "simp! [*]",
        "annotated_tactic": [
          "simp! [*]",
          []
        ],
        "state_before": "case pos\nx : \u2115\nd : Decidable (x % 2 = 1)\nh : x % 2 = 1\n\u22a2 (bif decide (x % 2 = 1) then 1 else 0) = x % 2",
        "state_after": "no goals"
      },
      {
        "tactic": "cases mod_two_eq_zero_or_one x <;> simp! [*, Nat.zero_ne_one]",
        "annotated_tactic": [
          "cases <a>mod_two_eq_zero_or_one</a> x <;> simp! [*, <a>Nat.zero_ne_one</a>]",
          [
            {
              "full_name": "Nat.mod_two_eq_zero_or_one",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean",
              "def_pos": [
                531,
                9
              ],
              "def_end_pos": [
                531,
                31
              ]
            },
            {
              "full_name": "Nat.zero_ne_one",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean",
              "def_pos": [
                705,
                19
              ],
              "def_end_pos": [
                705,
                30
              ]
            }
          ]
        ],
        "state_before": "case neg\nx : \u2115\nd : Decidable (x % 2 = 1)\nh : \u00acx % 2 = 1\n\u22a2 (bif decide (x % 2 = 1) then 1 else 0) = x % 2",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2801120480289683,
    "entry_failed": false
  },
  "17303": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Polynomial/Content.lean",
    "full_name": "Polynomial.content_X_pow",
    "start": [
      134,
      1
    ],
    "end": [
      137,
      36
    ],
    "traced_tactics": [
      {
        "tactic": "induction' k with k hi",
        "annotated_tactic": [
          "induction' k with k hi",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\nk : \u2115\n\u22a2 (X ^ k).content = 1",
        "state_after": "case zero\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\n\u22a2 (X ^ 0).content = 1\n\ncase succ\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\nk : \u2115\nhi : (X ^ k).content = 1\n\u22a2 (X ^ (k + 1)).content = 1"
      },
      {
        "tactic": "rw [pow_succ', content_X_mul, hi]",
        "annotated_tactic": [
          "rw [<a>pow_succ'</a>, <a>content_X_mul</a>, hi]",
          [
            {
              "full_name": "pow_succ'",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                667,
                34
              ],
              "def_end_pos": [
                667,
                43
              ]
            },
            {
              "full_name": "Polynomial.content_X_mul",
              "def_path": "Mathlib/RingTheory/Polynomial/Content.lean",
              "def_pos": [
                109,
                9
              ],
              "def_end_pos": [
                109,
                22
              ]
            }
          ]
        ],
        "state_before": "case succ\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\nk : \u2115\nhi : (X ^ k).content = 1\n\u22a2 (X ^ (k + 1)).content = 1",
        "state_after": "no goals"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case zero\nR : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : NormalizedGCDMonoid R\n\u22a2 (X ^ 0).content = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.6312765419716015,
    "entry_failed": false
  },
  "17333": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Log/NegMulLog.lean",
    "full_name": "Real.hasDerivAt_mul_log",
    "start": [
      50,
      1
    ],
    "end": [
      53,
      12
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 deriv_mul_log hx, hasDerivAt_deriv_iff]",
        "annotated_tactic": [
          "rw [\u2190 <a>deriv_mul_log</a> hx, <a>hasDerivAt_deriv_iff</a>]",
          [
            {
              "full_name": "Real.deriv_mul_log",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Log/NegMulLog.lean",
              "def_pos": [
                45,
                7
              ],
              "def_end_pos": [
                45,
                20
              ]
            },
            {
              "full_name": "hasDerivAt_deriv_iff",
              "def_path": "Mathlib/Analysis/Calculus/Deriv/Basic.lean",
              "def_pos": [
                438,
                9
              ],
              "def_end_pos": [
                438,
                29
              ]
            }
          ]
        ],
        "state_before": "x : \u211d\nhx : x \u2260 0\n\u22a2 HasDerivAt (fun x => x * log x) (log x + 1) x",
        "state_after": "x : \u211d\nhx : x \u2260 0\n\u22a2 DifferentiableAt \u211d (fun x => x * log x) x"
      },
      {
        "tactic": "refine DifferentiableOn.differentiableAt differentiableOn_mul_log ?_",
        "annotated_tactic": [
          "refine <a>DifferentiableOn.differentiableAt</a> <a>differentiableOn_mul_log</a> ?_",
          [
            {
              "full_name": "DifferentiableOn.differentiableAt",
              "def_path": "Mathlib/Analysis/Calculus/FDeriv/Basic.lean",
              "def_pos": [
                564,
                9
              ],
              "def_end_pos": [
                564,
                42
              ]
            },
            {
              "full_name": "Real.differentiableOn_mul_log",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Log/NegMulLog.lean",
              "def_pos": [
                42,
                7
              ],
              "def_end_pos": [
                42,
                31
              ]
            }
          ]
        ],
        "state_before": "x : \u211d\nhx : x \u2260 0\n\u22a2 DifferentiableAt \u211d (fun x => x * log x) x",
        "state_after": "x : \u211d\nhx : x \u2260 0\n\u22a2 {0}\u1d9c \u2208 \ud835\udcdd x"
      },
      {
        "tactic": "simp [hx]",
        "annotated_tactic": [
          "simp [hx]",
          []
        ],
        "state_before": "x : \u211d\nhx : x \u2260 0\n\u22a2 {0}\u1d9c \u2208 \ud835\udcdd x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.1589615190168843,
    "entry_failed": false
  },
  "17370": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/AlgebraicTopology/SimplexCategory.lean",
    "full_name": "SimplexCategory.\u03b4_comp_\u03b4''",
    "start": [
      250,
      1
    ],
    "end": [
      255,
      12
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u03b4_comp_\u03b4]",
        "annotated_tactic": [
          "rw [<a>\u03b4_comp_\u03b4</a>]",
          [
            {
              "full_name": "SimplexCategory.\u03b4_comp_\u03b4",
              "def_path": "Mathlib/AlgebraicTopology/SimplexCategory.lean",
              "def_pos": [
                230,
                9
              ],
              "def_end_pos": [
                230,
                17
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\ni : Fin (n + 3)\nj : Fin (n + 2)\nH : i \u2264 j.castSucc\n\u22a2 \u03b4 (i.castLT \u22ef) \u226b \u03b4 j.succ = \u03b4 j \u226b \u03b4 i",
        "state_after": "n : \u2115\ni : Fin (n + 3)\nj : Fin (n + 2)\nH : i \u2264 j.castSucc\n\u22a2 \u03b4 j \u226b \u03b4 (i.castLT \u22ef).castSucc = \u03b4 j \u226b \u03b4 i\n\nn : \u2115\ni : Fin (n + 3)\nj : Fin (n + 2)\nH : i \u2264 j.castSucc\n\u22a2 i.castLT \u22ef \u2264 j"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "n : \u2115\ni : Fin (n + 3)\nj : Fin (n + 2)\nH : i \u2264 j.castSucc\n\u22a2 \u03b4 j \u226b \u03b4 (i.castLT \u22ef).castSucc = \u03b4 j \u226b \u03b4 i",
        "state_after": "no goals"
      },
      {
        "tactic": "exact H",
        "annotated_tactic": [
          "exact H",
          []
        ],
        "state_before": "n : \u2115\ni : Fin (n + 3)\nj : Fin (n + 2)\nH : i \u2264 j.castSucc\n\u22a2 i.castLT \u22ef \u2264 j",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.0721358199371025,
    "entry_failed": false
  },
  "17395": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/PowerSeries/Order.lean",
    "full_name": "PowerSeries.order_eq_nat",
    "start": [
      134,
      1
    ],
    "end": [
      139,
      44
    ],
    "traced_tactics": [
      {
        "tactic": "rcases eq_or_ne \u03c6 0 with (rfl | h\u03c6)",
        "annotated_tactic": [
          "rcases <a>eq_or_ne</a> \u03c6 0 with (rfl | h\u03c6)",
          [
            {
              "full_name": "eq_or_ne",
              "def_path": "Mathlib/Logic/Basic.lean",
              "def_pos": [
                212,
                9
              ],
              "def_end_pos": [
                212,
                17
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d : Semiring R\n\u03c6\u271d \u03c6 : R\u27e6X\u27e7\nn : \u2115\n\u22a2 \u03c6.order = \u2191n \u2194 (coeff R n) \u03c6 \u2260 0 \u2227 \u2200 i < n, (coeff R i) \u03c6 = 0",
        "state_after": "case inl\nR : Type u_1\ninst\u271d : Semiring R\n\u03c6 : R\u27e6X\u27e7\nn : \u2115\n\u22a2 order 0 = \u2191n \u2194 (coeff R n) 0 \u2260 0 \u2227 \u2200 i < n, (coeff R i) 0 = 0\n\ncase inr\nR : Type u_1\ninst\u271d : Semiring R\n\u03c6\u271d \u03c6 : R\u27e6X\u27e7\nn : \u2115\nh\u03c6 : \u03c6 \u2260 0\n\u22a2 \u03c6.order = \u2191n \u2194 (coeff R n) \u03c6 \u2260 0 \u2227 \u2200 i < n, (coeff R i) \u03c6 = 0"
      },
      {
        "tactic": "simp [order, dif_neg h\u03c6, Nat.find_eq_iff]",
        "annotated_tactic": [
          "simp [<a>order</a>, <a>dif_neg</a> h\u03c6, <a>Nat.find_eq_iff</a>]",
          [
            {
              "full_name": "PowerSeries.order",
              "def_path": "Mathlib/RingTheory/PowerSeries/Order.lean",
              "def_pos": [
                56,
                5
              ],
              "def_end_pos": [
                56,
                10
              ]
            },
            {
              "full_name": "dif_neg",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                954,
                9
              ],
              "def_end_pos": [
                954,
                16
              ]
            },
            {
              "full_name": "Nat.find_eq_iff",
              "def_path": "Mathlib/Data/Nat/Defs.lean",
              "def_pos": [
                1731,
                7
              ],
              "def_end_pos": [
                1731,
                18
              ]
            }
          ]
        ],
        "state_before": "case inr\nR : Type u_1\ninst\u271d : Semiring R\n\u03c6\u271d \u03c6 : R\u27e6X\u27e7\nn : \u2115\nh\u03c6 : \u03c6 \u2260 0\n\u22a2 \u03c6.order = \u2191n \u2194 (coeff R n) \u03c6 \u2260 0 \u2227 \u2200 i < n, (coeff R i) \u03c6 = 0",
        "state_after": "no goals"
      },
      {
        "tactic": "simpa [(coeff R _).map_zero] using (PartENat.natCast_ne_top _).symm",
        "annotated_tactic": [
          "simpa [(<a>coeff</a> R _).<a>map_zero</a>] using (<a>PartENat.natCast_ne_top</a> _).<a>symm</a>",
          [
            {
              "full_name": "PowerSeries.coeff",
              "def_path": "Mathlib/RingTheory/PowerSeries/Basic.lean",
              "def_pos": [
                139,
                5
              ],
              "def_end_pos": [
                139,
                10
              ]
            },
            {
              "full_name": "LinearMap.map_zero",
              "def_path": "Mathlib/Algebra/Module/LinearMap/Defs.lean",
              "def_pos": [
                363,
                19
              ],
              "def_end_pos": [
                363,
                27
              ]
            },
            {
              "full_name": "PartENat.natCast_ne_top",
              "def_path": "Mathlib/Data/Nat/PartENat.lean",
              "def_pos": [
                380,
                9
              ],
              "def_end_pos": [
                380,
                23
              ]
            },
            {
              "full_name": "Ne.symm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                704,
                9
              ],
              "def_end_pos": [
                704,
                16
              ]
            }
          ]
        ],
        "state_before": "case inl\nR : Type u_1\ninst\u271d : Semiring R\n\u03c6 : R\u27e6X\u27e7\nn : \u2115\n\u22a2 order 0 = \u2191n \u2194 (coeff R n) 0 \u2260 0 \u2227 \u2200 i < n, (coeff R i) 0 = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.466879906016402,
    "entry_failed": false
  },
  "17432": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Tropical/BigOperators.lean",
    "full_name": "Multiset.trop_inf",
    "start": [
      85,
      1
    ],
    "end": [
      89,
      16
    ],
    "traced_tactics": [
      {
        "tactic": "induction' s using Multiset.induction with s x IH",
        "annotated_tactic": [
          "induction' s using <a>Multiset.induction</a> with s x IH",
          [
            {
              "full_name": "Multiset.induction",
              "def_path": "Mathlib/Data/Multiset/Basic.lean",
              "def_pos": [
                168,
                19
              ],
              "def_end_pos": [
                168,
                28
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : Multiset R\n\u22a2 trop s.inf = (map trop s).sum",
        "state_after": "case empty\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\n\u22a2 trop (inf 0) = (map trop 0).sum\n\ncase cons\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : R\nx : Multiset R\nIH : trop x.inf = (map trop x).sum\n\u22a2 trop (s ::\u2098 x).inf = (map trop (s ::\u2098 x)).sum"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case empty\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\n\u22a2 trop (inf 0) = (map trop 0).sum",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [\u2190 IH]",
        "annotated_tactic": [
          "simp [\u2190 IH]",
          []
        ],
        "state_before": "case cons\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : OrderTop R\ns : R\nx : Multiset R\nIH : trop x.inf = (map trop x).sum\n\u22a2 trop (s ::\u2098 x).inf = (map trop (s ::\u2098 x)).sum",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8683187830029055,
    "entry_failed": false
  },
  "17543": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Bits.lean",
    "full_name": "Nat.div2_bits_eq_tail",
    "start": [
      622,
      1
    ],
    "end": [
      624,
      41
    ],
    "traced_tactics": [
      {
        "tactic": "induction' n using Nat.binaryRec' with b n h _",
        "annotated_tactic": [
          "induction' n using <a>Nat.binaryRec'</a> with b n h _",
          [
            {
              "full_name": "Nat.binaryRec'",
              "def_path": "Mathlib/Data/Nat/Bits.lean",
              "def_pos": [
                566,
                5
              ],
              "def_end_pos": [
                566,
                15
              ]
            }
          ]
        ],
        "state_before": "m n\u271d n : \u2115\n\u22a2 n.div2.bits = n.bits.tail",
        "state_after": "case z\nm n : \u2115\n\u22a2 (div2 0).bits = (bits 0).tail\n\ncase f\nm n\u271d : \u2115\nb : Bool\nn : \u2115\nh : n = 0 \u2192 b = true\na\u271d : n.div2.bits = n.bits.tail\n\u22a2 (bit b n).div2.bits = (bit b n).bits.tail"
      },
      {
        "tactic": "simp [div2_bit, bits_append_bit _ _ h]",
        "annotated_tactic": [
          "simp [<a>div2_bit</a>, <a>bits_append_bit</a> _ _ h]",
          [
            {
              "full_name": "Nat.div2_bit",
              "def_path": "Mathlib/Data/Nat/Bits.lean",
              "def_pos": [
                259,
                7
              ],
              "def_end_pos": [
                259,
                15
              ]
            },
            {
              "full_name": "Nat.bits_append_bit",
              "def_path": "Mathlib/Data/Nat/Bits.lean",
              "def_pos": [
                592,
                9
              ],
              "def_end_pos": [
                592,
                24
              ]
            }
          ]
        ],
        "state_before": "case f\nm n\u271d : \u2115\nb : Bool\nn : \u2115\nh : n = 0 \u2192 b = true\na\u271d : n.div2.bits = n.bits.tail\n\u22a2 (bit b n).div2.bits = (bit b n).bits.tail",
        "state_after": "no goals"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case z\nm n : \u2115\n\u22a2 (div2 0).bits = (bits 0).tail",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.5301822749897838,
    "entry_failed": false
  },
  "17548": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Polynomial/Monic.lean",
    "full_name": "Polynomial.monic_C_mul_of_mul_leadingCoeff_eq_one",
    "start": [
      76,
      1
    ],
    "end": [
      80,
      59
    ],
    "traced_tactics": [
      {
        "tactic": "unfold Monic",
        "annotated_tactic": [
          "unfold <a>Monic</a>",
          [
            {
              "full_name": "Polynomial.Monic",
              "def_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
              "def_pos": [
                77,
                5
              ],
              "def_end_pos": [
                77,
                10
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\na b\u271d : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nb : R\nhp : b * p.leadingCoeff = 1\n\u22a2 (C b * p).Monic",
        "state_after": "R : Type u\nS : Type v\na b\u271d : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nb : R\nhp : b * p.leadingCoeff = 1\n\u22a2 (C b * p).leadingCoeff = 1"
      },
      {
        "tactic": "nontriviality",
        "annotated_tactic": [
          "nontriviality",
          []
        ],
        "state_before": "R : Type u\nS : Type v\na b\u271d : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nb : R\nhp : b * p.leadingCoeff = 1\n\u22a2 (C b * p).leadingCoeff = 1",
        "state_after": "R : Type u\nS : Type v\na b\u271d : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nb : R\nhp : b * p.leadingCoeff = 1\na\u271d : Nontrivial R\n\u22a2 (C b * p).leadingCoeff = 1"
      },
      {
        "tactic": "rw [leadingCoeff_mul' _] <;> simp [leadingCoeff_C b, hp]",
        "annotated_tactic": [
          "rw [<a>leadingCoeff_mul'</a> _] <;> simp [<a>leadingCoeff_C</a> b, hp]",
          [
            {
              "full_name": "Polynomial.leadingCoeff_mul'",
              "def_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
              "def_pos": [
                1020,
                9
              ],
              "def_end_pos": [
                1020,
                26
              ]
            },
            {
              "full_name": "Polynomial.leadingCoeff_C",
              "def_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
              "def_pos": [
                875,
                9
              ],
              "def_end_pos": [
                875,
                23
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\na b\u271d : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nb : R\nhp : b * p.leadingCoeff = 1\na\u271d : Nontrivial R\n\u22a2 (C b * p).leadingCoeff = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.03985746006947,
    "entry_failed": false
  },
  "17608": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Computability/Encoding.lean",
    "full_name": "Computability.decode_encodeNat",
    "start": [
      152,
      1
    ],
    "end": [
      155,
      55
    ],
    "traced_tactics": [
      {
        "tactic": "intro n",
        "annotated_tactic": [
          "intro n",
          []
        ],
        "state_before": "\u22a2 \u2200 (n : \u2115), decodeNat (encodeNat n) = n",
        "state_after": "n : \u2115\n\u22a2 decodeNat (encodeNat n) = n"
      },
      {
        "tactic": "conv_rhs => rw [\u2190 Num.to_of_nat n]",
        "annotated_tactic": [
          "conv_rhs => rw [\u2190 <a>Num.to_of_nat</a> n]",
          [
            {
              "full_name": "Num.to_of_nat",
              "def_path": "Mathlib/Data/Num/Lemmas.lean",
              "def_pos": [
                478,
                9
              ],
              "def_end_pos": [
                478,
                18
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\n\u22a2 decodeNat (encodeNat n) = n",
        "state_after": "n : \u2115\n\u22a2 decodeNat (encodeNat n) = \u2191\u2191n"
      },
      {
        "tactic": "exact congr_arg ((\u2191) : Num \u2192 \u2115) (decode_encodeNum n)",
        "annotated_tactic": [
          "exact <a>congr_arg</a> ((\u2191) : <a>Num</a> \u2192 \u2115) (<a>decode_encodeNum</a> n)",
          [
            {
              "full_name": "congr_arg",
              "def_path": ".lake/packages/batteries/Batteries/Logic.lean",
              "def_pos": [
                76,
                7
              ],
              "def_end_pos": [
                76,
                16
              ]
            },
            {
              "full_name": "Num",
              "def_path": "Mathlib/Data/Num/Basic.lean",
              "def_pos": [
                41,
                11
              ],
              "def_end_pos": [
                41,
                14
              ]
            },
            {
              "full_name": "Computability.decode_encodeNum",
              "def_path": "Mathlib/Computability/Encoding.lean",
              "def_pos": [
                143,
                9
              ],
              "def_end_pos": [
                143,
                25
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\n\u22a2 decodeNat (encodeNat n) = \u2191\u2191n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.638193532009609,
    "entry_failed": false
  },
  "17642": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Instances/NNReal.lean",
    "full_name": "HasSum.toNNReal",
    "start": [
      185,
      11
    ],
    "end": [
      189,
      30
    ],
    "traced_tactics": [
      {
        "tactic": "lift y to \u211d\u22650 using hy.nonneg hf\u2080",
        "annotated_tactic": [
          "lift y to \u211d\u22650 using hy.nonneg hf\u2080",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\ny : \u211d\nhf\u2080 : \u2200 (n : \u03b1), 0 \u2264 f n\nhy : HasSum f y\n\u22a2 HasSum (fun x => (f x).toNNReal) y.toNNReal",
        "state_after": "case intro\n\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf\u2080 : \u2200 (n : \u03b1), 0 \u2264 f n\ny : \u211d\u22650\nhy : HasSum f \u2191y\n\u22a2 HasSum (fun x => (f x).toNNReal) (\u2191y).toNNReal"
      },
      {
        "tactic": "lift f to \u03b1 \u2192 \u211d\u22650 using hf\u2080",
        "annotated_tactic": [
          "lift f to \u03b1 \u2192 \u211d\u22650 using hf\u2080",
          []
        ],
        "state_before": "case intro\n\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\nhf\u2080 : \u2200 (n : \u03b1), 0 \u2264 f n\ny : \u211d\u22650\nhy : HasSum f \u2191y\n\u22a2 HasSum (fun x => (f x).toNNReal) (\u2191y).toNNReal",
        "state_after": "case intro.intro\n\u03b1 : Type u_1\ny : \u211d\u22650\nf : \u03b1 \u2192 \u211d\u22650\nhy : HasSum (fun i => \u2191(f i)) \u2191y\n\u22a2 HasSum (fun x => ((fun i => \u2191(f i)) x).toNNReal) (\u2191y).toNNReal"
      },
      {
        "tactic": "simpa [hasSum_coe] using hy",
        "annotated_tactic": [
          "simpa [<a>hasSum_coe</a>] using hy",
          [
            {
              "full_name": "NNReal.hasSum_coe",
              "def_path": "Mathlib/Topology/Instances/NNReal.lean",
              "def_pos": [
                181,
                9
              ],
              "def_end_pos": [
                181,
                19
              ]
            }
          ]
        ],
        "state_before": "case intro.intro\n\u03b1 : Type u_1\ny : \u211d\u22650\nf : \u03b1 \u2192 \u211d\u22650\nhy : HasSum (fun i => \u2191(f i)) \u2191y\n\u22a2 HasSum (fun x => ((fun i => \u2191(f i)) x).toNNReal) (\u2191y).toNNReal",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.5128595050191507,
    "entry_failed": false
  },
  "17707": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Sym/Sym2.lean",
    "full_name": "Sym2.map.injective",
    "start": [
      284,
      1
    ],
    "end": [
      287,
      21
    ],
    "traced_tactics": [
      {
        "tactic": "intro z z'",
        "annotated_tactic": [
          "intro z z'",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\nhinj : Injective f\n\u22a2 Injective (map f)",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\nhinj : Injective f\nz z' : Sym2 \u03b1\n\u22a2 map f z = map f z' \u2192 z = z'"
      },
      {
        "tactic": "refine Sym2.inductionOn\u2082 z z' (fun x y x' y' => ?_)",
        "annotated_tactic": [
          "refine <a>Sym2.inductionOn\u2082</a> z z' (fun x y x' y' => ?_)",
          [
            {
              "full_name": "Sym2.inductionOn\u2082",
              "def_path": "Mathlib/Data/Sym/Sym2.lean",
              "def_pos": [
                138,
                19
              ],
              "def_end_pos": [
                138,
                31
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\nhinj : Injective f\nz z' : Sym2 \u03b1\n\u22a2 map f z = map f z' \u2192 z = z'",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\nhinj : Injective f\nz z' : Sym2 \u03b1\nx y x' y' : \u03b1\n\u22a2 map f s(x, y) = map f s(x', y') \u2192 s(x, y) = s(x', y')"
      },
      {
        "tactic": "simp [hinj.eq_iff]",
        "annotated_tactic": [
          "simp [hinj.eq_iff]",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\nhinj : Injective f\nz z' : Sym2 \u03b1\nx y x' y' : \u03b1\n\u22a2 map f s(x, y) = map f s(x', y') \u2192 s(x, y) = s(x', y')",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.3723358659772202,
    "entry_failed": false
  },
  "17724": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Category/Compactum.lean",
    "full_name": "Compactum.isClosed_cl",
    "start": [
      275,
      1
    ],
    "end": [
      278,
      29
    ],
    "traced_tactics": [
      {
        "tactic": "rw [isClosed_iff]",
        "annotated_tactic": [
          "rw [<a>isClosed_iff</a>]",
          [
            {
              "full_name": "Compactum.isClosed_iff",
              "def_path": "Mathlib/Topology/Category/Compactum.lean",
              "def_pos": [
                172,
                9
              ],
              "def_end_pos": [
                172,
                21
              ]
            }
          ]
        ],
        "state_before": "X : Compactum\nA : Set X.A\n\u22a2 IsClosed (Compactum.cl A)",
        "state_after": "X : Compactum\nA : Set X.A\n\u22a2 \u2200 (F : Ultrafilter X.A), Compactum.cl A \u2208 F \u2192 X.str F \u2208 Compactum.cl A"
      },
      {
        "tactic": "intro F hF",
        "annotated_tactic": [
          "intro F hF",
          []
        ],
        "state_before": "X : Compactum\nA : Set X.A\n\u22a2 \u2200 (F : Ultrafilter X.A), Compactum.cl A \u2208 F \u2192 X.str F \u2208 Compactum.cl A",
        "state_after": "X : Compactum\nA : Set X.A\nF : Ultrafilter X.A\nhF : Compactum.cl A \u2208 F\n\u22a2 X.str F \u2208 Compactum.cl A"
      },
      {
        "tactic": "exact cl_cl _ \u27e8F, hF, rfl\u27e9",
        "annotated_tactic": [
          "exact <a>cl_cl</a> _ \u27e8F, hF, <a>rfl</a>\u27e9",
          [
            {
              "full_name": "_private.Mathlib.Topology.Category.Compactum.0.Compactum.cl_cl",
              "def_path": "Mathlib/Topology/Category/Compactum.lean",
              "def_pos": [
                216,
                17
              ],
              "def_end_pos": [
                216,
                22
              ]
            },
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "X : Compactum\nA : Set X.A\nF : Ultrafilter X.A\nhF : Compactum.cl A \u2208 F\n\u22a2 X.str F \u2208 Compactum.cl A",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.80856215802487,
    "entry_failed": false
  },
  "17754": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/Function/LpSeminorm/TriangleInequality.lean",
    "full_name": "MeasureTheory.LpAddConst_zero",
    "start": [
      80,
      1
    ],
    "end": [
      83,
      24
    ],
    "traced_tactics": [
      {
        "tactic": "rw [LpAddConst, if_neg]",
        "annotated_tactic": [
          "rw [<a>LpAddConst</a>, <a>if_neg</a>]",
          [
            {
              "full_name": "MeasureTheory.LpAddConst",
              "def_path": "Mathlib/MeasureTheory/Function/LpSeminorm/TriangleInequality.lean",
              "def_pos": [
                68,
                19
              ],
              "def_end_pos": [
                68,
                29
              ]
            },
            {
              "full_name": "if_neg",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                937,
                9
              ],
              "def_end_pos": [
                937,
                15
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\np : \u211d\u22650\u221e\nq : \u211d\n\u03bc : Measure \u03b1\nf g : \u03b1 \u2192 E\n\u22a2 LpAddConst 0 = 1",
        "state_after": "case hnc\n\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\np : \u211d\u22650\u221e\nq : \u211d\n\u03bc : Measure \u03b1\nf g : \u03b1 \u2192 E\n\u22a2 0 \u2209 Set.Ioo 0 1"
      },
      {
        "tactic": "intro h",
        "annotated_tactic": [
          "intro h",
          []
        ],
        "state_before": "case hnc\n\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\np : \u211d\u22650\u221e\nq : \u211d\n\u03bc : Measure \u03b1\nf g : \u03b1 \u2192 E\n\u22a2 0 \u2209 Set.Ioo 0 1",
        "state_after": "case hnc\n\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\np : \u211d\u22650\u221e\nq : \u211d\n\u03bc : Measure \u03b1\nf g : \u03b1 \u2192 E\nh : 0 \u2208 Set.Ioo 0 1\n\u22a2 False"
      },
      {
        "tactic": "exact lt_irrefl _ h.1",
        "annotated_tactic": [
          "exact <a>lt_irrefl</a> _ h.1",
          [
            {
              "full_name": "lt_irrefl",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                79,
                9
              ],
              "def_end_pos": [
                79,
                18
              ]
            }
          ]
        ],
        "state_before": "case hnc\n\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\np : \u211d\u22650\u221e\nq : \u211d\n\u03bc : Measure \u03b1\nf g : \u03b1 \u2192 E\nh : 0 \u2208 Set.Ioo 0 1\n\u22a2 False",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.744924974977039,
    "entry_failed": false
  },
  "17767": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Vector/Basic.lean",
    "full_name": "Vector.nodup_iff_injective_get",
    "start": [
      231,
      1
    ],
    "end": [
      234,
      37
    ],
    "traced_tactics": [
      {
        "tactic": "cases' v with l hl",
        "annotated_tactic": [
          "cases' v with l hl",
          []
        ],
        "state_before": "n : \u2115\n\u03b1 : Type u_1\nv : Vector \u03b1 n\n\u22a2 v.toList.Nodup \u2194 Function.Injective v.get",
        "state_after": "case mk\nn : \u2115\n\u03b1 : Type u_1\nl : List \u03b1\nhl : l.length = n\n\u22a2 (toList \u27e8l, hl\u27e9).Nodup \u2194 Function.Injective (get \u27e8l, hl\u27e9)"
      },
      {
        "tactic": "subst hl",
        "annotated_tactic": [
          "subst hl",
          []
        ],
        "state_before": "case mk\nn : \u2115\n\u03b1 : Type u_1\nl : List \u03b1\nhl : l.length = n\n\u22a2 (toList \u27e8l, hl\u27e9).Nodup \u2194 Function.Injective (get \u27e8l, hl\u27e9)",
        "state_after": "case mk\n\u03b1 : Type u_1\nl : List \u03b1\n\u22a2 (toList \u27e8l, \u22ef\u27e9).Nodup \u2194 Function.Injective (get \u27e8l, \u22ef\u27e9)"
      },
      {
        "tactic": "exact List.nodup_iff_injective_get",
        "annotated_tactic": [
          "exact <a>List.nodup_iff_injective_get</a>",
          [
            {
              "full_name": "List.nodup_iff_injective_get",
              "def_path": "Mathlib/Data/List/Nodup.lean",
              "def_pos": [
                103,
                9
              ],
              "def_end_pos": [
                103,
                32
              ]
            }
          ]
        ],
        "state_before": "case mk\n\u03b1 : Type u_1\nl : List \u03b1\n\u22a2 (toList \u27e8l, \u22ef\u27e9).Nodup \u2194 Function.Injective (get \u27e8l, \u22ef\u27e9)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.400278736022301,
    "entry_failed": false
  },
  "17777": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Cycle.lean",
    "full_name": "List.nextOr_cons_of_ne",
    "start": [
      54,
      1
    ],
    "end": [
      58,
      19
    ],
    "traced_tactics": [
      {
        "tactic": "cases' xs with z zs",
        "annotated_tactic": [
          "cases' xs with z zs",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nxs : List \u03b1\ny x d : \u03b1\nh : x \u2260 y\n\u22a2 (y :: xs).nextOr x d = xs.nextOr x d",
        "state_after": "case nil\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ny x d : \u03b1\nh : x \u2260 y\n\u22a2 [y].nextOr x d = [].nextOr x d\n\ncase cons\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ny x d : \u03b1\nh : x \u2260 y\nz : \u03b1\nzs : List \u03b1\n\u22a2 (y :: z :: zs).nextOr x d = (z :: zs).nextOr x d"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case nil\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ny x d : \u03b1\nh : x \u2260 y\n\u22a2 [y].nextOr x d = [].nextOr x d",
        "state_after": "no goals"
      },
      {
        "tactic": "exact if_neg h",
        "annotated_tactic": [
          "exact <a>if_neg</a> h",
          [
            {
              "full_name": "if_neg",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                937,
                9
              ],
              "def_end_pos": [
                937,
                15
              ]
            }
          ]
        ],
        "state_before": "case cons\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ny x d : \u03b1\nh : x \u2260 y\nz : \u03b1\nzs : List \u03b1\n\u22a2 (y :: z :: zs).nextOr x d = (z :: zs).nextOr x d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.1356875660130754,
    "entry_failed": false
  },
  "17783": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Squarefree.lean",
    "full_name": "Nat.minSqFac_dvd",
    "start": [
      229,
      1
    ],
    "end": [
      232,
      17
    ],
    "traced_tactics": [
      {
        "tactic": "have := minSqFac_has_prop n",
        "annotated_tactic": [
          "have := <a>minSqFac_has_prop</a> n",
          [
            {
              "full_name": "Nat.minSqFac_has_prop",
              "def_path": "Mathlib/Data/Nat/Squarefree.lean",
              "def_pos": [
                203,
                9
              ],
              "def_end_pos": [
                203,
                26
              ]
            }
          ]
        ],
        "state_before": "s : Finset \u2115\nm n\u271d p n d : \u2115\nh : n.minSqFac = some d\n\u22a2 d * d \u2223 n",
        "state_after": "s : Finset \u2115\nm n\u271d p n d : \u2115\nh : n.minSqFac = some d\nthis : n.MinSqFacProp n.minSqFac\n\u22a2 d * d \u2223 n"
      },
      {
        "tactic": "rw [h] at this",
        "annotated_tactic": [
          "rw [h] at this",
          []
        ],
        "state_before": "s : Finset \u2115\nm n\u271d p n d : \u2115\nh : n.minSqFac = some d\nthis : n.MinSqFacProp n.minSqFac\n\u22a2 d * d \u2223 n",
        "state_after": "s : Finset \u2115\nm n\u271d p n d : \u2115\nh : n.minSqFac = some d\nthis : n.MinSqFacProp (some d)\n\u22a2 d * d \u2223 n"
      },
      {
        "tactic": "exact this.2.1",
        "annotated_tactic": [
          "exact this.2.1",
          []
        ],
        "state_before": "s : Finset \u2115\nm n\u271d p n d : \u2115\nh : n.minSqFac = some d\nthis : n.MinSqFacProp (some d)\n\u22a2 d * d \u2223 n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.255699899047613,
    "entry_failed": false
  },
  "17785": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Int/GCD.lean",
    "full_name": "Nat.xgcd_val",
    "start": [
      112,
      1
    ],
    "end": [
      113,
      40
    ],
    "traced_tactics": [
      {
        "tactic": "unfold gcdA gcdB",
        "annotated_tactic": [
          "unfold <a>gcdA</a> <a>gcdB</a>",
          [
            {
              "full_name": "Nat.gcdA",
              "def_path": "Mathlib/Data/Int/GCD.lean",
              "def_pos": [
                64,
                5
              ],
              "def_end_pos": [
                64,
                9
              ]
            },
            {
              "full_name": "Nat.gcdB",
              "def_path": "Mathlib/Data/Int/GCD.lean",
              "def_pos": [
                69,
                5
              ],
              "def_end_pos": [
                69,
                9
              ]
            }
          ]
        ],
        "state_before": "x y : \u2115\n\u22a2 x.xgcd y = (x.gcdA y, x.gcdB y)",
        "state_after": "x y : \u2115\n\u22a2 x.xgcd y = ((x.xgcd y).1, (x.xgcd y).2)"
      },
      {
        "tactic": "cases xgcd x y",
        "annotated_tactic": [
          "cases <a>xgcd</a> x y",
          [
            {
              "full_name": "Nat.xgcd",
              "def_path": "Mathlib/Data/Int/GCD.lean",
              "def_pos": [
                59,
                5
              ],
              "def_end_pos": [
                59,
                9
              ]
            }
          ]
        ],
        "state_before": "x y : \u2115\n\u22a2 x.xgcd y = ((x.xgcd y).1, (x.xgcd y).2)",
        "state_after": "case mk\nx y : \u2115\nfst\u271d snd\u271d : \u2124\n\u22a2 (fst\u271d, snd\u271d) = ((fst\u271d, snd\u271d).1, (fst\u271d, snd\u271d).2)"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case mk\nx y : \u2115\nfst\u271d snd\u271d : \u2124\n\u22a2 (fst\u271d, snd\u271d) = ((fst\u271d, snd\u271d).1, (fst\u271d, snd\u271d).2)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.664206554996781,
    "entry_failed": false
  },
  "17814": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Totient.lean",
    "full_name": "Nat.totient_mul_of_prime_of_dvd",
    "start": [
      370,
      1
    ],
    "end": [
      374,
      56
    ],
    "traced_tactics": [
      {
        "tactic": "have h1 := totient_gcd_mul_totient_mul p n",
        "annotated_tactic": [
          "have h1 := <a>totient_gcd_mul_totient_mul</a> p n",
          [
            {
              "full_name": "Nat.totient_gcd_mul_totient_mul",
              "def_path": "Mathlib/Data/Nat/Totient.lean",
              "def_pos": [
                330,
                9
              ],
              "def_end_pos": [
                330,
                36
              ]
            }
          ]
        ],
        "state_before": "p n : \u2115\nhp : Prime p\nh : p \u2223 n\n\u22a2 \u03c6 (p * n) = p * \u03c6 n",
        "state_after": "p n : \u2115\nhp : Prime p\nh : p \u2223 n\nh1 : \u03c6 (p.gcd n) * \u03c6 (p * n) = \u03c6 p * \u03c6 n * p.gcd n\n\u22a2 \u03c6 (p * n) = p * \u03c6 n"
      },
      {
        "tactic": "rw [gcd_eq_left h, mul_assoc] at h1",
        "annotated_tactic": [
          "rw [<a>gcd_eq_left</a> h, <a>mul_assoc</a>] at h1",
          [
            {
              "full_name": "Nat.gcd_eq_left",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Gcd.lean",
              "def_pos": [
                189,
                9
              ],
              "def_end_pos": [
                189,
                20
              ]
            },
            {
              "full_name": "mul_assoc",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                289,
                9
              ],
              "def_end_pos": [
                289,
                18
              ]
            }
          ]
        ],
        "state_before": "p n : \u2115\nhp : Prime p\nh : p \u2223 n\nh1 : \u03c6 (p.gcd n) * \u03c6 (p * n) = \u03c6 p * \u03c6 n * p.gcd n\n\u22a2 \u03c6 (p * n) = p * \u03c6 n",
        "state_after": "p n : \u2115\nhp : Prime p\nh : p \u2223 n\nh1 : \u03c6 p * \u03c6 (p * n) = \u03c6 p * (\u03c6 n * p)\n\u22a2 \u03c6 (p * n) = p * \u03c6 n"
      },
      {
        "tactic": "simpa [(totient_pos.2 hp.pos).ne', mul_comm] using h1",
        "annotated_tactic": [
          "simpa [(<a>totient_pos</a>.2 hp.pos).<a>ne'</a>, <a>mul_comm</a>] using h1",
          [
            {
              "full_name": "Nat.totient_pos",
              "def_path": "Mathlib/Data/Nat/Totient.lean",
              "def_pos": [
                74,
                17
              ],
              "def_end_pos": [
                74,
                28
              ]
            },
            {
              "full_name": "LT.lt.ne'",
              "def_path": "Mathlib/Order/Basic.lean",
              "def_pos": [
                306,
                9
              ],
              "def_end_pos": [
                306,
                12
              ]
            },
            {
              "full_name": "mul_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                332,
                9
              ],
              "def_end_pos": [
                332,
                17
              ]
            }
          ]
        ],
        "state_before": "p n : \u2115\nhp : Prime p\nh : p \u2223 n\nh1 : \u03c6 p * \u03c6 (p * n) = \u03c6 p * (\u03c6 n * p)\n\u22a2 \u03c6 (p * n) = p * \u03c6 n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.4091982879908755,
    "entry_failed": false
  },
  "17899": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Dynamics/PeriodicPts.lean",
    "full_name": "Function.iterate_add_minimalPeriod_eq",
    "start": [
      292,
      1
    ],
    "end": [
      295,
      39
    ],
    "traced_tactics": [
      {
        "tactic": "rw [iterate_add_apply]",
        "annotated_tactic": [
          "rw [<a>iterate_add_apply</a>]",
          [
            {
              "full_name": "Function.iterate_add_apply",
              "def_path": "Mathlib/Logic/Function/Iterate.lean",
              "def_pos": [
                80,
                9
              ],
              "def_end_pos": [
                80,
                26
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf fa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nx y : \u03b1\nm n : \u2115\n\u22a2 f^[n + minimalPeriod f x] x = f^[n] x",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf fa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nx y : \u03b1\nm n : \u2115\n\u22a2 f^[n] (f^[minimalPeriod f x] x) = f^[n] x"
      },
      {
        "tactic": "congr",
        "annotated_tactic": [
          "congr",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf fa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nx y : \u03b1\nm n : \u2115\n\u22a2 f^[n] (f^[minimalPeriod f x] x) = f^[n] x",
        "state_after": "case e_a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf fa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nx y : \u03b1\nm n : \u2115\n\u22a2 f^[minimalPeriod f x] x = x"
      },
      {
        "tactic": "exact isPeriodicPt_minimalPeriod f x",
        "annotated_tactic": [
          "exact <a>isPeriodicPt_minimalPeriod</a> f x",
          [
            {
              "full_name": "Function.isPeriodicPt_minimalPeriod",
              "def_path": "Mathlib/Dynamics/PeriodicPts.lean",
              "def_pos": [
                279,
                9
              ],
              "def_end_pos": [
                279,
                35
              ]
            }
          ]
        ],
        "state_before": "case e_a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf fa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nx y : \u03b1\nm n : \u2115\n\u22a2 f^[minimalPeriod f x] x = x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.4629767200676724,
    "entry_failed": false
  },
  "17926": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Metric.lean",
    "full_name": "SimpleGraph.dist_ne_zero_iff_ne_and_reachable",
    "start": [
      125,
      1
    ],
    "end": [
      127,
      16
    ],
    "traced_tactics": [
      {
        "tactic": "rw [ne_eq, dist_eq_zero_iff_eq_or_not_reachable.not]",
        "annotated_tactic": [
          "rw [<a>ne_eq</a>, dist_eq_zero_iff_eq_or_not_reachable.not]",
          [
            {
              "full_name": "ne_eq",
              "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean",
              "def_pos": [
                89,
                17
              ],
              "def_end_pos": [
                89,
                22
              ]
            }
          ]
        ],
        "state_before": "V : Type u_1\nG : SimpleGraph V\nu v : V\n\u22a2 G.dist u v \u2260 0 \u2194 u \u2260 v \u2227 G.Reachable u v",
        "state_after": "V : Type u_1\nG : SimpleGraph V\nu v : V\n\u22a2 \u00ac(u = v \u2228 \u00acG.Reachable u v) \u2194 u \u2260 v \u2227 G.Reachable u v"
      },
      {
        "tactic": "push_neg",
        "annotated_tactic": [
          "push_neg",
          []
        ],
        "state_before": "V : Type u_1\nG : SimpleGraph V\nu v : V\n\u22a2 \u00ac(u = v \u2228 \u00acG.Reachable u v) \u2194 u \u2260 v \u2227 G.Reachable u v",
        "state_after": "V : Type u_1\nG : SimpleGraph V\nu v : V\n\u22a2 u \u2260 v \u2227 G.Reachable u v \u2194 u \u2260 v \u2227 G.Reachable u v"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "V : Type u_1\nG : SimpleGraph V\nu v : V\n\u22a2 u \u2260 v \u2227 G.Reachable u v \u2194 u \u2260 v \u2227 G.Reachable u v",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.3651634310372174,
    "entry_failed": false
  },
  "17946": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/ContinuousFunction/T0Sierpinski.lean",
    "full_name": "TopologicalSpace.productOfMemOpens_injective",
    "start": [
      55,
      1
    ],
    "end": [
      58,
      68
    ],
    "traced_tactics": [
      {
        "tactic": "intro x1 x2 h",
        "annotated_tactic": [
          "intro x1 x2 h",
          []
        ],
        "state_before": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T0Space X\n\u22a2 Function.Injective \u21d1(productOfMemOpens X)",
        "state_after": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T0Space X\nx1 x2 : X\nh : (productOfMemOpens X) x1 = (productOfMemOpens X) x2\n\u22a2 x1 = x2"
      },
      {
        "tactic": "apply Inseparable.eq",
        "annotated_tactic": [
          "apply <a>Inseparable.eq</a>",
          [
            {
              "full_name": "Inseparable.eq",
              "def_path": "Mathlib/Topology/Separation.lean",
              "def_pos": [
                276,
                9
              ],
              "def_end_pos": [
                276,
                23
              ]
            }
          ]
        ],
        "state_before": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T0Space X\nx1 x2 : X\nh : (productOfMemOpens X) x1 = (productOfMemOpens X) x2\n\u22a2 x1 = x2",
        "state_after": "case h\nX : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T0Space X\nx1 x2 : X\nh : (productOfMemOpens X) x1 = (productOfMemOpens X) x2\n\u22a2 Inseparable x1 x2"
      },
      {
        "tactic": "rw [\u2190 Inducing.inseparable_iff (productOfMemOpens_inducing X), h]",
        "annotated_tactic": [
          "rw [\u2190 <a>Inducing.inseparable_iff</a> (<a>productOfMemOpens_inducing</a> X), h]",
          [
            {
              "full_name": "Inducing.inseparable_iff",
              "def_path": "Mathlib/Topology/Inseparable.lean",
              "def_pos": [
                290,
                9
              ],
              "def_end_pos": [
                290,
                33
              ]
            },
            {
              "full_name": "TopologicalSpace.productOfMemOpens_inducing",
              "def_path": "Mathlib/Topology/ContinuousFunction/T0Sierpinski.lean",
              "def_pos": [
                50,
                9
              ],
              "def_end_pos": [
                50,
                35
              ]
            }
          ]
        ],
        "state_before": "case h\nX : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T0Space X\nx1 x2 : X\nh : (productOfMemOpens X) x1 = (productOfMemOpens X) x2\n\u22a2 Inseparable x1 x2",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2231707490282133,
    "entry_failed": false
  },
  "17957": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Real/EReal.lean",
    "full_name": "EReal.coe_toReal_le",
    "start": [
      422,
      1
    ],
    "end": [
      425,
      41
    ],
    "traced_tactics": [
      {
        "tactic": "by_cases h' : x = \u22a4",
        "annotated_tactic": [
          "by_cases h' : x = \u22a4",
          []
        ],
        "state_before": "x : EReal\nh : x \u2260 \u22a5\n\u22a2 \u2191x.toReal \u2264 x",
        "state_after": "case pos\nx : EReal\nh : x \u2260 \u22a5\nh' : x = \u22a4\n\u22a2 \u2191x.toReal \u2264 x\n\ncase neg\nx : EReal\nh : x \u2260 \u22a5\nh' : \u00acx = \u22a4\n\u22a2 \u2191x.toReal \u2264 x"
      },
      {
        "tactic": "simp only [h', le_top]",
        "annotated_tactic": [
          "simp only [h', <a>le_top</a>]",
          [
            {
              "full_name": "le_top",
              "def_path": "Mathlib/Order/BoundedOrder.lean",
              "def_pos": [
                66,
                9
              ],
              "def_end_pos": [
                66,
                15
              ]
            }
          ]
        ],
        "state_before": "case pos\nx : EReal\nh : x \u2260 \u22a5\nh' : x = \u22a4\n\u22a2 \u2191x.toReal \u2264 x",
        "state_after": "no goals"
      },
      {
        "tactic": "simp only [le_refl, coe_toReal h' h]",
        "annotated_tactic": [
          "simp only [<a>le_refl</a>, <a>coe_toReal</a> h' h]",
          [
            {
              "full_name": "le_refl",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                45,
                9
              ],
              "def_end_pos": [
                45,
                16
              ]
            },
            {
              "full_name": "EReal.coe_toReal",
              "def_path": "Mathlib/Data/Real/EReal.lean",
              "def_pos": [
                411,
                9
              ],
              "def_end_pos": [
                411,
                19
              ]
            }
          ]
        ],
        "state_before": "case neg\nx : EReal\nh : x \u2260 \u22a5\nh' : \u00acx = \u22a4\n\u22a2 \u2191x.toReal \u2264 x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.698029223014601,
    "entry_failed": false
  },
  "17980": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/LucasLehmer.lean",
    "full_name": "succ_mersenne",
    "start": [
      93,
      1
    ],
    "end": [
      95,
      45
    ],
    "traced_tactics": [
      {
        "tactic": "rw [mersenne, tsub_add_cancel_of_le]",
        "annotated_tactic": [
          "rw [<a>mersenne</a>, <a>tsub_add_cancel_of_le</a>]",
          [
            {
              "full_name": "mersenne",
              "def_path": "Mathlib/NumberTheory/LucasLehmer.lean",
              "def_pos": [
                44,
                5
              ],
              "def_end_pos": [
                44,
                13
              ]
            },
            {
              "full_name": "tsub_add_cancel_of_le",
              "def_path": "Mathlib/Algebra/Order/Sub/Canonical.lean",
              "def_pos": [
                31,
                9
              ],
              "def_end_pos": [
                31,
                30
              ]
            }
          ]
        ],
        "state_before": "k : \u2115\n\u22a2 mersenne k + 1 = 2 ^ k",
        "state_after": "k : \u2115\n\u22a2 1 \u2264 2 ^ k"
      },
      {
        "tactic": "exact one_le_pow_of_one_le (by norm_num) k",
        "annotated_tactic": [
          "exact <a>one_le_pow_of_one_le</a> (by norm_num) k",
          [
            {
              "full_name": "one_le_pow_of_one_le",
              "def_path": "Mathlib/Algebra/Order/Ring/Basic.lean",
              "def_pos": [
                82,
                9
              ],
              "def_end_pos": [
                82,
                29
              ]
            }
          ]
        ],
        "state_before": "k : \u2115\n\u22a2 1 \u2264 2 ^ k",
        "state_after": "no goals"
      },
      {
        "tactic": "norm_num",
        "annotated_tactic": [
          "norm_num",
          []
        ],
        "state_before": "k : \u2115\n\u22a2 1 \u2264 2",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.1378460120176896,
    "entry_failed": false
  },
  "18023": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/MetricSpace/Infsep.lean",
    "full_name": "Set.Nontrivial.infsep_of_fintype",
    "start": [
      468,
      1
    ],
    "end": [
      470,
      51
    ],
    "traced_tactics": [
      {
        "tactic": "simpa",
        "annotated_tactic": [
          "simpa",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u2191s\nhs : s.Nontrivial\n\u22a2 s.offDiag.toFinset.Nonempty",
        "state_after": "no goals"
      },
      {
        "tactic": "classical rw [Set.infsep_of_fintype, dif_pos hs]",
        "annotated_tactic": [
          "classical rw [<a>Set.infsep_of_fintype</a>, <a>dif_pos</a> hs]",
          [
            {
              "full_name": "Set.infsep_of_fintype",
              "def_path": "Mathlib/Topology/MetricSpace/Infsep.lean",
              "def_pos": [
                458,
                9
              ],
              "def_end_pos": [
                458,
                26
              ]
            },
            {
              "full_name": "dif_pos",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                949,
                9
              ],
              "def_end_pos": [
                949,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u2191s\nhs : s.Nontrivial\n\u22a2 s.infsep = s.offDiag.toFinset.inf' \u22ef (uncurry dist)",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [Set.infsep_of_fintype, dif_pos hs]",
        "annotated_tactic": [
          "rw [<a>Set.infsep_of_fintype</a>, <a>dif_pos</a> hs]",
          [
            {
              "full_name": "Set.infsep_of_fintype",
              "def_path": "Mathlib/Topology/MetricSpace/Infsep.lean",
              "def_pos": [
                458,
                9
              ],
              "def_end_pos": [
                458,
                26
              ]
            },
            {
              "full_name": "dif_pos",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                949,
                9
              ],
              "def_end_pos": [
                949,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u2191s\nhs : s.Nontrivial\n\u22a2 s.infsep = s.offDiag.toFinset.inf' \u22ef (uncurry dist)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.1276595039526,
    "entry_failed": false
  },
  "18025": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Tactic/Positivity/Core.lean",
    "full_name": "Mathlib.Meta.Positivity.pos_of_isNat",
    "start": [
      125,
      1
    ],
    "end": [
      129,
      16
    ],
    "traced_tactics": [
      {
        "tactic": "rw [NormNum.IsNat.to_eq h rfl]",
        "annotated_tactic": [
          "rw [<a>NormNum.IsNat.to_eq</a> h <a>rfl</a>]",
          [
            {
              "full_name": "Mathlib.Meta.NormNum.IsNat.to_eq",
              "def_path": "Mathlib/Tactic/NormNum/Result.lean",
              "def_pos": [
                136,
                9
              ],
              "def_end_pos": [
                136,
                20
              ]
            },
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "u : Level\n\u03b1 : Q(Type u)\nz\u03b1 : Q(Zero \u00ab$\u03b1\u00bb)\np\u03b1 : Q(PartialOrder \u00ab$\u03b1\u00bb)\nA : Type u_1\ne : A\nn : \u2115\ninst\u271d : StrictOrderedSemiring A\nh : NormNum.IsNat e n\nw : Nat.ble 1 n = true\n\u22a2 0 < e",
        "state_after": "u : Level\n\u03b1 : Q(Type u)\nz\u03b1 : Q(Zero \u00ab$\u03b1\u00bb)\np\u03b1 : Q(PartialOrder \u00ab$\u03b1\u00bb)\nA : Type u_1\ne : A\nn : \u2115\ninst\u271d : StrictOrderedSemiring A\nh : NormNum.IsNat e n\nw : Nat.ble 1 n = true\n\u22a2 0 < \u2191n"
      },
      {
        "tactic": "apply Nat.cast_pos.2",
        "annotated_tactic": [
          "apply <a>Nat.cast_pos</a>.2",
          [
            {
              "full_name": "Nat.cast_pos",
              "def_path": "Mathlib/Data/Nat/Cast/Order.lean",
              "def_pos": [
                92,
                9
              ],
              "def_end_pos": [
                92,
                17
              ]
            }
          ]
        ],
        "state_before": "u : Level\n\u03b1 : Q(Type u)\nz\u03b1 : Q(Zero \u00ab$\u03b1\u00bb)\np\u03b1 : Q(PartialOrder \u00ab$\u03b1\u00bb)\nA : Type u_1\ne : A\nn : \u2115\ninst\u271d : StrictOrderedSemiring A\nh : NormNum.IsNat e n\nw : Nat.ble 1 n = true\n\u22a2 0 < \u2191n",
        "state_after": "u : Level\n\u03b1 : Q(Type u)\nz\u03b1 : Q(Zero \u00ab$\u03b1\u00bb)\np\u03b1 : Q(PartialOrder \u00ab$\u03b1\u00bb)\nA : Type u_1\ne : A\nn : \u2115\ninst\u271d : StrictOrderedSemiring A\nh : NormNum.IsNat e n\nw : Nat.ble 1 n = true\n\u22a2 0 < n"
      },
      {
        "tactic": "simpa using w",
        "annotated_tactic": [
          "simpa using w",
          []
        ],
        "state_before": "u : Level\n\u03b1 : Q(Type u)\nz\u03b1 : Q(Zero \u00ab$\u03b1\u00bb)\np\u03b1 : Q(PartialOrder \u00ab$\u03b1\u00bb)\nA : Type u_1\ne : A\nn : \u2115\ninst\u271d : StrictOrderedSemiring A\nh : NormNum.IsNat e n\nw : Nat.ble 1 n = true\n\u22a2 0 < n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8548368699848652,
    "entry_failed": false
  },
  "18105": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Cast/Field.lean",
    "full_name": "Nat.one_div_lt_one_div",
    "start": [
      76,
      1
    ],
    "end": [
      79,
      10
    ],
    "traced_tactics": [
      {
        "tactic": "refine one_div_lt_one_div_of_lt ?_ ?_",
        "annotated_tactic": [
          "refine <a>one_div_lt_one_div_of_lt</a> ?_ ?_",
          [
            {
              "full_name": "one_div_lt_one_div_of_lt",
              "def_path": "Mathlib/Algebra/Order/Field/Basic.lean",
              "def_pos": [
                396,
                9
              ],
              "def_end_pos": [
                396,
                33
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedSemifield \u03b1\nn m : \u2115\nh : n < m\n\u22a2 1 / (\u2191m + 1) < 1 / (\u2191n + 1)",
        "state_after": "case refine_1\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedSemifield \u03b1\nn m : \u2115\nh : n < m\n\u22a2 0 < \u2191n + 1\n\ncase refine_2\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedSemifield \u03b1\nn m : \u2115\nh : n < m\n\u22a2 \u2191n + 1 < \u2191m + 1"
      },
      {
        "tactic": "exact Nat.cast_add_one_pos _",
        "annotated_tactic": [
          "exact <a>Nat.cast_add_one_pos</a> _",
          [
            {
              "full_name": "Nat.cast_add_one_pos",
              "def_path": "Mathlib/Data/Nat/Cast/Order.lean",
              "def_pos": [
                80,
                9
              ],
              "def_end_pos": [
                80,
                25
              ]
            }
          ]
        ],
        "state_before": "case refine_1\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedSemifield \u03b1\nn m : \u2115\nh : n < m\n\u22a2 0 < \u2191n + 1",
        "state_after": "no goals"
      },
      {
        "tactic": "simpa",
        "annotated_tactic": [
          "simpa",
          []
        ],
        "state_before": "case refine_2\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedSemifield \u03b1\nn m : \u2115\nh : n < m\n\u22a2 \u2191n + 1 < \u2191m + 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9771576789207757,
    "entry_failed": false
  },
  "18107": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Int/Defs.lean",
    "full_name": "Int.eq_mul_div_of_mul_eq_mul_of_dvd_left",
    "start": [
      698,
      1
    ],
    "end": [
      702,
      55
    ],
    "traced_tactics": [
      {
        "tactic": "obtain \u27e8k, rfl\u27e9 := hbc",
        "annotated_tactic": [
          "obtain \u27e8k, rfl\u27e9 := hbc",
          []
        ],
        "state_before": "a b c d m n : \u2124\nhb : b \u2260 0\nhbc : b \u2223 c\nh : b * a = c * d\n\u22a2 a = c / b * d",
        "state_after": "case intro\na b d m n : \u2124\nhb : b \u2260 0\nk : \u2124\nh : b * a = b * k * d\n\u22a2 a = b * k / b * d"
      },
      {
        "tactic": "rw [Int.mul_ediv_cancel_left _ hb]",
        "annotated_tactic": [
          "rw [<a>Int.mul_ediv_cancel_left</a> _ hb]",
          [
            {
              "full_name": "Int.mul_ediv_cancel_left",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/DivModLemmas.lean",
              "def_pos": [
                357,
                17
              ],
              "def_end_pos": [
                357,
                37
              ]
            }
          ]
        ],
        "state_before": "case intro\na b d m n : \u2124\nhb : b \u2260 0\nk : \u2124\nh : b * a = b * k * d\n\u22a2 a = b * k / b * d",
        "state_after": "case intro\na b d m n : \u2124\nhb : b \u2260 0\nk : \u2124\nh : b * a = b * k * d\n\u22a2 a = k * d"
      },
      {
        "tactic": "rwa [Int.mul_assoc, Int.mul_eq_mul_left_iff hb] at h",
        "annotated_tactic": [
          "rwa [<a>Int.mul_assoc</a>, <a>Int.mul_eq_mul_left_iff</a> hb] at h",
          [
            {
              "full_name": "Int.mul_assoc",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Lemmas.lean",
              "def_pos": [
                376,
                19
              ],
              "def_end_pos": [
                376,
                28
              ]
            },
            {
              "full_name": "Int.mul_eq_mul_left_iff",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Lemmas.lean",
              "def_pos": [
                499,
                9
              ],
              "def_end_pos": [
                499,
                28
              ]
            }
          ]
        ],
        "state_before": "case intro\na b d m n : \u2124\nhb : b \u2260 0\nk : \u2124\nh : b * a = b * k * d\n\u22a2 a = k * d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.808782842941582,
    "entry_failed": false
  },
  "18130": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/UniformSpace/Cauchy.lean",
    "full_name": "Cauchy.ultrafilter_of",
    "start": [
      63,
      1
    ],
    "end": [
      67,
      70
    ],
    "traced_tactics": [
      {
        "tactic": "haveI := h.1",
        "annotated_tactic": [
          "haveI := h.1",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\nl : Filter \u03b1\nh : Cauchy l\n\u22a2 Cauchy \u2191(Ultrafilter.of l)",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\nl : Filter \u03b1\nh : Cauchy l\nthis : l.NeBot\n\u22a2 Cauchy \u2191(Ultrafilter.of l)"
      },
      {
        "tactic": "have := Ultrafilter.of_le l",
        "annotated_tactic": [
          "have := <a>Ultrafilter.of_le</a> l",
          [
            {
              "full_name": "Ultrafilter.of_le",
              "def_path": "Mathlib/Order/Filter/Ultrafilter.lean",
              "def_pos": [
                385,
                9
              ],
              "def_end_pos": [
                385,
                14
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\nl : Filter \u03b1\nh : Cauchy l\nthis : l.NeBot\n\u22a2 Cauchy \u2191(Ultrafilter.of l)",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\nl : Filter \u03b1\nh : Cauchy l\nthis\u271d : l.NeBot\nthis : \u2191(Ultrafilter.of l) \u2264 l\n\u22a2 Cauchy \u2191(Ultrafilter.of l)"
      },
      {
        "tactic": "exact \u27e8Ultrafilter.neBot _, (Filter.prod_mono this this).trans h.2\u27e9",
        "annotated_tactic": [
          "exact \u27e8Ultrafilter.neBot _, (<a>Filter.prod_mono</a> this this).<a>trans</a> h.2\u27e9",
          [
            {
              "full_name": "Filter.prod_mono",
              "def_path": "Mathlib/Order/Filter/Prod.lean",
              "def_pos": [
                247,
                9
              ],
              "def_end_pos": [
                247,
                18
              ]
            },
            {
              "full_name": "LE.le.trans",
              "def_path": "Mathlib/Order/Basic.lean",
              "def_pos": [
                115,
                7
              ],
              "def_end_pos": [
                115,
                18
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nuniformSpace : UniformSpace \u03b1\nl : Filter \u03b1\nh : Cauchy l\nthis\u271d : l.NeBot\nthis : \u2191(Ultrafilter.of l) \u2264 l\n\u22a2 Cauchy \u2191(Ultrafilter.of l)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.4066915119765326,
    "entry_failed": false
  },
  "18168": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Polynomial/Pochhammer.lean",
    "full_name": "ascPochhammer_map",
    "start": [
      83,
      1
    ],
    "end": [
      87,
      49
    ],
    "traced_tactics": [
      {
        "tactic": "induction' n with n ih",
        "annotated_tactic": [
          "induction' n with n ih",
          []
        ],
        "state_before": "S : Type u\ninst\u271d\u00b9 : Semiring S\nT : Type v\ninst\u271d : Semiring T\nf : S \u2192+* T\nn : \u2115\n\u22a2 map f (ascPochhammer S n) = ascPochhammer T n",
        "state_after": "case zero\nS : Type u\ninst\u271d\u00b9 : Semiring S\nT : Type v\ninst\u271d : Semiring T\nf : S \u2192+* T\n\u22a2 map f (ascPochhammer S 0) = ascPochhammer T 0\n\ncase succ\nS : Type u\ninst\u271d\u00b9 : Semiring S\nT : Type v\ninst\u271d : Semiring T\nf : S \u2192+* T\nn : \u2115\nih : map f (ascPochhammer S n) = ascPochhammer T n\n\u22a2 map f (ascPochhammer S (n + 1)) = ascPochhammer T (n + 1)"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case zero\nS : Type u\ninst\u271d\u00b9 : Semiring S\nT : Type v\ninst\u271d : Semiring T\nf : S \u2192+* T\n\u22a2 map f (ascPochhammer S 0) = ascPochhammer T 0",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [ih, ascPochhammer_succ_left, map_comp]",
        "annotated_tactic": [
          "simp [ih, <a>ascPochhammer_succ_left</a>, <a>map_comp</a>]",
          [
            {
              "full_name": "ascPochhammer_succ_left",
              "def_path": "Mathlib/RingTheory/Polynomial/Pochhammer.lean",
              "def_pos": [
                64,
                9
              ],
              "def_end_pos": [
                64,
                32
              ]
            },
            {
              "full_name": "Polynomial.map_comp",
              "def_path": "Mathlib/Algebra/Polynomial/Eval.lean",
              "def_pos": [
                973,
                9
              ],
              "def_end_pos": [
                973,
                17
              ]
            }
          ]
        ],
        "state_before": "case succ\nS : Type u\ninst\u271d\u00b9 : Semiring S\nT : Type v\ninst\u271d : Semiring T\nf : S \u2192+* T\nn : \u2115\nih : map f (ascPochhammer S n) = ascPochhammer T n\n\u22a2 map f (ascPochhammer S (n + 1)) = ascPochhammer T (n + 1)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.752303052926436,
    "entry_failed": false
  },
  "18276": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/MetricSpace/Infsep.lean",
    "full_name": "Set.nontrivial_of_infsep_pos",
    "start": [
      348,
      1
    ],
    "end": [
      351,
      37
    ],
    "traced_tactics": [
      {
        "tactic": "contrapose hs",
        "annotated_tactic": [
          "contrapose hs",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EDist \u03b1\nx y : \u03b1\ns : Set \u03b1\nhs : 0 < s.infsep\n\u22a2 s.Nontrivial",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EDist \u03b1\nx y : \u03b1\ns : Set \u03b1\nhs : \u00acs.Nontrivial\n\u22a2 \u00ac0 < s.infsep"
      },
      {
        "tactic": "rw [not_nontrivial_iff] at hs",
        "annotated_tactic": [
          "rw [<a>not_nontrivial_iff</a>] at hs",
          [
            {
              "full_name": "Set.not_nontrivial_iff",
              "def_path": "Mathlib/Data/Set/Subsingleton.lean",
              "def_pos": [
                305,
                9
              ],
              "def_end_pos": [
                305,
                27
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EDist \u03b1\nx y : \u03b1\ns : Set \u03b1\nhs : \u00acs.Nontrivial\n\u22a2 \u00ac0 < s.infsep",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EDist \u03b1\nx y : \u03b1\ns : Set \u03b1\nhs : s.Subsingleton\n\u22a2 \u00ac0 < s.infsep"
      },
      {
        "tactic": "exact hs.infsep_zero \u25b8 lt_irrefl _",
        "annotated_tactic": [
          "exact hs.infsep_zero \u25b8 <a>lt_irrefl</a> _",
          [
            {
              "full_name": "lt_irrefl",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                79,
                9
              ],
              "def_end_pos": [
                79,
                18
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : EDist \u03b1\nx y : \u03b1\ns : Set \u03b1\nhs : s.Subsingleton\n\u22a2 \u00ac0 < s.infsep",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.6238260651007295,
    "entry_failed": false
  },
  "18334": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": ".lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "full_name": "Batteries.BinomialHeap.Imp.HeapNode.rankTR_eq",
    "start": [
      60,
      18
    ],
    "end": [
      65,
      60
    ],
    "traced_tactics": [
      {
        "tactic": "funext \u03b1 s",
        "annotated_tactic": [
          "funext \u03b1 s",
          []
        ],
        "state_before": "\u22a2 @Batteries.BinomialHeap.Imp.HeapNode.rankTR = @rank",
        "state_after": "case h.h\n\u03b1 : Type u_1\ns : HeapNode \u03b1\n\u22a2 Batteries.BinomialHeap.Imp.HeapNode.rankTR s = s.rank"
      },
      {
        "tactic": "exact go s 0",
        "annotated_tactic": [
          "exact go s 0",
          []
        ],
        "state_before": "case h.h\n\u03b1 : Type u_1\ns : HeapNode \u03b1\n\u22a2 Batteries.BinomialHeap.Imp.HeapNode.rankTR s = s.rank",
        "state_after": "no goals"
      },
      {
        "tactic": "simp_arith only [rankTR.go, go, rank]",
        "annotated_tactic": [
          "simp_arith only [<a>rankTR.go</a>, go, <a>rank</a>]",
          [
            {
              "full_name": "_private.\u00ab.lake\u00bb.packages.batteries.Batteries.Data.BinomialHeap.Basic.0.Batteries.BinomialHeap.Imp.HeapNode.rankTR.go",
              "def_path": ".lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
              "def_pos": [
                56,
                3
              ],
              "def_end_pos": [
                56,
                5
              ]
            },
            {
              "full_name": "Batteries.BinomialHeap.Imp.HeapNode.rank",
              "def_path": ".lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
              "def_pos": [
                49,
                5
              ],
              "def_end_pos": [
                49,
                18
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type ?u.2530\na\u271d : \u03b1\nchild\u271d sibling\u271d : HeapNode \u03b1\nx\u271d : Nat\n\u22a2 Batteries.BinomialHeap.Imp.HeapNode.rankTR.go (node a\u271d child\u271d sibling\u271d) x\u271d = (node a\u271d child\u271d sibling\u271d).rank + x\u271d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.1955893990816548,
    "entry_failed": false
  },
  "18337": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Size.lean",
    "full_name": "Nat.size_bit",
    "start": [
      55,
      1
    ],
    "end": [
      61,
      16
    ],
    "traced_tactics": [
      {
        "tactic": "rw [size]",
        "annotated_tactic": [
          "rw [<a>size</a>]",
          [
            {
              "full_name": "Nat.size",
              "def_path": "Mathlib/Data/Nat/Bits.lean",
              "def_pos": [
                220,
                5
              ],
              "def_end_pos": [
                220,
                9
              ]
            }
          ]
        ],
        "state_before": "b : Bool\nn : \u2115\nh : bit b n \u2260 0\n\u22a2 (bit b n).size = n.size.succ",
        "state_after": "b : Bool\nn : \u2115\nh : bit b n \u2260 0\n\u22a2 binaryRec 0 (fun x x => succ) (bit b n) = (binaryRec 0 (fun x x => succ) n).succ"
      },
      {
        "tactic": "conv =>\n  lhs\n  rw [binaryRec]\n  simp [h]",
        "annotated_tactic": [
          "conv =>\n    lhs\n    rw [<a>binaryRec</a>]\n    simp [h]",
          [
            {
              "full_name": "Nat.binaryRec",
              "def_path": "Mathlib/Data/Nat/Bits.lean",
              "def_pos": [
                204,
                5
              ],
              "def_end_pos": [
                204,
                14
              ]
            }
          ]
        ],
        "state_before": "b : Bool\nn : \u2115\nh : bit b n \u2260 0\n\u22a2 binaryRec 0 (fun x x => succ) (bit b n) = (binaryRec 0 (fun x x => succ) n).succ",
        "state_after": "b : Bool\nn : \u2115\nh : bit b n \u2260 0\n\u22a2 binaryRec 0 (fun x x => succ) (bit b n).div2 + 1 = (binaryRec 0 (fun x x => succ) n).succ"
      },
      {
        "tactic": "rw [div2_bit]",
        "annotated_tactic": [
          "rw [<a>div2_bit</a>]",
          [
            {
              "full_name": "Nat.div2_bit",
              "def_path": "Mathlib/Data/Nat/Bits.lean",
              "def_pos": [
                259,
                7
              ],
              "def_end_pos": [
                259,
                15
              ]
            }
          ]
        ],
        "state_before": "b : Bool\nn : \u2115\nh : bit b n \u2260 0\n\u22a2 binaryRec 0 (fun x x => succ) (bit b n).div2 + 1 = (binaryRec 0 (fun x x => succ) n).succ",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.086906807962805,
    "entry_failed": false
  },
  "18359": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Bits.lean",
    "full_name": "Nat.bodd_eq_bits_head",
    "start": [
      617,
      1
    ],
    "end": [
      619,
      41
    ],
    "traced_tactics": [
      {
        "tactic": "induction' n using Nat.binaryRec' with b n h _",
        "annotated_tactic": [
          "induction' n using <a>Nat.binaryRec'</a> with b n h _",
          [
            {
              "full_name": "Nat.binaryRec'",
              "def_path": "Mathlib/Data/Nat/Bits.lean",
              "def_pos": [
                566,
                5
              ],
              "def_end_pos": [
                566,
                15
              ]
            }
          ]
        ],
        "state_before": "m n\u271d n : \u2115\n\u22a2 n.bodd = n.bits.headI",
        "state_after": "case z\nm n : \u2115\n\u22a2 bodd 0 = (bits 0).headI\n\ncase f\nm n\u271d : \u2115\nb : Bool\nn : \u2115\nh : n = 0 \u2192 b = true\na\u271d : n.bodd = n.bits.headI\n\u22a2 (bit b n).bodd = (bit b n).bits.headI"
      },
      {
        "tactic": "simp [bodd_bit, bits_append_bit _ _ h]",
        "annotated_tactic": [
          "simp [<a>bodd_bit</a>, <a>bits_append_bit</a> _ _ h]",
          [
            {
              "full_name": "Nat.bodd_bit",
              "def_path": "Mathlib/Data/Nat/Bits.lean",
              "def_pos": [
                252,
                7
              ],
              "def_end_pos": [
                252,
                15
              ]
            },
            {
              "full_name": "Nat.bits_append_bit",
              "def_path": "Mathlib/Data/Nat/Bits.lean",
              "def_pos": [
                592,
                9
              ],
              "def_end_pos": [
                592,
                24
              ]
            }
          ]
        ],
        "state_before": "case f\nm n\u271d : \u2115\nb : Bool\nn : \u2115\nh : n = 0 \u2192 b = true\na\u271d : n.bodd = n.bits.headI\n\u22a2 (bit b n).bodd = (bit b n).bits.headI",
        "state_after": "no goals"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case z\nm n : \u2115\n\u22a2 bodd 0 = (bits 0).headI",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.4835951740387827,
    "entry_failed": false
  },
  "18391": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/EulerProduct/Basic.lean",
    "full_name": "Summable.norm_lt_one",
    "start": [
      45,
      1
    ],
    "end": [
      52,
      58
    ],
    "traced_tactics": [
      {
        "tactic": "refine summable_geometric_iff_norm_lt_one.mp ?_",
        "annotated_tactic": [
          "refine summable_geometric_iff_norm_lt_one.mp ?_",
          []
        ],
        "state_before": "F : Type u_1\ninst\u271d\u00b9 : NormedField F\ninst\u271d : CompleteSpace F\nf : \u2115 \u2192* F\nhsum : Summable \u21d1f\np : \u2115\nhp : 1 < p\n\u22a2 \u2016f p\u2016 < 1",
        "state_after": "F : Type u_1\ninst\u271d\u00b9 : NormedField F\ninst\u271d : CompleteSpace F\nf : \u2115 \u2192* F\nhsum : Summable \u21d1f\np : \u2115\nhp : 1 < p\n\u22a2 Summable fun n => f p ^ n"
      },
      {
        "tactic": "simp_rw [\u2190 map_pow]",
        "annotated_tactic": [
          "simp_rw [\u2190 <a>map_pow</a>]",
          [
            {
              "full_name": "map_pow",
              "def_path": "Mathlib/Algebra/Group/Hom/Defs.lean",
              "def_pos": [
                473,
                9
              ],
              "def_end_pos": [
                473,
                16
              ]
            }
          ]
        ],
        "state_before": "F : Type u_1\ninst\u271d\u00b9 : NormedField F\ninst\u271d : CompleteSpace F\nf : \u2115 \u2192* F\nhsum : Summable \u21d1f\np : \u2115\nhp : 1 < p\n\u22a2 Summable fun n => f p ^ n",
        "state_after": "F : Type u_1\ninst\u271d\u00b9 : NormedField F\ninst\u271d : CompleteSpace F\nf : \u2115 \u2192* F\nhsum : Summable \u21d1f\np : \u2115\nhp : 1 < p\n\u22a2 Summable fun n => f (p ^ n)"
      },
      {
        "tactic": "exact hsum.comp_injective <| Nat.pow_right_injective hp",
        "annotated_tactic": [
          "exact hsum.comp_injective <| <a>Nat.pow_right_injective</a> hp",
          [
            {
              "full_name": "Nat.pow_right_injective",
              "def_path": "Mathlib/Data/Nat/Defs.lean",
              "def_pos": [
                756,
                17
              ],
              "def_end_pos": [
                756,
                36
              ]
            }
          ]
        ],
        "state_before": "F : Type u_1\ninst\u271d\u00b9 : NormedField F\ninst\u271d : CompleteSpace F\nf : \u2115 \u2192* F\nhsum : Summable \u21d1f\np : \u2115\nhp : 1 < p\n\u22a2 Summable fun n => f (p ^ n)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.673755473922938,
    "entry_failed": false
  },
  "18416": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/PowerSeries/Basic.lean",
    "full_name": "PowerSeries.subsingleton_iff",
    "start": [
      272,
      11
    ],
    "end": [
      275,
      50
    ],
    "traced_tactics": [
      {
        "tactic": "refine \u27e8fun h \u21a6 ?_, fun _ \u21a6 inferInstance\u27e9",
        "annotated_tactic": [
          "refine \u27e8fun h \u21a6 ?_, fun _ \u21a6 <a>inferInstance</a>\u27e9",
          [
            {
              "full_name": "inferInstance",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                99,
                8
              ],
              "def_end_pos": [
                99,
                21
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d : Semiring R\n\u22a2 Subsingleton R\u27e6X\u27e7 \u2194 Subsingleton R",
        "state_after": "R : Type u_1\ninst\u271d : Semiring R\nh : Subsingleton R\u27e6X\u27e7\n\u22a2 Subsingleton R"
      },
      {
        "tactic": "rw [subsingleton_iff] at h \u22a2",
        "annotated_tactic": [
          "rw [<a>subsingleton_iff</a>] at h \u22a2",
          [
            {
              "full_name": "subsingleton_iff",
              "def_path": "Mathlib/Logic/Nontrivial/Defs.lean",
              "def_pos": [
                77,
                9
              ],
              "def_end_pos": [
                77,
                25
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d : Semiring R\nh : Subsingleton R\u27e6X\u27e7\n\u22a2 Subsingleton R",
        "state_after": "R : Type u_1\ninst\u271d : Semiring R\nh : \u2200 (x y : R\u27e6X\u27e7), x = y\n\u22a2 \u2200 (x y : R), x = y"
      },
      {
        "tactic": "exact fun a b \u21a6 C_injective (h (C R a) (C R b))",
        "annotated_tactic": [
          "exact fun a b \u21a6 <a>C_injective</a> (h (<a>C</a> R a) (<a>C</a> R b))",
          [
            {
              "full_name": "PowerSeries.C_injective",
              "def_path": "Mathlib/RingTheory/PowerSeries/Basic.lean",
              "def_pos": [
                267,
                9
              ],
              "def_end_pos": [
                267,
                20
              ]
            },
            {
              "full_name": "PowerSeries.C",
              "def_path": "Mathlib/RingTheory/PowerSeries/Basic.lean",
              "def_pos": [
                210,
                5
              ],
              "def_end_pos": [
                210,
                6
              ]
            },
            {
              "full_name": "PowerSeries.C",
              "def_path": "Mathlib/RingTheory/PowerSeries/Basic.lean",
              "def_pos": [
                210,
                5
              ],
              "def_end_pos": [
                210,
                6
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d : Semiring R\nh : \u2200 (x y : R\u27e6X\u27e7), x = y\n\u22a2 \u2200 (x y : R), x = y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.884187191957608,
    "entry_failed": false
  },
  "18433": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": ".lake/packages/batteries/Batteries/Data/Sum/Lemmas.lean",
    "full_name": "Sum.LiftRel.lex",
    "start": [
      199,
      11
    ],
    "end": [
      202,
      22
    ],
    "traced_tactics": [
      {
        "tactic": "cases h",
        "annotated_tactic": [
          "cases h",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\na b : \u03b1 \u2295 \u03b2\nh : LiftRel r s a b\n\u22a2 Lex r s a b",
        "state_after": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\na\u271d\u00b9 c\u271d : \u03b1\na\u271d : r a\u271d\u00b9 c\u271d\n\u22a2 Lex r s (inl a\u271d\u00b9) (inl c\u271d)\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nb\u271d d\u271d : \u03b2\na\u271d : s b\u271d d\u271d\n\u22a2 Lex r s (inr b\u271d) (inr d\u271d)"
      },
      {
        "tactic": "exact Lex.inl \u2039_\u203a",
        "annotated_tactic": [
          "exact <a>Lex.inl</a> \u2039_\u203a",
          [
            {
              "full_name": "Sum.Lex.inl",
              "def_path": ".lake/packages/batteries/Batteries/Data/Sum/Basic.lean",
              "def_pos": [
                142,
                15
              ],
              "def_end_pos": [
                142,
                18
              ]
            }
          ]
        ],
        "state_before": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\na\u271d\u00b9 c\u271d : \u03b1\na\u271d : r a\u271d\u00b9 c\u271d\n\u22a2 Lex r s (inl a\u271d\u00b9) (inl c\u271d)",
        "state_after": "no goals"
      },
      {
        "tactic": "exact Lex.inr \u2039_\u203a",
        "annotated_tactic": [
          "exact <a>Lex.inr</a> \u2039_\u203a",
          [
            {
              "full_name": "Sum.Lex.inr",
              "def_path": ".lake/packages/batteries/Batteries/Data/Sum/Basic.lean",
              "def_pos": [
                144,
                15
              ],
              "def_end_pos": [
                144,
                18
              ]
            }
          ]
        ],
        "state_before": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : \u03b2 \u2192 \u03b2 \u2192 Prop\nb\u271d d\u271d : \u03b2\na\u271d : s b\u271d d\u271d\n\u22a2 Lex r s (inr b\u271d) (inr d\u271d)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2770790219074115,
    "entry_failed": false
  },
  "18448": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/RingHom/Surjective.lean",
    "full_name": "RingHom.surjective_respectsIso",
    "start": [
      30,
      1
    ],
    "end": [
      33,
      21
    ],
    "traced_tactics": [
      {
        "tactic": "apply surjective_stableUnderComposition.respectsIso",
        "annotated_tactic": [
          "apply surjective_stableUnderComposition.respectsIso",
          []
        ],
        "state_before": "\u22a2 RespectsIso fun {X Y} [CommRing X] [CommRing Y] f => Function.Surjective \u21d1f",
        "state_after": "\u22a2 \u2200 {R S : Type u_1} [inst : CommRing R] [inst_1 : CommRing S] (e : R \u2243+* S), Function.Surjective \u21d1e.toRingHom"
      },
      {
        "tactic": "intros _ _ _ _ e",
        "annotated_tactic": [
          "intros _ _ _ _ e",
          []
        ],
        "state_before": "\u22a2 \u2200 {R S : Type u_1} [inst : CommRing R] [inst_1 : CommRing S] (e : R \u2243+* S), Function.Surjective \u21d1e.toRingHom",
        "state_after": "R\u271d S\u271d : Type u_1\ninst\u271d\u00b9 : CommRing R\u271d\ninst\u271d : CommRing S\u271d\ne : R\u271d \u2243+* S\u271d\n\u22a2 Function.Surjective \u21d1e.toRingHom"
      },
      {
        "tactic": "exact e.surjective",
        "annotated_tactic": [
          "exact e.surjective",
          []
        ],
        "state_before": "R\u271d S\u271d : Type u_1\ninst\u271d\u00b9 : CommRing R\u271d\ninst\u271d : CommRing S\u271d\ne : R\u271d \u2243+* S\u271d\n\u22a2 Function.Surjective \u21d1e.toRingHom",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6520544269587845,
    "entry_failed": false
  },
  "18515": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/MetricSpace/Bounded.lean",
    "full_name": "Metric.dist_le_diam_of_mem'",
    "start": [
      456,
      1
    ],
    "end": [
      460,
      43
    ],
    "traced_tactics": [
      {
        "tactic": "rw [diam, dist_edist]",
        "annotated_tactic": [
          "rw [<a>diam</a>, <a>dist_edist</a>]",
          [
            {
              "full_name": "Metric.diam",
              "def_path": "Mathlib/Topology/MetricSpace/Bounded.lean",
              "def_pos": [
                388,
                19
              ],
              "def_end_pos": [
                388,
                23
              ]
            },
            {
              "full_name": "dist_edist",
              "def_path": "Mathlib/Topology/MetricSpace/Pseudo/Defs.lean",
              "def_pos": [
                389,
                9
              ],
              "def_end_pos": [
                389,
                19
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nx y z : \u03b1\nh : EMetric.diam s \u2260 \u22a4\nhx : x \u2208 s\nhy : y \u2208 s\n\u22a2 dist x y \u2264 diam s",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nx y z : \u03b1\nh : EMetric.diam s \u2260 \u22a4\nhx : x \u2208 s\nhy : y \u2208 s\n\u22a2 (edist x y).toReal \u2264 (EMetric.diam s).toReal"
      },
      {
        "tactic": "rw [ENNReal.toReal_le_toReal (edist_ne_top _ _) h]",
        "annotated_tactic": [
          "rw [<a>ENNReal.toReal_le_toReal</a> (<a>edist_ne_top</a> _ _) h]",
          [
            {
              "full_name": "ENNReal.toReal_le_toReal",
              "def_path": "Mathlib/Data/ENNReal/Real.lean",
              "def_pos": [
                76,
                9
              ],
              "def_end_pos": [
                76,
                25
              ]
            },
            {
              "full_name": "edist_ne_top",
              "def_path": "Mathlib/Topology/MetricSpace/Pseudo/Defs.lean",
              "def_pos": [
                336,
                9
              ],
              "def_end_pos": [
                336,
                21
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nx y z : \u03b1\nh : EMetric.diam s \u2260 \u22a4\nhx : x \u2208 s\nhy : y \u2208 s\n\u22a2 (edist x y).toReal \u2264 (EMetric.diam s).toReal",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nx y z : \u03b1\nh : EMetric.diam s \u2260 \u22a4\nhx : x \u2208 s\nhy : y \u2208 s\n\u22a2 edist x y \u2264 EMetric.diam s"
      },
      {
        "tactic": "exact EMetric.edist_le_diam_of_mem hx hy",
        "annotated_tactic": [
          "exact <a>EMetric.edist_le_diam_of_mem</a> hx hy",
          [
            {
              "full_name": "EMetric.edist_le_diam_of_mem",
              "def_path": "Mathlib/Topology/EMetricSpace/Basic.lean",
              "def_pos": [
                916,
                9
              ],
              "def_end_pos": [
                916,
                29
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nx y z : \u03b1\nh : EMetric.diam s \u2260 \u22a4\nhx : x \u2208 s\nhy : y \u2208 s\n\u22a2 edist x y \u2264 EMetric.diam s",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.9502293680561706,
    "entry_failed": false
  },
  "18541": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Logic/Equiv/Functor.lean",
    "full_name": "Functor.mapEquiv_refl",
    "start": [
      57,
      1
    ],
    "end": [
      60,
      31
    ],
    "traced_tactics": [
      {
        "tactic": "ext x",
        "annotated_tactic": [
          "ext x",
          []
        ],
        "state_before": "\u03b1 \u03b2 : Type u\nf : Type u \u2192 Type v\ninst\u271d\u00b9 : Functor f\ninst\u271d : LawfulFunctor f\n\u22a2 mapEquiv f (Equiv.refl \u03b1) = Equiv.refl (f \u03b1)",
        "state_after": "case H\n\u03b1 \u03b2 : Type u\nf : Type u \u2192 Type v\ninst\u271d\u00b9 : Functor f\ninst\u271d : LawfulFunctor f\nx : f \u03b1\n\u22a2 (mapEquiv f (Equiv.refl \u03b1)) x = (Equiv.refl (f \u03b1)) x"
      },
      {
        "tactic": "simp only [mapEquiv_apply, refl_apply]",
        "annotated_tactic": [
          "simp only [<a>mapEquiv_apply</a>, <a>refl_apply</a>]",
          [
            {
              "full_name": "Functor.mapEquiv_apply",
              "def_path": "Mathlib/Logic/Equiv/Functor.lean",
              "def_pos": [
                46,
                9
              ],
              "def_end_pos": [
                46,
                23
              ]
            },
            {
              "full_name": "Equiv.refl_apply",
              "def_path": "Mathlib/Logic/Equiv/Defs.lean",
              "def_pos": [
                268,
                17
              ],
              "def_end_pos": [
                268,
                27
              ]
            }
          ]
        ],
        "state_before": "case H\n\u03b1 \u03b2 : Type u\nf : Type u \u2192 Type v\ninst\u271d\u00b9 : Functor f\ninst\u271d : LawfulFunctor f\nx : f \u03b1\n\u22a2 (mapEquiv f (Equiv.refl \u03b1)) x = (Equiv.refl (f \u03b1)) x",
        "state_after": "case H\n\u03b1 \u03b2 : Type u\nf : Type u \u2192 Type v\ninst\u271d\u00b9 : Functor f\ninst\u271d : LawfulFunctor f\nx : f \u03b1\n\u22a2 \u21d1(Equiv.refl \u03b1) <$> x = x"
      },
      {
        "tactic": "exact LawfulFunctor.id_map x",
        "annotated_tactic": [
          "exact <a>LawfulFunctor.id_map</a> x",
          [
            {
              "full_name": "LawfulFunctor.id_map",
              "def_path": ".lake/packages/lean4/src/lean/Init/Control/Lawful/Basic.lean",
              "def_pos": [
                26,
                3
              ],
              "def_end_pos": [
                26,
                9
              ]
            }
          ]
        ],
        "state_before": "case H\n\u03b1 \u03b2 : Type u\nf : Type u \u2192 Type v\ninst\u271d\u00b9 : Functor f\ninst\u271d : LawfulFunctor f\nx : f \u03b1\n\u22a2 \u21d1(Equiv.refl \u03b1) <$> x = x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 0.9500716140028089,
    "entry_failed": false
  },
  "18547": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Category/TopCat/Limits/Products.lean",
    "full_name": "TopCat.prodIsoProd_hom_apply",
    "start": [
      218,
      1
    ],
    "end": [
      224,
      65
    ],
    "traced_tactics": [
      {
        "tactic": "apply Prod.ext",
        "annotated_tactic": [
          "apply <a>Prod.ext</a>",
          [
            {
              "full_name": "Prod.ext",
              "def_path": ".lake/packages/lean4/src/lean/Init/Ext.lean",
              "def_pos": [
                101,
                16
              ],
              "def_end_pos": [
                101,
                24
              ]
            }
          ]
        ],
        "state_before": "J : Type v\ninst\u271d : SmallCategory J\nX Y : TopCat\nx : \u2191(X \u2a2f Y)\n\u22a2 (X.prodIsoProd Y).hom x = (prod.fst x, prod.snd x)",
        "state_after": "case a\nJ : Type v\ninst\u271d : SmallCategory J\nX Y : TopCat\nx : \u2191(X \u2a2f Y)\n\u22a2 ((X.prodIsoProd Y).hom x).1 = (prod.fst x, prod.snd x).1\n\ncase a\nJ : Type v\ninst\u271d : SmallCategory J\nX Y : TopCat\nx : \u2191(X \u2a2f Y)\n\u22a2 ((X.prodIsoProd Y).hom x).2 = (prod.fst x, prod.snd x).2"
      },
      {
        "tactic": "exact ConcreteCategory.congr_hom (prodIsoProd_hom_fst X Y) x",
        "annotated_tactic": [
          "exact <a>ConcreteCategory.congr_hom</a> (<a>prodIsoProd_hom_fst</a> X Y) x",
          [
            {
              "full_name": "CategoryTheory.ConcreteCategory.congr_hom",
              "def_path": "Mathlib/CategoryTheory/ConcreteCategory/Basic.lean",
              "def_pos": [
                141,
                9
              ],
              "def_end_pos": [
                141,
                35
              ]
            },
            {
              "full_name": "TopCat.prodIsoProd_hom_fst",
              "def_path": "Mathlib/Topology/Category/TopCat/Limits/Products.lean",
              "def_pos": [
                204,
                9
              ],
              "def_end_pos": [
                204,
                28
              ]
            }
          ]
        ],
        "state_before": "case a\nJ : Type v\ninst\u271d : SmallCategory J\nX Y : TopCat\nx : \u2191(X \u2a2f Y)\n\u22a2 ((X.prodIsoProd Y).hom x).1 = (prod.fst x, prod.snd x).1",
        "state_after": "no goals"
      },
      {
        "tactic": "exact ConcreteCategory.congr_hom (prodIsoProd_hom_snd X Y) x",
        "annotated_tactic": [
          "exact <a>ConcreteCategory.congr_hom</a> (<a>prodIsoProd_hom_snd</a> X Y) x",
          [
            {
              "full_name": "CategoryTheory.ConcreteCategory.congr_hom",
              "def_path": "Mathlib/CategoryTheory/ConcreteCategory/Basic.lean",
              "def_pos": [
                141,
                9
              ],
              "def_end_pos": [
                141,
                35
              ]
            },
            {
              "full_name": "TopCat.prodIsoProd_hom_snd",
              "def_path": "Mathlib/Topology/Category/TopCat/Limits/Products.lean",
              "def_pos": [
                211,
                9
              ],
              "def_end_pos": [
                211,
                28
              ]
            }
          ]
        ],
        "state_before": "case a\nJ : Type v\ninst\u271d : SmallCategory J\nX Y : TopCat\nx : \u2191(X \u2a2f Y)\n\u22a2 ((X.prodIsoProd Y).hom x).2 = (prod.fst x, prod.snd x).2",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.404017655993812,
    "entry_failed": false
  },
  "18594": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/OmegaCompletePartialOrder.lean",
    "full_name": "is\u03c9Sup_\u03c9Sup",
    "start": [
      110,
      1
    ],
    "end": [
      113,
      18
    ],
    "traced_tactics": [
      {
        "tactic": "constructor",
        "annotated_tactic": [
          "constructor",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : OmegaCompletePartialOrder \u03b1\nc : Chain \u03b1\n\u22a2 Is\u03c9Sup c (\u03c9Sup c)",
        "state_after": "case left\n\u03b1 : Type u_1\ninst\u271d : OmegaCompletePartialOrder \u03b1\nc : Chain \u03b1\n\u22a2 \u2200 (i : \u2115), c i \u2264 \u03c9Sup c\n\ncase right\n\u03b1 : Type u_1\ninst\u271d : OmegaCompletePartialOrder \u03b1\nc : Chain \u03b1\n\u22a2 \u2200 (y : \u03b1), (\u2200 (i : \u2115), c i \u2264 y) \u2192 \u03c9Sup c \u2264 y"
      },
      {
        "tactic": "apply le_\u03c9Sup",
        "annotated_tactic": [
          "apply <a>le_\u03c9Sup</a>",
          [
            {
              "full_name": "OmegaCompletePartialOrder.le_\u03c9Sup",
              "def_path": "Mathlib/Order/OmegaCompletePartialOrder.lean",
              "def_pos": [
                188,
                3
              ],
              "def_end_pos": [
                188,
                10
              ]
            }
          ]
        ],
        "state_before": "case left\n\u03b1 : Type u_1\ninst\u271d : OmegaCompletePartialOrder \u03b1\nc : Chain \u03b1\n\u22a2 \u2200 (i : \u2115), c i \u2264 \u03c9Sup c",
        "state_after": "no goals"
      },
      {
        "tactic": "apply \u03c9Sup_le",
        "annotated_tactic": [
          "apply <a>\u03c9Sup_le</a>",
          [
            {
              "full_name": "OmegaCompletePartialOrder.\u03c9Sup_le",
              "def_path": "Mathlib/Order/OmegaCompletePartialOrder.lean",
              "def_pos": [
                190,
                3
              ],
              "def_end_pos": [
                190,
                10
              ]
            }
          ]
        ],
        "state_before": "case right\n\u03b1 : Type u_1\ninst\u271d : OmegaCompletePartialOrder \u03b1\nc : Chain \u03b1\n\u22a2 \u2200 (y : \u03b1), (\u2200 (i : \u2115), c i \u2264 y) \u2192 \u03c9Sup c \u2264 y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8801416360074654,
    "entry_failed": false
  },
  "18604": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/PythagoreanTriples.lean",
    "full_name": "coprime_sq_sub_mul",
    "start": [
      402,
      9
    ],
    "end": [
      407,
      60
    ],
    "traced_tactics": [
      {
        "tactic": "cases' hmn with h1 h2",
        "annotated_tactic": [
          "cases' hmn with h1 h2",
          []
        ],
        "state_before": "m n : \u2124\nh : m.gcd n = 1\nhmn : m % 2 = 0 \u2227 n % 2 = 1 \u2228 m % 2 = 1 \u2227 n % 2 = 0\n\u22a2 (m ^ 2 - n ^ 2).gcd (2 * m * n) = 1",
        "state_after": "case inl\nm n : \u2124\nh : m.gcd n = 1\nh1 : m % 2 = 0 \u2227 n % 2 = 1\n\u22a2 (m ^ 2 - n ^ 2).gcd (2 * m * n) = 1\n\ncase inr\nm n : \u2124\nh : m.gcd n = 1\nh2 : m % 2 = 1 \u2227 n % 2 = 0\n\u22a2 (m ^ 2 - n ^ 2).gcd (2 * m * n) = 1"
      },
      {
        "tactic": "exact coprime_sq_sub_mul_of_even_odd h h1.left h1.right",
        "annotated_tactic": [
          "exact <a>coprime_sq_sub_mul_of_even_odd</a> h h1.left h1.right",
          [
            {
              "full_name": "_private.Mathlib.NumberTheory.PythagoreanTriples.0.coprime_sq_sub_mul_of_even_odd",
              "def_path": "Mathlib/NumberTheory/PythagoreanTriples.lean",
              "def_pos": [
                363,
                17
              ],
              "def_end_pos": [
                363,
                47
              ]
            }
          ]
        ],
        "state_before": "case inl\nm n : \u2124\nh : m.gcd n = 1\nh1 : m % 2 = 0 \u2227 n % 2 = 1\n\u22a2 (m ^ 2 - n ^ 2).gcd (2 * m * n) = 1",
        "state_after": "no goals"
      },
      {
        "tactic": "exact coprime_sq_sub_mul_of_odd_even h h2.left h2.right",
        "annotated_tactic": [
          "exact <a>coprime_sq_sub_mul_of_odd_even</a> h h2.left h2.right",
          [
            {
              "full_name": "_private.Mathlib.NumberTheory.PythagoreanTriples.0.coprime_sq_sub_mul_of_odd_even",
              "def_path": "Mathlib/NumberTheory/PythagoreanTriples.lean",
              "def_pos": [
                396,
                17
              ],
              "def_end_pos": [
                396,
                47
              ]
            }
          ]
        ],
        "state_before": "case inr\nm n : \u2124\nh : m.gcd n = 1\nh2 : m % 2 = 1 \u2227 n % 2 = 0\n\u22a2 (m ^ 2 - n ^ 2).gcd (2 * m * n) = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.617481561959721,
    "entry_failed": false
  },
  "18655": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/Constructions/Polish.lean",
    "full_name": "IsClosed.analyticSet",
    "start": [
      288,
      1
    ],
    "end": [
      292,
      64
    ],
    "traced_tactics": [
      {
        "tactic": "haveI : PolishSpace s := hs.polishSpace",
        "annotated_tactic": [
          "haveI : <a>PolishSpace</a> s := hs.polishSpace",
          [
            {
              "full_name": "PolishSpace",
              "def_path": "Mathlib/Topology/MetricSpace/Polish.lean",
              "def_pos": [
                66,
                7
              ],
              "def_end_pos": [
                66,
                18
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : PolishSpace \u03b1\ns : Set \u03b1\nhs : IsClosed s\n\u22a2 AnalyticSet s",
        "state_after": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : PolishSpace \u03b1\ns : Set \u03b1\nhs : IsClosed s\nthis : PolishSpace \u2191s\n\u22a2 AnalyticSet s"
      },
      {
        "tactic": "rw [\u2190 @Subtype.range_val \u03b1 s]",
        "annotated_tactic": [
          "rw [\u2190 @<a>Subtype.range_val</a> \u03b1 s]",
          [
            {
              "full_name": "Subtype.range_val",
              "def_path": "Mathlib/Data/Set/Image.lean",
              "def_pos": [
                1381,
                9
              ],
              "def_end_pos": [
                1381,
                18
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : PolishSpace \u03b1\ns : Set \u03b1\nhs : IsClosed s\nthis : PolishSpace \u2191s\n\u22a2 AnalyticSet s",
        "state_after": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : PolishSpace \u03b1\ns : Set \u03b1\nhs : IsClosed s\nthis : PolishSpace \u2191s\n\u22a2 AnalyticSet (range Subtype.val)"
      },
      {
        "tactic": "exact analyticSet_range_of_polishSpace continuous_subtype_val",
        "annotated_tactic": [
          "exact <a>analyticSet_range_of_polishSpace</a> <a>continuous_subtype_val</a>",
          [
            {
              "full_name": "MeasureTheory.analyticSet_range_of_polishSpace",
              "def_path": "Mathlib/MeasureTheory/Constructions/Polish.lean",
              "def_pos": [
                174,
                9
              ],
              "def_end_pos": [
                174,
                41
              ]
            },
            {
              "full_name": "continuous_subtype_val",
              "def_path": "Mathlib/Topology/Constructions.lean",
              "def_pos": [
                1092,
                9
              ],
              "def_end_pos": [
                1092,
                31
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : PolishSpace \u03b1\ns : Set \u03b1\nhs : IsClosed s\nthis : PolishSpace \u2191s\n\u22a2 AnalyticSet (range Subtype.val)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.2141998179722577,
    "entry_failed": false
  },
  "18734": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/OuterMeasure/OfFunction.lean",
    "full_name": "MeasureTheory.OuterMeasure.le_boundedBy'",
    "start": [
      275,
      1
    ],
    "end": [
      279,
      56
    ],
    "traced_tactics": [
      {
        "tactic": "rw [le_boundedBy, forall_congr']",
        "annotated_tactic": [
          "rw [<a>le_boundedBy</a>, <a>forall_congr'</a>]",
          [
            {
              "full_name": "MeasureTheory.OuterMeasure.le_boundedBy",
              "def_path": "Mathlib/MeasureTheory/OuterMeasure/OfFunction.lean",
              "def_pos": [
                270,
                9
              ],
              "def_end_pos": [
                270,
                21
              ]
            },
            {
              "full_name": "forall_congr'",
              "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean",
              "def_pos": [
                207,
                9
              ],
              "def_end_pos": [
                207,
                22
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nm : Set \u03b1 \u2192 \u211d\u22650\u221e\n\u03bc : OuterMeasure \u03b1\n\u22a2 \u03bc \u2264 boundedBy m \u2194 \u2200 (s : Set \u03b1), s.Nonempty \u2192 \u03bc s \u2264 m s",
        "state_after": "\u03b1 : Type u_1\nm : Set \u03b1 \u2192 \u211d\u22650\u221e\n\u03bc : OuterMeasure \u03b1\n\u22a2 \u2200 (a : Set \u03b1), \u03bc a \u2264 m a \u2194 a.Nonempty \u2192 \u03bc a \u2264 m a"
      },
      {
        "tactic": "intro s",
        "annotated_tactic": [
          "intro s",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nm : Set \u03b1 \u2192 \u211d\u22650\u221e\n\u03bc : OuterMeasure \u03b1\n\u22a2 \u2200 (a : Set \u03b1), \u03bc a \u2264 m a \u2194 a.Nonempty \u2192 \u03bc a \u2264 m a",
        "state_after": "\u03b1 : Type u_1\nm : Set \u03b1 \u2192 \u211d\u22650\u221e\n\u03bc : OuterMeasure \u03b1\ns : Set \u03b1\n\u22a2 \u03bc s \u2264 m s \u2194 s.Nonempty \u2192 \u03bc s \u2264 m s"
      },
      {
        "tactic": "rcases s.eq_empty_or_nonempty with h | h <;> simp [h]",
        "annotated_tactic": [
          "rcases s.eq_empty_or_nonempty with h | h <;> simp [h]",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nm : Set \u03b1 \u2192 \u211d\u22650\u221e\n\u03bc : OuterMeasure \u03b1\ns : Set \u03b1\n\u22a2 \u03bc s \u2264 m s \u2194 s.Nonempty \u2192 \u03bc s \u2264 m s",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.5039730550488457,
    "entry_failed": false
  },
  "18783": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Surreal/Basic.lean",
    "full_name": "SetTheory.PGame.Numeric.isOption",
    "start": [
      92,
      1
    ],
    "end": [
      95,
      23
    ],
    "traced_tactics": [
      {
        "tactic": "cases h",
        "annotated_tactic": [
          "cases h",
          []
        ],
        "state_before": "x' x : PGame\nh : x'.IsOption x\nhx : x.Numeric\n\u22a2 x'.Numeric",
        "state_after": "case moveLeft\nx : PGame\nhx : x.Numeric\ni\u271d : x.LeftMoves\n\u22a2 (x.moveLeft i\u271d).Numeric\n\ncase moveRight\nx : PGame\nhx : x.Numeric\ni\u271d : x.RightMoves\n\u22a2 (x.moveRight i\u271d).Numeric"
      },
      {
        "tactic": "apply hx.moveLeft",
        "annotated_tactic": [
          "apply hx.moveLeft",
          []
        ],
        "state_before": "case moveLeft\nx : PGame\nhx : x.Numeric\ni\u271d : x.LeftMoves\n\u22a2 (x.moveLeft i\u271d).Numeric",
        "state_after": "no goals"
      },
      {
        "tactic": "apply hx.moveRight",
        "annotated_tactic": [
          "apply hx.moveRight",
          []
        ],
        "state_before": "case moveRight\nx : PGame\nhx : x.Numeric\ni\u271d : x.RightMoves\n\u22a2 (x.moveRight i\u271d).Numeric",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5300615490414202,
    "entry_failed": false
  },
  "18798": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Matroid/Basic.lean",
    "full_name": "Matroid.not_infiniteRk",
    "start": [
      430,
      1
    ],
    "end": [
      431,
      71
    ],
    "traced_tactics": [
      {
        "tactic": "intro h",
        "annotated_tactic": [
          "intro h",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nM\u271d M : Matroid \u03b1\ninst\u271d : M.FiniteRk\n\u22a2 \u00acM.InfiniteRk",
        "state_after": "\u03b1 : Type u_1\nM\u271d M : Matroid \u03b1\ninst\u271d : M.FiniteRk\nh : M.InfiniteRk\n\u22a2 False"
      },
      {
        "tactic": "obtain \u27e8B,hB\u27e9 := M.exists_base",
        "annotated_tactic": [
          "obtain \u27e8B,hB\u27e9 := M.exists_base",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nM\u271d M : Matroid \u03b1\ninst\u271d : M.FiniteRk\nh : M.InfiniteRk\n\u22a2 False",
        "state_after": "case intro\n\u03b1 : Type u_1\nM\u271d M : Matroid \u03b1\ninst\u271d : M.FiniteRk\nh : M.InfiniteRk\nB : Set \u03b1\nhB : M.Base B\n\u22a2 False"
      },
      {
        "tactic": "exact hB.infinite hB.finite",
        "annotated_tactic": [
          "exact hB.infinite hB.finite",
          []
        ],
        "state_before": "case intro\n\u03b1 : Type u_1\nM\u271d M : Matroid \u03b1\ninst\u271d : M.FiniteRk\nh : M.InfiniteRk\nB : Set \u03b1\nhB : M.Base B\n\u22a2 False",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.29320421803277,
    "entry_failed": false
  },
  "19057": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Cardinal/Finite.lean",
    "full_name": "Nat.card_sum",
    "start": [
      167,
      1
    ],
    "end": [
      170,
      55
    ],
    "traced_tactics": [
      {
        "tactic": "have := Fintype.ofFinite \u03b1",
        "annotated_tactic": [
          "have := <a>Fintype.ofFinite</a> \u03b1",
          [
            {
              "full_name": "Fintype.ofFinite",
              "def_path": "Mathlib/Data/Fintype/Card.lean",
              "def_pos": [
                449,
                19
              ],
              "def_end_pos": [
                449,
                35
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\n\u22a2 Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis : Fintype \u03b1\n\u22a2 Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2"
      },
      {
        "tactic": "have := Fintype.ofFinite \u03b2",
        "annotated_tactic": [
          "have := <a>Fintype.ofFinite</a> \u03b2",
          [
            {
              "full_name": "Fintype.ofFinite",
              "def_path": "Mathlib/Data/Fintype/Card.lean",
              "def_pos": [
                449,
                19
              ],
              "def_end_pos": [
                449,
                35
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis : Fintype \u03b1\n\u22a2 Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis\u271d : Fintype \u03b1\nthis : Fintype \u03b2\n\u22a2 Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2"
      },
      {
        "tactic": "simp_rw [Nat.card_eq_fintype_card, Fintype.card_sum]",
        "annotated_tactic": [
          "simp_rw [<a>Nat.card_eq_fintype_card</a>, <a>Fintype.card_sum</a>]",
          [
            {
              "full_name": "Nat.card_eq_fintype_card",
              "def_path": "Mathlib/SetTheory/Cardinal/Finite.lean",
              "def_pos": [
                40,
                9
              ],
              "def_end_pos": [
                40,
                29
              ]
            },
            {
              "full_name": "Fintype.card_sum",
              "def_path": "Mathlib/Data/Fintype/Sum.lean",
              "def_pos": [
                36,
                9
              ],
              "def_end_pos": [
                36,
                25
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Finite \u03b2\nthis\u271d : Fintype \u03b1\nthis : Fintype \u03b2\n\u22a2 Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.408982207067311,
    "entry_failed": false
  },
  "19105": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Finset/Card.lean",
    "full_name": "Finset.card_singleton_inter",
    "start": [
      92,
      1
    ],
    "end": [
      95,
      43
    ],
    "traced_tactics": [
      {
        "tactic": "cases' Finset.decidableMem a s with h h",
        "annotated_tactic": [
          "cases' <a>Finset.decidableMem</a> a s with h h",
          [
            {
              "full_name": "Finset.decidableMem",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                189,
                10
              ],
              "def_end_pos": [
                189,
                22
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t : Finset \u03b1\na b : \u03b1\ninst\u271d : DecidableEq \u03b1\n\u22a2 ({a} \u2229 s).card \u2264 1",
        "state_after": "case isFalse\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t : Finset \u03b1\na b : \u03b1\ninst\u271d : DecidableEq \u03b1\nh : a \u2209 s\n\u22a2 ({a} \u2229 s).card \u2264 1\n\ncase isTrue\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t : Finset \u03b1\na b : \u03b1\ninst\u271d : DecidableEq \u03b1\nh : a \u2208 s\n\u22a2 ({a} \u2229 s).card \u2264 1"
      },
      {
        "tactic": "simp [Finset.singleton_inter_of_not_mem h]",
        "annotated_tactic": [
          "simp [<a>Finset.singleton_inter_of_not_mem</a> h]",
          [
            {
              "full_name": "Finset.singleton_inter_of_not_mem",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                1716,
                9
              ],
              "def_end_pos": [
                1716,
                35
              ]
            }
          ]
        ],
        "state_before": "case isFalse\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t : Finset \u03b1\na b : \u03b1\ninst\u271d : DecidableEq \u03b1\nh : a \u2209 s\n\u22a2 ({a} \u2229 s).card \u2264 1",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [Finset.singleton_inter_of_mem h]",
        "annotated_tactic": [
          "simp [<a>Finset.singleton_inter_of_mem</a> h]",
          [
            {
              "full_name": "Finset.singleton_inter_of_mem",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                1711,
                9
              ],
              "def_end_pos": [
                1711,
                31
              ]
            }
          ]
        ],
        "state_before": "case isTrue\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t : Finset \u03b1\na b : \u03b1\ninst\u271d : DecidableEq \u03b1\nh : a \u2208 s\n\u22a2 ({a} \u2229 s).card \u2264 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.3293885400053114,
    "entry_failed": false
  },
  "19120": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Sym/Basic.lean",
    "full_name": "Sym.exists_eq_cons_of_succ",
    "start": [
      321,
      1
    ],
    "end": [
      323,
      58
    ],
    "traced_tactics": [
      {
        "tactic": "obtain \u27e8a, ha\u27e9 := exists_mem s",
        "annotated_tactic": [
          "obtain \u27e8a, ha\u27e9 := <a>exists_mem</a> s",
          [
            {
              "full_name": "Sym.exists_mem",
              "def_path": "Mathlib/Data/Sym/Basic.lean",
              "def_pos": [
                307,
                9
              ],
              "def_end_pos": [
                307,
                19
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn n' m : \u2115\ns\u271d : Sym \u03b1 n\na b : \u03b1\ns : Sym \u03b1 n.succ\n\u22a2 \u2203 a s', s = a ::\u209b s'",
        "state_after": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nn n' m : \u2115\ns\u271d : Sym \u03b1 n\na\u271d b : \u03b1\ns : Sym \u03b1 n.succ\na : \u03b1\nha : a \u2208 s\n\u22a2 \u2203 a s', s = a ::\u209b s'"
      },
      {
        "tactic": "classical exact \u27e8a, s.erase a ha, (cons_erase ha).symm\u27e9",
        "annotated_tactic": [
          "classical exact \u27e8a, s.erase a ha, (<a>cons_erase</a> ha).<a>symm</a>\u27e9",
          [
            {
              "full_name": "Sym.cons_erase",
              "def_path": "Mathlib/Data/Sym/Basic.lean",
              "def_pos": [
                231,
                9
              ],
              "def_end_pos": [
                231,
                19
              ]
            },
            {
              "full_name": "Eq.symm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                323,
                9
              ],
              "def_end_pos": [
                323,
                16
              ]
            }
          ]
        ],
        "state_before": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nn n' m : \u2115\ns\u271d : Sym \u03b1 n\na\u271d b : \u03b1\ns : Sym \u03b1 n.succ\na : \u03b1\nha : a \u2208 s\n\u22a2 \u2203 a s', s = a ::\u209b s'",
        "state_after": "no goals"
      },
      {
        "tactic": "exact \u27e8a, s.erase a ha, (cons_erase ha).symm\u27e9",
        "annotated_tactic": [
          "exact \u27e8a, s.erase a ha, (<a>cons_erase</a> ha).<a>symm</a>\u27e9",
          [
            {
              "full_name": "Sym.cons_erase",
              "def_path": "Mathlib/Data/Sym/Basic.lean",
              "def_pos": [
                231,
                9
              ],
              "def_end_pos": [
                231,
                19
              ]
            },
            {
              "full_name": "Eq.symm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                323,
                9
              ],
              "def_end_pos": [
                323,
                16
              ]
            }
          ]
        ],
        "state_before": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nn n' m : \u2115\ns\u271d : Sym \u03b1 n\na\u271d b : \u03b1\ns : Sym \u03b1 n.succ\na : \u03b1\nha : a \u2208 s\n\u22a2 \u2203 a s', s = a ::\u209b s'",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.4811249350896105,
    "entry_failed": false
  },
  "19165": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean",
    "full_name": "Polynomial.map_cyclotomic_int",
    "start": [
      266,
      1
    ],
    "end": [
      270,
      27
    ],
    "traced_tactics": [
      {
        "tactic": "by_cases hzero : n = 0",
        "annotated_tactic": [
          "by_cases hzero : n = 0",
          []
        ],
        "state_before": "n : \u2115\nR : Type u_1\ninst\u271d : Ring R\n\u22a2 map (Int.castRingHom R) (cyclotomic n \u2124) = cyclotomic n R",
        "state_after": "case pos\nn : \u2115\nR : Type u_1\ninst\u271d : Ring R\nhzero : n = 0\n\u22a2 map (Int.castRingHom R) (cyclotomic n \u2124) = cyclotomic n R\n\ncase neg\nn : \u2115\nR : Type u_1\ninst\u271d : Ring R\nhzero : \u00acn = 0\n\u22a2 map (Int.castRingHom R) (cyclotomic n \u2124) = cyclotomic n R"
      },
      {
        "tactic": "simp [cyclotomic, hzero]",
        "annotated_tactic": [
          "simp [<a>cyclotomic</a>, hzero]",
          [
            {
              "full_name": "Polynomial.cyclotomic",
              "def_path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean",
              "def_pos": [
                253,
                5
              ],
              "def_end_pos": [
                253,
                15
              ]
            }
          ]
        ],
        "state_before": "case neg\nn : \u2115\nR : Type u_1\ninst\u271d : Ring R\nhzero : \u00acn = 0\n\u22a2 map (Int.castRingHom R) (cyclotomic n \u2124) = cyclotomic n R",
        "state_after": "no goals"
      },
      {
        "tactic": "simp only [hzero, cyclotomic, dif_pos, Polynomial.map_one]",
        "annotated_tactic": [
          "simp only [hzero, <a>cyclotomic</a>, <a>dif_pos</a>, <a>Polynomial.map_one</a>]",
          [
            {
              "full_name": "Polynomial.cyclotomic",
              "def_path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean",
              "def_pos": [
                253,
                5
              ],
              "def_end_pos": [
                253,
                15
              ]
            },
            {
              "full_name": "dif_pos",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                949,
                9
              ],
              "def_end_pos": [
                949,
                16
              ]
            },
            {
              "full_name": "Polynomial.map_one",
              "def_path": "Mathlib/Algebra/Polynomial/Eval.lean",
              "def_pos": [
                744,
                19
              ],
              "def_end_pos": [
                744,
                26
              ]
            }
          ]
        ],
        "state_before": "case pos\nn : \u2115\nR : Type u_1\ninst\u271d : Ring R\nhzero : n = 0\n\u22a2 map (Int.castRingHom R) (cyclotomic n \u2124) = cyclotomic n R",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.9808217169484124,
    "entry_failed": false
  },
  "19173": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Finmap.lean",
    "full_name": "Finmap.not_mem_erase_self",
    "start": [
      438,
      1
    ],
    "end": [
      441,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "rw [mem_erase, not_and_or, not_not]",
        "annotated_tactic": [
          "rw [<a>mem_erase</a>, <a>not_and_or</a>, <a>not_not</a>]",
          [
            {
              "full_name": "Finmap.mem_erase",
              "def_path": "Mathlib/Data/Finmap.lean",
              "def_pos": [
                434,
                9
              ],
              "def_end_pos": [
                434,
                18
              ]
            },
            {
              "full_name": "not_and_or",
              "def_path": "Mathlib/Logic/Basic.lean",
              "def_pos": [
                481,
                9
              ],
              "def_end_pos": [
                481,
                19
              ]
            },
            {
              "full_name": "Classical.not_not",
              "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean",
              "def_pos": [
                135,
                17
              ],
              "def_end_pos": [
                135,
                24
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : DecidableEq \u03b1\na : \u03b1\ns : Finmap \u03b2\n\u22a2 a \u2209 erase a s",
        "state_after": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : DecidableEq \u03b1\na : \u03b1\ns : Finmap \u03b2\n\u22a2 a = a \u2228 a \u2209 s"
      },
      {
        "tactic": "left",
        "annotated_tactic": [
          "left",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : DecidableEq \u03b1\na : \u03b1\ns : Finmap \u03b2\n\u22a2 a = a \u2228 a \u2209 s",
        "state_after": "case h\n\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : DecidableEq \u03b1\na : \u03b1\ns : Finmap \u03b2\n\u22a2 a = a"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case h\n\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\ninst\u271d : DecidableEq \u03b1\na : \u03b1\ns : Finmap \u03b2\n\u22a2 a = a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.1663805639836937,
    "entry_failed": false
  },
  "19253": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/NNRat/Defs.lean",
    "full_name": "NNRat.divNat_mul_left",
    "start": [
      420,
      1
    ],
    "end": [
      421,
      58
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "p q : \u211a\u22650\nn\u2081 n\u2082 d\u2081 d\u2082 d\u271d a : \u2115\nha : a \u2260 0\nn d : \u2115\n\u22a2 divNat (a * n) (a * d) = divNat n d",
        "state_after": "case a\np q : \u211a\u22650\nn\u2081 n\u2082 d\u2081 d\u2082 d\u271d a : \u2115\nha : a \u2260 0\nn d : \u2115\n\u22a2 \u2191(divNat (a * n) (a * d)) = \u2191(divNat n d)"
      },
      {
        "tactic": "push_cast",
        "annotated_tactic": [
          "push_cast",
          []
        ],
        "state_before": "case a\np q : \u211a\u22650\nn\u2081 n\u2082 d\u2081 d\u2082 d\u271d a : \u2115\nha : a \u2260 0\nn d : \u2115\n\u22a2 \u2191(divNat (a * n) (a * d)) = \u2191(divNat n d)",
        "state_after": "case a\np q : \u211a\u22650\nn\u2081 n\u2082 d\u2081 d\u2082 d\u271d a : \u2115\nha : a \u2260 0\nn d : \u2115\n\u22a2 Rat.divInt (\u2191a * \u2191n) (\u2191a * \u2191d) = Rat.divInt \u2191n \u2191d"
      },
      {
        "tactic": "exact Rat.divInt_mul_left (mod_cast ha)",
        "annotated_tactic": [
          "exact <a>Rat.divInt_mul_left</a> (mod_cast ha)",
          [
            {
              "full_name": "Rat.divInt_mul_left",
              "def_path": ".lake/packages/batteries/Batteries/Data/Rat/Lemmas.lean",
              "def_pos": [
                163,
                9
              ],
              "def_end_pos": [
                163,
                24
              ]
            }
          ]
        ],
        "state_before": "case a\np q : \u211a\u22650\nn\u2081 n\u2082 d\u2081 d\u2082 d\u271d a : \u2115\nha : a \u2260 0\nn d : \u2115\n\u22a2 Rat.divInt (\u2191a * \u2191n) (\u2191a * \u2191d) = Rat.divInt \u2191n \u2191d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.4005597210489213,
    "entry_failed": false
  },
  "19261": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/HahnSeries/Multiplication.lean",
    "full_name": "HahnSeries.order_one",
    "start": [
      65,
      1
    ],
    "end": [
      68,
      35
    ],
    "traced_tactics": [
      {
        "tactic": "cases subsingleton_or_nontrivial R",
        "annotated_tactic": [
          "cases <a>subsingleton_or_nontrivial</a> R",
          [
            {
              "full_name": "subsingleton_or_nontrivial",
              "def_path": "Mathlib/Logic/Nontrivial/Defs.lean",
              "def_pos": [
                99,
                9
              ],
              "def_end_pos": [
                99,
                35
              ]
            }
          ]
        ],
        "state_before": "\u0393 : Type u_1\n\u0393' : Type u_2\nR : Type u_3\ninst\u271d\u00b2 : Zero \u0393\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : MulZeroOneClass R\n\u22a2 order 1 = 0",
        "state_after": "case inl\n\u0393 : Type u_1\n\u0393' : Type u_2\nR : Type u_3\ninst\u271d\u00b2 : Zero \u0393\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : MulZeroOneClass R\nh\u271d : Subsingleton R\n\u22a2 order 1 = 0\n\ncase inr\n\u0393 : Type u_1\n\u0393' : Type u_2\nR : Type u_3\ninst\u271d\u00b2 : Zero \u0393\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : MulZeroOneClass R\nh\u271d : Nontrivial R\n\u22a2 order 1 = 0"
      },
      {
        "tactic": "rw [Subsingleton.elim (1 : HahnSeries \u0393 R) 0, order_zero]",
        "annotated_tactic": [
          "rw [<a>Subsingleton.elim</a> (1 : <a>HahnSeries</a> \u0393 R) 0, <a>order_zero</a>]",
          [
            {
              "full_name": "Subsingleton.elim",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1015,
                19
              ],
              "def_end_pos": [
                1015,
                36
              ]
            },
            {
              "full_name": "HahnSeries",
              "def_path": "Mathlib/RingTheory/HahnSeries/Basic.lean",
              "def_pos": [
                45,
                11
              ],
              "def_end_pos": [
                45,
                21
              ]
            },
            {
              "full_name": "HahnSeries.order_zero",
              "def_path": "Mathlib/RingTheory/HahnSeries/Basic.lean",
              "def_pos": [
                301,
                9
              ],
              "def_end_pos": [
                301,
                19
              ]
            }
          ]
        ],
        "state_before": "case inl\n\u0393 : Type u_1\n\u0393' : Type u_2\nR : Type u_3\ninst\u271d\u00b2 : Zero \u0393\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : MulZeroOneClass R\nh\u271d : Subsingleton R\n\u22a2 order 1 = 0",
        "state_after": "no goals"
      },
      {
        "tactic": "exact order_single one_ne_zero",
        "annotated_tactic": [
          "exact <a>order_single</a> <a>one_ne_zero</a>",
          [
            {
              "full_name": "HahnSeries.order_single",
              "def_path": "Mathlib/RingTheory/HahnSeries/Basic.lean",
              "def_pos": [
                325,
                9
              ],
              "def_end_pos": [
                325,
                21
              ]
            },
            {
              "full_name": "one_ne_zero",
              "def_path": "Mathlib/Algebra/NeZero.lean",
              "def_pos": [
                58,
                15
              ],
              "def_end_pos": [
                58,
                26
              ]
            }
          ]
        ],
        "state_before": "case inr\n\u0393 : Type u_1\n\u0393' : Type u_2\nR : Type u_3\ninst\u271d\u00b2 : Zero \u0393\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : MulZeroOneClass R\nh\u271d : Nontrivial R\n\u22a2 order 1 = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9139549869578332,
    "entry_failed": false
  },
  "19332": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean",
    "full_name": "NNReal.sqrt_eq_rpow",
    "start": [
      128,
      1
    ],
    "end": [
      131,
      30
    ],
    "traced_tactics": [
      {
        "tactic": "refine NNReal.eq ?_",
        "annotated_tactic": [
          "refine <a>NNReal.eq</a> ?_",
          [
            {
              "full_name": "NNReal.eq",
              "def_path": "Mathlib/Data/NNReal/Basic.lean",
              "def_pos": [
                97,
                26
              ],
              "def_end_pos": [
                97,
                28
              ]
            }
          ]
        ],
        "state_before": "w x\u271d y z : \u211d\nx : \u211d\u22650\n\u22a2 sqrt x = x ^ (1 / 2)",
        "state_after": "w x\u271d y z : \u211d\nx : \u211d\u22650\n\u22a2 \u2191(sqrt x) = \u2191(x ^ (1 / 2))"
      },
      {
        "tactic": "push_cast",
        "annotated_tactic": [
          "push_cast",
          []
        ],
        "state_before": "w x\u271d y z : \u211d\nx : \u211d\u22650\n\u22a2 \u2191(sqrt x) = \u2191(x ^ (1 / 2))",
        "state_after": "w x\u271d y z : \u211d\nx : \u211d\u22650\n\u22a2 \u221a\u2191x = \u2191x ^ (1 / 2)"
      },
      {
        "tactic": "exact Real.sqrt_eq_rpow x.1",
        "annotated_tactic": [
          "exact <a>Real.sqrt_eq_rpow</a> x.1",
          [
            {
              "full_name": "Real.sqrt_eq_rpow",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean",
              "def_pos": [
                908,
                9
              ],
              "def_end_pos": [
                908,
                21
              ]
            }
          ]
        ],
        "state_before": "w x\u271d y z : \u211d\nx : \u211d\u22650\n\u22a2 \u221a\u2191x = \u2191x ^ (1 / 2)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.1542119740042835,
    "entry_failed": false
  },
  "19365": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/MetricSpace/GromovHausdorff.lean",
    "full_name": "GromovHausdorff.GHSpace.toGHSpace_rep",
    "start": [
      142,
      1
    ],
    "end": [
      145,
      22
    ],
    "traced_tactics": [
      {
        "tactic": "change toGHSpace (Quot.out p : NonemptyCompacts \u2113_infty_\u211d) = p",
        "annotated_tactic": [
          "change <a>toGHSpace</a> (<a>Quot.out</a> p : <a>NonemptyCompacts</a> \u2113_infty_\u211d) = p",
          [
            {
              "full_name": "GromovHausdorff.toGHSpace",
              "def_path": "Mathlib/Topology/MetricSpace/GromovHausdorff.lean",
              "def_pos": [
                90,
                5
              ],
              "def_end_pos": [
                90,
                14
              ]
            },
            {
              "full_name": "Quot.out",
              "def_path": "Mathlib/Data/Quot.lean",
              "def_pos": [
                363,
                19
              ],
              "def_end_pos": [
                363,
                27
              ]
            },
            {
              "full_name": "TopologicalSpace.NonemptyCompacts",
              "def_path": "Mathlib/Topology/Sets/Compacts.lean",
              "def_pos": [
                208,
                11
              ],
              "def_end_pos": [
                208,
                27
              ]
            }
          ]
        ],
        "state_before": "p : GHSpace\n\u22a2 toGHSpace p.Rep = p",
        "state_after": "p : GHSpace\n\u22a2 toGHSpace \u21a5(Quot.out p) = p"
      },
      {
        "tactic": "rw [\u2190 eq_toGHSpace]",
        "annotated_tactic": [
          "rw [\u2190 <a>eq_toGHSpace</a>]",
          [
            {
              "full_name": "GromovHausdorff.eq_toGHSpace",
              "def_path": "Mathlib/Topology/MetricSpace/GromovHausdorff.lean",
              "def_pos": [
                122,
                9
              ],
              "def_end_pos": [
                122,
                21
              ]
            }
          ]
        ],
        "state_before": "p : GHSpace\n\u22a2 toGHSpace \u21a5(Quot.out p) = p",
        "state_after": "p : GHSpace\n\u22a2 \u27e6Quot.out p\u27e7 = p"
      },
      {
        "tactic": "exact Quot.out_eq p",
        "annotated_tactic": [
          "exact <a>Quot.out_eq</a> p",
          [
            {
              "full_name": "Quot.out_eq",
              "def_path": "Mathlib/Data/Quot.lean",
              "def_pos": [
                373,
                9
              ],
              "def_end_pos": [
                373,
                20
              ]
            }
          ]
        ],
        "state_before": "p : GHSpace\n\u22a2 \u27e6Quot.out p\u27e7 = p",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.784608029993251,
    "entry_failed": false
  },
  "19512": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean",
    "full_name": "Real.Angle.neg_coe_pi",
    "start": [
      134,
      1
    ],
    "end": [
      137,
      33
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 coe_neg, angle_eq_iff_two_pi_dvd_sub]",
        "annotated_tactic": [
          "rw [\u2190 <a>coe_neg</a>, <a>angle_eq_iff_two_pi_dvd_sub</a>]",
          [
            {
              "full_name": "Real.Angle.coe_neg",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean",
              "def_pos": [
                89,
                9
              ],
              "def_end_pos": [
                89,
                16
              ]
            },
            {
              "full_name": "Real.Angle.angle_eq_iff_two_pi_dvd_sub",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean",
              "def_pos": [
                119,
                9
              ],
              "def_end_pos": [
                119,
                36
              ]
            }
          ]
        ],
        "state_before": "\u22a2 -\u2191\u03c0 = \u2191\u03c0",
        "state_after": "\u22a2 \u2203 k, -\u03c0 - \u03c0 = 2 * \u03c0 * \u2191k"
      },
      {
        "tactic": "use -1",
        "annotated_tactic": [
          "use -1",
          []
        ],
        "state_before": "\u22a2 \u2203 k, -\u03c0 - \u03c0 = 2 * \u03c0 * \u2191k",
        "state_after": "case h\n\n\u22a2 -\u03c0 - \u03c0 = 2 * \u03c0 * \u2191(-1)"
      },
      {
        "tactic": "simp [two_mul, sub_eq_add_neg]",
        "annotated_tactic": [
          "simp [<a>two_mul</a>, <a>sub_eq_add_neg</a>]",
          [
            {
              "full_name": "two_mul",
              "def_path": "Mathlib/Algebra/Ring/Defs.lean",
              "def_pos": [
                179,
                9
              ],
              "def_end_pos": [
                179,
                16
              ]
            },
            {
              "full_name": "sub_eq_add_neg",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                1057,
                3
              ],
              "def_end_pos": [
                1057,
                14
              ]
            }
          ]
        ],
        "state_before": "case h\n\n\u22a2 -\u03c0 - \u03c0 = 2 * \u03c0 * \u2191(-1)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.903725395910442,
    "entry_failed": false
  },
  "19621": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Rotate.lean",
    "full_name": "List.IsRotated.cyclicPermutations",
    "start": [
      684,
      11
    ],
    "end": [
      687,
      21
    ],
    "traced_tactics": [
      {
        "tactic": "obtain \u27e8k, rfl\u27e9 := h",
        "annotated_tactic": [
          "obtain \u27e8k, rfl\u27e9 := h",
          []
        ],
        "state_before": "\u03b1 : Type u\nl\u271d l'\u271d l l' : List \u03b1\nh : l ~r l'\n\u22a2 l.cyclicPermutations ~r l'.cyclicPermutations",
        "state_after": "case intro\n\u03b1 : Type u\nl\u271d l' l : List \u03b1\nk : \u2115\n\u22a2 l.cyclicPermutations ~r (l.rotate k).cyclicPermutations"
      },
      {
        "tactic": "exact \u27e8k, by simp\u27e9",
        "annotated_tactic": [
          "exact \u27e8k, by simp\u27e9",
          []
        ],
        "state_before": "case intro\n\u03b1 : Type u\nl\u271d l' l : List \u03b1\nk : \u2115\n\u22a2 l.cyclicPermutations ~r (l.rotate k).cyclicPermutations",
        "state_after": "no goals"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "\u03b1 : Type u\nl\u271d l' l : List \u03b1\nk : \u2115\n\u22a2 l.cyclicPermutations.rotate k = (l.rotate k).cyclicPermutations",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.4808384228963405,
    "entry_failed": false
  },
  "19636": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Seq/Seq.lean",
    "full_name": "Stream'.Seq.tail_cons",
    "start": [
      265,
      1
    ],
    "end": [
      268,
      21
    ],
    "traced_tactics": [
      {
        "tactic": "cases' s with f al",
        "annotated_tactic": [
          "cases' s with f al",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\na : \u03b1\ns : Seq \u03b1\n\u22a2 (cons a s).tail = s",
        "state_after": "case mk\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\na : \u03b1\nf : Stream' (Option \u03b1)\nal : f.IsSeq\n\u22a2 (cons a \u27e8f, al\u27e9).tail = \u27e8f, al\u27e9"
      },
      {
        "tactic": "apply Subtype.eq",
        "annotated_tactic": [
          "apply <a>Subtype.eq</a>",
          [
            {
              "full_name": "Subtype.eq",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1110,
                19
              ],
              "def_end_pos": [
                1110,
                21
              ]
            }
          ]
        ],
        "state_before": "case mk\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\na : \u03b1\nf : Stream' (Option \u03b1)\nal : f.IsSeq\n\u22a2 (cons a \u27e8f, al\u27e9).tail = \u27e8f, al\u27e9",
        "state_after": "case mk.a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\na : \u03b1\nf : Stream' (Option \u03b1)\nal : f.IsSeq\n\u22a2 \u2191(cons a \u27e8f, al\u27e9).tail = \u2191\u27e8f, al\u27e9"
      },
      {
        "tactic": "dsimp [tail, cons]",
        "annotated_tactic": [
          "dsimp [<a>tail</a>, <a>cons</a>]",
          [
            {
              "full_name": "Stream'.Seq.tail",
              "def_path": "Mathlib/Data/Seq/Seq.lean",
              "def_pos": [
                146,
                5
              ],
              "def_end_pos": [
                146,
                9
              ]
            },
            {
              "full_name": "Stream'.Seq.cons",
              "def_path": "Mathlib/Data/Seq/Seq.lean",
              "def_pos": [
                59,
                5
              ],
              "def_end_pos": [
                59,
                9
              ]
            }
          ]
        ],
        "state_before": "case mk.a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\na : \u03b1\nf : Stream' (Option \u03b1)\nal : f.IsSeq\n\u22a2 \u2191(cons a \u27e8f, al\u27e9).tail = \u2191\u27e8f, al\u27e9",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.375085200998001,
    "entry_failed": false
  },
  "19672": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/MetricSpace/PiNat.lean",
    "full_name": "PiNat.cylinder_eq_res",
    "start": [
      247,
      1
    ],
    "end": [
      251,
      18
    ],
    "traced_tactics": [
      {
        "tactic": "ext y",
        "annotated_tactic": [
          "ext y",
          []
        ],
        "state_before": "E : \u2115 \u2192 Type u_1\n\u03b1 : Type u_2\nx : \u2115 \u2192 \u03b1\nn : \u2115\n\u22a2 cylinder x n = {y | res y n = res x n}",
        "state_after": "case h\nE : \u2115 \u2192 Type u_1\n\u03b1 : Type u_2\nx : \u2115 \u2192 \u03b1\nn : \u2115\ny : \u2115 \u2192 \u03b1\n\u22a2 y \u2208 cylinder x n \u2194 y \u2208 {y | res y n = res x n}"
      },
      {
        "tactic": "dsimp [cylinder]",
        "annotated_tactic": [
          "dsimp [<a>cylinder</a>]",
          [
            {
              "full_name": "PiNat.cylinder",
              "def_path": "Mathlib/Topology/MetricSpace/PiNat.lean",
              "def_pos": [
                108,
                5
              ],
              "def_end_pos": [
                108,
                13
              ]
            }
          ]
        ],
        "state_before": "case h\nE : \u2115 \u2192 Type u_1\n\u03b1 : Type u_2\nx : \u2115 \u2192 \u03b1\nn : \u2115\ny : \u2115 \u2192 \u03b1\n\u22a2 y \u2208 cylinder x n \u2194 y \u2208 {y | res y n = res x n}",
        "state_after": "case h\nE : \u2115 \u2192 Type u_1\n\u03b1 : Type u_2\nx : \u2115 \u2192 \u03b1\nn : \u2115\ny : \u2115 \u2192 \u03b1\n\u22a2 (\u2200 i < n, y i = x i) \u2194 res y n = res x n"
      },
      {
        "tactic": "rw [res_eq_res]",
        "annotated_tactic": [
          "rw [<a>res_eq_res</a>]",
          [
            {
              "full_name": "PiNat.res_eq_res",
              "def_path": "Mathlib/Topology/MetricSpace/PiNat.lean",
              "def_pos": [
                223,
                9
              ],
              "def_end_pos": [
                223,
                19
              ]
            }
          ]
        ],
        "state_before": "case h\nE : \u2115 \u2192 Type u_1\n\u03b1 : Type u_2\nx : \u2115 \u2192 \u03b1\nn : \u2115\ny : \u2115 \u2192 \u03b1\n\u22a2 (\u2200 i < n, y i = x i) \u2194 res y n = res x n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.3956184659618884,
    "entry_failed": false
  },
  "19694": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/Normed/Group/SemiNormedGrp/Kernels.lean",
    "full_name": "SemiNormedGrp.explicitCokernelDesc_comp_eq_desc",
    "start": [
      284,
      1
    ],
    "end": [
      292,
      63
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 CategoryTheory.Category.assoc, cond', Limits.zero_comp]",
        "annotated_tactic": [
          "rw [\u2190 <a>CategoryTheory.Category.assoc</a>, cond', <a>Limits.zero_comp</a>]",
          [
            {
              "full_name": "CategoryTheory.Category.assoc",
              "def_path": "Mathlib/CategoryTheory/Category/Basic.lean",
              "def_pos": [
                181,
                3
              ],
              "def_end_pos": [
                181,
                8
              ]
            },
            {
              "full_name": "CategoryTheory.Limits.zero_comp",
              "def_path": "Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean",
              "def_pos": [
                72,
                9
              ],
              "def_end_pos": [
                72,
                18
              ]
            }
          ]
        ],
        "state_before": "X Y Z W : SemiNormedGrp\nf : X \u27f6 Y\ng : Y \u27f6 Z\nh : Z \u27f6 W\ncond' : f \u226b g = 0\n\u22a2 f \u226b g \u226b h = 0",
        "state_after": "no goals"
      },
      {
        "tactic": "refine explicitCokernelDesc_unique _ _ ?_",
        "annotated_tactic": [
          "refine <a>explicitCokernelDesc_unique</a> _ _ ?_",
          [
            {
              "full_name": "SemiNormedGrp.explicitCokernelDesc_unique",
              "def_path": "Mathlib/Analysis/Normed/Group/SemiNormedGrp/Kernels.lean",
              "def_pos": [
                273,
                9
              ],
              "def_end_pos": [
                273,
                36
              ]
            }
          ]
        ],
        "state_before": "X Y Z W : SemiNormedGrp\nf : X \u27f6 Y\ng : Y \u27f6 Z\nh : Z \u27f6 W\ncond' : f \u226b g = 0\n\u22a2 explicitCokernelDesc cond' \u226b h = explicitCokernelDesc \u22ef",
        "state_after": "X Y Z W : SemiNormedGrp\nf : X \u27f6 Y\ng : Y \u27f6 Z\nh : Z \u27f6 W\ncond' : f \u226b g = 0\n\u22a2 explicitCokernel\u03c0 f \u226b explicitCokernelDesc cond' \u226b h = g \u226b h"
      },
      {
        "tactic": "rw [\u2190 CategoryTheory.Category.assoc, explicitCokernel\u03c0_desc]",
        "annotated_tactic": [
          "rw [\u2190 <a>CategoryTheory.Category.assoc</a>, <a>explicitCokernel\u03c0_desc</a>]",
          [
            {
              "full_name": "CategoryTheory.Category.assoc",
              "def_path": "Mathlib/CategoryTheory/Category/Basic.lean",
              "def_pos": [
                181,
                3
              ],
              "def_end_pos": [
                181,
                8
              ]
            },
            {
              "full_name": "SemiNormedGrp.explicitCokernel\u03c0_desc",
              "def_path": "Mathlib/Analysis/Normed/Group/SemiNormedGrp/Kernels.lean",
              "def_pos": [
                260,
                9
              ],
              "def_end_pos": [
                260,
                31
              ]
            }
          ]
        ],
        "state_before": "X Y Z W : SemiNormedGrp\nf : X \u27f6 Y\ng : Y \u27f6 Z\nh : Z \u27f6 W\ncond' : f \u226b g = 0\n\u22a2 explicitCokernel\u03c0 f \u226b explicitCokernelDesc cond' \u226b h = g \u226b h",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.9410873090382665,
    "entry_failed": false
  },
  "19711": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Coprime/Lemmas.lean",
    "full_name": "Nat.Coprime.cast",
    "start": [
      50,
      1
    ],
    "end": [
      54,
      28
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 isCoprime_iff_coprime] at h",
        "annotated_tactic": [
          "rw [\u2190 <a>isCoprime_iff_coprime</a>] at h",
          [
            {
              "full_name": "Nat.isCoprime_iff_coprime",
              "def_path": "Mathlib/RingTheory/Coprime/Lemmas.lean",
              "def_pos": [
                42,
                9
              ],
              "def_end_pos": [
                42,
                34
              ]
            }
          ]
        ],
        "state_before": "R\u271d : Type u\nI : Type v\ninst\u271d\u00b9 : CommSemiring R\u271d\nx y z : R\u271d\ns : I \u2192 R\u271d\nt : Finset I\nR : Type u_1\ninst\u271d : CommRing R\na b : \u2115\nh : a.Coprime b\n\u22a2 IsCoprime \u2191a \u2191b",
        "state_after": "R\u271d : Type u\nI : Type v\ninst\u271d\u00b9 : CommSemiring R\u271d\nx y z : R\u271d\ns : I \u2192 R\u271d\nt : Finset I\nR : Type u_1\ninst\u271d : CommRing R\na b : \u2115\nh : IsCoprime \u2191a \u2191b\n\u22a2 IsCoprime \u2191a \u2191b"
      },
      {
        "tactic": "rw [\u2190 Int.cast_natCast a, \u2190 Int.cast_natCast b]",
        "annotated_tactic": [
          "rw [\u2190 <a>Int.cast_natCast</a> a, \u2190 <a>Int.cast_natCast</a> b]",
          [
            {
              "full_name": "Int.cast_natCast",
              "def_path": "Mathlib/Data/Int/Cast/Basic.lean",
              "def_pos": [
                66,
                9
              ],
              "def_end_pos": [
                66,
                21
              ]
            },
            {
              "full_name": "Int.cast_natCast",
              "def_path": "Mathlib/Data/Int/Cast/Basic.lean",
              "def_pos": [
                66,
                9
              ],
              "def_end_pos": [
                66,
                21
              ]
            }
          ]
        ],
        "state_before": "R\u271d : Type u\nI : Type v\ninst\u271d\u00b9 : CommSemiring R\u271d\nx y z : R\u271d\ns : I \u2192 R\u271d\nt : Finset I\nR : Type u_1\ninst\u271d : CommRing R\na b : \u2115\nh : IsCoprime \u2191a \u2191b\n\u22a2 IsCoprime \u2191a \u2191b",
        "state_after": "R\u271d : Type u\nI : Type v\ninst\u271d\u00b9 : CommSemiring R\u271d\nx y z : R\u271d\ns : I \u2192 R\u271d\nt : Finset I\nR : Type u_1\ninst\u271d : CommRing R\na b : \u2115\nh : IsCoprime \u2191a \u2191b\n\u22a2 IsCoprime \u2191\u2191a \u2191\u2191b"
      },
      {
        "tactic": "exact IsCoprime.intCast h",
        "annotated_tactic": [
          "exact <a>IsCoprime.intCast</a> h",
          [
            {
              "full_name": "IsCoprime.intCast",
              "def_path": "Mathlib/RingTheory/Coprime/Basic.lean",
              "def_pos": [
                76,
                7
              ],
              "def_end_pos": [
                76,
                24
              ]
            }
          ]
        ],
        "state_before": "R\u271d : Type u\nI : Type v\ninst\u271d\u00b9 : CommSemiring R\u271d\nx y z : R\u271d\ns : I \u2192 R\u271d\nt : Finset I\nR : Type u_1\ninst\u271d : CommRing R\na b : \u2115\nh : IsCoprime \u2191a \u2191b\n\u22a2 IsCoprime \u2191\u2191a \u2191\u2191b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.534621698083356,
    "entry_failed": false
  },
  "19754": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/SpecificGroups/Quaternion.lean",
    "full_name": "QuaternionGroup.quaternionGroup_one_isCyclic",
    "start": [
      226,
      1
    ],
    "end": [
      229,
      23
    ],
    "traced_tactics": [
      {
        "tactic": "apply isCyclic_of_orderOf_eq_card",
        "annotated_tactic": [
          "apply <a>isCyclic_of_orderOf_eq_card</a>",
          [
            {
              "full_name": "isCyclic_of_orderOf_eq_card",
              "def_path": "Mathlib/GroupTheory/SpecificGroups/Cyclic.lean",
              "def_pos": [
                124,
                9
              ],
              "def_end_pos": [
                124,
                36
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\n\u22a2 IsCyclic (QuaternionGroup 1)",
        "state_after": "case hx\nn : \u2115\n\u22a2 orderOf ?x = Fintype.card (QuaternionGroup 1)\n\ncase x\nn : \u2115\n\u22a2 QuaternionGroup 1"
      },
      {
        "tactic": "rw [card, mul_one]",
        "annotated_tactic": [
          "rw [<a>card</a>, <a>mul_one</a>]",
          [
            {
              "full_name": "QuaternionGroup.card",
              "def_path": "Mathlib/GroupTheory/SpecificGroups/Quaternion.lean",
              "def_pos": [
                174,
                9
              ],
              "def_end_pos": [
                174,
                13
              ]
            },
            {
              "full_name": "mul_one",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                483,
                9
              ],
              "def_end_pos": [
                483,
                16
              ]
            }
          ]
        ],
        "state_before": "case hx\nn : \u2115\n\u22a2 orderOf ?x = Fintype.card (QuaternionGroup 1)",
        "state_after": "case hx\nn : \u2115\n\u22a2 orderOf ?x = 4"
      },
      {
        "tactic": "exact orderOf_xa 0",
        "annotated_tactic": [
          "exact <a>orderOf_xa</a> 0",
          [
            {
              "full_name": "QuaternionGroup.orderOf_xa",
              "def_path": "Mathlib/GroupTheory/SpecificGroups/Quaternion.lean",
              "def_pos": [
                211,
                9
              ],
              "def_end_pos": [
                211,
                19
              ]
            }
          ]
        ],
        "state_before": "case hx\nn : \u2115\n\u22a2 orderOf ?x = 4",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.600979384966195,
    "entry_failed": false
  },
  "19776": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Probability/Distributions/Geometric.lean",
    "full_name": "ProbabilityTheory.geometricPMFReal_nonneg",
    "start": [
      54,
      1
    ],
    "end": [
      58,
      13
    ],
    "traced_tactics": [
      {
        "tactic": "rw [geometricPMFReal]",
        "annotated_tactic": [
          "rw [<a>geometricPMFReal</a>]",
          [
            {
              "full_name": "ProbabilityTheory.geometricPMFReal",
              "def_path": "Mathlib/Probability/Distributions/Geometric.lean",
              "def_pos": [
                36,
                5
              ],
              "def_end_pos": [
                36,
                21
              ]
            }
          ]
        ],
        "state_before": "p : \u211d\nn : \u2115\nhp_pos : 0 < p\nhp_le_one : p \u2264 1\n\u22a2 0 \u2264 geometricPMFReal p n",
        "state_after": "p : \u211d\nn : \u2115\nhp_pos : 0 < p\nhp_le_one : p \u2264 1\n\u22a2 0 \u2264 (1 - p) ^ n * p"
      },
      {
        "tactic": "have : 0 \u2264 1 - p := sub_nonneg.mpr hp_le_one",
        "annotated_tactic": [
          "have : 0 \u2264 1 - p := sub_nonneg.mpr hp_le_one",
          []
        ],
        "state_before": "p : \u211d\nn : \u2115\nhp_pos : 0 < p\nhp_le_one : p \u2264 1\n\u22a2 0 \u2264 (1 - p) ^ n * p",
        "state_after": "p : \u211d\nn : \u2115\nhp_pos : 0 < p\nhp_le_one : p \u2264 1\nthis : 0 \u2264 1 - p\n\u22a2 0 \u2264 (1 - p) ^ n * p"
      },
      {
        "tactic": "positivity",
        "annotated_tactic": [
          "positivity",
          []
        ],
        "state_before": "p : \u211d\nn : \u2115\nhp_pos : 0 < p\nhp_le_one : p \u2264 1\nthis : 0 \u2264 1 - p\n\u22a2 0 \u2264 (1 - p) ^ n * p",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7282846110174432,
    "entry_failed": false
  },
  "19935": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Multiset/Nodup.lean",
    "full_name": "Multiset.count_eq_of_nodup",
    "start": [
      96,
      1
    ],
    "end": [
      100,
      37
    ],
    "traced_tactics": [
      {
        "tactic": "split_ifs with h",
        "annotated_tactic": [
          "split_ifs with h",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d t : Multiset \u03b1\na\u271d : \u03b1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\ns : Multiset \u03b1\nd : s.Nodup\n\u22a2 count a s = if a \u2208 s then 1 else 0",
        "state_after": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d t : Multiset \u03b1\na\u271d : \u03b1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\ns : Multiset \u03b1\nd : s.Nodup\nh : a \u2208 s\n\u22a2 count a s = 1\n\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d t : Multiset \u03b1\na\u271d : \u03b1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\ns : Multiset \u03b1\nd : s.Nodup\nh : a \u2209 s\n\u22a2 count a s = 0"
      },
      {
        "tactic": "exact count_eq_one_of_mem d h",
        "annotated_tactic": [
          "exact <a>count_eq_one_of_mem</a> d h",
          [
            {
              "full_name": "Multiset.count_eq_one_of_mem",
              "def_path": "Mathlib/Data/Multiset/Nodup.lean",
              "def_pos": [
                91,
                9
              ],
              "def_end_pos": [
                91,
                28
              ]
            }
          ]
        ],
        "state_before": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d t : Multiset \u03b1\na\u271d : \u03b1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\ns : Multiset \u03b1\nd : s.Nodup\nh : a \u2208 s\n\u22a2 count a s = 1",
        "state_after": "no goals"
      },
      {
        "tactic": "exact count_eq_zero_of_not_mem h",
        "annotated_tactic": [
          "exact <a>count_eq_zero_of_not_mem</a> h",
          [
            {
              "full_name": "Multiset.count_eq_zero_of_not_mem",
              "def_path": "Mathlib/Data/Multiset/Basic.lean",
              "def_pos": [
                2522,
                9
              ],
              "def_end_pos": [
                2522,
                33
              ]
            }
          ]
        ],
        "state_before": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns\u271d t : Multiset \u03b1\na\u271d : \u03b1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\ns : Multiset \u03b1\nd : s.Nodup\nh : a \u2209 s\n\u22a2 count a s = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4592518070712686,
    "entry_failed": false
  },
  "19956": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/CharP/ExpChar.lean",
    "full_name": "charZero_of_expChar_one'",
    "start": [
      113,
      1
    ],
    "end": [
      116,
      49
    ],
    "traced_tactics": [
      {
        "tactic": "cases hq",
        "annotated_tactic": [
          "cases hq",
          []
        ],
        "state_before": "R : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Nontrivial R\nhq : ExpChar R 1\n\u22a2 CharZero R",
        "state_after": "case zero\nR : Type u\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : CharZero R\n\u22a2 CharZero R\n\ncase prime\nR : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Nontrivial R\nhprime\u271d : Nat.Prime 1\nhchar\u271d : CharP R 1\n\u22a2 CharZero R"
      },
      {
        "tactic": "assumption",
        "annotated_tactic": [
          "assumption",
          []
        ],
        "state_before": "case zero\nR : Type u\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : CharZero R\n\u22a2 CharZero R",
        "state_after": "no goals"
      },
      {
        "tactic": "exact False.elim (CharP.char_ne_one R 1 rfl)",
        "annotated_tactic": [
          "exact <a>False.elim</a> (<a>CharP.char_ne_one</a> R 1 <a>rfl</a>)",
          [
            {
              "full_name": "False.elim",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                236,
                21
              ],
              "def_end_pos": [
                236,
                31
              ]
            },
            {
              "full_name": "CharP.char_ne_one",
              "def_path": "Mathlib/Algebra/CharP/Defs.lean",
              "def_pos": [
                253,
                7
              ],
              "def_end_pos": [
                253,
                18
              ]
            },
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "case prime\nR : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Nontrivial R\nhprime\u271d : Nat.Prime 1\nhchar\u271d : CharP R 1\n\u22a2 CharZero R",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9022581070894375,
    "entry_failed": false
  },
  "20083": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Fintype/Card.lean",
    "full_name": "Fintype.card_of_subtype",
    "start": [
      126,
      1
    ],
    "end": [
      130,
      26
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 subtype_card s H]",
        "annotated_tactic": [
          "rw [\u2190 <a>subtype_card</a> s H]",
          [
            {
              "full_name": "Fintype.subtype_card",
              "def_path": "Mathlib/Data/Fintype/Card.lean",
              "def_pos": [
                121,
                9
              ],
              "def_end_pos": [
                121,
                21
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np : \u03b1 \u2192 Prop\ns : Finset \u03b1\nH : \u2200 (x : \u03b1), x \u2208 s \u2194 p x\ninst\u271d : Fintype { x // p x }\n\u22a2 card { x // p x } = s.card",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np : \u03b1 \u2192 Prop\ns : Finset \u03b1\nH : \u2200 (x : \u03b1), x \u2208 s \u2194 p x\ninst\u271d : Fintype { x // p x }\n\u22a2 card { x // p x } = card { x // p x }"
      },
      {
        "tactic": "congr",
        "annotated_tactic": [
          "congr",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np : \u03b1 \u2192 Prop\ns : Finset \u03b1\nH : \u2200 (x : \u03b1), x \u2208 s \u2194 p x\ninst\u271d : Fintype { x // p x }\n\u22a2 card { x // p x } = card { x // p x }",
        "state_after": "case h.e_2.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np : \u03b1 \u2192 Prop\ns : Finset \u03b1\nH : \u2200 (x : \u03b1), x \u2208 s \u2194 p x\ninst\u271d : Fintype { x // p x }\n\u22a2 inst\u271d = Fintype.subtype s H"
      },
      {
        "tactic": "apply Subsingleton.elim",
        "annotated_tactic": [
          "apply <a>Subsingleton.elim</a>",
          [
            {
              "full_name": "Subsingleton.elim",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1015,
                19
              ],
              "def_end_pos": [
                1015,
                36
              ]
            }
          ]
        ],
        "state_before": "case h.e_2.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np : \u03b1 \u2192 Prop\ns : Finset \u03b1\nH : \u2200 (x : \u03b1), x \u2208 s \u2194 p x\ninst\u271d : Fintype { x // p x }\n\u22a2 inst\u271d = Fintype.subtype s H",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.4920939849689603,
    "entry_failed": false
  },
  "20194": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/GeomSum.lean",
    "full_name": "geom_sum_mul",
    "start": [
      230,
      1
    ],
    "end": [
      233,
      13
    ],
    "traced_tactics": [
      {
        "tactic": "have := (Commute.one_right x).geom_sum\u2082_mul n",
        "annotated_tactic": [
          "have := (<a>Commute.one_right</a> x).<a>geom_sum\u2082_mul</a> n",
          [
            {
              "full_name": "Commute.one_right",
              "def_path": "Mathlib/Algebra/Group/Commute/Defs.lean",
              "def_pos": [
                156,
                9
              ],
              "def_end_pos": [
                156,
                18
              ]
            },
            {
              "full_name": "Commute.geom_sum\u2082_mul",
              "def_path": "Mathlib/Algebra/GeomSum.lean",
              "def_pos": [
                169,
                19
              ],
              "def_end_pos": [
                169,
                40
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\ninst\u271d : Ring \u03b1\nx : \u03b1\nn : \u2115\n\u22a2 (\u2211 i \u2208 range n, x ^ i) * (x - 1) = x ^ n - 1",
        "state_after": "\u03b1 : Type u\ninst\u271d : Ring \u03b1\nx : \u03b1\nn : \u2115\nthis : (\u2211 i \u2208 range n, x ^ i * 1 ^ (n - 1 - i)) * (x - 1) = x ^ n - 1 ^ n\n\u22a2 (\u2211 i \u2208 range n, x ^ i) * (x - 1) = x ^ n - 1"
      },
      {
        "tactic": "rw [one_pow, geom_sum\u2082_with_one] at this",
        "annotated_tactic": [
          "rw [<a>one_pow</a>, <a>geom_sum\u2082_with_one</a>] at this",
          [
            {
              "full_name": "one_pow",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                696,
                39
              ],
              "def_end_pos": [
                696,
                46
              ]
            },
            {
              "full_name": "geom_sum\u2082_with_one",
              "def_path": "Mathlib/Algebra/GeomSum.lean",
              "def_pos": [
                98,
                9
              ],
              "def_end_pos": [
                98,
                27
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\ninst\u271d : Ring \u03b1\nx : \u03b1\nn : \u2115\nthis : (\u2211 i \u2208 range n, x ^ i * 1 ^ (n - 1 - i)) * (x - 1) = x ^ n - 1 ^ n\n\u22a2 (\u2211 i \u2208 range n, x ^ i) * (x - 1) = x ^ n - 1",
        "state_after": "\u03b1 : Type u\ninst\u271d : Ring \u03b1\nx : \u03b1\nn : \u2115\nthis : (\u2211 i \u2208 range n, x ^ i) * (x - 1) = x ^ n - 1\n\u22a2 (\u2211 i \u2208 range n, x ^ i) * (x - 1) = x ^ n - 1"
      },
      {
        "tactic": "exact this",
        "annotated_tactic": [
          "exact this",
          []
        ],
        "state_before": "\u03b1 : Type u\ninst\u271d : Ring \u03b1\nx : \u03b1\nn : \u2115\nthis : (\u2211 i \u2208 range n, x ^ i) * (x - 1) = x ^ n - 1\n\u22a2 (\u2211 i \u2208 range n, x ^ i) * (x - 1) = x ^ n - 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.104004365974106,
    "entry_failed": false
  },
  "20200": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Factorial/Basic.lean",
    "full_name": "Nat.factorial_mul_ascFactorial'",
    "start": [
      256,
      1
    ],
    "end": [
      260,
      47
    ],
    "traced_tactics": [
      {
        "tactic": "rw [Nat.sub_add_comm h, Nat.sub_one]",
        "annotated_tactic": [
          "rw [<a>Nat.sub_add_comm</a> h, <a>Nat.sub_one</a>]",
          [
            {
              "full_name": "Nat.sub_add_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean",
              "def_pos": [
                125,
                19
              ],
              "def_end_pos": [
                125,
                31
              ]
            },
            {
              "full_name": "Nat.sub_one",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean",
              "def_pos": [
                95,
                19
              ],
              "def_end_pos": [
                95,
                26
              ]
            }
          ]
        ],
        "state_before": "n k : \u2115\nh : 0 < n\n\u22a2 (n - 1)! * n.ascFactorial k = (n + k - 1)!",
        "state_after": "n k : \u2115\nh : 0 < n\n\u22a2 n.pred ! * n.ascFactorial k = (n.pred + k)!"
      },
      {
        "tactic": "nth_rw 2 [Nat.eq_add_of_sub_eq h rfl]",
        "annotated_tactic": [
          "nth_rw 2 [<a>Nat.eq_add_of_sub_eq</a> h <a>rfl</a>]",
          [
            {
              "full_name": "Nat.eq_add_of_sub_eq",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean",
              "def_pos": [
                917,
                19
              ],
              "def_end_pos": [
                917,
                35
              ]
            },
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "n k : \u2115\nh : 0 < n\n\u22a2 n.pred ! * n.ascFactorial k = (n.pred + k)!",
        "state_after": "n k : \u2115\nh : 0 < n\n\u22a2 n.pred ! * (n - succ 0 + succ 0).ascFactorial k = (n.pred + k)!"
      },
      {
        "tactic": "rw [Nat.sub_one, factorial_mul_ascFactorial]",
        "annotated_tactic": [
          "rw [<a>Nat.sub_one</a>, <a>factorial_mul_ascFactorial</a>]",
          [
            {
              "full_name": "Nat.sub_one",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lemmas.lean",
              "def_pos": [
                95,
                19
              ],
              "def_end_pos": [
                95,
                26
              ]
            },
            {
              "full_name": "Nat.factorial_mul_ascFactorial",
              "def_path": "Mathlib/Data/Nat/Factorial/Basic.lean",
              "def_pos": [
                246,
                9
              ],
              "def_end_pos": [
                246,
                35
              ]
            }
          ]
        ],
        "state_before": "n k : \u2115\nh : 0 < n\n\u22a2 n.pred ! * (n - succ 0 + succ 0).ascFactorial k = (n.pred + k)!",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.966884460998699,
    "entry_failed": false
  },
  "20205": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/MonoidAlgebra/Division.lean",
    "full_name": "AddMonoidAlgebra.modOf_apply_of_exists_add",
    "start": [
      139,
      1
    ],
    "end": [
      141,
      77
    ],
    "traced_tactics": [
      {
        "tactic": "classical exact Finsupp.filter_apply_neg _ _ <| by rwa [Classical.not_not]",
        "annotated_tactic": [
          "classical exact <a>Finsupp.filter_apply_neg</a> _ _ <| by rwa [<a>Classical.not_not</a>]",
          [
            {
              "full_name": "Finsupp.filter_apply_neg",
              "def_path": "Mathlib/Data/Finsupp/Basic.lean",
              "def_pos": [
                907,
                9
              ],
              "def_end_pos": [
                907,
                25
              ]
            },
            {
              "full_name": "Classical.not_not",
              "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean",
              "def_pos": [
                135,
                17
              ],
              "def_end_pos": [
                135,
                24
              ]
            }
          ]
        ],
        "state_before": "k : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : Semiring k\ninst\u271d : AddCancelCommMonoid G\nx : k[G]\ng g' : G\nh : \u2203 d, g' = g + d\n\u22a2 (x %\u1d52\u1da0 g) g' = 0",
        "state_after": "no goals"
      },
      {
        "tactic": "exact Finsupp.filter_apply_neg _ _ <| by rwa [Classical.not_not]",
        "annotated_tactic": [
          "exact <a>Finsupp.filter_apply_neg</a> _ _ <| by rwa [<a>Classical.not_not</a>]",
          [
            {
              "full_name": "Finsupp.filter_apply_neg",
              "def_path": "Mathlib/Data/Finsupp/Basic.lean",
              "def_pos": [
                907,
                9
              ],
              "def_end_pos": [
                907,
                25
              ]
            },
            {
              "full_name": "Classical.not_not",
              "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean",
              "def_pos": [
                135,
                17
              ],
              "def_end_pos": [
                135,
                24
              ]
            }
          ]
        ],
        "state_before": "k : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : Semiring k\ninst\u271d : AddCancelCommMonoid G\nx : k[G]\ng g' : G\nh : \u2203 d, g' = g + d\n\u22a2 (x %\u1d52\u1da0 g) g' = 0",
        "state_after": "no goals"
      },
      {
        "tactic": "rwa [Classical.not_not]",
        "annotated_tactic": [
          "rwa [<a>Classical.not_not</a>]",
          [
            {
              "full_name": "Classical.not_not",
              "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean",
              "def_pos": [
                135,
                17
              ],
              "def_end_pos": [
                135,
                24
              ]
            }
          ]
        ],
        "state_before": "k : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : Semiring k\ninst\u271d : AddCancelCommMonoid G\nx : k[G]\ng g' : G\nh : \u2203 d, g' = g + d\n\u22a2 \u00ac\u00ac\u2203 g\u2082, g' = g + g\u2082",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.4913334940792993,
    "entry_failed": false
  },
  "20294": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Divisibility/Basic.lean",
    "full_name": "dvd_mul",
    "start": [
      225,
      1
    ],
    "end": [
      229,
      26
    ],
    "traced_tactics": [
      {
        "tactic": "refine \u27e8exists_dvd_and_dvd_of_dvd_mul, ?_\u27e9",
        "annotated_tactic": [
          "refine \u27e8<a>exists_dvd_and_dvd_of_dvd_mul</a>, ?_\u27e9",
          [
            {
              "full_name": "exists_dvd_and_dvd_of_dvd_mul",
              "def_path": "Mathlib/Algebra/Divisibility/Basic.lean",
              "def_pos": [
                127,
                9
              ],
              "def_end_pos": [
                127,
                38
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CommSemigroup \u03b1\na b c : \u03b1\ninst\u271d : DecompositionMonoid \u03b1\nk m n : \u03b1\n\u22a2 k \u2223 m * n \u2194 \u2203 d\u2081 d\u2082, d\u2081 \u2223 m \u2227 d\u2082 \u2223 n \u2227 k = d\u2081 * d\u2082",
        "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CommSemigroup \u03b1\na b c : \u03b1\ninst\u271d : DecompositionMonoid \u03b1\nk m n : \u03b1\n\u22a2 (\u2203 d\u2081 d\u2082, d\u2081 \u2223 m \u2227 d\u2082 \u2223 n \u2227 k = d\u2081 * d\u2082) \u2192 k \u2223 m * n"
      },
      {
        "tactic": "rintro \u27e8d\u2081, d\u2082, hy, hz, rfl\u27e9",
        "annotated_tactic": [
          "rintro \u27e8d\u2081, d\u2082, hy, hz, rfl\u27e9",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CommSemigroup \u03b1\na b c : \u03b1\ninst\u271d : DecompositionMonoid \u03b1\nk m n : \u03b1\n\u22a2 (\u2203 d\u2081 d\u2082, d\u2081 \u2223 m \u2227 d\u2082 \u2223 n \u2227 k = d\u2081 * d\u2082) \u2192 k \u2223 m * n",
        "state_after": "case intro.intro.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CommSemigroup \u03b1\na b c : \u03b1\ninst\u271d : DecompositionMonoid \u03b1\nm n d\u2081 d\u2082 : \u03b1\nhy : d\u2081 \u2223 m\nhz : d\u2082 \u2223 n\n\u22a2 d\u2081 * d\u2082 \u2223 m * n"
      },
      {
        "tactic": "exact mul_dvd_mul hy hz",
        "annotated_tactic": [
          "exact <a>mul_dvd_mul</a> hy hz",
          [
            {
              "full_name": "mul_dvd_mul",
              "def_path": "Mathlib/Algebra/Divisibility/Basic.lean",
              "def_pos": [
                217,
                9
              ],
              "def_end_pos": [
                217,
                20
              ]
            }
          ]
        ],
        "state_before": "case intro.intro.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CommSemigroup \u03b1\na b c : \u03b1\ninst\u271d : DecompositionMonoid \u03b1\nm n d\u2081 d\u2082 : \u03b1\nhy : d\u2081 \u2223 m\nhz : d\u2082 \u2223 n\n\u22a2 d\u2081 * d\u2082 \u2223 m * n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6626185120549053,
    "entry_failed": false
  },
  "20301": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Homology/ComplexShape.lean",
    "full_name": "ComplexShape.prev_eq'",
    "start": [
      161,
      1
    ],
    "end": [
      164,
      53
    ],
    "traced_tactics": [
      {
        "tactic": "apply c.prev_eq _ h",
        "annotated_tactic": [
          "apply c.prev_eq _ h",
          []
        ],
        "state_before": "\u03b9 : Type u_1\nc : ComplexShape \u03b9\ni j : \u03b9\nh : c.Rel i j\n\u22a2 c.prev j = i",
        "state_after": "\u03b9 : Type u_1\nc : ComplexShape \u03b9\ni j : \u03b9\nh : c.Rel i j\n\u22a2 c.Rel (c.prev j) j"
      },
      {
        "tactic": "rw [prev, dif_pos]",
        "annotated_tactic": [
          "rw [<a>prev</a>, <a>dif_pos</a>]",
          [
            {
              "full_name": "ComplexShape.prev",
              "def_path": "Mathlib/Algebra/Homology/ComplexShape.lean",
              "def_pos": [
                150,
                5
              ],
              "def_end_pos": [
                150,
                9
              ]
            },
            {
              "full_name": "dif_pos",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                949,
                9
              ],
              "def_end_pos": [
                949,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\nc : ComplexShape \u03b9\ni j : \u03b9\nh : c.Rel i j\n\u22a2 c.Rel (c.prev j) j",
        "state_after": "\u03b9 : Type u_1\nc : ComplexShape \u03b9\ni j : \u03b9\nh : c.Rel i j\n\u22a2 c.Rel ?hc.choose j\n\ncase hc\n\u03b9 : Type u_1\nc : ComplexShape \u03b9\ni j : \u03b9\nh : c.Rel i j\n\u22a2 \u2203 i, c.Rel i j"
      },
      {
        "tactic": "exact Exists.choose_spec (\u27e8i, h\u27e9 : \u2203 k, c.Rel k j)",
        "annotated_tactic": [
          "exact <a>Exists.choose_spec</a> (\u27e8i, h\u27e9 : \u2203 k, c.Rel k j)",
          [
            {
              "full_name": "Exists.choose_spec",
              "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean",
              "def_pos": [
                177,
                9
              ],
              "def_end_pos": [
                177,
                27
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\nc : ComplexShape \u03b9\ni j : \u03b9\nh : c.Rel i j\n\u22a2 c.Rel ?hc.choose j\n\ncase hc\n\u03b9 : Type u_1\nc : ComplexShape \u03b9\ni j : \u03b9\nh : c.Rel i j\n\u22a2 \u2203 i, c.Rel i j",
        "state_after": "no goals"
      }
    ],
    "entry_time": 0.9674750139238313,
    "entry_failed": false
  },
  "20332": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Real/Irrational.lean",
    "full_name": "Irrational.div_int",
    "start": [
      473,
      1
    ],
    "end": [
      476,
      25
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 cast_intCast]",
        "annotated_tactic": [
          "rw [\u2190 <a>cast_intCast</a>]",
          [
            {
              "full_name": "Rat.cast_intCast",
              "def_path": "Mathlib/Data/Rat/Cast/Defs.lean",
              "def_pos": [
                115,
                9
              ],
              "def_end_pos": [
                115,
                21
              ]
            }
          ]
        ],
        "state_before": "q : \u211a\nx y : \u211d\nh : Irrational x\nm : \u2124\nhm : m \u2260 0\n\u22a2 Irrational (x / \u2191m)",
        "state_after": "q : \u211a\nx y : \u211d\nh : Irrational x\nm : \u2124\nhm : m \u2260 0\n\u22a2 Irrational (x / \u2191\u2191m)"
      },
      {
        "tactic": "refine h.div_rat ?_",
        "annotated_tactic": [
          "refine h.div_rat ?_",
          []
        ],
        "state_before": "q : \u211a\nx y : \u211d\nh : Irrational x\nm : \u2124\nhm : m \u2260 0\n\u22a2 Irrational (x / \u2191\u2191m)",
        "state_after": "q : \u211a\nx y : \u211d\nh : Irrational x\nm : \u2124\nhm : m \u2260 0\n\u22a2 \u2191m \u2260 0"
      },
      {
        "tactic": "rwa [Int.cast_ne_zero]",
        "annotated_tactic": [
          "rwa [<a>Int.cast_ne_zero</a>]",
          [
            {
              "full_name": "Int.cast_ne_zero",
              "def_path": "Mathlib/Data/Int/Cast/Lemmas.lean",
              "def_pos": [
                82,
                7
              ],
              "def_end_pos": [
                82,
                19
              ]
            }
          ]
        ],
        "state_before": "q : \u211a\nx y : \u211d\nh : Irrational x\nm : \u2124\nhm : m \u2260 0\n\u22a2 \u2191m \u2260 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.477711529005319,
    "entry_failed": false
  },
  "20338": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Filter/SmallSets.lean",
    "full_name": "Filter.bind_smallSets_gc",
    "start": [
      47,
      1
    ],
    "end": [
      51,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "intro L l",
        "annotated_tactic": [
          "intro L l",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_3\nl l' la : Filter \u03b1\nlb : Filter \u03b2\n\u22a2 GaloisConnection (fun L => L.bind \ud835\udcdf) smallSets",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_3\nl\u271d l' la : Filter \u03b1\nlb : Filter \u03b2\nL : Filter (Set \u03b1)\nl : Filter \u03b1\n\u22a2 (fun L => L.bind \ud835\udcdf) L \u2264 l \u2194 L \u2264 l.smallSets"
      },
      {
        "tactic": "simp_rw [smallSets_eq_generate, le_generate_iff, image_subset_iff]",
        "annotated_tactic": [
          "simp_rw [<a>smallSets_eq_generate</a>, <a>le_generate_iff</a>, <a>image_subset_iff</a>]",
          [
            {
              "full_name": "Filter.smallSets_eq_generate",
              "def_path": "Mathlib/Order/Filter/SmallSets.lean",
              "def_pos": [
                40,
                9
              ],
              "def_end_pos": [
                40,
                30
              ]
            },
            {
              "full_name": "Filter.le_generate_iff",
              "def_path": "Mathlib/Order/Filter/Basic.lean",
              "def_pos": [
                370,
                9
              ],
              "def_end_pos": [
                370,
                24
              ]
            },
            {
              "full_name": "Set.image_subset_iff",
              "def_path": "Mathlib/Data/Set/Image.lean",
              "def_pos": [
                481,
                9
              ],
              "def_end_pos": [
                481,
                25
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_3\nl\u271d l' la : Filter \u03b1\nlb : Filter \u03b2\nL : Filter (Set \u03b1)\nl : Filter \u03b1\n\u22a2 (fun L => L.bind \ud835\udcdf) L \u2264 l \u2194 L \u2264 l.smallSets",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_3\nl\u271d l' la : Filter \u03b1\nlb : Filter \u03b2\nL : Filter (Set \u03b1)\nl : Filter \u03b1\n\u22a2 L.bind \ud835\udcdf \u2264 l \u2194 l.sets \u2286 powerset \u207b\u00b9' L.sets"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_3\nl\u271d l' la : Filter \u03b1\nlb : Filter \u03b2\nL : Filter (Set \u03b1)\nl : Filter \u03b1\n\u22a2 L.bind \ud835\udcdf \u2264 l \u2194 l.sets \u2286 powerset \u207b\u00b9' L.sets",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.377085326006636,
    "entry_failed": false
  },
  "20354": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/IsWellOrderLimitElement.lean",
    "full_name": "IsWellOrderLimitElement.neq_bot",
    "start": [
      55,
      1
    ],
    "end": [
      58,
      13
    ],
    "traced_tactics": [
      {
        "tactic": "rintro rfl",
        "annotated_tactic": [
          "rintro rfl",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsWellOrder \u03b1 fun x x_1 => x < x_1\na : \u03b1\nha : IsWellOrderLimitElement a\ninst\u271d : OrderBot \u03b1\n\u22a2 a \u2260 \u22a5",
        "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsWellOrder \u03b1 fun x x_1 => x < x_1\ninst\u271d : OrderBot \u03b1\nha : IsWellOrderLimitElement \u22a5\n\u22a2 False"
      },
      {
        "tactic": "obtain \u27e8b, hb\u27e9 := ha.not_bot",
        "annotated_tactic": [
          "obtain \u27e8b, hb\u27e9 := ha.not_bot",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsWellOrder \u03b1 fun x x_1 => x < x_1\ninst\u271d : OrderBot \u03b1\nha : IsWellOrderLimitElement \u22a5\n\u22a2 False",
        "state_after": "case intro\n\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsWellOrder \u03b1 fun x x_1 => x < x_1\ninst\u271d : OrderBot \u03b1\nha : IsWellOrderLimitElement \u22a5\nb : \u03b1\nhb : b < \u22a5\n\u22a2 False"
      },
      {
        "tactic": "simp at hb",
        "annotated_tactic": [
          "simp at hb",
          []
        ],
        "state_before": "case intro\n\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsWellOrder \u03b1 fun x x_1 => x < x_1\ninst\u271d : OrderBot \u03b1\nha : IsWellOrderLimitElement \u22a5\nb : \u03b1\nhb : b < \u22a5\n\u22a2 False",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2314507259288803,
    "entry_failed": false
  },
  "20376": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Filter/Cofinite.lean",
    "full_name": "Nat.cofinite_eq_atTop",
    "start": [
      167,
      1
    ],
    "end": [
      170,
      61
    ],
    "traced_tactics": [
      {
        "tactic": "refine le_antisymm ?_ atTop_le_cofinite",
        "annotated_tactic": [
          "refine <a>le_antisymm</a> ?_ <a>atTop_le_cofinite</a>",
          [
            {
              "full_name": "le_antisymm",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                188,
                9
              ],
              "def_end_pos": [
                188,
                20
              ]
            },
            {
              "full_name": "Filter.atTop_le_cofinite",
              "def_path": "Mathlib/Order/Filter/Cofinite.lean",
              "def_pos": [
                112,
                9
              ],
              "def_end_pos": [
                112,
                26
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\n\u22a2 cofinite = atTop",
        "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\n\u22a2 cofinite \u2264 atTop"
      },
      {
        "tactic": "refine atTop_basis.ge_iff.2 fun N _ => ?_",
        "annotated_tactic": [
          "refine atTop_basis.ge_iff.2 fun N _ => ?_",
          []
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\n\u22a2 cofinite \u2264 atTop",
        "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nN : \u2115\nx\u271d : True\n\u22a2 Ici N \u2208 cofinite"
      },
      {
        "tactic": "simpa only [mem_cofinite, compl_Ici] using finite_lt_nat N",
        "annotated_tactic": [
          "simpa only [<a>mem_cofinite</a>, <a>compl_Ici</a>] using <a>finite_lt_nat</a> N",
          [
            {
              "full_name": "Filter.mem_cofinite",
              "def_path": "Mathlib/Order/Filter/Cofinite.lean",
              "def_pos": [
                37,
                9
              ],
              "def_end_pos": [
                37,
                21
              ]
            },
            {
              "full_name": "Set.compl_Ici",
              "def_path": "Mathlib/Order/Interval/Set/Basic.lean",
              "def_pos": [
                1101,
                9
              ],
              "def_end_pos": [
                1101,
                18
              ]
            },
            {
              "full_name": "Set.finite_lt_nat",
              "def_path": "Mathlib/Data/Set/Finite.lean",
              "def_pos": [
                919,
                9
              ],
              "def_end_pos": [
                919,
                22
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\nN : \u2115\nx\u271d : True\n\u22a2 Ici N \u2208 cofinite",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.642566842958331,
    "entry_failed": false
  },
  "20384": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/JacobsonIdeal.lean",
    "full_name": "Ideal.isUnit_of_sub_one_mem_jacobson_bot",
    "start": [
      251,
      1
    ],
    "end": [
      255,
      36
    ],
    "traced_tactics": [
      {
        "tactic": "cases' exists_mul_sub_mem_of_sub_one_mem_jacobson r h with s hs",
        "annotated_tactic": [
          "cases' <a>exists_mul_sub_mem_of_sub_one_mem_jacobson</a> r h with s hs",
          [
            {
              "full_name": "Ideal.exists_mul_sub_mem_of_sub_one_mem_jacobson",
              "def_path": "Mathlib/RingTheory/JacobsonIdeal.lean",
              "def_pos": [
                125,
                9
              ],
              "def_end_pos": [
                125,
                51
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI : Ideal R\nr : R\nh : r - 1 \u2208 \u22a5.jacobson\n\u22a2 IsUnit r",
        "state_after": "case intro\nR : Type u\nS : Type v\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI : Ideal R\nr : R\nh : r - 1 \u2208 \u22a5.jacobson\ns : R\nhs : s * r - 1 \u2208 \u22a5\n\u22a2 IsUnit r"
      },
      {
        "tactic": "rw [mem_bot, sub_eq_zero, mul_comm] at hs",
        "annotated_tactic": [
          "rw [<a>mem_bot</a>, <a>sub_eq_zero</a>, <a>mul_comm</a>] at hs",
          [
            {
              "full_name": "Ideal.mem_bot",
              "def_path": "Mathlib/RingTheory/Ideal/Basic.lean",
              "def_pos": [
                444,
                9
              ],
              "def_end_pos": [
                444,
                16
              ]
            },
            {
              "full_name": "sub_eq_zero",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                1070,
                3
              ],
              "def_end_pos": [
                1070,
                14
              ]
            },
            {
              "full_name": "mul_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                332,
                9
              ],
              "def_end_pos": [
                332,
                17
              ]
            }
          ]
        ],
        "state_before": "case intro\nR : Type u\nS : Type v\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI : Ideal R\nr : R\nh : r - 1 \u2208 \u22a5.jacobson\ns : R\nhs : s * r - 1 \u2208 \u22a5\n\u22a2 IsUnit r",
        "state_after": "case intro\nR : Type u\nS : Type v\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI : Ideal R\nr : R\nh : r - 1 \u2208 \u22a5.jacobson\ns : R\nhs : r * s = 1\n\u22a2 IsUnit r"
      },
      {
        "tactic": "exact isUnit_of_mul_eq_one _ _ hs",
        "annotated_tactic": [
          "exact <a>isUnit_of_mul_eq_one</a> _ _ hs",
          [
            {
              "full_name": "isUnit_of_mul_eq_one",
              "def_path": "Mathlib/Algebra/Group/Units.lean",
              "def_pos": [
                701,
                9
              ],
              "def_end_pos": [
                701,
                29
              ]
            }
          ]
        ],
        "state_before": "case intro\nR : Type u\nS : Type v\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI : Ideal R\nr : R\nh : r - 1 \u2208 \u22a5.jacobson\ns : R\nhs : r * s = 1\n\u22a2 IsUnit r",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.431802897946909,
    "entry_failed": false
  },
  "20458": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Coprime/Basic.lean",
    "full_name": "IsCoprime.dvd_of_dvd_mul_left",
    "start": [
      108,
      1
    ],
    "end": [
      111,
      51
    ],
    "traced_tactics": [
      {
        "tactic": "let \u27e8a, b, H\u27e9 := H1",
        "annotated_tactic": [
          "let \u27e8a, b, H\u27e9 := H1",
          []
        ],
        "state_before": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nH1 : IsCoprime x y\nH2 : x \u2223 y * z\n\u22a2 x \u2223 z",
        "state_after": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nH1 : IsCoprime x y\nH2 : x \u2223 y * z\na b : R\nH : a * x + b * y = 1\n\u22a2 x \u2223 z"
      },
      {
        "tactic": "rw [\u2190 one_mul z, \u2190 H, add_mul, mul_right_comm, mul_assoc b]",
        "annotated_tactic": [
          "rw [\u2190 <a>one_mul</a> z, \u2190 H, <a>add_mul</a>, <a>mul_right_comm</a>, <a>mul_assoc</a> b]",
          [
            {
              "full_name": "one_mul",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                477,
                9
              ],
              "def_end_pos": [
                477,
                16
              ]
            },
            {
              "full_name": "add_mul",
              "def_path": "Mathlib/Algebra/Ring/Defs.lean",
              "def_pos": [
                91,
                7
              ],
              "def_end_pos": [
                91,
                14
              ]
            },
            {
              "full_name": "mul_right_comm",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                190,
                9
              ],
              "def_end_pos": [
                190,
                23
              ]
            },
            {
              "full_name": "mul_assoc",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                289,
                9
              ],
              "def_end_pos": [
                289,
                18
              ]
            }
          ]
        ],
        "state_before": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nH1 : IsCoprime x y\nH2 : x \u2223 y * z\na b : R\nH : a * x + b * y = 1\n\u22a2 x \u2223 z",
        "state_after": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nH1 : IsCoprime x y\nH2 : x \u2223 y * z\na b : R\nH : a * x + b * y = 1\n\u22a2 x \u2223 a * z * x + b * (y * z)"
      },
      {
        "tactic": "exact dvd_add (dvd_mul_left _ _) (H2.mul_left _)",
        "annotated_tactic": [
          "exact <a>dvd_add</a> (<a>dvd_mul_left</a> _ _) (H2.mul_left _)",
          [
            {
              "full_name": "dvd_add",
              "def_path": "Mathlib/Algebra/Ring/Divisibility/Basic.lean",
              "def_pos": [
                46,
                9
              ],
              "def_end_pos": [
                46,
                16
              ]
            },
            {
              "full_name": "dvd_mul_left",
              "def_path": "Mathlib/Algebra/Divisibility/Basic.lean",
              "def_pos": [
                205,
                9
              ],
              "def_end_pos": [
                205,
                21
              ]
            }
          ]
        ],
        "state_before": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nH1 : IsCoprime x y\nH2 : x \u2223 y * z\na b : R\nH : a * x + b * y = 1\n\u22a2 x \u2223 a * z * x + b * (y * z)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.0949267270043492,
    "entry_failed": false
  },
  "20469": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Ring/Basic.lean",
    "full_name": "pow_right_injective",
    "start": [
      208,
      1
    ],
    "end": [
      211,
      47
    ],
    "traced_tactics": [
      {
        "tactic": "obtain ha\u2081 | ha\u2081 := ha\u2081.lt_or_lt",
        "annotated_tactic": [
          "obtain ha\u2081 | ha\u2081 := ha\u2081.lt_or_lt",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nM : Type u_2\nR : Type u_3\ninst\u271d : LinearOrderedSemiring R\na b : R\nm n : \u2115\nha\u2080 : 0 < a\nha\u2081 : a \u2260 1\n\u22a2 Injective fun x => a ^ x",
        "state_after": "case inl\n\u03b1 : Type u_1\nM : Type u_2\nR : Type u_3\ninst\u271d : LinearOrderedSemiring R\na b : R\nm n : \u2115\nha\u2080 : 0 < a\nha\u2081\u271d : a \u2260 1\nha\u2081 : a < 1\n\u22a2 Injective fun x => a ^ x\n\ncase inr\n\u03b1 : Type u_1\nM : Type u_2\nR : Type u_3\ninst\u271d : LinearOrderedSemiring R\na b : R\nm n : \u2115\nha\u2080 : 0 < a\nha\u2081\u271d : a \u2260 1\nha\u2081 : 1 < a\n\u22a2 Injective fun x => a ^ x"
      },
      {
        "tactic": "exact (pow_right_strictAnti ha\u2080 ha\u2081).injective",
        "annotated_tactic": [
          "exact (<a>pow_right_strictAnti</a> ha\u2080 ha\u2081).<a>injective</a>",
          [
            {
              "full_name": "pow_right_strictAnti",
              "def_path": "Mathlib/Algebra/Order/Ring/Basic.lean",
              "def_pos": [
                164,
                9
              ],
              "def_end_pos": [
                164,
                29
              ]
            },
            {
              "full_name": "StrictAnti.injective",
              "def_path": "Mathlib/Order/Monotone/Basic.lean",
              "def_pos": [
                903,
                9
              ],
              "def_end_pos": [
                903,
                29
              ]
            }
          ]
        ],
        "state_before": "case inl\n\u03b1 : Type u_1\nM : Type u_2\nR : Type u_3\ninst\u271d : LinearOrderedSemiring R\na b : R\nm n : \u2115\nha\u2080 : 0 < a\nha\u2081\u271d : a \u2260 1\nha\u2081 : a < 1\n\u22a2 Injective fun x => a ^ x",
        "state_after": "no goals"
      },
      {
        "tactic": "exact (pow_right_strictMono ha\u2081).injective",
        "annotated_tactic": [
          "exact (<a>pow_right_strictMono</a> ha\u2081).<a>injective</a>",
          [
            {
              "full_name": "pow_right_strictMono",
              "def_path": "Mathlib/Algebra/Order/Ring/Basic.lean",
              "def_pos": [
                144,
                7
              ],
              "def_end_pos": [
                144,
                27
              ]
            },
            {
              "full_name": "StrictMono.injective",
              "def_path": "Mathlib/Order/Monotone/Basic.lean",
              "def_pos": [
                899,
                9
              ],
              "def_end_pos": [
                899,
                29
              ]
            }
          ]
        ],
        "state_before": "case inr\n\u03b1 : Type u_1\nM : Type u_2\nR : Type u_3\ninst\u271d : LinearOrderedSemiring R\na b : R\nm n : \u2115\nha\u2080 : 0 < a\nha\u2081\u271d : a \u2260 1\nha\u2081 : 1 < a\n\u22a2 Injective fun x => a ^ x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.273728546919301,
    "entry_failed": false
  },
  "20532": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Duplicate.lean",
    "full_name": "List.Duplicate.mem_cons_self",
    "start": [
      52,
      1
    ],
    "end": [
      55,
      16
    ],
    "traced_tactics": [
      {
        "tactic": "cases' h with _ h _ _ h",
        "annotated_tactic": [
          "cases' h with _ h _ _ h",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nl : List \u03b1\nx : \u03b1\nh : x \u2208+ x :: l\n\u22a2 x \u2208 l",
        "state_after": "case cons_mem\n\u03b1 : Type u_1\nl : List \u03b1\nx : \u03b1\nh : x \u2208 l\n\u22a2 x \u2208 l\n\ncase cons_duplicate\n\u03b1 : Type u_1\nl : List \u03b1\nx : \u03b1\nh : x \u2208+ l\n\u22a2 x \u2208 l"
      },
      {
        "tactic": "exact h",
        "annotated_tactic": [
          "exact h",
          []
        ],
        "state_before": "case cons_mem\n\u03b1 : Type u_1\nl : List \u03b1\nx : \u03b1\nh : x \u2208 l\n\u22a2 x \u2208 l",
        "state_after": "no goals"
      },
      {
        "tactic": "exact h.mem",
        "annotated_tactic": [
          "exact h.mem",
          []
        ],
        "state_before": "case cons_duplicate\n\u03b1 : Type u_1\nl : List \u03b1\nx : \u03b1\nh : x \u2208+ l\n\u22a2 x \u2208 l",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.1358721379656345,
    "entry_failed": false
  },
  "20625": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Group/Basic.lean",
    "full_name": "eq_one_iff_eq_one_of_mul_eq_one",
    "start": [
      160,
      1
    ],
    "end": [
      161,
      46
    ],
    "traced_tactics": [
      {
        "tactic": "constructor <;> (rintro rfl; simpa using h)",
        "annotated_tactic": [
          "constructor <;> (rintro rfl; simpa using h)",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : Type u_3\nM\u271d : Type u_4\nM : Type u\ninst\u271d : MulOneClass M\na b : M\nh : a * b = 1\n\u22a2 a = 1 \u2194 b = 1",
        "state_after": "no goals"
      },
      {
        "tactic": "rintro rfl",
        "annotated_tactic": [
          "rintro rfl",
          []
        ],
        "state_before": "case mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : Type u_3\nM\u271d : Type u_4\nM : Type u\ninst\u271d : MulOneClass M\na b : M\nh : a * b = 1\n\u22a2 b = 1 \u2192 a = 1",
        "state_after": "case mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : Type u_3\nM\u271d : Type u_4\nM : Type u\ninst\u271d : MulOneClass M\na : M\nh : a * 1 = 1\n\u22a2 a = 1"
      },
      {
        "tactic": "simpa using h",
        "annotated_tactic": [
          "simpa using h",
          []
        ],
        "state_before": "case mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : Type u_3\nM\u271d : Type u_4\nM : Type u\ninst\u271d : MulOneClass M\na : M\nh : a * 1 = 1\n\u22a2 a = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.810792285017669,
    "entry_failed": false
  },
  "20674": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/Monoidal/Cartesian/Comon_.lean",
    "full_name": "comul_eq_diag",
    "start": [
      43,
      9
    ],
    "end": [
      46,
      43
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : HasTerminal C\ninst\u271d : HasBinaryProducts C\nA : Comon_ C\n\u22a2 A.comul = diag A.X",
        "state_after": "case w\u2081\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : HasTerminal C\ninst\u271d : HasBinaryProducts C\nA : Comon_ C\n\u22a2 A.comul \u226b prod.fst = diag A.X \u226b prod.fst\n\ncase w\u2082\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : HasTerminal C\ninst\u271d : HasBinaryProducts C\nA : Comon_ C\n\u22a2 A.comul \u226b prod.snd = diag A.X \u226b prod.snd"
      },
      {
        "tactic": "simpa using A.comul_counit =\u226b prod.fst",
        "annotated_tactic": [
          "simpa using A.comul_counit =\u226b <a>prod.fst</a>",
          [
            {
              "full_name": "CategoryTheory.Limits.prod.fst",
              "def_path": "Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean",
              "def_pos": [
                546,
                8
              ],
              "def_end_pos": [
                546,
                16
              ]
            }
          ]
        ],
        "state_before": "case w\u2081\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : HasTerminal C\ninst\u271d : HasBinaryProducts C\nA : Comon_ C\n\u22a2 A.comul \u226b prod.fst = diag A.X \u226b prod.fst",
        "state_after": "no goals"
      },
      {
        "tactic": "simpa using A.counit_comul =\u226b prod.snd",
        "annotated_tactic": [
          "simpa using A.counit_comul =\u226b <a>prod.snd</a>",
          [
            {
              "full_name": "CategoryTheory.Limits.prod.snd",
              "def_path": "Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean",
              "def_pos": [
                551,
                8
              ],
              "def_end_pos": [
                551,
                16
              ]
            }
          ]
        ],
        "state_before": "case w\u2082\nC : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : HasTerminal C\ninst\u271d : HasBinaryProducts C\nA : Comon_ C\n\u22a2 A.comul \u226b prod.snd = diag A.X \u226b prod.snd",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.9705899740802124,
    "entry_failed": false
  },
  "20748": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Sym/Sym2.lean",
    "full_name": "Sym2.fromRel_bot",
    "start": [
      512,
      1
    ],
    "end": [
      515,
      46
    ],
    "traced_tactics": [
      {
        "tactic": "apply Set.eq_empty_of_forall_not_mem fun e => _",
        "annotated_tactic": [
          "apply <a>Set.eq_empty_of_forall_not_mem</a> fun e => _",
          [
            {
              "full_name": "Set.eq_empty_of_forall_not_mem",
              "def_path": "Mathlib/Data/Set/Basic.lean",
              "def_pos": [
                556,
                9
              ],
              "def_end_pos": [
                556,
                35
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ne : Sym2 \u03b1\nf : \u03b1 \u2192 \u03b2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 fromRel \u22ef = \u2205",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ne : Sym2 \u03b1\nf : \u03b1 \u2192 \u03b2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 \u2200 (e : Sym2 \u03b1), e \u2209 fromRel \u22ef"
      },
      {
        "tactic": "apply Sym2.ind",
        "annotated_tactic": [
          "apply <a>Sym2.ind</a>",
          [
            {
              "full_name": "Sym2.ind",
              "def_path": "Mathlib/Data/Sym/Sym2.lean",
              "def_pos": [
                128,
                19
              ],
              "def_end_pos": [
                128,
                22
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ne : Sym2 \u03b1\nf : \u03b1 \u2192 \u03b2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 \u2200 (e : Sym2 \u03b1), e \u2209 fromRel \u22ef",
        "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ne : Sym2 \u03b1\nf : \u03b1 \u2192 \u03b2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 \u2200 (x y : \u03b1), s(x, y) \u2209 fromRel \u22ef"
      },
      {
        "tactic": "simp [-Set.bot_eq_empty, Prop.bot_eq_false]",
        "annotated_tactic": [
          "simp [-<a>Set.bot_eq_empty</a>, <a>Prop.bot_eq_false</a>]",
          [
            {
              "full_name": "Set.bot_eq_empty",
              "def_path": "Mathlib/Data/Set/Basic.lean",
              "def_pos": [
                96,
                9
              ],
              "def_end_pos": [
                96,
                21
              ]
            },
            {
              "full_name": "Prop.bot_eq_false",
              "def_path": "Mathlib/Order/PropInstances.lean",
              "def_pos": [
                40,
                9
              ],
              "def_end_pos": [
                40,
                26
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ne : Sym2 \u03b1\nf : \u03b1 \u2192 \u03b2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 \u2200 (x y : \u03b1), s(x, y) \u2209 fromRel \u22ef",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.209401882952079,
    "entry_failed": false
  },
  "20762": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Seq/Computation.lean",
    "full_name": "Computation.mem_of_get_eq",
    "start": [
      460,
      1
    ],
    "end": [
      460,
      85
    ],
    "traced_tactics": [
      {
        "tactic": "intro h",
        "annotated_tactic": [
          "intro h",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns : Computation \u03b1\nh : s.Terminates\na : \u03b1\n\u22a2 s.get = a \u2192 a \u2208 s",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns : Computation \u03b1\nh\u271d : s.Terminates\na : \u03b1\nh : s.get = a\n\u22a2 a \u2208 s"
      },
      {
        "tactic": "rw [\u2190 h]",
        "annotated_tactic": [
          "rw [\u2190 h]",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns : Computation \u03b1\nh\u271d : s.Terminates\na : \u03b1\nh : s.get = a\n\u22a2 a \u2208 s",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns : Computation \u03b1\nh\u271d : s.Terminates\na : \u03b1\nh : s.get = a\n\u22a2 s.get \u2208 s"
      },
      {
        "tactic": "apply get_mem",
        "annotated_tactic": [
          "apply <a>get_mem</a>",
          [
            {
              "full_name": "Computation.get_mem",
              "def_path": "Mathlib/Data/Seq/Computation.lean",
              "def_pos": [
                452,
                9
              ],
              "def_end_pos": [
                452,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns : Computation \u03b1\nh\u271d : s.Terminates\na : \u03b1\nh : s.get = a\n\u22a2 s.get \u2208 s",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.648818642948754,
    "entry_failed": false
  },
  "20852": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Algebra/Operations.lean",
    "full_name": "Submodule.one_eq_span",
    "start": [
      106,
      1
    ],
    "end": [
      109,
      69
    ],
    "traced_tactics": [
      {
        "tactic": "apply Submodule.ext",
        "annotated_tactic": [
          "apply <a>Submodule.ext</a>",
          [
            {
              "full_name": "Submodule.ext",
              "def_path": "Mathlib/Algebra/Module/Submodule/Basic.lean",
              "def_pos": [
                95,
                9
              ],
              "def_end_pos": [
                95,
                12
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nS T : Set A\nM N P Q : Submodule R A\nm n : A\n\u22a2 1 = span R {1}",
        "state_after": "case h\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nS T : Set A\nM N P Q : Submodule R A\nm n : A\n\u22a2 \u2200 (x : A), x \u2208 1 \u2194 x \u2208 span R {1}"
      },
      {
        "tactic": "intro a",
        "annotated_tactic": [
          "intro a",
          []
        ],
        "state_before": "case h\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nS T : Set A\nM N P Q : Submodule R A\nm n : A\n\u22a2 \u2200 (x : A), x \u2208 1 \u2194 x \u2208 span R {1}",
        "state_after": "case h\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nS T : Set A\nM N P Q : Submodule R A\nm n a : A\n\u22a2 a \u2208 1 \u2194 a \u2208 span R {1}"
      },
      {
        "tactic": "simp only [mem_one, mem_span_singleton, Algebra.smul_def, mul_one]",
        "annotated_tactic": [
          "simp only [<a>mem_one</a>, <a>mem_span_singleton</a>, <a>Algebra.smul_def</a>, <a>mul_one</a>]",
          [
            {
              "full_name": "Submodule.mem_one",
              "def_path": "Mathlib/Algebra/Algebra/Operations.lean",
              "def_pos": [
                97,
                9
              ],
              "def_end_pos": [
                97,
                16
              ]
            },
            {
              "full_name": "Submodule.mem_span_singleton",
              "def_path": "Mathlib/LinearAlgebra/Span.lean",
              "def_pos": [
                486,
                9
              ],
              "def_end_pos": [
                486,
                27
              ]
            },
            {
              "full_name": "Algebra.smul_def",
              "def_path": "Mathlib/Algebra/Algebra/Defs.lean",
              "def_pos": [
                326,
                9
              ],
              "def_end_pos": [
                326,
                17
              ]
            },
            {
              "full_name": "mul_one",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                483,
                9
              ],
              "def_end_pos": [
                483,
                16
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b9 : Sort u\u03b9\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nS T : Set A\nM N P Q : Submodule R A\nm n a : A\n\u22a2 a \u2208 1 \u2194 a \u2208 span R {1}",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.4350061020813882,
    "entry_failed": false
  },
  "20907": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Group/Subgroup/ZPowers.lean",
    "full_name": "ofAdd_image_zmultiples_eq_zpowers_ofAdd",
    "start": [
      201,
      1
    ],
    "end": [
      206,
      48
    ],
    "traced_tactics": [
      {
        "tactic": "symm",
        "annotated_tactic": [
          "symm",
          []
        ],
        "state_before": "G : Type u_1\ninst\u271d\u00b2 : Group G\nA : Type u_2\ninst\u271d\u00b9 : AddGroup A\nN : Type u_3\ninst\u271d : Group N\nx : A\n\u22a2 \u21d1Multiplicative.ofAdd '' \u2191(AddSubgroup.zmultiples x) = \u2191(Subgroup.zpowers (Multiplicative.ofAdd x))",
        "state_after": "G : Type u_1\ninst\u271d\u00b2 : Group G\nA : Type u_2\ninst\u271d\u00b9 : AddGroup A\nN : Type u_3\ninst\u271d : Group N\nx : A\n\u22a2 \u2191(Subgroup.zpowers (Multiplicative.ofAdd x)) = \u21d1Multiplicative.ofAdd '' \u2191(AddSubgroup.zmultiples x)"
      },
      {
        "tactic": "rw [Equiv.eq_image_iff_symm_image_eq]",
        "annotated_tactic": [
          "rw [<a>Equiv.eq_image_iff_symm_image_eq</a>]",
          [
            {
              "full_name": "Equiv.eq_image_iff_symm_image_eq",
              "def_path": "Mathlib/Logic/Equiv/Set.lean",
              "def_pos": [
                87,
                9
              ],
              "def_end_pos": [
                87,
                35
              ]
            }
          ]
        ],
        "state_before": "G : Type u_1\ninst\u271d\u00b2 : Group G\nA : Type u_2\ninst\u271d\u00b9 : AddGroup A\nN : Type u_3\ninst\u271d : Group N\nx : A\n\u22a2 \u2191(Subgroup.zpowers (Multiplicative.ofAdd x)) = \u21d1Multiplicative.ofAdd '' \u2191(AddSubgroup.zmultiples x)",
        "state_after": "G : Type u_1\ninst\u271d\u00b2 : Group G\nA : Type u_2\ninst\u271d\u00b9 : AddGroup A\nN : Type u_3\ninst\u271d : Group N\nx : A\n\u22a2 \u21d1Multiplicative.ofAdd.symm '' \u2191(Subgroup.zpowers (Multiplicative.ofAdd x)) = \u2191(AddSubgroup.zmultiples x)"
      },
      {
        "tactic": "exact ofMul_image_zpowers_eq_zmultiples_ofMul",
        "annotated_tactic": [
          "exact <a>ofMul_image_zpowers_eq_zmultiples_ofMul</a>",
          [
            {
              "full_name": "ofMul_image_zpowers_eq_zmultiples_ofMul",
              "def_path": "Mathlib/Algebra/Group/Subgroup/ZPowers.lean",
              "def_pos": [
                188,
                9
              ],
              "def_end_pos": [
                188,
                48
              ]
            }
          ]
        ],
        "state_before": "G : Type u_1\ninst\u271d\u00b2 : Group G\nA : Type u_2\ninst\u271d\u00b9 : AddGroup A\nN : Type u_3\ninst\u271d : Group N\nx : A\n\u22a2 \u21d1Multiplicative.ofAdd.symm '' \u2191(Subgroup.zpowers (Multiplicative.ofAdd x)) = \u2191(AddSubgroup.zmultiples x)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.815721577964723,
    "entry_failed": false
  },
  "20938": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Prod.lean",
    "full_name": "SimpleGraph.Connected.ofBoxProdRight",
    "start": [
      210,
      11
    ],
    "end": [
      213,
      40
    ],
    "traced_tactics": [
      {
        "tactic": "haveI := (nonempty_prod.1 h.nonempty).1",
        "annotated_tactic": [
          "haveI := (<a>nonempty_prod</a>.1 h.nonempty).1",
          [
            {
              "full_name": "nonempty_prod",
              "def_path": "Mathlib/Logic/Nonempty.lean",
              "def_pos": [
                175,
                9
              ],
              "def_end_pos": [
                175,
                22
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nh : (G \u25a1 H).Connected\n\u22a2 H.Connected",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nh : (G \u25a1 H).Connected\nthis : Nonempty \u03b1\n\u22a2 H.Connected"
      },
      {
        "tactic": "haveI := (nonempty_prod.1 h.nonempty).2",
        "annotated_tactic": [
          "haveI := (<a>nonempty_prod</a>.1 h.nonempty).2",
          [
            {
              "full_name": "nonempty_prod",
              "def_path": "Mathlib/Logic/Nonempty.lean",
              "def_pos": [
                175,
                9
              ],
              "def_end_pos": [
                175,
                22
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nh : (G \u25a1 H).Connected\nthis : Nonempty \u03b1\n\u22a2 H.Connected",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nh : (G \u25a1 H).Connected\nthis\u271d : Nonempty \u03b1\nthis : Nonempty \u03b2\n\u22a2 H.Connected"
      },
      {
        "tactic": "exact \u27e8h.preconnected.ofBoxProdRight\u27e9",
        "annotated_tactic": [
          "exact \u27e8h.preconnected.ofBoxProdRight\u27e9",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nh : (G \u25a1 H).Connected\nthis\u271d : Nonempty \u03b1\nthis : Nonempty \u03b2\n\u22a2 H.Connected",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.064298404031433,
    "entry_failed": false
  },
  "20954": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/SpecificGroups/Quaternion.lean",
    "full_name": "QuaternionGroup.a_one_pow_n",
    "start": [
      189,
      1
    ],
    "end": [
      192,
      28
    ],
    "traced_tactics": [
      {
        "tactic": "rw [a_one_pow, one_def]",
        "annotated_tactic": [
          "rw [<a>a_one_pow</a>, <a>one_def</a>]",
          [
            {
              "full_name": "QuaternionGroup.a_one_pow",
              "def_path": "Mathlib/GroupTheory/SpecificGroups/Quaternion.lean",
              "def_pos": [
                180,
                9
              ],
              "def_end_pos": [
                180,
                18
              ]
            },
            {
              "full_name": "QuaternionGroup.one_def",
              "def_path": "Mathlib/GroupTheory/SpecificGroups/Quaternion.lean",
              "def_pos": [
                131,
                9
              ],
              "def_end_pos": [
                131,
                16
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\n\u22a2 a 1 ^ (2 * n) = 1",
        "state_after": "n : \u2115\n\u22a2 a \u2191(2 * n) = a 0"
      },
      {
        "tactic": "congr 1",
        "annotated_tactic": [
          "congr 1",
          []
        ],
        "state_before": "n : \u2115\n\u22a2 a \u2191(2 * n) = a 0",
        "state_after": "case e_a\nn : \u2115\n\u22a2 \u2191(2 * n) = 0"
      },
      {
        "tactic": "exact ZMod.natCast_self _",
        "annotated_tactic": [
          "exact <a>ZMod.natCast_self</a> _",
          [
            {
              "full_name": "ZMod.natCast_self",
              "def_path": "Mathlib/Data/ZMod/Basic.lean",
              "def_pos": [
                143,
                9
              ],
              "def_end_pos": [
                143,
                21
              ]
            }
          ]
        ],
        "state_before": "case e_a\nn : \u2115\n\u22a2 \u2191(2 * n) = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.421006507007405,
    "entry_failed": false
  },
  "21040": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Logic/Basic.lean",
    "full_name": "lawful_beq_subsingleton",
    "start": [
      1350,
      1
    ],
    "end": [
      1355,
      28
    ],
    "traced_tactics": [
      {
        "tactic": "apply beq_ext",
        "annotated_tactic": [
          "apply <a>beq_ext</a>",
          [
            {
              "full_name": "beq_ext",
              "def_path": "Mathlib/Logic/Basic.lean",
              "def_pos": [
                1341,
                9
              ],
              "def_end_pos": [
                1341,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst1 inst2 : BEq \u03b1\ninst\u271d\u00b9 : LawfulBEq \u03b1\ninst\u271d : LawfulBEq \u03b1\n\u22a2 inst1 = inst2",
        "state_after": "case h\n\u03b1 : Type u_1\ninst1 inst2 : BEq \u03b1\ninst\u271d\u00b9 : LawfulBEq \u03b1\ninst\u271d : LawfulBEq \u03b1\n\u22a2 \u2200 (x y : \u03b1), (x == y) = (x == y)"
      },
      {
        "tactic": "intro x y",
        "annotated_tactic": [
          "intro x y",
          []
        ],
        "state_before": "case h\n\u03b1 : Type u_1\ninst1 inst2 : BEq \u03b1\ninst\u271d\u00b9 : LawfulBEq \u03b1\ninst\u271d : LawfulBEq \u03b1\n\u22a2 \u2200 (x y : \u03b1), (x == y) = (x == y)",
        "state_after": "case h\n\u03b1 : Type u_1\ninst1 inst2 : BEq \u03b1\ninst\u271d\u00b9 : LawfulBEq \u03b1\ninst\u271d : LawfulBEq \u03b1\nx y : \u03b1\n\u22a2 (x == y) = (x == y)"
      },
      {
        "tactic": "simp only [beq_eq_decide]",
        "annotated_tactic": [
          "simp only [<a>beq_eq_decide</a>]",
          [
            {
              "full_name": "beq_eq_decide",
              "def_path": "Mathlib/Logic/Basic.lean",
              "def_pos": [
                1336,
                9
              ],
              "def_end_pos": [
                1336,
                22
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u_1\ninst1 inst2 : BEq \u03b1\ninst\u271d\u00b9 : LawfulBEq \u03b1\ninst\u271d : LawfulBEq \u03b1\nx y : \u03b1\n\u22a2 (x == y) = (x == y)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.098490436910652,
    "entry_failed": false
  },
  "21152": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/OmegaCompletePartialOrder.lean",
    "full_name": "OmegaCompletePartialOrder.continuous_id",
    "start": [
      324,
      1
    ],
    "end": [
      324,
      88
    ],
    "traced_tactics": [
      {
        "tactic": "intro c",
        "annotated_tactic": [
          "intro c",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type u_1\ninst\u271d\u00b2 : OmegaCompletePartialOrder \u03b1\ninst\u271d\u00b9 : OmegaCompletePartialOrder \u03b2\ninst\u271d : OmegaCompletePartialOrder \u03b3\nf : \u03b1 \u2192o \u03b2\ng : \u03b2 \u2192o \u03b3\n\u22a2 Continuous OrderHom.id",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type u_1\ninst\u271d\u00b2 : OmegaCompletePartialOrder \u03b1\ninst\u271d\u00b9 : OmegaCompletePartialOrder \u03b2\ninst\u271d : OmegaCompletePartialOrder \u03b3\nf : \u03b1 \u2192o \u03b2\ng : \u03b2 \u2192o \u03b3\nc : Chain \u03b1\n\u22a2 OrderHom.id (\u03c9Sup c) = \u03c9Sup (c.map OrderHom.id)"
      },
      {
        "tactic": "rw [c.map_id]",
        "annotated_tactic": [
          "rw [c.map_id]",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type u_1\ninst\u271d\u00b2 : OmegaCompletePartialOrder \u03b1\ninst\u271d\u00b9 : OmegaCompletePartialOrder \u03b2\ninst\u271d : OmegaCompletePartialOrder \u03b3\nf : \u03b1 \u2192o \u03b2\ng : \u03b2 \u2192o \u03b3\nc : Chain \u03b1\n\u22a2 OrderHom.id (\u03c9Sup c) = \u03c9Sup (c.map OrderHom.id)",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type u_1\ninst\u271d\u00b2 : OmegaCompletePartialOrder \u03b1\ninst\u271d\u00b9 : OmegaCompletePartialOrder \u03b2\ninst\u271d : OmegaCompletePartialOrder \u03b3\nf : \u03b1 \u2192o \u03b2\ng : \u03b2 \u2192o \u03b3\nc : Chain \u03b1\n\u22a2 OrderHom.id (\u03c9Sup c) = \u03c9Sup c"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type u_1\ninst\u271d\u00b2 : OmegaCompletePartialOrder \u03b1\ninst\u271d\u00b9 : OmegaCompletePartialOrder \u03b2\ninst\u271d : OmegaCompletePartialOrder \u03b3\nf : \u03b1 \u2192o \u03b2\ng : \u03b2 \u2192o \u03b3\nc : Chain \u03b1\n\u22a2 OrderHom.id (\u03c9Sup c) = \u03c9Sup c",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.4436222299700603,
    "entry_failed": false
  },
  "21170": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/Measure/Stieltjes.lean",
    "full_name": "StieltjesFunction.borel_le_measurable",
    "start": [
      374,
      1
    ],
    "end": [
      377,
      64
    ],
    "traced_tactics": [
      {
        "tactic": "rw [borel_eq_generateFrom_Ioi]",
        "annotated_tactic": [
          "rw [<a>borel_eq_generateFrom_Ioi</a>]",
          [
            {
              "full_name": "borel_eq_generateFrom_Ioi",
              "def_path": "Mathlib/MeasureTheory/Constructions/BorelSpace/Order.lean",
              "def_pos": [
                77,
                9
              ],
              "def_end_pos": [
                77,
                34
              ]
            }
          ]
        ],
        "state_before": "f : StieltjesFunction\n\u22a2 borel \u211d \u2264 f.outer.caratheodory",
        "state_after": "f : StieltjesFunction\n\u22a2 MeasurableSpace.generateFrom (range Ioi) \u2264 f.outer.caratheodory"
      },
      {
        "tactic": "refine MeasurableSpace.generateFrom_le ?_",
        "annotated_tactic": [
          "refine <a>MeasurableSpace.generateFrom_le</a> ?_",
          [
            {
              "full_name": "MeasurableSpace.generateFrom_le",
              "def_path": "Mathlib/MeasureTheory/MeasurableSpace/Defs.lean",
              "def_pos": [
                390,
                9
              ],
              "def_end_pos": [
                390,
                24
              ]
            }
          ]
        ],
        "state_before": "f : StieltjesFunction\n\u22a2 MeasurableSpace.generateFrom (range Ioi) \u2264 f.outer.caratheodory",
        "state_after": "f : StieltjesFunction\n\u22a2 \u2200 t \u2208 range Ioi, MeasurableSet t"
      },
      {
        "tactic": "simp (config := { contextual := true }) [f.measurableSet_Ioi]",
        "annotated_tactic": [
          "simp (config := { contextual := <a>true</a> }) [f.measurableSet_Ioi]",
          [
            {
              "full_name": "Bool.true",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                571,
                5
              ],
              "def_end_pos": [
                571,
                9
              ]
            }
          ]
        ],
        "state_before": "f : StieltjesFunction\n\u22a2 \u2200 t \u2208 range Ioi, MeasurableSet t",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.30466893396806,
    "entry_failed": false
  },
  "21195": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Factors.lean",
    "full_name": "Nat.dvd_of_mem_factors",
    "start": [
      152,
      1
    ],
    "end": [
      155,
      64
    ],
    "traced_tactics": [
      {
        "tactic": "rcases n.eq_zero_or_pos with (rfl | hn)",
        "annotated_tactic": [
          "rcases n.eq_zero_or_pos with (rfl | hn)",
          []
        ],
        "state_before": "n p : \u2115\nh : p \u2208 n.factors\n\u22a2 p \u2223 n",
        "state_after": "case inl\np : \u2115\nh : p \u2208 factors 0\n\u22a2 p \u2223 0\n\ncase inr\nn p : \u2115\nh : p \u2208 n.factors\nhn : n > 0\n\u22a2 p \u2223 n"
      },
      {
        "tactic": "exact dvd_zero p",
        "annotated_tactic": [
          "exact <a>dvd_zero</a> p",
          [
            {
              "full_name": "dvd_zero",
              "def_path": "Mathlib/Algebra/GroupWithZero/Divisibility.lean",
              "def_pos": [
                41,
                9
              ],
              "def_end_pos": [
                41,
                17
              ]
            }
          ]
        ],
        "state_before": "case inl\np : \u2115\nh : p \u2208 factors 0\n\u22a2 p \u2223 0",
        "state_after": "no goals"
      },
      {
        "tactic": "rwa [\u2190 mem_factors_iff_dvd hn.ne' (prime_of_mem_factors h)]",
        "annotated_tactic": [
          "rwa [\u2190 <a>mem_factors_iff_dvd</a> hn.ne' (<a>prime_of_mem_factors</a> h)]",
          [
            {
              "full_name": "Nat.mem_factors_iff_dvd",
              "def_path": "Mathlib/Data/Nat/Factors.lean",
              "def_pos": [
                146,
                9
              ],
              "def_end_pos": [
                146,
                28
              ]
            },
            {
              "full_name": "Nat.prime_of_mem_factors",
              "def_path": "Mathlib/Data/Nat/Factors.lean",
              "def_pos": [
                55,
                9
              ],
              "def_end_pos": [
                55,
                29
              ]
            }
          ]
        ],
        "state_before": "case inr\nn p : \u2115\nh : p \u2208 n.factors\nhn : n > 0\n\u22a2 p \u2223 n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.012437175028026,
    "entry_failed": false
  },
  "21212": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Option/Basic.lean",
    "full_name": "Option.orElse_eq_some",
    "start": [
      400,
      1
    ],
    "end": [
      404,
      49
    ],
    "traced_tactics": [
      {
        "tactic": "cases o",
        "annotated_tactic": [
          "cases o",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\no o' : Option \u03b1\nx : \u03b1\n\u22a2 (HOrElse.hOrElse o fun x => o') = some x \u2194 o = some x \u2228 o = none \u2227 o' = some x",
        "state_after": "case none\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\no' : Option \u03b1\nx : \u03b1\n\u22a2 (HOrElse.hOrElse none fun x => o') = some x \u2194 none = some x \u2228 none = none \u2227 o' = some x\n\ncase some\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\no' : Option \u03b1\nx val\u271d : \u03b1\n\u22a2 (HOrElse.hOrElse (some val\u271d) fun x => o') = some x \u2194 some val\u271d = some x \u2228 some val\u271d = none \u2227 o' = some x"
      },
      {
        "tactic": "simp only [true_and, false_or, eq_self_iff_true, none_orElse]",
        "annotated_tactic": [
          "simp only [<a>true_and</a>, <a>false_or</a>, <a>eq_self_iff_true</a>, <a>none_orElse</a>]",
          [
            {
              "full_name": "true_and",
              "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean",
              "def_pos": [
                105,
                17
              ],
              "def_end_pos": [
                105,
                25
              ]
            },
            {
              "full_name": "false_or",
              "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean",
              "def_pos": [
                122,
                17
              ],
              "def_end_pos": [
                122,
                25
              ]
            },
            {
              "full_name": "eq_self_iff_true",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1380,
                9
              ],
              "def_end_pos": [
                1380,
                25
              ]
            },
            {
              "full_name": "Option.none_orElse",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Option/Lemmas.lean",
              "def_pos": [
                185,
                17
              ],
              "def_end_pos": [
                185,
                28
              ]
            }
          ]
        ],
        "state_before": "case none\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\no' : Option \u03b1\nx : \u03b1\n\u22a2 (HOrElse.hOrElse none fun x => o') = some x \u2194 none = some x \u2228 none = none \u2227 o' = some x",
        "state_after": "no goals"
      },
      {
        "tactic": "simp only [some_orElse, or_false, false_and]",
        "annotated_tactic": [
          "simp only [<a>some_orElse</a>, <a>or_false</a>, <a>false_and</a>]",
          [
            {
              "full_name": "Option.some_orElse",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Option/Lemmas.lean",
              "def_pos": [
                183,
                17
              ],
              "def_end_pos": [
                183,
                28
              ]
            },
            {
              "full_name": "or_false",
              "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean",
              "def_pos": [
                121,
                17
              ],
              "def_end_pos": [
                121,
                25
              ]
            },
            {
              "full_name": "false_and",
              "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean",
              "def_pos": [
                110,
                17
              ],
              "def_end_pos": [
                110,
                26
              ]
            }
          ]
        ],
        "state_before": "case some\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\no' : Option \u03b1\nx val\u271d : \u03b1\n\u22a2 (HOrElse.hOrElse (some val\u271d) fun x => o') = some x \u2194 some val\u271d = some x \u2228 some val\u271d = none \u2227 o' = some x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9575178819941357,
    "entry_failed": false
  },
  "21226": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Interval/Finset/Nat.lean",
    "full_name": "Nat.range_eq_Icc_zero_sub_one",
    "start": [
      70,
      1
    ],
    "end": [
      73,
      47
    ],
    "traced_tactics": [
      {
        "tactic": "ext b",
        "annotated_tactic": [
          "ext b",
          []
        ],
        "state_before": "a b c n : \u2115\nhn : n \u2260 0\n\u22a2 range n = Icc 0 (n - 1)",
        "state_after": "case a\na b\u271d c n : \u2115\nhn : n \u2260 0\nb : \u2115\n\u22a2 b \u2208 range n \u2194 b \u2208 Icc 0 (n - 1)"
      },
      {
        "tactic": "simp_all only [mem_Icc, zero_le, true_and, mem_range]",
        "annotated_tactic": [
          "simp_all only [<a>mem_Icc</a>, <a>zero_le</a>, <a>true_and</a>, <a>mem_range</a>]",
          [
            {
              "full_name": "Finset.mem_Icc",
              "def_path": "Mathlib/Order/Interval/Finset/Defs.lean",
              "def_pos": [
                313,
                9
              ],
              "def_end_pos": [
                313,
                16
              ]
            },
            {
              "full_name": "Nat.zero_le",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                1663,
                9
              ],
              "def_end_pos": [
                1663,
                20
              ]
            },
            {
              "full_name": "true_and",
              "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean",
              "def_pos": [
                105,
                17
              ],
              "def_end_pos": [
                105,
                25
              ]
            },
            {
              "full_name": "Finset.mem_range",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                2935,
                9
              ],
              "def_end_pos": [
                2935,
                18
              ]
            }
          ]
        ],
        "state_before": "case a\na b\u271d c n : \u2115\nhn : n \u2260 0\nb : \u2115\n\u22a2 b \u2208 range n \u2194 b \u2208 Icc 0 (n - 1)",
        "state_after": "case a\na b\u271d c n : \u2115\nhn : n \u2260 0\nb : \u2115\n\u22a2 b < n \u2194 b \u2264 n - 1"
      },
      {
        "tactic": "exact lt_iff_le_pred (zero_lt_of_ne_zero hn)",
        "annotated_tactic": [
          "exact <a>lt_iff_le_pred</a> (<a>zero_lt_of_ne_zero</a> hn)",
          [
            {
              "full_name": "Nat.lt_iff_le_pred",
              "def_path": "Mathlib/Data/Nat/Defs.lean",
              "def_pos": [
                144,
                7
              ],
              "def_end_pos": [
                144,
                21
              ]
            },
            {
              "full_name": "Nat.zero_lt_of_ne_zero",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean",
              "def_pos": [
                375,
                9
              ],
              "def_end_pos": [
                375,
                27
              ]
            }
          ]
        ],
        "state_before": "case a\na b\u271d c n : \u2115\nhn : n \u2260 0\nb : \u2115\n\u22a2 b < n \u2194 b \u2264 n - 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8373945279745385,
    "entry_failed": false
  },
  "21233": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/PowerSeries/WellKnown.lean",
    "full_name": "PowerSeries.invUnitsSub_mul_X",
    "start": [
      52,
      1
    ],
    "end": [
      55,
      37
    ],
    "traced_tactics": [
      {
        "tactic": "ext (_ | n)",
        "annotated_tactic": [
          "ext (_ | n)",
          []
        ],
        "state_before": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : Ring R\ninst\u271d : Ring S\nu : R\u02e3\n\u22a2 invUnitsSub u * X = invUnitsSub u * (C R) \u2191u - 1",
        "state_after": "case h.zero\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : Ring R\ninst\u271d : Ring S\nu : R\u02e3\n\u22a2 (coeff R 0) (invUnitsSub u * X) = (coeff R 0) (invUnitsSub u * (C R) \u2191u - 1)\n\ncase h.succ\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : Ring R\ninst\u271d : Ring S\nu : R\u02e3\nn : \u2115\n\u22a2 (coeff R (n + 1)) (invUnitsSub u * X) = (coeff R (n + 1)) (invUnitsSub u * (C R) \u2191u - 1)"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case h.zero\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : Ring R\ninst\u271d : Ring S\nu : R\u02e3\n\u22a2 (coeff R 0) (invUnitsSub u * X) = (coeff R 0) (invUnitsSub u * (C R) \u2191u - 1)",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [n.succ_ne_zero, pow_succ']",
        "annotated_tactic": [
          "simp [n.succ_ne_zero, <a>pow_succ'</a>]",
          [
            {
              "full_name": "pow_succ'",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                667,
                34
              ],
              "def_end_pos": [
                667,
                43
              ]
            }
          ]
        ],
        "state_before": "case h.succ\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : Ring R\ninst\u271d : Ring S\nu : R\u02e3\nn : \u2115\n\u22a2 (coeff R (n + 1)) (invUnitsSub u * X) = (coeff R (n + 1)) (invUnitsSub u * (C R) \u2191u - 1)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6670139039633796,
    "entry_failed": false
  },
  "21240": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Real/GoldenRatio.lean",
    "full_name": "goldConj_sq",
    "start": [
      98,
      1
    ],
    "end": [
      101,
      33
    ],
    "traced_tactics": [
      {
        "tactic": "rw [goldenConj, \u2190 sub_eq_zero]",
        "annotated_tactic": [
          "rw [<a>goldenConj</a>, \u2190 <a>sub_eq_zero</a>]",
          [
            {
              "full_name": "goldenConj",
              "def_path": "Mathlib/Data/Real/GoldenRatio.lean",
              "def_pos": [
                36,
                8
              ],
              "def_end_pos": [
                36,
                18
              ]
            },
            {
              "full_name": "sub_eq_zero",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                1070,
                3
              ],
              "def_end_pos": [
                1070,
                14
              ]
            }
          ]
        ],
        "state_before": "\u22a2 \u03c8 ^ 2 = \u03c8 + 1",
        "state_after": "\u22a2 ((1 - \u221a5) / 2) ^ 2 - ((1 - \u221a5) / 2 + 1) = 0"
      },
      {
        "tactic": "ring_nf",
        "annotated_tactic": [
          "ring_nf",
          []
        ],
        "state_before": "\u22a2 ((1 - \u221a5) / 2) ^ 2 - ((1 - \u221a5) / 2 + 1) = 0",
        "state_after": "\u22a2 -5 / 4 + \u221a5 ^ 2 * (1 / 4) = 0"
      },
      {
        "tactic": "rw [Real.sq_sqrt] <;> norm_num",
        "annotated_tactic": [
          "rw [<a>Real.sq_sqrt</a>] <;> norm_num",
          [
            {
              "full_name": "Real.sq_sqrt",
              "def_path": "Mathlib/Data/Real/Sqrt.lean",
              "def_pos": [
                201,
                9
              ],
              "def_end_pos": [
                201,
                16
              ]
            }
          ]
        ],
        "state_before": "\u22a2 -5 / 4 + \u221a5 ^ 2 * (1 / 4) = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.267091760993935,
    "entry_failed": false
  },
  "21270": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/Convex/SpecificFunctions/Basic.lean",
    "full_name": "convexOn_rpow",
    "start": [
      206,
      1
    ],
    "end": [
      209,
      42
    ],
    "traced_tactics": [
      {
        "tactic": "rcases eq_or_lt_of_le hp with (rfl | hp)",
        "annotated_tactic": [
          "rcases <a>eq_or_lt_of_le</a> hp with (rfl | hp)",
          [
            {
              "full_name": "eq_or_lt_of_le",
              "def_path": "Mathlib/Order/Basic.lean",
              "def_pos": [
                381,
                9
              ],
              "def_end_pos": [
                381,
                23
              ]
            }
          ]
        ],
        "state_before": "p : \u211d\nhp : 1 \u2264 p\n\u22a2 ConvexOn \u211d (Ici 0) fun x => x ^ p",
        "state_after": "case inl\nhp : 1 \u2264 1\n\u22a2 ConvexOn \u211d (Ici 0) fun x => x ^ 1\n\ncase inr\np : \u211d\nhp\u271d : 1 \u2264 p\nhp : 1 < p\n\u22a2 ConvexOn \u211d (Ici 0) fun x => x ^ p"
      },
      {
        "tactic": "exact (strictConvexOn_rpow hp).convexOn",
        "annotated_tactic": [
          "exact (<a>strictConvexOn_rpow</a> hp).<a>convexOn</a>",
          [
            {
              "full_name": "strictConvexOn_rpow",
              "def_path": "Mathlib/Analysis/Convex/SpecificFunctions/Basic.lean",
              "def_pos": [
                178,
                9
              ],
              "def_end_pos": [
                178,
                28
              ]
            },
            {
              "full_name": "StrictConvexOn.convexOn",
              "def_path": "Mathlib/Analysis/Convex/Function.lean",
              "def_pos": [
                370,
                9
              ],
              "def_end_pos": [
                370,
                32
              ]
            }
          ]
        ],
        "state_before": "case inr\np : \u211d\nhp\u271d : 1 \u2264 p\nhp : 1 < p\n\u22a2 ConvexOn \u211d (Ici 0) fun x => x ^ p",
        "state_after": "no goals"
      },
      {
        "tactic": "simpa using convexOn_id (convex_Ici _)",
        "annotated_tactic": [
          "simpa using <a>convexOn_id</a> (<a>convex_Ici</a> _)",
          [
            {
              "full_name": "convexOn_id",
              "def_path": "Mathlib/Analysis/Convex/Function.lean",
              "def_pos": [
                93,
                9
              ],
              "def_end_pos": [
                93,
                20
              ]
            },
            {
              "full_name": "convex_Ici",
              "def_path": "Mathlib/Analysis/Convex/Basic.lean",
              "def_pos": [
                284,
                9
              ],
              "def_end_pos": [
                284,
                19
              ]
            }
          ]
        ],
        "state_before": "case inl\nhp : 1 \u2264 1\n\u22a2 ConvexOn \u211d (Ici 0) fun x => x ^ 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.399844769970514,
    "entry_failed": false
  },
  "21514": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Stream/Init.lean",
    "full_name": "Stream'.iterate_eq",
    "start": [
      282,
      1
    ],
    "end": [
      284,
      25
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 Stream'.eta (iterate f a)]",
        "annotated_tactic": [
          "rw [\u2190 <a>Stream'.eta</a> (<a>iterate</a> f a)]",
          [
            {
              "full_name": "Stream'.eta",
              "def_path": "Mathlib/Data/Stream/Init.lean",
              "def_pos": [
                31,
                19
              ],
              "def_end_pos": [
                31,
                22
              ]
            },
            {
              "full_name": "Stream'.iterate",
              "def_path": "Mathlib/Data/Stream/Defs.lean",
              "def_pos": [
                83,
                5
              ],
              "def_end_pos": [
                83,
                12
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\nf : \u03b1 \u2192 \u03b1\na : \u03b1\n\u22a2 iterate f a = a :: iterate f (f a)",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\nf : \u03b1 \u2192 \u03b1\na : \u03b1\n\u22a2 (iterate f a).head :: (iterate f a).tail = a :: iterate f (f a)"
      },
      {
        "tactic": "rw [tail_iterate]",
        "annotated_tactic": [
          "rw [<a>tail_iterate</a>]",
          [
            {
              "full_name": "Stream'.tail_iterate",
              "def_path": "Mathlib/Data/Stream/Init.lean",
              "def_pos": [
                274,
                9
              ],
              "def_end_pos": [
                274,
                21
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\nf : \u03b1 \u2192 \u03b1\na : \u03b1\n\u22a2 (iterate f a).head :: (iterate f a).tail = a :: iterate f (f a)",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\nf : \u03b1 \u2192 \u03b1\na : \u03b1\n\u22a2 (iterate f a).head :: iterate f (f a) = a :: iterate f (f a)"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\nf : \u03b1 \u2192 \u03b1\na : \u03b1\n\u22a2 (iterate f a).head :: iterate f (f a) = a :: iterate f (f a)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.0868253470398486,
    "entry_failed": false
  },
  "21614": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/PEquiv.lean",
    "full_name": "PEquiv.trans_refl",
    "start": [
      174,
      1
    ],
    "end": [
      175,
      34
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type x\nf : \u03b1 \u2243. \u03b2\n\u22a2 f.trans (PEquiv.refl \u03b2) = f",
        "state_after": "case h.a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type x\nf : \u03b1 \u2243. \u03b2\nx\u271d : \u03b1\na\u271d : \u03b2\n\u22a2 a\u271d \u2208 (f.trans (PEquiv.refl \u03b2)) x\u271d \u2194 a\u271d \u2208 f x\u271d"
      },
      {
        "tactic": "dsimp [PEquiv.trans]",
        "annotated_tactic": [
          "dsimp [<a>PEquiv.trans</a>]",
          [
            {
              "full_name": "PEquiv.trans",
              "def_path": "Mathlib/Data/PEquiv.lean",
              "def_pos": [
                118,
                15
              ],
              "def_end_pos": [
                118,
                20
              ]
            }
          ]
        ],
        "state_before": "case h.a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type x\nf : \u03b1 \u2243. \u03b2\nx\u271d : \u03b1\na\u271d : \u03b2\n\u22a2 a\u271d \u2208 (f.trans (PEquiv.refl \u03b2)) x\u271d \u2194 a\u271d \u2208 f x\u271d",
        "state_after": "case h.a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type x\nf : \u03b1 \u2243. \u03b2\nx\u271d : \u03b1\na\u271d : \u03b2\n\u22a2 a\u271d \u2208 (f x\u271d).bind \u21d1(PEquiv.refl \u03b2) \u2194 a\u271d \u2208 f x\u271d"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case h.a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b4 : Type x\nf : \u03b1 \u2243. \u03b2\nx\u271d : \u03b1\na\u271d : \u03b2\n\u22a2 a\u271d \u2208 (f x\u271d).bind \u21d1(PEquiv.refl \u03b2) \u2194 a\u271d \u2208 f x\u271d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6903904520440847,
    "entry_failed": false
  },
  "21730": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Totient.lean",
    "full_name": "Nat.sum_totient'",
    "start": [
      180,
      1
    ],
    "end": [
      183,
      40
    ],
    "traced_tactics": [
      {
        "tactic": "convert sum_totient _ using 1",
        "annotated_tactic": [
          "convert <a>sum_totient</a> _ using 1",
          [
            {
              "full_name": "Nat.sum_totient",
              "def_path": "Mathlib/Data/Nat/Totient.lean",
              "def_pos": [
                168,
                9
              ],
              "def_end_pos": [
                168,
                20
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\n\u22a2 \u2211 m \u2208 filter (fun x => x \u2223 n) (range n.succ), \u03c6 m = n",
        "state_after": "case h.e'_2\nn : \u2115\n\u22a2 \u2211 m \u2208 filter (fun x => x \u2223 n) (range n.succ), \u03c6 m = n.divisors.sum \u03c6"
      },
      {
        "tactic": "simp only [Nat.divisors, sum_filter, range_eq_Ico]",
        "annotated_tactic": [
          "simp only [<a>Nat.divisors</a>, <a>sum_filter</a>, <a>range_eq_Ico</a>]",
          [
            {
              "full_name": "Nat.divisors",
              "def_path": "Mathlib/NumberTheory/Divisors.lean",
              "def_pos": [
                42,
                5
              ],
              "def_end_pos": [
                42,
                13
              ]
            },
            {
              "full_name": "Finset.sum_filter",
              "def_path": "Mathlib/Algebra/BigOperators/Group/Finset.lean",
              "def_pos": [
                971,
                3
              ],
              "def_end_pos": [
                971,
                14
              ]
            },
            {
              "full_name": "Finset.range_eq_Ico",
              "def_path": "Mathlib/Order/Interval/Finset/Nat.lean",
              "def_pos": [
                75,
                9
              ],
              "def_end_pos": [
                75,
                35
              ]
            }
          ]
        ],
        "state_before": "case h.e'_2\nn : \u2115\n\u22a2 \u2211 m \u2208 filter (fun x => x \u2223 n) (range n.succ), \u03c6 m = n.divisors.sum \u03c6",
        "state_after": "case h.e'_2\nn : \u2115\n\u22a2 (\u2211 a \u2208 Ico 0 n.succ, if a \u2223 n then \u03c6 a else 0) = \u2211 a \u2208 Ico 1 (n + 1), if a \u2223 n then \u03c6 a else 0"
      },
      {
        "tactic": "rw [sum_eq_sum_Ico_succ_bot] <;> simp",
        "annotated_tactic": [
          "rw [<a>sum_eq_sum_Ico_succ_bot</a>] <;> simp",
          [
            {
              "full_name": "Finset.sum_eq_sum_Ico_succ_bot",
              "def_path": "Mathlib/Algebra/BigOperators/Intervals.lean",
              "def_pos": [
                117,
                3
              ],
              "def_end_pos": [
                117,
                14
              ]
            }
          ]
        ],
        "state_before": "case h.e'_2\nn : \u2115\n\u22a2 (\u2211 a \u2208 Ico 0 n.succ, if a \u2223 n then \u03c6 a else 0) = \u2211 a \u2208 Ico 1 (n + 1), if a \u2223 n then \u03c6 a else 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.959615022991784,
    "entry_failed": false
  },
  "21764": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/Padics/PadicNumbers.lean",
    "full_name": "PadicSeq.lift_index_left_left",
    "start": [
      175,
      1
    ],
    "end": [
      180,
      17
    ],
    "traced_tactics": [
      {
        "tactic": "apply stationaryPoint_spec hf",
        "annotated_tactic": [
          "apply <a>stationaryPoint_spec</a> hf",
          [
            {
              "full_name": "PadicSeq.stationaryPoint_spec",
              "def_path": "Mathlib/NumberTheory/Padics/PadicNumbers.lean",
              "def_pos": [
                109,
                9
              ],
              "def_end_pos": [
                109,
                29
              ]
            }
          ]
        ],
        "state_before": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\nf : PadicSeq p\nhf : \u00acf \u2248 0\nv2 v3 : \u2115\n\u22a2 padicNorm p (\u2191f (stationaryPoint hf)) = padicNorm p (\u2191f (max (stationaryPoint hf) (max v2 v3)))",
        "state_after": "case a\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nf : PadicSeq p\nhf : \u00acf \u2248 0\nv2 v3 : \u2115\n\u22a2 stationaryPoint hf \u2264 max (stationaryPoint hf) (max v2 v3)\n\ncase a\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nf : PadicSeq p\nhf : \u00acf \u2248 0\nv2 v3 : \u2115\n\u22a2 stationaryPoint hf \u2264 stationaryPoint hf"
      },
      {
        "tactic": "apply le_max_left",
        "annotated_tactic": [
          "apply <a>le_max_left</a>",
          [
            {
              "full_name": "le_max_left",
              "def_path": "Mathlib/Init/Order/LinearOrder.lean",
              "def_pos": [
                54,
                9
              ],
              "def_end_pos": [
                54,
                20
              ]
            }
          ]
        ],
        "state_before": "case a\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nf : PadicSeq p\nhf : \u00acf \u2248 0\nv2 v3 : \u2115\n\u22a2 stationaryPoint hf \u2264 max (stationaryPoint hf) (max v2 v3)",
        "state_after": "no goals"
      },
      {
        "tactic": "exact le_rfl",
        "annotated_tactic": [
          "exact <a>le_rfl</a>",
          [
            {
              "full_name": "le_rfl",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                50,
                9
              ],
              "def_end_pos": [
                50,
                15
              ]
            }
          ]
        ],
        "state_before": "case a\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nf : PadicSeq p\nhf : \u00acf \u2248 0\nv2 v3 : \u2115\n\u22a2 stationaryPoint hf \u2264 stationaryPoint hf",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.450267435051501,
    "entry_failed": false
  },
  "21800": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/LocallyConstant/Basic.lean",
    "full_name": "IsLocallyConstant.exists_eq_const",
    "start": [
      170,
      1
    ],
    "end": [
      174,
      53
    ],
    "traced_tactics": [
      {
        "tactic": "cases' isEmpty_or_nonempty X with h h",
        "annotated_tactic": [
          "cases' <a>isEmpty_or_nonempty</a> X with h h",
          [
            {
              "full_name": "isEmpty_or_nonempty",
              "def_path": "Mathlib/Logic/IsEmpty.lean",
              "def_pos": [
                221,
                9
              ],
              "def_end_pos": [
                221,
                28
              ]
            }
          ]
        ],
        "state_before": "X : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : PreconnectedSpace X\ninst\u271d : Nonempty Y\nf : X \u2192 Y\nhf : IsLocallyConstant f\n\u22a2 \u2203 y, f = Function.const X y",
        "state_after": "case inl\nX : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : PreconnectedSpace X\ninst\u271d : Nonempty Y\nf : X \u2192 Y\nhf : IsLocallyConstant f\nh : IsEmpty X\n\u22a2 \u2203 y, f = Function.const X y\n\ncase inr\nX : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : PreconnectedSpace X\ninst\u271d : Nonempty Y\nf : X \u2192 Y\nhf : IsLocallyConstant f\nh : Nonempty X\n\u22a2 \u2203 y, f = Function.const X y"
      },
      {
        "tactic": "exact \u27e8Classical.arbitrary Y, funext <| h.elim\u27e9",
        "annotated_tactic": [
          "exact \u27e8<a>Classical.arbitrary</a> Y, <a>funext</a> <| h.elim\u27e9",
          [
            {
              "full_name": "Classical.arbitrary",
              "def_path": "Mathlib/Logic/Nonempty.lean",
              "def_pos": [
                99,
                32
              ],
              "def_end_pos": [
                99,
                51
              ]
            },
            {
              "full_name": "funext",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1817,
                9
              ],
              "def_end_pos": [
                1817,
                15
              ]
            }
          ]
        ],
        "state_before": "case inl\nX : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : PreconnectedSpace X\ninst\u271d : Nonempty Y\nf : X \u2192 Y\nhf : IsLocallyConstant f\nh : IsEmpty X\n\u22a2 \u2203 y, f = Function.const X y",
        "state_after": "no goals"
      },
      {
        "tactic": "exact \u27e8f (Classical.arbitrary X), hf.eq_const _\u27e9",
        "annotated_tactic": [
          "exact \u27e8f (<a>Classical.arbitrary</a> X), hf.eq_const _\u27e9",
          [
            {
              "full_name": "Classical.arbitrary",
              "def_path": "Mathlib/Logic/Nonempty.lean",
              "def_pos": [
                99,
                32
              ],
              "def_end_pos": [
                99,
                51
              ]
            }
          ]
        ],
        "state_before": "case inr\nX : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : PreconnectedSpace X\ninst\u271d : Nonempty Y\nf : X \u2192 Y\nhf : IsLocallyConstant f\nh : Nonempty X\n\u22a2 \u2203 y, f = Function.const X y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.108119311975315,
    "entry_failed": false
  },
  "21823": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Setoid/Basic.lean",
    "full_name": "Setoid.sInf_def",
    "start": [
      155,
      1
    ],
    "end": [
      158,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set (Setoid \u03b1)\n\u22a2 (sInf s).Rel = sInf (Rel '' s)",
        "state_after": "case h.h.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set (Setoid \u03b1)\nx\u271d\u00b9 x\u271d : \u03b1\n\u22a2 (sInf s).Rel x\u271d\u00b9 x\u271d \u2194 sInf (Rel '' s) x\u271d\u00b9 x\u271d"
      },
      {
        "tactic": "simp only [sInf_image, iInf_apply, iInf_Prop_eq]",
        "annotated_tactic": [
          "simp only [<a>sInf_image</a>, <a>iInf_apply</a>, <a>iInf_Prop_eq</a>]",
          [
            {
              "full_name": "sInf_image",
              "def_path": "Mathlib/Order/CompleteLattice.lean",
              "def_pos": [
                1353,
                9
              ],
              "def_end_pos": [
                1353,
                19
              ]
            },
            {
              "full_name": "iInf_apply",
              "def_path": "Mathlib/Order/CompleteLattice.lean",
              "def_pos": [
                1761,
                9
              ],
              "def_end_pos": [
                1761,
                19
              ]
            },
            {
              "full_name": "iInf_Prop_eq",
              "def_path": "Mathlib/Order/CompleteLattice.lean",
              "def_pos": [
                1722,
                9
              ],
              "def_end_pos": [
                1722,
                21
              ]
            }
          ]
        ],
        "state_before": "case h.h.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set (Setoid \u03b1)\nx\u271d\u00b9 x\u271d : \u03b1\n\u22a2 (sInf s).Rel x\u271d\u00b9 x\u271d \u2194 sInf (Rel '' s) x\u271d\u00b9 x\u271d",
        "state_after": "case h.h.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set (Setoid \u03b1)\nx\u271d\u00b9 x\u271d : \u03b1\n\u22a2 (sInf s).Rel x\u271d\u00b9 x\u271d \u2194 \u2200 i \u2208 s, i.Rel x\u271d\u00b9 x\u271d"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case h.h.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set (Setoid \u03b1)\nx\u271d\u00b9 x\u271d : \u03b1\n\u22a2 (sInf s).Rel x\u271d\u00b9 x\u271d \u2194 \u2200 i \u2208 s, i.Rel x\u271d\u00b9 x\u271d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4593876209110022,
    "entry_failed": false
  },
  "21840": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Coprime/Basic.lean",
    "full_name": "IsCoprime.dvd_of_dvd_mul_right",
    "start": [
      102,
      1
    ],
    "end": [
      105,
      51
    ],
    "traced_tactics": [
      {
        "tactic": "let \u27e8a, b, H\u27e9 := H1",
        "annotated_tactic": [
          "let \u27e8a, b, H\u27e9 := H1",
          []
        ],
        "state_before": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nH1 : IsCoprime x z\nH2 : x \u2223 y * z\n\u22a2 x \u2223 y",
        "state_after": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nH1 : IsCoprime x z\nH2 : x \u2223 y * z\na b : R\nH : a * x + b * z = 1\n\u22a2 x \u2223 y"
      },
      {
        "tactic": "rw [\u2190 mul_one y, \u2190 H, mul_add, \u2190 mul_assoc, mul_left_comm]",
        "annotated_tactic": [
          "rw [\u2190 <a>mul_one</a> y, \u2190 H, <a>mul_add</a>, \u2190 <a>mul_assoc</a>, <a>mul_left_comm</a>]",
          [
            {
              "full_name": "mul_one",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                483,
                9
              ],
              "def_end_pos": [
                483,
                16
              ]
            },
            {
              "full_name": "mul_add",
              "def_path": "Mathlib/Algebra/Ring/Defs.lean",
              "def_pos": [
                83,
                7
              ],
              "def_end_pos": [
                83,
                14
              ]
            },
            {
              "full_name": "mul_assoc",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                289,
                9
              ],
              "def_end_pos": [
                289,
                18
              ]
            },
            {
              "full_name": "mul_left_comm",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                184,
                9
              ],
              "def_end_pos": [
                184,
                22
              ]
            }
          ]
        ],
        "state_before": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nH1 : IsCoprime x z\nH2 : x \u2223 y * z\na b : R\nH : a * x + b * z = 1\n\u22a2 x \u2223 y",
        "state_after": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nH1 : IsCoprime x z\nH2 : x \u2223 y * z\na b : R\nH : a * x + b * z = 1\n\u22a2 x \u2223 y * a * x + b * (y * z)"
      },
      {
        "tactic": "exact dvd_add (dvd_mul_left _ _) (H2.mul_left _)",
        "annotated_tactic": [
          "exact <a>dvd_add</a> (<a>dvd_mul_left</a> _ _) (H2.mul_left _)",
          [
            {
              "full_name": "dvd_add",
              "def_path": "Mathlib/Algebra/Ring/Divisibility/Basic.lean",
              "def_pos": [
                46,
                9
              ],
              "def_end_pos": [
                46,
                16
              ]
            },
            {
              "full_name": "dvd_mul_left",
              "def_path": "Mathlib/Algebra/Divisibility/Basic.lean",
              "def_pos": [
                205,
                9
              ],
              "def_end_pos": [
                205,
                21
              ]
            }
          ]
        ],
        "state_before": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nH1 : IsCoprime x z\nH2 : x \u2223 y * z\na b : R\nH : a * x + b * z = 1\n\u22a2 x \u2223 y * a * x + b * (y * z)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.0093538319924846,
    "entry_failed": false
  },
  "21892": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/Padics/PadicNorm.lean",
    "full_name": "padicNorm.nonzero",
    "start": [
      130,
      11
    ],
    "end": [
      133,
      35
    ],
    "traced_tactics": [
      {
        "tactic": "rw [padicNorm.eq_zpow_of_nonzero hq]",
        "annotated_tactic": [
          "rw [<a>padicNorm.eq_zpow_of_nonzero</a> hq]",
          [
            {
              "full_name": "padicNorm.eq_zpow_of_nonzero",
              "def_path": "Mathlib/NumberTheory/Padics/PadicNorm.lean",
              "def_pos": [
                54,
                19
              ],
              "def_end_pos": [
                54,
                37
              ]
            }
          ]
        ],
        "state_before": "p : \u2115\nhp : Fact (Nat.Prime p)\nq : \u211a\nhq : q \u2260 0\n\u22a2 padicNorm p q \u2260 0",
        "state_after": "p : \u2115\nhp : Fact (Nat.Prime p)\nq : \u211a\nhq : q \u2260 0\n\u22a2 \u2191p ^ (-padicValRat p q) \u2260 0"
      },
      {
        "tactic": "apply zpow_ne_zero",
        "annotated_tactic": [
          "apply <a>zpow_ne_zero</a>",
          [
            {
              "full_name": "zpow_ne_zero",
              "def_path": "Mathlib/Algebra/GroupWithZero/Units/Basic.lean",
              "def_pos": [
                435,
                7
              ],
              "def_end_pos": [
                435,
                19
              ]
            }
          ]
        ],
        "state_before": "p : \u2115\nhp : Fact (Nat.Prime p)\nq : \u211a\nhq : q \u2260 0\n\u22a2 \u2191p ^ (-padicValRat p q) \u2260 0",
        "state_after": "case a\np : \u2115\nhp : Fact (Nat.Prime p)\nq : \u211a\nhq : q \u2260 0\n\u22a2 \u2191p \u2260 0"
      },
      {
        "tactic": "exact mod_cast ne_of_gt hp.1.pos",
        "annotated_tactic": [
          "exact mod_cast <a>ne_of_gt</a> hp.1.<a>pos</a>",
          [
            {
              "full_name": "ne_of_gt",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                104,
                9
              ],
              "def_end_pos": [
                104,
                17
              ]
            },
            {
              "full_name": "Nat.Prime.pos",
              "def_path": "Mathlib/Data/Nat/Prime.lean",
              "def_pos": [
                65,
                9
              ],
              "def_end_pos": [
                65,
                18
              ]
            }
          ]
        ],
        "state_before": "case a\np : \u2115\nhp : Fact (Nat.Prime p)\nq : \u211a\nhq : q \u2260 0\n\u22a2 \u2191p \u2260 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8315114040160552,
    "entry_failed": false
  },
  "21905": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/Limits/Shapes/StrictInitial.lean",
    "full_name": "CategoryTheory.Limits.IsTerminal.strict_hom_ext",
    "start": [
      192,
      1
    ],
    "end": [
      195,
      54
    ],
    "traced_tactics": [
      {
        "tactic": "haveI := hI.isIso_from f",
        "annotated_tactic": [
          "haveI := hI.isIso_from f",
          []
        ],
        "state_before": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasStrictTerminalObjects C\nI : C\nhI : IsTerminal I\nA : C\nf g : I \u27f6 A\n\u22a2 f = g",
        "state_after": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasStrictTerminalObjects C\nI : C\nhI : IsTerminal I\nA : C\nf g : I \u27f6 A\nthis : IsIso f\n\u22a2 f = g"
      },
      {
        "tactic": "haveI := hI.isIso_from g",
        "annotated_tactic": [
          "haveI := hI.isIso_from g",
          []
        ],
        "state_before": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasStrictTerminalObjects C\nI : C\nhI : IsTerminal I\nA : C\nf g : I \u27f6 A\nthis : IsIso f\n\u22a2 f = g",
        "state_after": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasStrictTerminalObjects C\nI : C\nhI : IsTerminal I\nA : C\nf g : I \u27f6 A\nthis\u271d : IsIso f\nthis : IsIso g\n\u22a2 f = g"
      },
      {
        "tactic": "exact eq_of_inv_eq_inv (hI.hom_ext (inv f) (inv g))",
        "annotated_tactic": [
          "exact <a>eq_of_inv_eq_inv</a> (hI.hom_ext (<a>inv</a> f) (<a>inv</a> g))",
          [
            {
              "full_name": "CategoryTheory.eq_of_inv_eq_inv",
              "def_path": "Mathlib/CategoryTheory/Iso.lean",
              "def_pos": [
                490,
                9
              ],
              "def_end_pos": [
                490,
                25
              ]
            },
            {
              "full_name": "CategoryTheory.inv",
              "def_path": "Mathlib/CategoryTheory/Iso.lean",
              "def_pos": [
                279,
                19
              ],
              "def_end_pos": [
                279,
                22
              ]
            },
            {
              "full_name": "CategoryTheory.inv",
              "def_path": "Mathlib/CategoryTheory/Iso.lean",
              "def_pos": [
                279,
                19
              ],
              "def_end_pos": [
                279,
                22
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasStrictTerminalObjects C\nI : C\nhI : IsTerminal I\nA : C\nf g : I \u27f6 A\nthis\u271d : IsIso f\nthis : IsIso g\n\u22a2 f = g",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4362448719330132,
    "entry_failed": false
  },
  "21949": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Multiset/Sym.lean",
    "full_name": "Multiset.sym2_mono",
    "start": [
      63,
      1
    ],
    "end": [
      66,
      56
    ],
    "traced_tactics": [
      {
        "tactic": "refine Quotient.inductionOn\u2082 m m' (fun xs ys h => ?_) h",
        "annotated_tactic": [
          "refine <a>Quotient.inductionOn\u2082</a> m m' (fun xs ys h => ?_) h",
          [
            {
              "full_name": "Quotient.inductionOn\u2082",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1717,
                19
              ],
              "def_end_pos": [
                1717,
                31
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nm m' : Multiset \u03b1\nh : m \u2264 m'\n\u22a2 m.sym2 \u2264 m'.sym2",
        "state_after": "\u03b1 : Type u_1\nm m' : Multiset \u03b1\nh\u271d : m \u2264 m'\nxs ys : List \u03b1\nh : \u27e6xs\u27e7 \u2264 \u27e6ys\u27e7\n\u22a2 Multiset.sym2 \u27e6xs\u27e7 \u2264 Multiset.sym2 \u27e6ys\u27e7"
      },
      {
        "tactic": "suffices xs <+~ ys from this.sym2",
        "annotated_tactic": [
          "suffices xs <+~ ys from this.sym2",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nm m' : Multiset \u03b1\nh\u271d : m \u2264 m'\nxs ys : List \u03b1\nh : \u27e6xs\u27e7 \u2264 \u27e6ys\u27e7\n\u22a2 Multiset.sym2 \u27e6xs\u27e7 \u2264 Multiset.sym2 \u27e6ys\u27e7",
        "state_after": "\u03b1 : Type u_1\nm m' : Multiset \u03b1\nh\u271d : m \u2264 m'\nxs ys : List \u03b1\nh : \u27e6xs\u27e7 \u2264 \u27e6ys\u27e7\n\u22a2 xs <+~ ys"
      },
      {
        "tactic": "simpa only [quot_mk_to_coe, coe_le, sym2_coe] using h",
        "annotated_tactic": [
          "simpa only [<a>quot_mk_to_coe</a>, <a>coe_le</a>, <a>sym2_coe</a>] using h",
          [
            {
              "full_name": "Multiset.quot_mk_to_coe",
              "def_path": "Mathlib/Data/Multiset/Basic.lean",
              "def_pos": [
                46,
                9
              ],
              "def_end_pos": [
                46,
                23
              ]
            },
            {
              "full_name": "Multiset.coe_le",
              "def_path": "Mathlib/Data/Multiset/Basic.lean",
              "def_pos": [
                555,
                9
              ],
              "def_end_pos": [
                555,
                15
              ]
            },
            {
              "full_name": "Multiset.sym2_coe",
              "def_path": "Mathlib/Data/Multiset/Sym.lean",
              "def_pos": [
                44,
                17
              ],
              "def_end_pos": [
                44,
                25
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nm m' : Multiset \u03b1\nh\u271d : m \u2264 m'\nxs ys : List \u03b1\nh : \u27e6xs\u27e7 \u2264 \u27e6ys\u27e7\n\u22a2 xs <+~ ys",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.217138993088156,
    "entry_failed": false
  },
  "21965": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/SumTwoSquares.lean",
    "full_name": "ZMod.isSquare_neg_one_of_dvd",
    "start": [
      77,
      1
    ],
    "end": [
      81,
      17
    ],
    "traced_tactics": [
      {
        "tactic": "let f : ZMod n \u2192+* ZMod m := ZMod.castHom hd _",
        "annotated_tactic": [
          "let f : <a>ZMod</a> n \u2192+* <a>ZMod</a> m := <a>ZMod.castHom</a> hd _",
          [
            {
              "full_name": "ZMod",
              "def_path": "Mathlib/Data/ZMod/Defs.lean",
              "def_pos": [
                95,
                5
              ],
              "def_end_pos": [
                95,
                9
              ]
            },
            {
              "full_name": "ZMod",
              "def_path": "Mathlib/Data/ZMod/Defs.lean",
              "def_pos": [
                95,
                5
              ],
              "def_end_pos": [
                95,
                9
              ]
            },
            {
              "full_name": "ZMod.castHom",
              "def_path": "Mathlib/Data/ZMod/Basic.lean",
              "def_pos": [
                373,
                5
              ],
              "def_end_pos": [
                373,
                12
              ]
            }
          ]
        ],
        "state_before": "m n : \u2115\nhd : m \u2223 n\nhs : IsSquare (-1)\n\u22a2 IsSquare (-1)",
        "state_after": "m n : \u2115\nhd : m \u2223 n\nhs : IsSquare (-1)\nf : ZMod n \u2192+* ZMod m := castHom hd (ZMod m)\n\u22a2 IsSquare (-1)"
      },
      {
        "tactic": "rw [\u2190 RingHom.map_one f, \u2190 RingHom.map_neg]",
        "annotated_tactic": [
          "rw [\u2190 <a>RingHom.map_one</a> f, \u2190 <a>RingHom.map_neg</a>]",
          [
            {
              "full_name": "RingHom.map_one",
              "def_path": "Mathlib/Algebra/Ring/Hom/Defs.lean",
              "def_pos": [
                551,
                19
              ],
              "def_end_pos": [
                551,
                26
              ]
            },
            {
              "full_name": "RingHom.map_neg",
              "def_path": "Mathlib/Algebra/Ring/Hom/Defs.lean",
              "def_pos": [
                607,
                19
              ],
              "def_end_pos": [
                607,
                26
              ]
            }
          ]
        ],
        "state_before": "m n : \u2115\nhd : m \u2223 n\nhs : IsSquare (-1)\nf : ZMod n \u2192+* ZMod m := castHom hd (ZMod m)\n\u22a2 IsSquare (-1)",
        "state_after": "m n : \u2115\nhd : m \u2223 n\nhs : IsSquare (-1)\nf : ZMod n \u2192+* ZMod m := castHom hd (ZMod m)\n\u22a2 IsSquare (f (-1))"
      },
      {
        "tactic": "exact hs.map f",
        "annotated_tactic": [
          "exact hs.map f",
          []
        ],
        "state_before": "m n : \u2115\nhd : m \u2223 n\nhs : IsSquare (-1)\nf : ZMod n \u2192+* ZMod m := castHom hd (ZMod m)\n\u22a2 IsSquare (f (-1))",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.2448376449756324,
    "entry_failed": false
  },
  "21975": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/Quiver/Cast.lean",
    "full_name": "Quiver.Hom.cast_eq_cast",
    "start": [
      38,
      1
    ],
    "end": [
      41,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "rw [hu, hv]",
        "annotated_tactic": [
          "rw [hu, hv]",
          []
        ],
        "state_before": "U : Type u_1\ninst\u271d : Quiver U\nu v u' v' : U\nhu : u = u'\nhv : v = v'\ne : u \u27f6 v\n\u22a2 (u \u27f6 v) = (u' \u27f6 v')",
        "state_after": "no goals"
      },
      {
        "tactic": "subst_vars",
        "annotated_tactic": [
          "subst_vars",
          []
        ],
        "state_before": "U : Type u_1\ninst\u271d : Quiver U\nu v u' v' : U\nhu : u = u'\nhv : v = v'\ne : u \u27f6 v\n\u22a2 cast hu hv e = _root_.cast \u22ef e",
        "state_after": "U : Type u_1\ninst\u271d : Quiver U\nu' v' : U\ne : u' \u27f6 v'\n\u22a2 cast \u22ef \u22ef e = _root_.cast \u22ef e"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "U : Type u_1\ninst\u271d : Quiver U\nu' v' : U\ne : u' \u27f6 v'\n\u22a2 cast \u22ef \u22ef e = _root_.cast \u22ef e",
        "state_after": "no goals"
      }
    ],
    "entry_time": 0.9744811840355396,
    "entry_failed": false
  },
  "22000": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Nodup.lean",
    "full_name": "List.count_eq_of_nodup",
    "start": [
      212,
      1
    ],
    "end": [
      216,
      37
    ],
    "traced_tactics": [
      {
        "tactic": "split_ifs with h",
        "annotated_tactic": [
          "split_ifs with h",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nl\u271d l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na\u271d b : \u03b1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List \u03b1\nd : l.Nodup\n\u22a2 count a l = if a \u2208 l then 1 else 0",
        "state_after": "case pos\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na\u271d b : \u03b1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List \u03b1\nd : l.Nodup\nh : a \u2208 l\n\u22a2 count a l = 1\n\ncase neg\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na\u271d b : \u03b1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List \u03b1\nd : l.Nodup\nh : a \u2209 l\n\u22a2 count a l = 0"
      },
      {
        "tactic": "exact count_eq_one_of_mem d h",
        "annotated_tactic": [
          "exact <a>count_eq_one_of_mem</a> d h",
          [
            {
              "full_name": "List.count_eq_one_of_mem",
              "def_path": "Mathlib/Data/List/Nodup.lean",
              "def_pos": [
                207,
                9
              ],
              "def_end_pos": [
                207,
                28
              ]
            }
          ]
        ],
        "state_before": "case pos\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na\u271d b : \u03b1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List \u03b1\nd : l.Nodup\nh : a \u2208 l\n\u22a2 count a l = 1",
        "state_after": "no goals"
      },
      {
        "tactic": "exact count_eq_zero_of_not_mem h",
        "annotated_tactic": [
          "exact <a>count_eq_zero_of_not_mem</a> h",
          [
            {
              "full_name": "List.count_eq_zero_of_not_mem",
              "def_path": ".lake/packages/batteries/Batteries/Data/List/Count.lean",
              "def_pos": [
                170,
                21
              ],
              "def_end_pos": [
                170,
                45
              ]
            }
          ]
        ],
        "state_before": "case neg\n\u03b1 : Type u\n\u03b2 : Type v\nl\u271d l\u2081 l\u2082 : List \u03b1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na\u271d b : \u03b1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List \u03b1\nd : l.Nodup\nh : a \u2209 l\n\u22a2 count a l = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.173247955972329,
    "entry_failed": false
  },
  "22056": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Logic/Equiv/Fin.lean",
    "full_name": "finSuccEquiv'_last_apply",
    "start": [
      199,
      1
    ],
    "end": [
      203,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "rcases Fin.exists_castSucc_eq.2 h with \u27e8i, rfl\u27e9",
        "annotated_tactic": [
          "rcases <a>Fin.exists_castSucc_eq</a>.2 h with \u27e8i, rfl\u27e9",
          [
            {
              "full_name": "Fin.exists_castSucc_eq",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Fin/Lemmas.lean",
              "def_pos": [
                429,
                9
              ],
              "def_end_pos": [
                429,
                27
              ]
            }
          ]
        ],
        "state_before": "m n : \u2115\ni : Fin (n + 1)\nh : i \u2260 Fin.last n\n\u22a2 (finSuccEquiv' (Fin.last n)) i = some (i.castLT \u22ef)",
        "state_after": "case intro\nm n : \u2115\ni : Fin n\nh : i.castSucc \u2260 Fin.last n\n\u22a2 (finSuccEquiv' (Fin.last n)) i.castSucc = some (i.castSucc.castLT \u22ef)"
      },
      {
        "tactic": "rw [finSuccEquiv'_last_apply_castSucc]",
        "annotated_tactic": [
          "rw [<a>finSuccEquiv'_last_apply_castSucc</a>]",
          [
            {
              "full_name": "finSuccEquiv'_last_apply_castSucc",
              "def_path": "Mathlib/Logic/Equiv/Fin.lean",
              "def_pos": [
                195,
                9
              ],
              "def_end_pos": [
                195,
                42
              ]
            }
          ]
        ],
        "state_before": "case intro\nm n : \u2115\ni : Fin n\nh : i.castSucc \u2260 Fin.last n\n\u22a2 (finSuccEquiv' (Fin.last n)) i.castSucc = some (i.castSucc.castLT \u22ef)",
        "state_after": "case intro\nm n : \u2115\ni : Fin n\nh : i.castSucc \u2260 Fin.last n\n\u22a2 some i = some (i.castSucc.castLT \u22ef)"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case intro\nm n : \u2115\ni : Fin n\nh : i.castSucc \u2260 Fin.last n\n\u22a2 some i = some (i.castSucc.castLT \u22ef)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8986441829474643,
    "entry_failed": false
  },
  "22131": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/PNat/Factors.lean",
    "full_name": "PrimeMultiset.prod_ofNatList",
    "start": [
      195,
      1
    ],
    "end": [
      198,
      13
    ],
    "traced_tactics": [
      {
        "tactic": "have := prod_ofNatMultiset (l : Multiset \u2115) h",
        "annotated_tactic": [
          "have := <a>prod_ofNatMultiset</a> (l : <a>Multiset</a> \u2115) h",
          [
            {
              "full_name": "PrimeMultiset.prod_ofNatMultiset",
              "def_path": "Mathlib/Data/PNat/Factors.lean",
              "def_pos": [
                166,
                9
              ],
              "def_end_pos": [
                166,
                27
              ]
            },
            {
              "full_name": "Multiset",
              "def_path": "Mathlib/Data/Multiset/Basic.lean",
              "def_pos": [
                30,
                5
              ],
              "def_end_pos": [
                30,
                13
              ]
            }
          ]
        ],
        "state_before": "l : List \u2115\nh : \u2200 p \u2208 l, Nat.Prime p\n\u22a2 \u2191(ofNatList l h).prod = l.prod",
        "state_after": "l : List \u2115\nh : \u2200 p \u2208 l, Nat.Prime p\nthis : \u2191(ofNatMultiset (\u2191l) h).prod = (\u2191l).prod\n\u22a2 \u2191(ofNatList l h).prod = l.prod"
      },
      {
        "tactic": "rw [Multiset.prod_coe] at this",
        "annotated_tactic": [
          "rw [<a>Multiset.prod_coe</a>] at this",
          [
            {
              "full_name": "Multiset.prod_coe",
              "def_path": "Mathlib/Algebra/BigOperators/Group/Multiset.lean",
              "def_pos": [
                60,
                9
              ],
              "def_end_pos": [
                60,
                17
              ]
            }
          ]
        ],
        "state_before": "l : List \u2115\nh : \u2200 p \u2208 l, Nat.Prime p\nthis : \u2191(ofNatMultiset (\u2191l) h).prod = (\u2191l).prod\n\u22a2 \u2191(ofNatList l h).prod = l.prod",
        "state_after": "l : List \u2115\nh : \u2200 p \u2208 l, Nat.Prime p\nthis : \u2191(ofNatMultiset (\u2191l) h).prod = l.prod\n\u22a2 \u2191(ofNatList l h).prod = l.prod"
      },
      {
        "tactic": "exact this",
        "annotated_tactic": [
          "exact this",
          []
        ],
        "state_before": "l : List \u2115\nh : \u2200 p \u2208 l, Nat.Prime p\nthis : \u2191(ofNatMultiset (\u2191l) h).prod = l.prod\n\u22a2 \u2191(ofNatList l h).prod = l.prod",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9240662719821557,
    "entry_failed": false
  },
  "22216": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Group/AddChar.lean",
    "full_name": "AddChar.mulShift_mul",
    "start": [
      375,
      1
    ],
    "end": [
      378,
      64
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : Ring R\ninst\u271d : CommMonoid M\n\u03c8 : AddChar R M\nr s : R\n\u22a2 \u03c8.mulShift r * \u03c8.mulShift s = \u03c8.mulShift (r + s)",
        "state_after": "case h\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : Ring R\ninst\u271d : CommMonoid M\n\u03c8 : AddChar R M\nr s x\u271d : R\n\u22a2 (\u03c8.mulShift r * \u03c8.mulShift s) x\u271d = (\u03c8.mulShift (r + s)) x\u271d"
      },
      {
        "tactic": "rw [mulShift_apply, right_distrib, map_add_eq_mul]",
        "annotated_tactic": [
          "rw [<a>mulShift_apply</a>, <a>right_distrib</a>, <a>map_add_eq_mul</a>]",
          [
            {
              "full_name": "AddChar.mulShift_apply",
              "def_path": "Mathlib/Algebra/Group/AddChar.lean",
              "def_pos": [
                353,
                15
              ],
              "def_end_pos": [
                353,
                29
              ]
            },
            {
              "full_name": "right_distrib",
              "def_path": "Mathlib/Algebra/Ring/Defs.lean",
              "def_pos": [
                86,
                9
              ],
              "def_end_pos": [
                86,
                22
              ]
            },
            {
              "full_name": "AddChar.map_add_eq_mul",
              "def_path": "Mathlib/Algebra/Group/AddChar.lean",
              "def_pos": [
                100,
                7
              ],
              "def_end_pos": [
                100,
                21
              ]
            }
          ]
        ],
        "state_before": "case h\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : Ring R\ninst\u271d : CommMonoid M\n\u03c8 : AddChar R M\nr s x\u271d : R\n\u22a2 (\u03c8.mulShift r * \u03c8.mulShift s) x\u271d = (\u03c8.mulShift (r + s)) x\u271d",
        "state_after": "case h\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : Ring R\ninst\u271d : CommMonoid M\n\u03c8 : AddChar R M\nr s x\u271d : R\n\u22a2 (\u03c8.mulShift r * \u03c8.mulShift s) x\u271d = \u03c8 (r * x\u271d) * \u03c8 (s * x\u271d)"
      },
      {
        "tactic": "norm_cast",
        "annotated_tactic": [
          "norm_cast",
          []
        ],
        "state_before": "case h\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : Ring R\ninst\u271d : CommMonoid M\n\u03c8 : AddChar R M\nr s x\u271d : R\n\u22a2 (\u03c8.mulShift r * \u03c8.mulShift s) x\u271d = \u03c8 (r * x\u271d) * \u03c8 (s * x\u271d)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.364936826983467,
    "entry_failed": false
  },
  "22237": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Cast/Field.lean",
    "full_name": "Nat.one_div_le_one_div",
    "start": [
      70,
      1
    ],
    "end": [
      73,
      10
    ],
    "traced_tactics": [
      {
        "tactic": "refine one_div_le_one_div_of_le ?_ ?_",
        "annotated_tactic": [
          "refine <a>one_div_le_one_div_of_le</a> ?_ ?_",
          [
            {
              "full_name": "one_div_le_one_div_of_le",
              "def_path": "Mathlib/Algebra/Order/Field/Basic.lean",
              "def_pos": [
                392,
                9
              ],
              "def_end_pos": [
                392,
                33
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedSemifield \u03b1\nn m : \u2115\nh : n \u2264 m\n\u22a2 1 / (\u2191m + 1) \u2264 1 / (\u2191n + 1)",
        "state_after": "case refine_1\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedSemifield \u03b1\nn m : \u2115\nh : n \u2264 m\n\u22a2 0 < \u2191n + 1\n\ncase refine_2\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedSemifield \u03b1\nn m : \u2115\nh : n \u2264 m\n\u22a2 \u2191n + 1 \u2264 \u2191m + 1"
      },
      {
        "tactic": "exact Nat.cast_add_one_pos _",
        "annotated_tactic": [
          "exact <a>Nat.cast_add_one_pos</a> _",
          [
            {
              "full_name": "Nat.cast_add_one_pos",
              "def_path": "Mathlib/Data/Nat/Cast/Order.lean",
              "def_pos": [
                80,
                9
              ],
              "def_end_pos": [
                80,
                25
              ]
            }
          ]
        ],
        "state_before": "case refine_1\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedSemifield \u03b1\nn m : \u2115\nh : n \u2264 m\n\u22a2 0 < \u2191n + 1",
        "state_after": "no goals"
      },
      {
        "tactic": "simpa",
        "annotated_tactic": [
          "simpa",
          []
        ],
        "state_before": "case refine_2\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedSemifield \u03b1\nn m : \u2115\nh : n \u2264 m\n\u22a2 \u2191n + 1 \u2264 \u2191m + 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8271873249905184,
    "entry_failed": false
  },
  "22246": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/SuccPred/LinearLocallyFinite.lean",
    "full_name": "toZ_iterate_succ_le",
    "start": [
      234,
      1
    ],
    "end": [
      237,
      28
    ],
    "traced_tactics": [
      {
        "tactic": "rw [toZ_of_ge (le_succ_iterate _ _)]",
        "annotated_tactic": [
          "rw [<a>toZ_of_ge</a> (<a>le_succ_iterate</a> _ _)]",
          [
            {
              "full_name": "toZ_of_ge",
              "def_path": "Mathlib/Order/SuccPred/LinearLocallyFinite.lean",
              "def_pos": [
                195,
                9
              ],
              "def_end_pos": [
                195,
                18
              ]
            },
            {
              "full_name": "Order.le_succ_iterate",
              "def_path": "Mathlib/Order/SuccPred/Basic.lean",
              "def_pos": [
                301,
                9
              ],
              "def_end_pos": [
                301,
                24
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\ninst\u271d\u00b3 : LinearOrder \u03b9\ninst\u271d\u00b2 : SuccOrder \u03b9\ninst\u271d\u00b9 : IsSuccArchimedean \u03b9\ninst\u271d : PredOrder \u03b9\ni0 i : \u03b9\nn : \u2115\n\u22a2 toZ i0 (succ^[n] i0) \u2264 \u2191n",
        "state_after": "\u03b9 : Type u_1\ninst\u271d\u00b3 : LinearOrder \u03b9\ninst\u271d\u00b2 : SuccOrder \u03b9\ninst\u271d\u00b9 : IsSuccArchimedean \u03b9\ninst\u271d : PredOrder \u03b9\ni0 i : \u03b9\nn : \u2115\n\u22a2 \u2191(Nat.find \u22ef) \u2264 \u2191n"
      },
      {
        "tactic": "norm_cast",
        "annotated_tactic": [
          "norm_cast",
          []
        ],
        "state_before": "\u03b9 : Type u_1\ninst\u271d\u00b3 : LinearOrder \u03b9\ninst\u271d\u00b2 : SuccOrder \u03b9\ninst\u271d\u00b9 : IsSuccArchimedean \u03b9\ninst\u271d : PredOrder \u03b9\ni0 i : \u03b9\nn : \u2115\n\u22a2 \u2191(Nat.find \u22ef) \u2264 \u2191n",
        "state_after": "\u03b9 : Type u_1\ninst\u271d\u00b3 : LinearOrder \u03b9\ninst\u271d\u00b2 : SuccOrder \u03b9\ninst\u271d\u00b9 : IsSuccArchimedean \u03b9\ninst\u271d : PredOrder \u03b9\ni0 i : \u03b9\nn : \u2115\n\u22a2 Nat.find \u22ef \u2264 n"
      },
      {
        "tactic": "exact Nat.find_min' _ rfl",
        "annotated_tactic": [
          "exact <a>Nat.find_min'</a> _ <a>rfl</a>",
          [
            {
              "full_name": "Nat.find_min'",
              "def_path": "Mathlib/Init/Data/Nat/Lemmas.lean",
              "def_pos": [
                715,
                19
              ],
              "def_end_pos": [
                715,
                28
              ]
            },
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\ninst\u271d\u00b3 : LinearOrder \u03b9\ninst\u271d\u00b2 : SuccOrder \u03b9\ninst\u271d\u00b9 : IsSuccArchimedean \u03b9\ninst\u271d : PredOrder \u03b9\ni0 i : \u03b9\nn : \u2115\n\u22a2 Nat.find \u22ef \u2264 n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.039858371950686,
    "entry_failed": false
  },
  "22324": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/ModelTheory/FinitelyGenerated.lean",
    "full_name": "FirstOrder.Language.Structure.CG.map_of_surjective",
    "start": [
      240,
      1
    ],
    "end": [
      244,
      18
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 Hom.range_eq_top] at hs",
        "annotated_tactic": [
          "rw [\u2190 <a>Hom.range_eq_top</a>] at hs",
          [
            {
              "full_name": "FirstOrder.Language.Hom.range_eq_top",
              "def_path": "Mathlib/ModelTheory/Substructures.lean",
              "def_pos": [
                870,
                9
              ],
              "def_end_pos": [
                870,
                21
              ]
            }
          ]
        ],
        "state_before": "L : Language\nM : Type u_1\ninst\u271d\u00b9 : L.Structure M\nN : Type u_2\ninst\u271d : L.Structure N\nh : CG L M\nf : M \u2192[L] N\nhs : Function.Surjective \u21d1f\n\u22a2 CG L N",
        "state_after": "L : Language\nM : Type u_1\ninst\u271d\u00b9 : L.Structure M\nN : Type u_2\ninst\u271d : L.Structure N\nh : CG L M\nf : M \u2192[L] N\nhs : f.range = \u22a4\n\u22a2 CG L N"
      },
      {
        "tactic": "rw [cg_def, \u2190 hs]",
        "annotated_tactic": [
          "rw [<a>cg_def</a>, \u2190 hs]",
          [
            {
              "full_name": "FirstOrder.Language.Structure.cg_def",
              "def_path": "Mathlib/ModelTheory/FinitelyGenerated.lean",
              "def_pos": [
                226,
                9
              ],
              "def_end_pos": [
                226,
                15
              ]
            }
          ]
        ],
        "state_before": "L : Language\nM : Type u_1\ninst\u271d\u00b9 : L.Structure M\nN : Type u_2\ninst\u271d : L.Structure N\nh : CG L M\nf : M \u2192[L] N\nhs : f.range = \u22a4\n\u22a2 CG L N",
        "state_after": "L : Language\nM : Type u_1\ninst\u271d\u00b9 : L.Structure M\nN : Type u_2\ninst\u271d : L.Structure N\nh : CG L M\nf : M \u2192[L] N\nhs : f.range = \u22a4\n\u22a2 f.range.CG"
      },
      {
        "tactic": "exact h.range f",
        "annotated_tactic": [
          "exact h.range f",
          []
        ],
        "state_before": "L : Language\nM : Type u_1\ninst\u271d\u00b9 : L.Structure M\nN : Type u_2\ninst\u271d : L.Structure N\nh : CG L M\nf : M \u2192[L] N\nhs : f.range = \u22a4\n\u22a2 f.range.CG",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.1287317069945857,
    "entry_failed": false
  },
  "22355": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Set/Countable.lean",
    "full_name": "Set.Countable.exists_eq_range",
    "start": [
      157,
      1
    ],
    "end": [
      161,
      40
    ],
    "traced_tactics": [
      {
        "tactic": "rcases hc.exists_surjective hs with \u27e8f, hf\u27e9",
        "annotated_tactic": [
          "rcases hc.exists_surjective hs with \u27e8f, hf\u27e9",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ns : Set \u03b1\nhc : s.Countable\nhs : s.Nonempty\n\u22a2 \u2203 f, s = range f",
        "state_after": "case intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ns : Set \u03b1\nhc : s.Countable\nhs : s.Nonempty\nf : \u2115 \u2192 \u2191s\nhf : Surjective f\n\u22a2 \u2203 f, s = range f"
      },
      {
        "tactic": "refine \u27e8(\u2191) \u2218 f, ?_\u27e9",
        "annotated_tactic": [
          "refine \u27e8(\u2191) \u2218 f, ?_\u27e9",
          []
        ],
        "state_before": "case intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ns : Set \u03b1\nhc : s.Countable\nhs : s.Nonempty\nf : \u2115 \u2192 \u2191s\nhf : Surjective f\n\u22a2 \u2203 f, s = range f",
        "state_after": "case intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ns : Set \u03b1\nhc : s.Countable\nhs : s.Nonempty\nf : \u2115 \u2192 \u2191s\nhf : Surjective f\n\u22a2 s = range (Subtype.val \u2218 f)"
      },
      {
        "tactic": "rw [hf.range_comp, Subtype.range_coe]",
        "annotated_tactic": [
          "rw [hf.range_comp, <a>Subtype.range_coe</a>]",
          [
            {
              "full_name": "Subtype.range_coe",
              "def_path": "Mathlib/Data/Set/Image.lean",
              "def_pos": [
                1373,
                9
              ],
              "def_end_pos": [
                1373,
                18
              ]
            }
          ]
        ],
        "state_before": "case intro\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ns : Set \u03b1\nhc : s.Countable\nhs : s.Nonempty\nf : \u2115 \u2192 \u2191s\nhf : Surjective f\n\u22a2 s = range (Subtype.val \u2218 f)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5822772509418428,
    "entry_failed": false
  },
  "22389": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/FieldTheory/KummerExtension.lean",
    "full_name": "ne_zero_of_irreducible_X_pow_sub_C'",
    "start": [
      116,
      1
    ],
    "end": [
      120,
      33
    ],
    "traced_tactics": [
      {
        "tactic": "rintro rfl",
        "annotated_tactic": [
          "rintro rfl",
          []
        ],
        "state_before": "K : Type u\ninst\u271d : Field K\nn : \u2115\nhn : n \u2260 1\na : K\nH : Irreducible (X ^ n - C a)\n\u22a2 a \u2260 0",
        "state_after": "K : Type u\ninst\u271d : Field K\nn : \u2115\nhn : n \u2260 1\nH : Irreducible (X ^ n - C 0)\n\u22a2 False"
      },
      {
        "tactic": "rw [map_zero, sub_zero] at H",
        "annotated_tactic": [
          "rw [<a>map_zero</a>, <a>sub_zero</a>] at H",
          [
            {
              "full_name": "map_zero",
              "def_path": "Mathlib/Algebra/Group/Hom/Defs.lean",
              "def_pos": [
                203,
                3
              ],
              "def_end_pos": [
                203,
                14
              ]
            },
            {
              "full_name": "sub_zero",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                489,
                3
              ],
              "def_end_pos": [
                489,
                14
              ]
            }
          ]
        ],
        "state_before": "K : Type u\ninst\u271d : Field K\nn : \u2115\nhn : n \u2260 1\nH : Irreducible (X ^ n - C 0)\n\u22a2 False",
        "state_after": "K : Type u\ninst\u271d : Field K\nn : \u2115\nhn : n \u2260 1\nH : Irreducible (X ^ n)\n\u22a2 False"
      },
      {
        "tactic": "exact not_irreducible_pow hn H",
        "annotated_tactic": [
          "exact <a>not_irreducible_pow</a> hn H",
          [
            {
              "full_name": "not_irreducible_pow",
              "def_path": "Mathlib/Algebra/Associated.lean",
              "def_pos": [
                239,
                9
              ],
              "def_end_pos": [
                239,
                28
              ]
            }
          ]
        ],
        "state_before": "K : Type u\ninst\u271d : Field K\nn : \u2115\nhn : n \u2260 1\nH : Irreducible (X ^ n)\n\u22a2 False",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.693861584062688,
    "entry_failed": false
  },
  "22422": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/AlgebraicGeometry/Morphisms/FiniteType.lean",
    "full_name": "AlgebraicGeometry.locallyOfFiniteType_eq",
    "start": [
      43,
      1
    ],
    "end": [
      46,
      39
    ],
    "traced_tactics": [
      {
        "tactic": "ext X Y f",
        "annotated_tactic": [
          "ext X Y f",
          []
        ],
        "state_before": "X Y : Scheme\nf : X \u27f6 Y\n\u22a2 @LocallyOfFiniteType = affineLocally @RingHom.FiniteType",
        "state_after": "case h.h.h.a\nX\u271d Y\u271d : Scheme\nf\u271d : X\u271d \u27f6 Y\u271d\nX Y : Scheme\nf : X \u27f6 Y\n\u22a2 LocallyOfFiniteType f \u2194 affineLocally (@RingHom.FiniteType) f"
      },
      {
        "tactic": "rw [locallyOfFiniteType_iff, affineLocally_iff_affineOpens_le]",
        "annotated_tactic": [
          "rw [<a>locallyOfFiniteType_iff</a>, <a>affineLocally_iff_affineOpens_le</a>]",
          [
            {
              "full_name": "AlgebraicGeometry.locallyOfFiniteType_iff",
              "def_path": "Mathlib/AlgebraicGeometry/Morphisms/FiniteType.lean",
              "def_pos": [
                37,
                3
              ],
              "def_end_pos": [
                37,
                9
              ]
            },
            {
              "full_name": "AlgebraicGeometry.affineLocally_iff_affineOpens_le",
              "def_path": "Mathlib/AlgebraicGeometry/Morphisms/RingHomProperties.lean",
              "def_pos": [
                163,
                9
              ],
              "def_end_pos": [
                163,
                41
              ]
            }
          ]
        ],
        "state_before": "case h.h.h.a\nX\u271d Y\u271d : Scheme\nf\u271d : X\u271d \u27f6 Y\u271d\nX Y : Scheme\nf : X \u27f6 Y\n\u22a2 LocallyOfFiniteType f \u2194 affineLocally (@RingHom.FiniteType) f",
        "state_after": "case h.h.h.a.hP\nX\u271d Y\u271d : Scheme\nf\u271d : X\u271d \u27f6 Y\u271d\nX Y : Scheme\nf : X \u27f6 Y\n\u22a2 RingHom.RespectsIso @RingHom.FiniteType"
      },
      {
        "tactic": "exact RingHom.finiteType_respectsIso",
        "annotated_tactic": [
          "exact <a>RingHom.finiteType_respectsIso</a>",
          [
            {
              "full_name": "RingHom.finiteType_respectsIso",
              "def_path": "Mathlib/RingTheory/RingHom/FiniteType.lean",
              "def_pos": [
                100,
                9
              ],
              "def_end_pos": [
                100,
                31
              ]
            }
          ]
        ],
        "state_before": "case h.h.h.a.hP\nX\u271d Y\u271d : Scheme\nf\u271d : X\u271d \u27f6 Y\u271d\nX Y : Scheme\nf : X \u27f6 Y\n\u22a2 RingHom.RespectsIso @RingHom.FiniteType",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.974831001018174,
    "entry_failed": false
  },
  "22490": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Rat/Defs.lean",
    "full_name": "Rat.coe_int_num_of_den_eq_one",
    "start": [
      537,
      1
    ],
    "end": [
      540,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "conv_rhs => rw [\u2190 num_divInt_den q, hq]",
        "annotated_tactic": [
          "conv_rhs => rw [\u2190 <a>num_divInt_den</a> q, hq]",
          [
            {
              "full_name": "Rat.num_divInt_den",
              "def_path": "Mathlib/Data/Rat/Defs.lean",
              "def_pos": [
                146,
                7
              ],
              "def_end_pos": [
                146,
                21
              ]
            }
          ]
        ],
        "state_before": "q\u271d a b c q : \u211a\nhq : q.den = 1\n\u22a2 \u2191q.num = q",
        "state_after": "q\u271d a b c q : \u211a\nhq : q.den = 1\n\u22a2 \u2191q.num = q.num /. \u21911"
      },
      {
        "tactic": "rw [intCast_eq_divInt]",
        "annotated_tactic": [
          "rw [<a>intCast_eq_divInt</a>]",
          [
            {
              "full_name": "Rat.intCast_eq_divInt",
              "def_path": "Mathlib/Data/Rat/Defs.lean",
              "def_pos": [
                152,
                9
              ],
              "def_end_pos": [
                152,
                26
              ]
            }
          ]
        ],
        "state_before": "q\u271d a b c q : \u211a\nhq : q.den = 1\n\u22a2 \u2191q.num = q.num /. \u21911",
        "state_after": "q\u271d a b c q : \u211a\nhq : q.den = 1\n\u22a2 q.num /. 1 = q.num /. \u21911"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "q\u271d a b c q : \u211a\nhq : q.den = 1\n\u22a2 q.num /. 1 = q.num /. \u21911",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.0086894090054557,
    "entry_failed": false
  },
  "22517": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/Comma/Arrow.lean",
    "full_name": "CategoryTheory.Arrow.iso_w",
    "start": [
      171,
      1
    ],
    "end": [
      174,
      44
    ],
    "traced_tactics": [
      {
        "tactic": "have eq := Arrow.hom.congr_right e.inv_hom_id",
        "annotated_tactic": [
          "have eq := <a>Arrow.hom.congr_right</a> e.inv_hom_id",
          [
            {
              "full_name": "CategoryTheory.Arrow.hom.congr_right",
              "def_path": "Mathlib/CategoryTheory/Comma/Arrow.lean",
              "def_pos": [
                167,
                9
              ],
              "def_end_pos": [
                167,
                24
              ]
            }
          ]
        ],
        "state_before": "T : Type u\ninst\u271d : Category.{v, u} T\nf g : Arrow T\ne : f \u2245 g\n\u22a2 g.hom = e.inv.left \u226b f.hom \u226b e.hom.right",
        "state_after": "T : Type u\ninst\u271d : Category.{v, u} T\nf g : Arrow T\ne : f \u2245 g\neq : (e.inv \u226b e.hom).right = (\ud835\udfd9 g).right\n\u22a2 g.hom = e.inv.left \u226b f.hom \u226b e.hom.right"
      },
      {
        "tactic": "rw [Arrow.comp_right, Arrow.id_right] at eq",
        "annotated_tactic": [
          "rw [<a>Arrow.comp_right</a>, <a>Arrow.id_right</a>] at eq",
          [
            {
              "full_name": "CategoryTheory.Arrow.comp_right",
              "def_path": "Mathlib/CategoryTheory/Comma/Arrow.lean",
              "def_pos": [
                74,
                9
              ],
              "def_end_pos": [
                74,
                19
              ]
            },
            {
              "full_name": "CategoryTheory.Arrow.id_right",
              "def_path": "Mathlib/CategoryTheory/Comma/Arrow.lean",
              "def_pos": [
                63,
                9
              ],
              "def_end_pos": [
                63,
                17
              ]
            }
          ]
        ],
        "state_before": "T : Type u\ninst\u271d : Category.{v, u} T\nf g : Arrow T\ne : f \u2245 g\neq : (e.inv \u226b e.hom).right = (\ud835\udfd9 g).right\n\u22a2 g.hom = e.inv.left \u226b f.hom \u226b e.hom.right",
        "state_after": "T : Type u\ninst\u271d : Category.{v, u} T\nf g : Arrow T\ne : f \u2245 g\neq : e.inv.right \u226b e.hom.right = \ud835\udfd9 g.right\n\u22a2 g.hom = e.inv.left \u226b f.hom \u226b e.hom.right"
      },
      {
        "tactic": "erw [Arrow.w_assoc, eq, Category.comp_id]",
        "annotated_tactic": [
          "erw [<a>Arrow.w_assoc</a>, eq, <a>Category.comp_id</a>]",
          [
            {
              "full_name": "CategoryTheory.Arrow.w_assoc",
              "def_path": "Mathlib/CategoryTheory/Comma/Arrow.lean",
              "def_pos": [
                126,
                3
              ],
              "def_end_pos": [
                126,
                40
              ]
            },
            {
              "full_name": "CategoryTheory.Category.comp_id",
              "def_path": "Mathlib/CategoryTheory/Category/Basic.lean",
              "def_pos": [
                179,
                3
              ],
              "def_end_pos": [
                179,
                10
              ]
            }
          ]
        ],
        "state_before": "T : Type u\ninst\u271d : Category.{v, u} T\nf g : Arrow T\ne : f \u2245 g\neq : e.inv.right \u226b e.hom.right = \ud835\udfd9 g.right\n\u22a2 g.hom = e.inv.left \u226b f.hom \u226b e.hom.right",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.880225781002082,
    "entry_failed": false
  },
  "22606": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/ENNReal/Real.lean",
    "full_name": "ENNReal.toReal_mono'",
    "start": [
      87,
      1
    ],
    "end": [
      90,
      35
    ],
    "traced_tactics": [
      {
        "tactic": "rcases eq_or_ne a \u221e with rfl | ha",
        "annotated_tactic": [
          "rcases <a>eq_or_ne</a> a \u221e with rfl | ha",
          [
            {
              "full_name": "eq_or_ne",
              "def_path": "Mathlib/Logic/Basic.lean",
              "def_pos": [
                212,
                9
              ],
              "def_end_pos": [
                212,
                17
              ]
            }
          ]
        ],
        "state_before": "a b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nh : a \u2264 b\nht : b = \u22a4 \u2192 a = \u22a4\n\u22a2 a.toReal \u2264 b.toReal",
        "state_after": "case inl\nb c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nh : \u22a4 \u2264 b\nht : b = \u22a4 \u2192 \u22a4 = \u22a4\n\u22a2 \u22a4.toReal \u2264 b.toReal\n\ncase inr\na b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nh : a \u2264 b\nht : b = \u22a4 \u2192 a = \u22a4\nha : a \u2260 \u22a4\n\u22a2 a.toReal \u2264 b.toReal"
      },
      {
        "tactic": "exact toReal_nonneg",
        "annotated_tactic": [
          "exact <a>toReal_nonneg</a>",
          [
            {
              "full_name": "ENNReal.toReal_nonneg",
              "def_path": "Mathlib/Data/ENNReal/Basic.lean",
              "def_pos": [
                247,
                17
              ],
              "def_end_pos": [
                247,
                30
              ]
            }
          ]
        ],
        "state_before": "case inl\nb c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nh : \u22a4 \u2264 b\nht : b = \u22a4 \u2192 \u22a4 = \u22a4\n\u22a2 \u22a4.toReal \u2264 b.toReal",
        "state_after": "no goals"
      },
      {
        "tactic": "exact toReal_mono (mt ht ha) h",
        "annotated_tactic": [
          "exact <a>toReal_mono</a> (<a>mt</a> ht ha) h",
          [
            {
              "full_name": "ENNReal.toReal_mono",
              "def_path": "Mathlib/Data/ENNReal/Real.lean",
              "def_pos": [
                83,
                9
              ],
              "def_end_pos": [
                83,
                20
              ]
            },
            {
              "full_name": "mt",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                647,
                9
              ],
              "def_end_pos": [
                647,
                11
              ]
            }
          ]
        ],
        "state_before": "case inr\na b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nh : a \u2264 b\nht : b = \u22a4 \u2192 a = \u22a4\nha : a \u2260 \u22a4\n\u22a2 a.toReal \u2264 b.toReal",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.1762493059504777,
    "entry_failed": false
  },
  "22610": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Polynomial/Degree/TrailingDegree.lean",
    "full_name": "Polynomial.natTrailingDegree_le_natDegree",
    "start": [
      325,
      1
    ],
    "end": [
      328,
      67
    ],
    "traced_tactics": [
      {
        "tactic": "by_cases hp : p = 0",
        "annotated_tactic": [
          "by_cases hp : p = 0",
          []
        ],
        "state_before": "R : Type u\nS : Type v\na b : R\nn m : \u2115\ninst\u271d : Semiring R\np\u271d q r p : R[X]\n\u22a2 p.natTrailingDegree \u2264 p.natDegree",
        "state_after": "case pos\nR : Type u\nS : Type v\na b : R\nn m : \u2115\ninst\u271d : Semiring R\np\u271d q r p : R[X]\nhp : p = 0\n\u22a2 p.natTrailingDegree \u2264 p.natDegree\n\ncase neg\nR : Type u\nS : Type v\na b : R\nn m : \u2115\ninst\u271d : Semiring R\np\u271d q r p : R[X]\nhp : \u00acp = 0\n\u22a2 p.natTrailingDegree \u2264 p.natDegree"
      },
      {
        "tactic": "rw [hp, natDegree_zero, natTrailingDegree_zero]",
        "annotated_tactic": [
          "rw [hp, <a>natDegree_zero</a>, <a>natTrailingDegree_zero</a>]",
          [
            {
              "full_name": "Polynomial.natDegree_zero",
              "def_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
              "def_pos": [
                108,
                9
              ],
              "def_end_pos": [
                108,
                23
              ]
            },
            {
              "full_name": "Polynomial.natTrailingDegree_zero",
              "def_path": "Mathlib/Algebra/Polynomial/Degree/TrailingDegree.lean",
              "def_pos": [
                94,
                9
              ],
              "def_end_pos": [
                94,
                31
              ]
            }
          ]
        ],
        "state_before": "case pos\nR : Type u\nS : Type v\na b : R\nn m : \u2115\ninst\u271d : Semiring R\np\u271d q r p : R[X]\nhp : p = 0\n\u22a2 p.natTrailingDegree \u2264 p.natDegree",
        "state_after": "no goals"
      },
      {
        "tactic": "exact le_natDegree_of_ne_zero (mt trailingCoeff_eq_zero.mp hp)",
        "annotated_tactic": [
          "exact <a>le_natDegree_of_ne_zero</a> (<a>mt</a> trailingCoeff_eq_zero.mp hp)",
          [
            {
              "full_name": "Polynomial.le_natDegree_of_ne_zero",
              "def_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
              "def_pos": [
                180,
                9
              ],
              "def_end_pos": [
                180,
                32
              ]
            },
            {
              "full_name": "mt",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                647,
                9
              ],
              "def_end_pos": [
                647,
                11
              ]
            }
          ]
        ],
        "state_before": "case neg\nR : Type u\nS : Type v\na b : R\nn m : \u2115\ninst\u271d : Semiring R\np\u271d q r p : R[X]\nhp : \u00acp = 0\n\u22a2 p.natTrailingDegree \u2264 p.natDegree",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.845358861028217,
    "entry_failed": false
  },
  "22735": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/MetricSpace/Contracting.lean",
    "full_name": "ContractingWith.tendsto_iterate_fixedPoint",
    "start": [
      338,
      1
    ],
    "end": [
      342,
      30
    ],
    "traced_tactics": [
      {
        "tactic": "convert tendsto_iterate_efixedPoint hf (edist_ne_top x _)",
        "annotated_tactic": [
          "convert <a>tendsto_iterate_efixedPoint</a> hf (<a>edist_ne_top</a> x _)",
          [
            {
              "full_name": "ContractingWith.tendsto_iterate_efixedPoint",
              "def_path": "Mathlib/Topology/MetricSpace/Contracting.lean",
              "def_pos": [
                132,
                9
              ],
              "def_end_pos": [
                132,
                36
              ]
            },
            {
              "full_name": "edist_ne_top",
              "def_path": "Mathlib/Topology/MetricSpace/Pseudo/Defs.lean",
              "def_pos": [
                336,
                9
              ],
              "def_end_pos": [
                336,
                21
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : MetricSpace \u03b1\nK : \u211d\u22650\nf : \u03b1 \u2192 \u03b1\nhf : ContractingWith K f\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : CompleteSpace \u03b1\nx : \u03b1\n\u22a2 Tendsto (fun n => f^[n] x) atTop (\ud835\udcdd (fixedPoint f hf))",
        "state_after": "case h.e'_5.h.e'_3\n\u03b1 : Type u_1\ninst\u271d\u00b2 : MetricSpace \u03b1\nK : \u211d\u22650\nf : \u03b1 \u2192 \u03b1\nhf : ContractingWith K f\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : CompleteSpace \u03b1\nx : \u03b1\n\u22a2 fixedPoint f hf = efixedPoint f hf x \u22ef"
      },
      {
        "tactic": "refine (fixedPoint_unique _ ?_).symm",
        "annotated_tactic": [
          "refine (<a>fixedPoint_unique</a> _ ?_).<a>symm</a>",
          [
            {
              "full_name": "ContractingWith.fixedPoint_unique",
              "def_path": "Mathlib/Topology/MetricSpace/Contracting.lean",
              "def_pos": [
                317,
                9
              ],
              "def_end_pos": [
                317,
                26
              ]
            },
            {
              "full_name": "Eq.symm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                323,
                9
              ],
              "def_end_pos": [
                323,
                16
              ]
            }
          ]
        ],
        "state_before": "case h.e'_5.h.e'_3\n\u03b1 : Type u_1\ninst\u271d\u00b2 : MetricSpace \u03b1\nK : \u211d\u22650\nf : \u03b1 \u2192 \u03b1\nhf : ContractingWith K f\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : CompleteSpace \u03b1\nx : \u03b1\n\u22a2 fixedPoint f hf = efixedPoint f hf x \u22ef",
        "state_after": "case h.e'_5.h.e'_3\n\u03b1 : Type u_1\ninst\u271d\u00b2 : MetricSpace \u03b1\nK : \u211d\u22650\nf : \u03b1 \u2192 \u03b1\nhf : ContractingWith K f\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : CompleteSpace \u03b1\nx : \u03b1\n\u22a2 IsFixedPt f (efixedPoint f hf x \u22ef)"
      },
      {
        "tactic": "apply efixedPoint_isFixedPt",
        "annotated_tactic": [
          "apply <a>efixedPoint_isFixedPt</a>",
          [
            {
              "full_name": "ContractingWith.efixedPoint_isFixedPt",
              "def_path": "Mathlib/Topology/MetricSpace/Contracting.lean",
              "def_pos": [
                127,
                9
              ],
              "def_end_pos": [
                127,
                30
              ]
            }
          ]
        ],
        "state_before": "case h.e'_5.h.e'_3\n\u03b1 : Type u_1\ninst\u271d\u00b2 : MetricSpace \u03b1\nK : \u211d\u22650\nf : \u03b1 \u2192 \u03b1\nhf : ContractingWith K f\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : CompleteSpace \u03b1\nx : \u03b1\n\u22a2 IsFixedPt f (efixedPoint f hf x \u22ef)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.5991597160464153,
    "entry_failed": false
  },
  "22894": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Sheaves/SheafCondition/Sites.lean",
    "full_name": "OpenEmbedding.functor_isContinuous",
    "start": [
      180,
      1
    ],
    "end": [
      185,
      38
    ],
    "traced_tactics": [
      {
        "tactic": "apply Functor.isContinuous_of_coverPreserving",
        "annotated_tactic": [
          "apply <a>Functor.isContinuous_of_coverPreserving</a>",
          [
            {
              "full_name": "CategoryTheory.Functor.isContinuous_of_coverPreserving",
              "def_path": "Mathlib/CategoryTheory/Sites/CoverPreserving.lean",
              "def_pos": [
                220,
                7
              ],
              "def_end_pos": [
                220,
                46
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d : Category.{v, u} C\nX Y : TopCat\nf : X \u27f6 Y\nF : TopCat.Presheaf C Y\nh : OpenEmbedding \u21d1f\n\u22a2 \u22ef.functor.IsContinuous (Opens.grothendieckTopology \u2191X) (Opens.grothendieckTopology \u2191Y)",
        "state_after": "case hF\u2081\nC : Type u\ninst\u271d : Category.{v, u} C\nX Y : TopCat\nf : X \u27f6 Y\nF : TopCat.Presheaf C Y\nh : OpenEmbedding \u21d1f\n\u22a2 CompatiblePreserving (Opens.grothendieckTopology \u2191Y) \u22ef.functor\n\ncase hF\u2082\nC : Type u\ninst\u271d : Category.{v, u} C\nX Y : TopCat\nf : X \u27f6 Y\nF : TopCat.Presheaf C Y\nh : OpenEmbedding \u21d1f\n\u22a2 CoverPreserving (Opens.grothendieckTopology \u2191X) (Opens.grothendieckTopology \u2191Y) \u22ef.functor"
      },
      {
        "tactic": "exact h.compatiblePreserving",
        "annotated_tactic": [
          "exact h.compatiblePreserving",
          []
        ],
        "state_before": "case hF\u2081\nC : Type u\ninst\u271d : Category.{v, u} C\nX Y : TopCat\nf : X \u27f6 Y\nF : TopCat.Presheaf C Y\nh : OpenEmbedding \u21d1f\n\u22a2 CompatiblePreserving (Opens.grothendieckTopology \u2191Y) \u22ef.functor",
        "state_after": "no goals"
      },
      {
        "tactic": "exact h.isOpenMap.coverPreserving",
        "annotated_tactic": [
          "exact h.isOpenMap.coverPreserving",
          []
        ],
        "state_before": "case hF\u2082\nC : Type u\ninst\u271d : Category.{v, u} C\nX Y : TopCat\nf : X \u27f6 Y\nF : TopCat.Presheaf C Y\nh : OpenEmbedding \u21d1f\n\u22a2 CoverPreserving (Opens.grothendieckTopology \u2191X) (Opens.grothendieckTopology \u2191Y) \u22ef.functor",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.3729114499874413,
    "entry_failed": false
  },
  "23027": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/WittVector/Truncated.lean",
    "full_name": "TruncatedWittVector.coeff_out",
    "start": [
      114,
      1
    ],
    "end": [
      115,
      54
    ],
    "traced_tactics": [
      {
        "tactic": "rw [out]",
        "annotated_tactic": [
          "rw [<a>out</a>]",
          [
            {
              "full_name": "TruncatedWittVector.out",
              "def_path": "Mathlib/RingTheory/WittVector/Truncated.lean",
              "def_pos": [
                109,
                5
              ],
              "def_end_pos": [
                109,
                8
              ]
            }
          ]
        ],
        "state_before": "p : \u2115\nhp : Fact (Nat.Prime p)\nn : \u2115\nR : Type u_1\ninst\u271d : CommRing R\nx : TruncatedWittVector p n R\ni : Fin n\n\u22a2 x.out.coeff \u2191i = coeff i x",
        "state_after": "p : \u2115\nhp : Fact (Nat.Prime p)\nn : \u2115\nR : Type u_1\ninst\u271d : CommRing R\nx : TruncatedWittVector p n R\ni : Fin n\n\u22a2 { coeff := fun i => if h : i < n then coeff \u27e8i, h\u27e9 x else 0 }.coeff \u2191i = coeff i x"
      },
      {
        "tactic": "dsimp only",
        "annotated_tactic": [
          "dsimp only",
          []
        ],
        "state_before": "p : \u2115\nhp : Fact (Nat.Prime p)\nn : \u2115\nR : Type u_1\ninst\u271d : CommRing R\nx : TruncatedWittVector p n R\ni : Fin n\n\u22a2 { coeff := fun i => if h : i < n then coeff \u27e8i, h\u27e9 x else 0 }.coeff \u2191i = coeff i x",
        "state_after": "p : \u2115\nhp : Fact (Nat.Prime p)\nn : \u2115\nR : Type u_1\ninst\u271d : CommRing R\nx : TruncatedWittVector p n R\ni : Fin n\n\u22a2 (if h : \u2191i < n then coeff \u27e8\u2191i, h\u27e9 x else 0) = coeff i x"
      },
      {
        "tactic": "rw [dif_pos i.is_lt, Fin.eta]",
        "annotated_tactic": [
          "rw [<a>dif_pos</a> i.is_lt, <a>Fin.eta</a>]",
          [
            {
              "full_name": "dif_pos",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                949,
                9
              ],
              "def_end_pos": [
                949,
                16
              ]
            },
            {
              "full_name": "Fin.eta",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Fin/Lemmas.lean",
              "def_pos": [
                38,
                27
              ],
              "def_end_pos": [
                38,
                30
              ]
            }
          ]
        ],
        "state_before": "p : \u2115\nhp : Fact (Nat.Prime p)\nn : \u2115\nR : Type u_1\ninst\u271d : CommRing R\nx : TruncatedWittVector p n R\ni : Fin n\n\u22a2 (if h : \u2191i < n then coeff \u27e8\u2191i, h\u27e9 x else 0) = coeff i x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9722035260638222,
    "entry_failed": false
  },
  "23092": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Real/GoldenRatio.lean",
    "full_name": "gold_sq",
    "start": [
      91,
      1
    ],
    "end": [
      94,
      33
    ],
    "traced_tactics": [
      {
        "tactic": "rw [goldenRatio, \u2190 sub_eq_zero]",
        "annotated_tactic": [
          "rw [<a>goldenRatio</a>, \u2190 <a>sub_eq_zero</a>]",
          [
            {
              "full_name": "goldenRatio",
              "def_path": "Mathlib/Data/Real/GoldenRatio.lean",
              "def_pos": [
                32,
                8
              ],
              "def_end_pos": [
                32,
                19
              ]
            },
            {
              "full_name": "sub_eq_zero",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                1070,
                3
              ],
              "def_end_pos": [
                1070,
                14
              ]
            }
          ]
        ],
        "state_before": "\u22a2 \u03c6 ^ 2 = \u03c6 + 1",
        "state_after": "\u22a2 ((1 + \u221a5) / 2) ^ 2 - ((1 + \u221a5) / 2 + 1) = 0"
      },
      {
        "tactic": "ring_nf",
        "annotated_tactic": [
          "ring_nf",
          []
        ],
        "state_before": "\u22a2 ((1 + \u221a5) / 2) ^ 2 - ((1 + \u221a5) / 2 + 1) = 0",
        "state_after": "\u22a2 -5 / 4 + \u221a5 ^ 2 * (1 / 4) = 0"
      },
      {
        "tactic": "rw [Real.sq_sqrt] <;> norm_num",
        "annotated_tactic": [
          "rw [<a>Real.sq_sqrt</a>] <;> norm_num",
          [
            {
              "full_name": "Real.sq_sqrt",
              "def_path": "Mathlib/Data/Real/Sqrt.lean",
              "def_pos": [
                201,
                9
              ],
              "def_end_pos": [
                201,
                16
              ]
            }
          ]
        ],
        "state_before": "\u22a2 -5 / 4 + \u221a5 ^ 2 * (1 / 4) = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.31439579394646,
    "entry_failed": false
  },
  "23186": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Perm/Fin.lean",
    "full_name": "Fin.cycleRange_zero'",
    "start": [
      245,
      1
    ],
    "end": [
      248,
      26
    ],
    "traced_tactics": [
      {
        "tactic": "cases' n with n",
        "annotated_tactic": [
          "cases' n with n",
          []
        ],
        "state_before": "n : \u2115\nh : 0 < n\n\u22a2 \u27e80, h\u27e9.cycleRange = 1",
        "state_after": "case zero\nh : 0 < 0\n\u22a2 \u27e80, h\u27e9.cycleRange = 1\n\ncase succ\nn : \u2115\nh : 0 < n + 1\n\u22a2 \u27e80, h\u27e9.cycleRange = 1"
      },
      {
        "tactic": "exact cycleRange_zero n",
        "annotated_tactic": [
          "exact <a>cycleRange_zero</a> n",
          [
            {
              "full_name": "Fin.cycleRange_zero",
              "def_path": "Mathlib/GroupTheory/Perm/Fin.lean",
              "def_pos": [
                231,
                9
              ],
              "def_end_pos": [
                231,
                24
              ]
            }
          ]
        ],
        "state_before": "case succ\nn : \u2115\nh : 0 < n + 1\n\u22a2 \u27e80, h\u27e9.cycleRange = 1",
        "state_after": "no goals"
      },
      {
        "tactic": "cases h",
        "annotated_tactic": [
          "cases h",
          []
        ],
        "state_before": "case zero\nh : 0 < 0\n\u22a2 \u27e80, h\u27e9.cycleRange = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.09133170498535,
    "entry_failed": false
  },
  "23294": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Algebra/FilterBasis.lean",
    "full_name": "GroupFilterBasis.nhds_one_eq",
    "start": [
      188,
      1
    ],
    "end": [
      192,
      15
    ],
    "traced_tactics": [
      {
        "tactic": "rw [B.nhds_eq]",
        "annotated_tactic": [
          "rw [B.nhds_eq]",
          []
        ],
        "state_before": "G : Type u\ninst\u271d : Group G\nB\u271d B : GroupFilterBasis G\n\u22a2 \ud835\udcdd 1 = toFilterBasis.filter",
        "state_after": "G : Type u\ninst\u271d : Group G\nB\u271d B : GroupFilterBasis G\n\u22a2 B.N 1 = toFilterBasis.filter"
      },
      {
        "tactic": "simp only [N, one_mul]",
        "annotated_tactic": [
          "simp only [<a>N</a>, <a>one_mul</a>]",
          [
            {
              "full_name": "GroupFilterBasis.N",
              "def_path": "Mathlib/Topology/Algebra/FilterBasis.lean",
              "def_pos": [
                141,
                5
              ],
              "def_end_pos": [
                141,
                6
              ]
            },
            {
              "full_name": "one_mul",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                477,
                9
              ],
              "def_end_pos": [
                477,
                16
              ]
            }
          ]
        ],
        "state_before": "G : Type u\ninst\u271d : Group G\nB\u271d B : GroupFilterBasis G\n\u22a2 B.N 1 = toFilterBasis.filter",
        "state_after": "G : Type u\ninst\u271d : Group G\nB\u271d B : GroupFilterBasis G\n\u22a2 map (fun y => y) toFilterBasis.filter = toFilterBasis.filter"
      },
      {
        "tactic": "exact map_id",
        "annotated_tactic": [
          "exact <a>map_id</a>",
          [
            {
              "full_name": "Filter.map_id",
              "def_path": "Mathlib/Order/Filter/Basic.lean",
              "def_pos": [
                1961,
                9
              ],
              "def_end_pos": [
                1961,
                15
              ]
            }
          ]
        ],
        "state_before": "G : Type u\ninst\u271d : Group G\nB\u271d B : GroupFilterBasis G\n\u22a2 map (fun y => y) toFilterBasis.filter = toFilterBasis.filter",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.249165693996474,
    "entry_failed": false
  },
  "23296": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Sym/Sym2.lean",
    "full_name": "Sym2.fromRel_ne",
    "start": [
      524,
      1
    ],
    "end": [
      525,
      31
    ],
    "traced_tactics": [
      {
        "tactic": "ext z",
        "annotated_tactic": [
          "ext z",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ne : Sym2 \u03b1\nf : \u03b1 \u2192 \u03b2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 fromRel \u22ef = {z | \u00acz.IsDiag}",
        "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ne : Sym2 \u03b1\nf : \u03b1 \u2192 \u03b2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nz : Sym2 \u03b1\n\u22a2 z \u2208 fromRel \u22ef \u2194 z \u2208 {z | \u00acz.IsDiag}"
      },
      {
        "tactic": "exact z.ind (by simp)",
        "annotated_tactic": [
          "exact z.ind (by simp)",
          []
        ],
        "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ne : Sym2 \u03b1\nf : \u03b1 \u2192 \u03b2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nz : Sym2 \u03b1\n\u22a2 z \u2208 fromRel \u22ef \u2194 z \u2208 {z | \u00acz.IsDiag}",
        "state_after": "no goals"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ne : Sym2 \u03b1\nf : \u03b1 \u2192 \u03b2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nz : Sym2 \u03b1\n\u22a2 \u2200 (x y : \u03b1), s(x, y) \u2208 fromRel \u22ef \u2194 s(x, y) \u2208 {z | \u00acz.IsDiag}",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.1912120110355318,
    "entry_failed": false
  },
  "23344": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/LinearAlgebra/Matrix/ZPow.lean",
    "full_name": "Matrix.zpow_neg_natCast",
    "start": [
      112,
      1
    ],
    "end": [
      115,
      37
    ],
    "traced_tactics": [
      {
        "tactic": "cases n",
        "annotated_tactic": [
          "cases n",
          []
        ],
        "state_before": "n' : Type u_1\ninst\u271d\u00b2 : DecidableEq n'\ninst\u271d\u00b9 : Fintype n'\nR : Type u_2\ninst\u271d : CommRing R\nA : M\nn : \u2115\n\u22a2 A ^ (-\u2191n) = (A ^ n)\u207b\u00b9",
        "state_after": "case zero\nn' : Type u_1\ninst\u271d\u00b2 : DecidableEq n'\ninst\u271d\u00b9 : Fintype n'\nR : Type u_2\ninst\u271d : CommRing R\nA : M\n\u22a2 A ^ (-\u21910) = (A ^ 0)\u207b\u00b9\n\ncase succ\nn' : Type u_1\ninst\u271d\u00b2 : DecidableEq n'\ninst\u271d\u00b9 : Fintype n'\nR : Type u_2\ninst\u271d : CommRing R\nA : M\nn\u271d : \u2115\n\u22a2 A ^ (-\u2191(n\u271d + 1)) = (A ^ (n\u271d + 1))\u207b\u00b9"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case zero\nn' : Type u_1\ninst\u271d\u00b2 : DecidableEq n'\ninst\u271d\u00b9 : Fintype n'\nR : Type u_2\ninst\u271d : CommRing R\nA : M\n\u22a2 A ^ (-\u21910) = (A ^ 0)\u207b\u00b9",
        "state_after": "no goals"
      },
      {
        "tactic": "exact DivInvMonoid.zpow_neg' _ _",
        "annotated_tactic": [
          "exact <a>DivInvMonoid.zpow_neg'</a> _ _",
          [
            {
              "full_name": "DivInvMonoid.zpow_neg'",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                948,
                13
              ],
              "def_end_pos": [
                948,
                22
              ]
            }
          ]
        ],
        "state_before": "case succ\nn' : Type u_1\ninst\u271d\u00b2 : DecidableEq n'\ninst\u271d\u00b9 : Fintype n'\nR : Type u_2\ninst\u271d : CommRing R\nA : M\nn\u271d : \u2115\n\u22a2 A ^ (-\u2191(n\u271d + 1)) = (A ^ (n\u271d + 1))\u207b\u00b9",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.003563724923879,
    "entry_failed": false
  },
  "23354": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Int/ModEq.lean",
    "full_name": "Int.natCast_modEq_iff",
    "start": [
      77,
      1
    ],
    "end": [
      78,
      67
    ],
    "traced_tactics": [
      {
        "tactic": "unfold ModEq Nat.ModEq",
        "annotated_tactic": [
          "unfold <a>ModEq</a> <a>Nat.ModEq</a>",
          [
            {
              "full_name": "Int.ModEq",
              "def_path": "Mathlib/Data/Int/ModEq.lean",
              "def_pos": [
                30,
                5
              ],
              "def_end_pos": [
                30,
                10
              ]
            },
            {
              "full_name": "Nat.ModEq",
              "def_path": "Mathlib/Data/Nat/ModEq.lean",
              "def_pos": [
                34,
                5
              ],
              "def_end_pos": [
                34,
                10
              ]
            }
          ]
        ],
        "state_before": "m n\u271d a\u271d b\u271d c d : \u2124\na b n : \u2115\n\u22a2 \u2191a \u2261 \u2191b [ZMOD \u2191n] \u2194 a \u2261 b [MOD n]",
        "state_after": "m n\u271d a\u271d b\u271d c d : \u2124\na b n : \u2115\n\u22a2 \u2191a % \u2191n = \u2191b % \u2191n \u2194 a % n = b % n"
      },
      {
        "tactic": "rw [\u2190 Int.ofNat_inj]",
        "annotated_tactic": [
          "rw [\u2190 <a>Int.ofNat_inj</a>]",
          [
            {
              "full_name": "Int.ofNat_inj",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Lemmas.lean",
              "def_pos": [
                56,
                22
              ],
              "def_end_pos": [
                56,
                31
              ]
            }
          ]
        ],
        "state_before": "m n\u271d a\u271d b\u271d c d : \u2124\na b n : \u2115\n\u22a2 \u2191a % \u2191n = \u2191b % \u2191n \u2194 a % n = b % n",
        "state_after": "m n\u271d a\u271d b\u271d c d : \u2124\na b n : \u2115\n\u22a2 \u2191a % \u2191n = \u2191b % \u2191n \u2194 \u2191(a % n) = \u2191(b % n)"
      },
      {
        "tactic": "simp [natCast_mod]",
        "annotated_tactic": [
          "simp [<a>natCast_mod</a>]",
          [
            {
              "full_name": "Int.natCast_mod",
              "def_path": "Mathlib/Data/Int/Defs.lean",
              "def_pos": [
                527,
                26
              ],
              "def_end_pos": [
                527,
                37
              ]
            }
          ]
        ],
        "state_before": "m n\u271d a\u271d b\u271d c d : \u2124\na b n : \u2115\n\u22a2 \u2191a % \u2191n = \u2191b % \u2191n \u2194 \u2191(a % n) = \u2191(b % n)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.3557338170940056,
    "entry_failed": false
  },
  "23364": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Indexes.lean",
    "full_name": "List.length_mapIdx",
    "start": [
      198,
      1
    ],
    "end": [
      201,
      14
    ],
    "traced_tactics": [
      {
        "tactic": "induction' l with hd tl IH generalizing f",
        "annotated_tactic": [
          "induction' l with hd tl IH generalizing f",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nl : List \u03b1\nf : \u2115 \u2192 \u03b1 \u2192 \u03b2\n\u22a2 (mapIdx f l).length = l.length",
        "state_after": "case nil\n\u03b1 : Type u\n\u03b2 : Type v\nf : \u2115 \u2192 \u03b1 \u2192 \u03b2\n\u22a2 (mapIdx f []).length = [].length\n\ncase cons\n\u03b1 : Type u\n\u03b2 : Type v\nhd : \u03b1\ntl : List \u03b1\nIH : \u2200 (f : \u2115 \u2192 \u03b1 \u2192 \u03b2), (mapIdx f tl).length = tl.length\nf : \u2115 \u2192 \u03b1 \u2192 \u03b2\n\u22a2 (mapIdx f (hd :: tl)).length = (hd :: tl).length"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case nil\n\u03b1 : Type u\n\u03b2 : Type v\nf : \u2115 \u2192 \u03b1 \u2192 \u03b2\n\u22a2 (mapIdx f []).length = [].length",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [IH]",
        "annotated_tactic": [
          "simp [IH]",
          []
        ],
        "state_before": "case cons\n\u03b1 : Type u\n\u03b2 : Type v\nhd : \u03b1\ntl : List \u03b1\nIH : \u2200 (f : \u2115 \u2192 \u03b1 \u2192 \u03b2), (mapIdx f tl).length = tl.length\nf : \u2115 \u2192 \u03b1 \u2192 \u03b2\n\u22a2 (mapIdx f (hd :: tl)).length = (hd :: tl).length",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6942792140180245,
    "entry_failed": false
  },
  "23367": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/Asymptotics/SpecificAsymptotics.lean",
    "full_name": "tendsto_pow_div_pow_atTop_zero",
    "start": [
      63,
      1
    ],
    "end": [
      67,
      8
    ],
    "traced_tactics": [
      {
        "tactic": "rw [tendsto_congr' pow_div_pow_eventuallyEq_atTop]",
        "annotated_tactic": [
          "rw [<a>tendsto_congr'</a> <a>pow_div_pow_eventuallyEq_atTop</a>]",
          [
            {
              "full_name": "Filter.tendsto_congr'",
              "def_path": "Mathlib/Order/Filter/Basic.lean",
              "def_pos": [
                3071,
                9
              ],
              "def_end_pos": [
                3071,
                23
              ]
            },
            {
              "full_name": "pow_div_pow_eventuallyEq_atTop",
              "def_path": "Mathlib/Analysis/Asymptotics/SpecificAsymptotics.lean",
              "def_pos": [
                42,
                9
              ],
              "def_end_pos": [
                42,
                39
              ]
            }
          ]
        ],
        "state_before": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \ud835\udd5c\ninst\u271d\u00b9 : TopologicalSpace \ud835\udd5c\ninst\u271d : OrderTopology \ud835\udd5c\np q : \u2115\nhpq : p < q\n\u22a2 Tendsto (fun x => x ^ p / x ^ q) atTop (\ud835\udcdd 0)",
        "state_after": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \ud835\udd5c\ninst\u271d\u00b9 : TopologicalSpace \ud835\udd5c\ninst\u271d : OrderTopology \ud835\udd5c\np q : \u2115\nhpq : p < q\n\u22a2 Tendsto (fun x => x ^ (\u2191p - \u2191q)) atTop (\ud835\udcdd 0)"
      },
      {
        "tactic": "apply tendsto_zpow_atTop_zero",
        "annotated_tactic": [
          "apply <a>tendsto_zpow_atTop_zero</a>",
          [
            {
              "full_name": "tendsto_zpow_atTop_zero",
              "def_path": "Mathlib/Topology/Algebra/Order/Field.lean",
              "def_pos": [
                165,
                9
              ],
              "def_end_pos": [
                165,
                32
              ]
            }
          ]
        ],
        "state_before": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \ud835\udd5c\ninst\u271d\u00b9 : TopologicalSpace \ud835\udd5c\ninst\u271d : OrderTopology \ud835\udd5c\np q : \u2115\nhpq : p < q\n\u22a2 Tendsto (fun x => x ^ (\u2191p - \u2191q)) atTop (\ud835\udcdd 0)",
        "state_after": "case hn\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \ud835\udd5c\ninst\u271d\u00b9 : TopologicalSpace \ud835\udd5c\ninst\u271d : OrderTopology \ud835\udd5c\np q : \u2115\nhpq : p < q\n\u22a2 \u2191p - \u2191q < 0"
      },
      {
        "tactic": "omega",
        "annotated_tactic": [
          "omega",
          []
        ],
        "state_before": "case hn\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : LinearOrderedField \ud835\udd5c\ninst\u271d\u00b9 : TopologicalSpace \ud835\udd5c\ninst\u271d : OrderTopology \ud835\udd5c\np q : \u2115\nhpq : p < q\n\u22a2 \u2191p - \u2191q < 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.909416459966451,
    "entry_failed": false
  },
  "23386": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/PrimeIdeal.lean",
    "full_name": "Order.Ideal.IsPrime.mem_or_compl_mem",
    "start": [
      176,
      1
    ],
    "end": [
      179,
      18
    ],
    "traced_tactics": [
      {
        "tactic": "apply hI.mem_or_mem",
        "annotated_tactic": [
          "apply hI.mem_or_mem",
          []
        ],
        "state_before": "P : Type u_1\ninst\u271d : BooleanAlgebra P\nx : P\nI : Ideal P\nhI : I.IsPrime\n\u22a2 x \u2208 I \u2228 x\u1d9c \u2208 I",
        "state_after": "P : Type u_1\ninst\u271d : BooleanAlgebra P\nx : P\nI : Ideal P\nhI : I.IsPrime\n\u22a2 x \u2293 x\u1d9c \u2208 I"
      },
      {
        "tactic": "rw [inf_compl_eq_bot]",
        "annotated_tactic": [
          "rw [<a>inf_compl_eq_bot</a>]",
          [
            {
              "full_name": "inf_compl_eq_bot",
              "def_path": "Mathlib/Order/Heyting/Basic.lean",
              "def_pos": [
                819,
                9
              ],
              "def_end_pos": [
                819,
                25
              ]
            }
          ]
        ],
        "state_before": "P : Type u_1\ninst\u271d : BooleanAlgebra P\nx : P\nI : Ideal P\nhI : I.IsPrime\n\u22a2 x \u2293 x\u1d9c \u2208 I",
        "state_after": "P : Type u_1\ninst\u271d : BooleanAlgebra P\nx : P\nI : Ideal P\nhI : I.IsPrime\n\u22a2 \u22a5 \u2208 I"
      },
      {
        "tactic": "exact I.bot_mem",
        "annotated_tactic": [
          "exact I.bot_mem",
          []
        ],
        "state_before": "P : Type u_1\ninst\u271d : BooleanAlgebra P\nx : P\nI : Ideal P\nhI : I.IsPrime\n\u22a2 \u22a5 \u2208 I",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4357958399923518,
    "entry_failed": false
  },
  "23428": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Connected/PathConnected.lean",
    "full_name": "Path.symm_symm",
    "start": [
      178,
      1
    ],
    "end": [
      181,
      30
    ],
    "traced_tactics": [
      {
        "tactic": "ext t",
        "annotated_tactic": [
          "ext t",
          []
        ],
        "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y z : X\n\u03b9 : Type u_3\n\u03b3\u271d \u03b3 : Path x y\n\u22a2 \u03b3.symm.symm = \u03b3",
        "state_after": "case a.h\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y z : X\n\u03b9 : Type u_3\n\u03b3\u271d \u03b3 : Path x y\nt : \u2191I\n\u22a2 \u03b3.symm.symm t = \u03b3 t"
      },
      {
        "tactic": "show \u03b3 (\u03c3 (\u03c3 t)) = \u03b3 t",
        "annotated_tactic": [
          "show \u03b3 (\u03c3 (\u03c3 t)) = \u03b3 t",
          []
        ],
        "state_before": "case a.h\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y z : X\n\u03b9 : Type u_3\n\u03b3\u271d \u03b3 : Path x y\nt : \u2191I\n\u22a2 \u03b3.symm.symm t = \u03b3 t",
        "state_after": "case a.h\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y z : X\n\u03b9 : Type u_3\n\u03b3\u271d \u03b3 : Path x y\nt : \u2191I\n\u22a2 \u03b3 (\u03c3 (\u03c3 t)) = \u03b3 t"
      },
      {
        "tactic": "rw [unitInterval.symm_symm]",
        "annotated_tactic": [
          "rw [<a>unitInterval.symm_symm</a>]",
          [
            {
              "full_name": "unitInterval.symm_symm",
              "def_path": "Mathlib/Topology/UnitInterval.lean",
              "def_pos": [
                122,
                9
              ],
              "def_end_pos": [
                122,
                18
              ]
            }
          ]
        ],
        "state_before": "case a.h\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y z : X\n\u03b9 : Type u_3\n\u03b3\u271d \u03b3 : Path x y\nt : \u2191I\n\u22a2 \u03b3 (\u03c3 (\u03c3 t)) = \u03b3 t",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.8990218320395797,
    "entry_failed": false
  },
  "23447": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/CharP/ExpChar.lean",
    "full_name": "expChar_is_prime_or_one",
    "start": [
      141,
      1
    ],
    "end": [
      144,
      30
    ],
    "traced_tactics": [
      {
        "tactic": "cases hq with\n| zero => exact .inr rfl\n| prime hp => exact .inl hp",
        "annotated_tactic": [
          "cases hq with\n  | <a>zero</a> => exact .inr <a>rfl</a>\n  | <a>prime</a> hp => exact .inl hp",
          [
            {
              "full_name": "ExpChar.zero",
              "def_path": "Mathlib/Algebra/CharP/ExpChar.lean",
              "def_pos": [
                44,
                5
              ],
              "def_end_pos": [
                44,
                9
              ]
            },
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            },
            {
              "full_name": "ExpChar.prime",
              "def_path": "Mathlib/Algebra/CharP/ExpChar.lean",
              "def_pos": [
                45,
                5
              ],
              "def_end_pos": [
                45,
                10
              ]
            }
          ]
        ],
        "state_before": "R : Type u\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : NoZeroDivisors R\nq : \u2115\nhq : ExpChar R q\n\u22a2 Nat.Prime q \u2228 q = 1",
        "state_after": "no goals"
      },
      {
        "tactic": "exact .inr rfl",
        "annotated_tactic": [
          "exact .inr <a>rfl</a>",
          [
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "case zero\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : CharZero R\n\u22a2 Nat.Prime 1 \u2228 1 = 1",
        "state_after": "no goals"
      },
      {
        "tactic": "exact .inl hp",
        "annotated_tactic": [
          "exact .inl hp",
          []
        ],
        "state_before": "case prime\nR : Type u\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : NoZeroDivisors R\nq : \u2115\nhp : Nat.Prime q\nhchar\u271d : CharP R q\n\u22a2 Nat.Prime q \u2228 q = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.971964480006136,
    "entry_failed": false
  },
  "23458": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean",
    "full_name": "jacobiSym.list_prod_left",
    "start": [
      259,
      1
    ],
    "end": [
      262,
      64
    ],
    "traced_tactics": [
      {
        "tactic": "induction' l with n l' ih",
        "annotated_tactic": [
          "induction' l with n l' ih",
          []
        ],
        "state_before": "l : List \u2124\nn : \u2115\n\u22a2 J(l.prod | n) = (List.map (fun a => J(a | n)) l).prod",
        "state_after": "case nil\nn : \u2115\n\u22a2 J([].prod | n) = (List.map (fun a => J(a | n)) []).prod\n\ncase cons\nn\u271d : \u2115\nn : \u2124\nl' : List \u2124\nih : J(l'.prod | n\u271d) = (List.map (fun a => J(a | n\u271d)) l').prod\n\u22a2 J((n :: l').prod | n\u271d) = (List.map (fun a => J(a | n\u271d)) (n :: l')).prod"
      },
      {
        "tactic": "simp only [List.prod_nil, List.map_nil, one_left]",
        "annotated_tactic": [
          "simp only [<a>List.prod_nil</a>, <a>List.map_nil</a>, <a>one_left</a>]",
          [
            {
              "full_name": "List.prod_nil",
              "def_path": "Mathlib/Algebra/BigOperators/Group/List.lean",
              "def_pos": [
                66,
                9
              ],
              "def_end_pos": [
                66,
                17
              ]
            },
            {
              "full_name": "List.map_nil",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean",
              "def_pos": [
                365,
                17
              ],
              "def_end_pos": [
                365,
                24
              ]
            },
            {
              "full_name": "jacobiSym.one_left",
              "def_path": "Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean",
              "def_pos": [
                149,
                9
              ],
              "def_end_pos": [
                149,
                17
              ]
            }
          ]
        ],
        "state_before": "case nil\nn : \u2115\n\u22a2 J([].prod | n) = (List.map (fun a => J(a | n)) []).prod",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [List.map, List.prod_cons, List.prod_cons, mul_left, ih]",
        "annotated_tactic": [
          "rw [<a>List.map</a>, <a>List.prod_cons</a>, <a>List.prod_cons</a>, <a>mul_left</a>, ih]",
          [
            {
              "full_name": "List.map",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean",
              "def_pos": [
                361,
                19
              ],
              "def_end_pos": [
                361,
                22
              ]
            },
            {
              "full_name": "List.prod_cons",
              "def_path": "Mathlib/Algebra/BigOperators/Group/List.lean",
              "def_pos": [
                95,
                9
              ],
              "def_end_pos": [
                95,
                18
              ]
            },
            {
              "full_name": "List.prod_cons",
              "def_path": "Mathlib/Algebra/BigOperators/Group/List.lean",
              "def_pos": [
                95,
                9
              ],
              "def_end_pos": [
                95,
                18
              ]
            },
            {
              "full_name": "jacobiSym.mul_left",
              "def_path": "Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean",
              "def_pos": [
                159,
                9
              ],
              "def_end_pos": [
                159,
                17
              ]
            }
          ]
        ],
        "state_before": "case cons\nn\u271d : \u2115\nn : \u2124\nl' : List \u2124\nih : J(l'.prod | n\u271d) = (List.map (fun a => J(a | n\u271d)) l').prod\n\u22a2 J((n :: l').prod | n\u271d) = (List.map (fun a => J(a | n\u271d)) (n :: l')).prod",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.223194140009582,
    "entry_failed": false
  },
  "23486": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Nilpotent/Defs.lean",
    "full_name": "Commute.isNilpotent_mul_left",
    "start": [
      229,
      1
    ],
    "end": [
      232,
      36
    ],
    "traced_tactics": [
      {
        "tactic": "obtain \u27e8n, hn\u27e9 := h",
        "annotated_tactic": [
          "obtain \u27e8n, hn\u27e9 := h",
          []
        ],
        "state_before": "R : Type u_1\nS : Type u_2\nx y : R\ninst\u271d : Semiring R\nh_comm : Commute x y\nh : IsNilpotent x\n\u22a2 IsNilpotent (x * y)",
        "state_after": "case intro\nR : Type u_1\nS : Type u_2\nx y : R\ninst\u271d : Semiring R\nh_comm : Commute x y\nn : \u2115\nhn : x ^ n = 0\n\u22a2 IsNilpotent (x * y)"
      },
      {
        "tactic": "use n",
        "annotated_tactic": [
          "use n",
          []
        ],
        "state_before": "case intro\nR : Type u_1\nS : Type u_2\nx y : R\ninst\u271d : Semiring R\nh_comm : Commute x y\nn : \u2115\nhn : x ^ n = 0\n\u22a2 IsNilpotent (x * y)",
        "state_after": "case h\nR : Type u_1\nS : Type u_2\nx y : R\ninst\u271d : Semiring R\nh_comm : Commute x y\nn : \u2115\nhn : x ^ n = 0\n\u22a2 (x * y) ^ n = 0"
      },
      {
        "tactic": "rw [h_comm.mul_pow, hn, zero_mul]",
        "annotated_tactic": [
          "rw [h_comm.mul_pow, hn, <a>zero_mul</a>]",
          [
            {
              "full_name": "MulZeroClass.zero_mul",
              "def_path": "Mathlib/Algebra/GroupWithZero/Defs.lean",
              "def_pos": [
                37,
                3
              ],
              "def_end_pos": [
                37,
                11
              ]
            }
          ]
        ],
        "state_before": "case h\nR : Type u_1\nS : Type u_2\nx y : R\ninst\u271d : Semiring R\nh_comm : Commute x y\nn : \u2115\nhn : x ^ n = 0\n\u22a2 (x * y) ^ n = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9186062620719895,
    "entry_failed": false
  },
  "23487": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Matroid/Restrict.lean",
    "full_name": "Matroid.Dep.of_restriction",
    "start": [
      366,
      1
    ],
    "end": [
      369,
      30
    ],
    "traced_tactics": [
      {
        "tactic": "obtain \u27e8R, hR, rfl\u27e9 := hNM",
        "annotated_tactic": [
          "obtain \u27e8R, hR, rfl\u27e9 := hNM",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nM : Matroid \u03b1\nR I J X Y : Set \u03b1\nN : Matroid \u03b1\nhX : N.Dep X\nhNM : N \u2264r M\n\u22a2 M.Dep X",
        "state_after": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nR\u271d I J X Y R : Set \u03b1\nhR : R \u2286 M.E\nhX : (M \u21be R).Dep X\n\u22a2 M.Dep X"
      },
      {
        "tactic": "rw [restrict_dep_iff] at hX",
        "annotated_tactic": [
          "rw [<a>restrict_dep_iff</a>] at hX",
          [
            {
              "full_name": "Matroid.restrict_dep_iff",
              "def_path": "Mathlib/Data/Matroid/Restrict.lean",
              "def_pos": [
                136,
                17
              ],
              "def_end_pos": [
                136,
                33
              ]
            }
          ]
        ],
        "state_before": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nR\u271d I J X Y R : Set \u03b1\nhR : R \u2286 M.E\nhX : (M \u21be R).Dep X\n\u22a2 M.Dep X",
        "state_after": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nR\u271d I J X Y R : Set \u03b1\nhR : R \u2286 M.E\nhX : \u00acM.Indep X \u2227 X \u2286 R\n\u22a2 M.Dep X"
      },
      {
        "tactic": "exact \u27e8hX.1, hX.2.trans hR\u27e9",
        "annotated_tactic": [
          "exact \u27e8hX.1, hX.2.<a>trans</a> hR\u27e9",
          [
            {
              "full_name": "HasSubset.Subset.trans",
              "def_path": "Mathlib/Order/RelClasses.lean",
              "def_pos": [
                655,
                7
              ],
              "def_end_pos": [
                655,
                29
              ]
            }
          ]
        ],
        "state_before": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nR\u271d I J X Y R : Set \u03b1\nhR : R \u2286 M.E\nhX : \u00acM.Indep X \u2227 X \u2286 R\n\u22a2 M.Dep X",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.703530401922762,
    "entry_failed": false
  },
  "23537": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/GeomSum.lean",
    "full_name": "geom_sum_mul_neg",
    "start": [
      240,
      1
    ],
    "end": [
      244,
      13
    ],
    "traced_tactics": [
      {
        "tactic": "have := congr_arg Neg.neg (geom_sum_mul x n)",
        "annotated_tactic": [
          "have := <a>congr_arg</a> <a>Neg.neg</a> (<a>geom_sum_mul</a> x n)",
          [
            {
              "full_name": "congr_arg",
              "def_path": ".lake/packages/batteries/Batteries/Logic.lean",
              "def_pos": [
                76,
                7
              ],
              "def_end_pos": [
                76,
                16
              ]
            },
            {
              "full_name": "Neg.neg",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                1329,
                3
              ],
              "def_end_pos": [
                1329,
                6
              ]
            },
            {
              "full_name": "geom_sum_mul",
              "def_path": "Mathlib/Algebra/GeomSum.lean",
              "def_pos": [
                230,
                9
              ],
              "def_end_pos": [
                230,
                21
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\ninst\u271d : Ring \u03b1\nx : \u03b1\nn : \u2115\n\u22a2 (\u2211 i \u2208 range n, x ^ i) * (1 - x) = 1 - x ^ n",
        "state_after": "\u03b1 : Type u\ninst\u271d : Ring \u03b1\nx : \u03b1\nn : \u2115\nthis : -((\u2211 i \u2208 range n, x ^ i) * (x - 1)) = -(x ^ n - 1)\n\u22a2 (\u2211 i \u2208 range n, x ^ i) * (1 - x) = 1 - x ^ n"
      },
      {
        "tactic": "rw [neg_sub, \u2190 mul_neg, neg_sub] at this",
        "annotated_tactic": [
          "rw [<a>neg_sub</a>, \u2190 <a>mul_neg</a>, <a>neg_sub</a>] at this",
          [
            {
              "full_name": "neg_sub",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                553,
                3
              ],
              "def_end_pos": [
                553,
                14
              ]
            },
            {
              "full_name": "mul_neg",
              "def_path": "Mathlib/Algebra/Ring/Defs.lean",
              "def_pos": [
                323,
                9
              ],
              "def_end_pos": [
                323,
                16
              ]
            },
            {
              "full_name": "neg_sub",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                553,
                3
              ],
              "def_end_pos": [
                553,
                14
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\ninst\u271d : Ring \u03b1\nx : \u03b1\nn : \u2115\nthis : -((\u2211 i \u2208 range n, x ^ i) * (x - 1)) = -(x ^ n - 1)\n\u22a2 (\u2211 i \u2208 range n, x ^ i) * (1 - x) = 1 - x ^ n",
        "state_after": "\u03b1 : Type u\ninst\u271d : Ring \u03b1\nx : \u03b1\nn : \u2115\nthis : (\u2211 i \u2208 range n, x ^ i) * (1 - x) = 1 - x ^ n\n\u22a2 (\u2211 i \u2208 range n, x ^ i) * (1 - x) = 1 - x ^ n"
      },
      {
        "tactic": "exact this",
        "annotated_tactic": [
          "exact this",
          []
        ],
        "state_before": "\u03b1 : Type u\ninst\u271d : Ring \u03b1\nx : \u03b1\nn : \u2115\nthis : (\u2211 i \u2208 range n, x ^ i) * (1 - x) = 1 - x ^ n\n\u22a2 (\u2211 i \u2208 range n, x ^ i) * (1 - x) = 1 - x ^ n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.415055408957414,
    "entry_failed": false
  },
  "23581": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Computability/Ackermann.lean",
    "full_name": "ack_two",
    "start": [
      89,
      1
    ],
    "end": [
      92,
      21
    ],
    "traced_tactics": [
      {
        "tactic": "induction' n with n IH",
        "annotated_tactic": [
          "induction' n with n IH",
          []
        ],
        "state_before": "n : \u2115\n\u22a2 ack 2 n = 2 * n + 3",
        "state_after": "case zero\n\n\u22a2 ack 2 0 = 2 * 0 + 3\n\ncase succ\nn : \u2115\nIH : ack 2 n = 2 * n + 3\n\u22a2 ack 2 (n + 1) = 2 * (n + 1) + 3"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case zero\n\n\u22a2 ack 2 0 = 2 * 0 + 3",
        "state_after": "no goals"
      },
      {
        "tactic": "simpa [mul_succ]",
        "annotated_tactic": [
          "simpa [<a>mul_succ</a>]",
          [
            {
              "full_name": "Nat.mul_succ",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean",
              "def_pos": [
                200,
                9
              ],
              "def_end_pos": [
                200,
                17
              ]
            }
          ]
        ],
        "state_before": "case succ\nn : \u2115\nIH : ack 2 n = 2 * n + 3\n\u22a2 ack 2 (n + 1) = 2 * (n + 1) + 3",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8864401169121265,
    "entry_failed": false
  },
  "23597": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/ZMod/Basic.lean",
    "full_name": "ZMod.cast_eq_val",
    "start": [
      183,
      1
    ],
    "end": [
      186,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "cases n",
        "annotated_tactic": [
          "cases n",
          []
        ],
        "state_before": "n : \u2115\nR : Type u_1\ninst\u271d\u00b9 : AddGroupWithOne R\ninst\u271d : NeZero n\na : ZMod n\n\u22a2 a.cast = \u2191a.val",
        "state_after": "case zero\nR : Type u_1\ninst\u271d\u00b9 : AddGroupWithOne R\ninst\u271d : NeZero 0\na : ZMod 0\n\u22a2 a.cast = \u2191a.val\n\ncase succ\nR : Type u_1\ninst\u271d\u00b9 : AddGroupWithOne R\nn\u271d : \u2115\ninst\u271d : NeZero (n\u271d + 1)\na : ZMod (n\u271d + 1)\n\u22a2 a.cast = \u2191a.val"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case succ\nR : Type u_1\ninst\u271d\u00b9 : AddGroupWithOne R\nn\u271d : \u2115\ninst\u271d : NeZero (n\u271d + 1)\na : ZMod (n\u271d + 1)\n\u22a2 a.cast = \u2191a.val",
        "state_after": "no goals"
      },
      {
        "tactic": "cases NeZero.ne 0 rfl",
        "annotated_tactic": [
          "cases <a>NeZero.ne</a> 0 <a>rfl</a>",
          [
            {
              "full_name": "NeZero.ne",
              "def_path": "Mathlib/Algebra/NeZero.lean",
              "def_pos": [
                30,
                9
              ],
              "def_end_pos": [
                30,
                18
              ]
            },
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "case zero\nR : Type u_1\ninst\u271d\u00b9 : AddGroupWithOne R\ninst\u271d : NeZero 0\na : ZMod 0\n\u22a2 a.cast = \u2191a.val",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.5548903899034485,
    "entry_failed": false
  },
  "23740": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Logic/Basic.lean",
    "full_name": "dite_ne_left_iff",
    "start": [
      1203,
      1
    ],
    "end": [
      1205,
      45
    ],
    "traced_tactics": [
      {
        "tactic": "rw [Ne, dite_eq_left_iff, not_forall]",
        "annotated_tactic": [
          "rw [<a>Ne</a>, <a>dite_eq_left_iff</a>, <a>not_forall</a>]",
          [
            {
              "full_name": "Ne",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                689,
                18
              ],
              "def_end_pos": [
                689,
                20
              ]
            },
            {
              "full_name": "dite_eq_left_iff",
              "def_path": ".lake/packages/lean4/src/lean/Init/ByCases.lean",
              "def_pos": [
                40,
                17
              ],
              "def_end_pos": [
                40,
                33
              ]
            },
            {
              "full_name": "Classical.not_forall",
              "def_path": ".lake/packages/lean4/src/lean/Init/Classical.lean",
              "def_pos": [
                137,
                21
              ],
              "def_end_pos": [
                137,
                31
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Sort u_1\n\u03c3 : \u03b1 \u2192 Sort u_2\nP Q R : Prop\ninst\u271d\u00b9 : Decidable P\ninst\u271d : Decidable Q\na b c : \u03b1\nA : P \u2192 \u03b1\nB : \u00acP \u2192 \u03b1\n\u22a2 dite P (fun x => a) B \u2260 a \u2194 \u2203 h, a \u2260 B h",
        "state_after": "\u03b1 : Sort u_1\n\u03c3 : \u03b1 \u2192 Sort u_2\nP Q R : Prop\ninst\u271d\u00b9 : Decidable P\ninst\u271d : Decidable Q\na b c : \u03b1\nA : P \u2192 \u03b1\nB : \u00acP \u2192 \u03b1\n\u22a2 (\u2203 x, \u00acB x = a) \u2194 \u2203 h, a \u2260 B h"
      },
      {
        "tactic": "exact exists_congr fun h \u21a6 by rw [ne_comm]",
        "annotated_tactic": [
          "exact <a>exists_congr</a> fun h \u21a6 by rw [<a>ne_comm</a>]",
          [
            {
              "full_name": "exists_congr",
              "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean",
              "def_pos": [
                210,
                9
              ],
              "def_end_pos": [
                210,
                21
              ]
            },
            {
              "full_name": "ne_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                706,
                9
              ],
              "def_end_pos": [
                706,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Sort u_1\n\u03c3 : \u03b1 \u2192 Sort u_2\nP Q R : Prop\ninst\u271d\u00b9 : Decidable P\ninst\u271d : Decidable Q\na b c : \u03b1\nA : P \u2192 \u03b1\nB : \u00acP \u2192 \u03b1\n\u22a2 (\u2203 x, \u00acB x = a) \u2194 \u2203 h, a \u2260 B h",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [ne_comm]",
        "annotated_tactic": [
          "rw [<a>ne_comm</a>]",
          [
            {
              "full_name": "ne_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                706,
                9
              ],
              "def_end_pos": [
                706,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Sort u_1\n\u03c3 : \u03b1 \u2192 Sort u_2\nP Q R : Prop\ninst\u271d\u00b9 : Decidable P\ninst\u271d : Decidable Q\na b c : \u03b1\nA : P \u2192 \u03b1\nB : \u00acP \u2192 \u03b1\nh : \u00acP\n\u22a2 \u00acB h = a \u2194 a \u2260 B h",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.871641987003386,
    "entry_failed": false
  },
  "23758": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Choose/Basic.lean",
    "full_name": "Nat.multichoose_one",
    "start": [
      391,
      1
    ],
    "end": [
      393,
      39
    ],
    "traced_tactics": [
      {
        "tactic": "induction' k with k IH",
        "annotated_tactic": [
          "induction' k with k IH",
          []
        ],
        "state_before": "k : \u2115\n\u22a2 multichoose 1 k = 1",
        "state_after": "case zero\n\n\u22a2 multichoose 1 0 = 1\n\ncase succ\nk : \u2115\nIH : multichoose 1 k = 1\n\u22a2 multichoose 1 (k + 1) = 1"
      },
      {
        "tactic": "simp [multichoose_succ_succ 0 k, IH]",
        "annotated_tactic": [
          "simp [<a>multichoose_succ_succ</a> 0 k, IH]",
          [
            {
              "full_name": "Nat.multichoose_succ_succ",
              "def_path": "Mathlib/Data/Nat/Choose/Basic.lean",
              "def_pos": [
                385,
                9
              ],
              "def_end_pos": [
                385,
                30
              ]
            }
          ]
        ],
        "state_before": "case succ\nk : \u2115\nIH : multichoose 1 k = 1\n\u22a2 multichoose 1 (k + 1) = 1",
        "state_after": "no goals"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case zero\n\n\u22a2 multichoose 1 0 = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.453457169001922,
    "entry_failed": false
  },
  "23819": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/ENNReal/Real.lean",
    "full_name": "ENNReal.toReal_add",
    "start": [
      37,
      1
    ],
    "end": [
      40,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "lift a to \u211d\u22650 using ha",
        "annotated_tactic": [
          "lift a to \u211d\u22650 using ha",
          []
        ],
        "state_before": "a b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nha : a \u2260 \u22a4\nhb : b \u2260 \u22a4\n\u22a2 (a + b).toReal = a.toReal + b.toReal",
        "state_after": "case intro\nb c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nhb : b \u2260 \u22a4\na : \u211d\u22650\n\u22a2 (\u2191a + b).toReal = (\u2191a).toReal + b.toReal"
      },
      {
        "tactic": "lift b to \u211d\u22650 using hb",
        "annotated_tactic": [
          "lift b to \u211d\u22650 using hb",
          []
        ],
        "state_before": "case intro\nb c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nhb : b \u2260 \u22a4\na : \u211d\u22650\n\u22a2 (\u2191a + b).toReal = (\u2191a).toReal + b.toReal",
        "state_after": "case intro.intro\nc d : \u211d\u22650\u221e\nr p q a b : \u211d\u22650\n\u22a2 (\u2191a + \u2191b).toReal = (\u2191a).toReal + (\u2191b).toReal"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case intro.intro\nc d : \u211d\u22650\u221e\nr p q a b : \u211d\u22650\n\u22a2 (\u2191a + \u2191b).toReal = (\u2191a).toReal + (\u2191b).toReal",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7725326529471204,
    "entry_failed": false
  },
  "23916": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Sym/Sym2.lean",
    "full_name": "Sym2.mem_map",
    "start": [
      407,
      1
    ],
    "end": [
      410,
      8
    ],
    "traced_tactics": [
      {
        "tactic": "induction' z with x y",
        "annotated_tactic": [
          "induction' z with x y",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\nz : Sym2 \u03b1\n\u22a2 b \u2208 map f z \u2194 \u2203 a \u2208 z, f a = b",
        "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\nx y : \u03b1\n\u22a2 b \u2208 map f s(x, y) \u2194 \u2203 a \u2208 s(x, y), f a = b"
      },
      {
        "tactic": "simp only [map_pair_eq, mem_iff, exists_eq_or_imp, exists_eq_left]",
        "annotated_tactic": [
          "simp only [<a>map_pair_eq</a>, <a>mem_iff</a>, <a>exists_eq_or_imp</a>, <a>exists_eq_left</a>]",
          [
            {
              "full_name": "Sym2.map_pair_eq",
              "def_path": "Mathlib/Data/Sym/Sym2.lean",
              "def_pos": [
                280,
                9
              ],
              "def_end_pos": [
                280,
                20
              ]
            },
            {
              "full_name": "Sym2.mem_iff",
              "def_path": "Mathlib/Data/Sym/Sym2.lean",
              "def_pos": [
                350,
                9
              ],
              "def_end_pos": [
                350,
                16
              ]
            },
            {
              "full_name": "exists_eq_or_imp",
              "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean",
              "def_pos": [
                298,
                17
              ],
              "def_end_pos": [
                298,
                33
              ]
            },
            {
              "full_name": "exists_eq_left",
              "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean",
              "def_pos": [
                282,
                17
              ],
              "def_end_pos": [
                282,
                31
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\nx y : \u03b1\n\u22a2 b \u2208 map f s(x, y) \u2194 \u2203 a \u2208 s(x, y), f a = b",
        "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\nx y : \u03b1\n\u22a2 b = f x \u2228 b = f y \u2194 f x = b \u2228 f y = b"
      },
      {
        "tactic": "aesop",
        "annotated_tactic": [
          "aesop",
          []
        ],
        "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\nx y : \u03b1\n\u22a2 b = f x \u2228 b = f y \u2194 f x = b \u2228 f y = b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.1078761219978333,
    "entry_failed": false
  },
  "23918": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Stream/Init.lean",
    "full_name": "Stream'.tail_inits",
    "start": [
      692,
      1
    ],
    "end": [
      695,
      28
    ],
    "traced_tactics": [
      {
        "tactic": "unfold inits",
        "annotated_tactic": [
          "unfold <a>inits</a>",
          [
            {
              "full_name": "Stream'.inits",
              "def_path": "Mathlib/Data/Stream/Defs.lean",
              "def_pos": [
                173,
                5
              ],
              "def_end_pos": [
                173,
                10
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\ns : Stream' \u03b1\n\u22a2 s.inits.tail = initsCore [s.head, s.tail.head] s.tail.tail",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\ns : Stream' \u03b1\n\u22a2 (initsCore [s.head] s.tail).tail = initsCore [s.head, s.tail.head] s.tail.tail"
      },
      {
        "tactic": "rw [inits_core_eq]",
        "annotated_tactic": [
          "rw [<a>inits_core_eq</a>]",
          [
            {
              "full_name": "Stream'.inits_core_eq",
              "def_path": "Mathlib/Data/Stream/Init.lean",
              "def_pos": [
                686,
                9
              ],
              "def_end_pos": [
                686,
                22
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\ns : Stream' \u03b1\n\u22a2 (initsCore [s.head] s.tail).tail = initsCore [s.head, s.tail.head] s.tail.tail",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\ns : Stream' \u03b1\n\u22a2 ([s.head] :: initsCore ([s.head] ++ [s.tail.head]) s.tail.tail).tail = initsCore [s.head, s.tail.head] s.tail.tail"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\ns : Stream' \u03b1\n\u22a2 ([s.head] :: initsCore ([s.head] ++ [s.tail.head]) s.tail.tail).tail = initsCore [s.head, s.tail.head] s.tail.tail",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.1544956320431083,
    "entry_failed": false
  },
  "23953": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/EuclideanDomain/Basic.lean",
    "full_name": "EuclideanDomain.dvd_lcm_right",
    "start": [
      258,
      1
    ],
    "end": [
      265,
      92
    ],
    "traced_tactics": [
      {
        "tactic": "rw [lcm, hxy, div_zero]",
        "annotated_tactic": [
          "rw [<a>lcm</a>, hxy, <a>div_zero</a>]",
          [
            {
              "full_name": "EuclideanDomain.lcm",
              "def_path": "Mathlib/Algebra/EuclideanDomain/Defs.lean",
              "def_pos": [
                286,
                5
              ],
              "def_end_pos": [
                286,
                8
              ]
            },
            {
              "full_name": "EuclideanDomain.div_zero",
              "def_path": "Mathlib/Algebra/EuclideanDomain/Defs.lean",
              "def_pos": [
                170,
                9
              ],
              "def_end_pos": [
                170,
                17
              ]
            }
          ]
        ],
        "state_before": "R : Type u\ninst\u271d\u00b9 : EuclideanDomain R\ninst\u271d : DecidableEq R\nx y : R\nhxy : gcd x y = 0\n\u22a2 y \u2223 lcm x y",
        "state_after": "R : Type u\ninst\u271d\u00b9 : EuclideanDomain R\ninst\u271d : DecidableEq R\nx y : R\nhxy : gcd x y = 0\n\u22a2 y \u2223 0"
      },
      {
        "tactic": "exact dvd_zero _",
        "annotated_tactic": [
          "exact <a>dvd_zero</a> _",
          [
            {
              "full_name": "dvd_zero",
              "def_path": "Mathlib/Algebra/GroupWithZero/Divisibility.lean",
              "def_pos": [
                41,
                9
              ],
              "def_end_pos": [
                41,
                17
              ]
            }
          ]
        ],
        "state_before": "R : Type u\ninst\u271d\u00b9 : EuclideanDomain R\ninst\u271d : DecidableEq R\nx y : R\nhxy : gcd x y = 0\n\u22a2 y \u2223 0",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [\u2190 mul_assoc, mul_right_comm, \u2190 hz]",
        "annotated_tactic": [
          "rw [\u2190 <a>mul_assoc</a>, <a>mul_right_comm</a>, \u2190 hz]",
          [
            {
              "full_name": "mul_assoc",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                289,
                9
              ],
              "def_end_pos": [
                289,
                18
              ]
            },
            {
              "full_name": "mul_right_comm",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                190,
                9
              ],
              "def_end_pos": [
                190,
                23
              ]
            }
          ]
        ],
        "state_before": "R : Type u\ninst\u271d\u00b9 : EuclideanDomain R\ninst\u271d : DecidableEq R\nx y : R\nhxy : \u00acgcd x y = 0\nz : R\nhz : x = gcd x y * z\n\u22a2 gcd x y * (y * z) = x * y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.219544215942733,
    "entry_failed": false
  },
  "23969": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Group/Centralizer.lean",
    "full_name": "Set.subset_centralizer_centralizer",
    "start": [
      124,
      1
    ],
    "end": [
      128,
      35
    ],
    "traced_tactics": [
      {
        "tactic": "intro x hx",
        "annotated_tactic": [
          "intro x hx",
          []
        ],
        "state_before": "M : Type u_1\nS T : Set M\na b : M\ninst\u271d : Mul M\ns : Set M\n\u22a2 s \u2286 s.centralizer.centralizer",
        "state_after": "M : Type u_1\nS T : Set M\na b : M\ninst\u271d : Mul M\ns : Set M\nx : M\nhx : x \u2208 s\n\u22a2 x \u2208 s.centralizer.centralizer"
      },
      {
        "tactic": "simp only [Set.mem_centralizer_iff]",
        "annotated_tactic": [
          "simp only [<a>Set.mem_centralizer_iff</a>]",
          [
            {
              "full_name": "Set.mem_centralizer_iff",
              "def_path": "Mathlib/Algebra/Group/Centralizer.lean",
              "def_pos": [
                44,
                9
              ],
              "def_end_pos": [
                44,
                28
              ]
            }
          ]
        ],
        "state_before": "M : Type u_1\nS T : Set M\na b : M\ninst\u271d : Mul M\ns : Set M\nx : M\nhx : x \u2208 s\n\u22a2 x \u2208 s.centralizer.centralizer",
        "state_after": "M : Type u_1\nS T : Set M\na b : M\ninst\u271d : Mul M\ns : Set M\nx : M\nhx : x \u2208 s\n\u22a2 \u2200 (m : M), (\u2200 m_1 \u2208 s, m_1 * m = m * m_1) \u2192 m * x = x * m"
      },
      {
        "tactic": "exact fun y hy => (hy x hx).symm",
        "annotated_tactic": [
          "exact fun y hy => (hy x hx).<a>symm</a>",
          [
            {
              "full_name": "Eq.symm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                323,
                9
              ],
              "def_end_pos": [
                323,
                16
              ]
            }
          ]
        ],
        "state_before": "M : Type u_1\nS T : Set M\na b : M\ninst\u271d : Mul M\ns : Set M\nx : M\nhx : x \u2208 s\n\u22a2 \u2200 (m : M), (\u2200 m_1 \u2208 s, m_1 * m = m * m_1) \u2192 m * x = x * m",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2176091310102493,
    "entry_failed": false
  },
  "23970": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Real/EReal.lean",
    "full_name": "EReal.le_coe_toReal",
    "start": [
      416,
      1
    ],
    "end": [
      419,
      41
    ],
    "traced_tactics": [
      {
        "tactic": "by_cases h' : x = \u22a5",
        "annotated_tactic": [
          "by_cases h' : x = \u22a5",
          []
        ],
        "state_before": "x : EReal\nh : x \u2260 \u22a4\n\u22a2 x \u2264 \u2191x.toReal",
        "state_after": "case pos\nx : EReal\nh : x \u2260 \u22a4\nh' : x = \u22a5\n\u22a2 x \u2264 \u2191x.toReal\n\ncase neg\nx : EReal\nh : x \u2260 \u22a4\nh' : \u00acx = \u22a5\n\u22a2 x \u2264 \u2191x.toReal"
      },
      {
        "tactic": "simp only [h', bot_le]",
        "annotated_tactic": [
          "simp only [h', <a>bot_le</a>]",
          [
            {
              "full_name": "bot_le",
              "def_path": "Mathlib/Order/BoundedOrder.lean",
              "def_pos": [
                224,
                9
              ],
              "def_end_pos": [
                224,
                15
              ]
            }
          ]
        ],
        "state_before": "case pos\nx : EReal\nh : x \u2260 \u22a4\nh' : x = \u22a5\n\u22a2 x \u2264 \u2191x.toReal",
        "state_after": "no goals"
      },
      {
        "tactic": "simp only [le_refl, coe_toReal h h']",
        "annotated_tactic": [
          "simp only [<a>le_refl</a>, <a>coe_toReal</a> h h']",
          [
            {
              "full_name": "le_refl",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                45,
                9
              ],
              "def_end_pos": [
                45,
                16
              ]
            },
            {
              "full_name": "EReal.coe_toReal",
              "def_path": "Mathlib/Data/Real/EReal.lean",
              "def_pos": [
                411,
                9
              ],
              "def_end_pos": [
                411,
                19
              ]
            }
          ]
        ],
        "state_before": "case neg\nx : EReal\nh : x \u2260 \u22a4\nh' : \u00acx = \u22a5\n\u22a2 x \u2264 \u2191x.toReal",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.772391228936613,
    "entry_failed": false
  },
  "24057": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Digits.lean",
    "full_name": "Nat.ofDigits_one",
    "start": [
      290,
      1
    ],
    "end": [
      293,
      39
    ],
    "traced_tactics": [
      {
        "tactic": "induction' L with _ _ ih",
        "annotated_tactic": [
          "induction' L with _ _ ih",
          []
        ],
        "state_before": "n : \u2115\nL : List \u2115\n\u22a2 ofDigits 1 L = L.sum",
        "state_after": "case nil\nn : \u2115\n\u22a2 ofDigits 1 [] = [].sum\n\ncase cons\nn head\u271d : \u2115\ntail\u271d : List \u2115\nih : ofDigits 1 tail\u271d = tail\u271d.sum\n\u22a2 ofDigits 1 (head\u271d :: tail\u271d) = (head\u271d :: tail\u271d).sum"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case nil\nn : \u2115\n\u22a2 ofDigits 1 [] = [].sum",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [ofDigits, List.sum_cons, ih]",
        "annotated_tactic": [
          "simp [<a>ofDigits</a>, <a>List.sum_cons</a>, ih]",
          [
            {
              "full_name": "Nat.ofDigits",
              "def_path": "Mathlib/Data/Nat/Digits.lean",
              "def_pos": [
                162,
                5
              ],
              "def_end_pos": [
                162,
                13
              ]
            },
            {
              "full_name": "List.sum_cons",
              "def_path": "Mathlib/Algebra/BigOperators/Group/List.lean",
              "def_pos": [
                94,
                3
              ],
              "def_end_pos": [
                94,
                14
              ]
            }
          ]
        ],
        "state_before": "case cons\nn head\u271d : \u2115\ntail\u271d : List \u2115\nih : ofDigits 1 tail\u271d = tail\u271d.sum\n\u22a2 ofDigits 1 (head\u271d :: tail\u271d) = (head\u271d :: tail\u271d).sum",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.5404471929650754,
    "entry_failed": false
  },
  "24115": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/Integral/Periodic.lean",
    "full_name": "AddCircle.measure_univ",
    "start": [
      71,
      11
    ],
    "end": [
      74,
      75
    ],
    "traced_tactics": [
      {
        "tactic": "dsimp [volume]",
        "annotated_tactic": [
          "dsimp [<a>volume</a>]",
          [
            {
              "full_name": "MeasureTheory.MeasureSpace.volume",
              "def_path": "Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean",
              "def_pos": [
                367,
                3
              ],
              "def_end_pos": [
                367,
                9
              ]
            }
          ]
        ],
        "state_before": "T : \u211d\nhT : Fact (0 < T)\n\u22a2 volume univ = ENNReal.ofReal T",
        "state_after": "T : \u211d\nhT : Fact (0 < T)\n\u22a2 ENNReal.ofReal T * (addHaarMeasure \u22a4) univ = ENNReal.ofReal T"
      },
      {
        "tactic": "rw [\u2190 PositiveCompacts.coe_top]",
        "annotated_tactic": [
          "rw [\u2190 <a>PositiveCompacts.coe_top</a>]",
          [
            {
              "full_name": "TopologicalSpace.PositiveCompacts.coe_top",
              "def_path": "Mathlib/Topology/Sets/Compacts.lean",
              "def_pos": [
                386,
                9
              ],
              "def_end_pos": [
                386,
                16
              ]
            }
          ]
        ],
        "state_before": "T : \u211d\nhT : Fact (0 < T)\n\u22a2 ENNReal.ofReal T * (addHaarMeasure \u22a4) univ = ENNReal.ofReal T",
        "state_after": "T : \u211d\nhT : Fact (0 < T)\n\u22a2 ENNReal.ofReal T * (addHaarMeasure \u22a4) \u2191\u22a4 = ENNReal.ofReal T"
      },
      {
        "tactic": "simp [addHaarMeasure_self (G := AddCircle T), -PositiveCompacts.coe_top]",
        "annotated_tactic": [
          "simp [<a>addHaarMeasure_self</a> (G := <a>AddCircle</a> T), -<a>PositiveCompacts.coe_top</a>]",
          [
            {
              "full_name": "MeasureTheory.Measure.addHaarMeasure_self",
              "def_path": "Mathlib/MeasureTheory/Measure/Haar/Basic.lean",
              "def_pos": [
                642,
                3
              ],
              "def_end_pos": [
                642,
                14
              ]
            },
            {
              "full_name": "AddCircle",
              "def_path": "Mathlib/Topology/Instances/AddCircle.lean",
              "def_pos": [
                122,
                8
              ],
              "def_end_pos": [
                122,
                17
              ]
            },
            {
              "full_name": "TopologicalSpace.PositiveCompacts.coe_top",
              "def_path": "Mathlib/Topology/Sets/Compacts.lean",
              "def_pos": [
                386,
                9
              ],
              "def_end_pos": [
                386,
                16
              ]
            }
          ]
        ],
        "state_before": "T : \u211d\nhT : Fact (0 < T)\n\u22a2 ENNReal.ofReal T * (addHaarMeasure \u22a4) \u2191\u22a4 = ENNReal.ofReal T",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.748856766964309,
    "entry_failed": false
  },
  "24222": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Zip.lean",
    "full_name": "List.map_prod_right_eq_zip",
    "start": [
      155,
      1
    ],
    "end": [
      159,
      17
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 zip_map']",
        "annotated_tactic": [
          "rw [\u2190 <a>zip_map'</a>]",
          [
            {
              "full_name": "List.zip_map'",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean",
              "def_pos": [
                2176,
                9
              ],
              "def_end_pos": [
                2176,
                17
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 map (fun x => (f x, x)) l = (map f l).zip l",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 (map f l).zip (map (fun x => x) l) = (map f l).zip l"
      },
      {
        "tactic": "congr",
        "annotated_tactic": [
          "congr",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 (map f l).zip (map (fun x => x) l) = (map f l).zip l",
        "state_after": "case e_a\n\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 map (fun x => x) l = l"
      },
      {
        "tactic": "exact map_id _",
        "annotated_tactic": [
          "exact <a>map_id</a> _",
          [
            {
              "full_name": "List.map_id",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean",
              "def_pos": [
                716,
                17
              ],
              "def_end_pos": [
                716,
                23
              ]
            }
          ]
        ],
        "state_before": "case e_a\n\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\nl : List \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 map (fun x => x) l = l",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6482128930510953,
    "entry_failed": false
  },
  "24225": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Finsupp/Multiset.lean",
    "full_name": "Finsupp.sum_id_lt_of_lt",
    "start": [
      234,
      1
    ],
    "end": [
      237,
      32
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 card_toMultiset, \u2190 card_toMultiset]",
        "annotated_tactic": [
          "rw [\u2190 <a>card_toMultiset</a>, \u2190 <a>card_toMultiset</a>]",
          [
            {
              "full_name": "Finsupp.card_toMultiset",
              "def_path": "Mathlib/Data/Finsupp/Multiset.lean",
              "def_pos": [
                67,
                9
              ],
              "def_end_pos": [
                67,
                24
              ]
            },
            {
              "full_name": "Finsupp.card_toMultiset",
              "def_path": "Mathlib/Data/Finsupp/Multiset.lean",
              "def_pos": [
                67,
                9
              ],
              "def_end_pos": [
                67,
                24
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nm n : \u03b9 \u2192\u2080 \u2115\nh : m < n\n\u22a2 (m.sum fun x => id) < n.sum fun x => id",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nm n : \u03b9 \u2192\u2080 \u2115\nh : m < n\n\u22a2 Multiset.card (toMultiset m) < Multiset.card (toMultiset n)"
      },
      {
        "tactic": "apply Multiset.card_lt_card",
        "annotated_tactic": [
          "apply <a>Multiset.card_lt_card</a>",
          [
            {
              "full_name": "Multiset.card_lt_card",
              "def_path": "Mathlib/Data/Multiset/Basic.lean",
              "def_pos": [
                818,
                9
              ],
              "def_end_pos": [
                818,
                21
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nm n : \u03b9 \u2192\u2080 \u2115\nh : m < n\n\u22a2 Multiset.card (toMultiset m) < Multiset.card (toMultiset n)",
        "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nm n : \u03b9 \u2192\u2080 \u2115\nh : m < n\n\u22a2 toMultiset m < toMultiset n"
      },
      {
        "tactic": "exact toMultiset_strictMono h",
        "annotated_tactic": [
          "exact <a>toMultiset_strictMono</a> h",
          [
            {
              "full_name": "Finsupp.toMultiset_strictMono",
              "def_path": "Mathlib/Data/Finsupp/Multiset.lean",
              "def_pos": [
                230,
                9
              ],
              "def_end_pos": [
                230,
                30
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nm n : \u03b9 \u2192\u2080 \u2115\nh : m < n\n\u22a2 toMultiset m < toMultiset n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.3523126729996875,
    "entry_failed": false
  },
  "24245": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/FieldTheory/IsAlgClosed/AlgebraicClosure.lean",
    "full_name": "AlgebraicClosure.toStepOfLE'.succ",
    "start": [
      210,
      9
    ],
    "end": [
      215,
      26
    ],
    "traced_tactics": [
      {
        "tactic": "ext x",
        "annotated_tactic": [
          "ext x",
          []
        ],
        "state_before": "k : Type u\ninst\u271d : Field k\nm n : \u2115\nh : m \u2264 n\n\u22a2 AlgebraicClosure.toStepOfLE' k m n.succ \u22ef = \u21d1(toStepSucc k n) \u2218 AlgebraicClosure.toStepOfLE' k m n h",
        "state_after": "case h\nk : Type u\ninst\u271d : Field k\nm n : \u2115\nh : m \u2264 n\nx : Step k m\n\u22a2 AlgebraicClosure.toStepOfLE' k m n.succ \u22ef x = (\u21d1(toStepSucc k n) \u2218 AlgebraicClosure.toStepOfLE' k m n h) x"
      },
      {
        "tactic": "convert Nat.leRecOn_succ h x",
        "annotated_tactic": [
          "convert <a>Nat.leRecOn_succ</a> h x",
          [
            {
              "full_name": "Nat.leRecOn_succ",
              "def_path": "Mathlib/Data/Nat/Defs.lean",
              "def_pos": [
                879,
                7
              ],
              "def_end_pos": [
                879,
                19
              ]
            }
          ]
        ],
        "state_before": "case h\nk : Type u\ninst\u271d : Field k\nm n : \u2115\nh : m \u2264 n\nx : Step k m\n\u22a2 AlgebraicClosure.toStepOfLE' k m n.succ \u22ef x = (\u21d1(toStepSucc k n) \u2218 AlgebraicClosure.toStepOfLE' k m n h) x",
        "state_after": "case h.convert_1\nk : Type u\ninst\u271d : Field k\nm n : \u2115\nh : m \u2264 n\nx : Step k m\n\u22a2 m \u2264 n + 1"
      },
      {
        "tactic": "exact h.trans n.le_succ",
        "annotated_tactic": [
          "exact h.trans n.le_succ",
          []
        ],
        "state_before": "case h.convert_1\nk : Type u\ninst\u271d : Field k\nm n : \u2115\nh : m \u2264 n\nx : Step k m\n\u22a2 m \u2264 n + 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.9832374680554494,
    "entry_failed": false
  },
  "24327": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/Constructions/Polish.lean",
    "full_name": "IsOpen.analyticSet_image",
    "start": [
      187,
      1
    ],
    "end": [
      191,
      78
    ],
    "traced_tactics": [
      {
        "tactic": "rw [image_eq_range]",
        "annotated_tactic": [
          "rw [<a>image_eq_range</a>]",
          [
            {
              "full_name": "Set.image_eq_range",
              "def_path": "Mathlib/Data/Set/Image.lean",
              "def_pos": [
                1055,
                9
              ],
              "def_end_pos": [
                1055,
                23
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\n\u03b2 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PolishSpace \u03b2\ns : Set \u03b2\nhs : IsOpen s\nf : \u03b2 \u2192 \u03b1\nf_cont : Continuous f\n\u22a2 AnalyticSet (f '' s)",
        "state_after": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\n\u03b2 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PolishSpace \u03b2\ns : Set \u03b2\nhs : IsOpen s\nf : \u03b2 \u2192 \u03b1\nf_cont : Continuous f\n\u22a2 AnalyticSet (range fun x => f \u2191x)"
      },
      {
        "tactic": "haveI : PolishSpace s := hs.polishSpace",
        "annotated_tactic": [
          "haveI : <a>PolishSpace</a> s := hs.polishSpace",
          [
            {
              "full_name": "PolishSpace",
              "def_path": "Mathlib/Topology/MetricSpace/Polish.lean",
              "def_pos": [
                66,
                7
              ],
              "def_end_pos": [
                66,
                18
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\n\u03b2 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PolishSpace \u03b2\ns : Set \u03b2\nhs : IsOpen s\nf : \u03b2 \u2192 \u03b1\nf_cont : Continuous f\n\u22a2 AnalyticSet (range fun x => f \u2191x)",
        "state_after": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\n\u03b2 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PolishSpace \u03b2\ns : Set \u03b2\nhs : IsOpen s\nf : \u03b2 \u2192 \u03b1\nf_cont : Continuous f\nthis : PolishSpace \u2191s\n\u22a2 AnalyticSet (range fun x => f \u2191x)"
      },
      {
        "tactic": "exact analyticSet_range_of_polishSpace (f_cont.comp continuous_subtype_val)",
        "annotated_tactic": [
          "exact <a>analyticSet_range_of_polishSpace</a> (f_cont.comp <a>continuous_subtype_val</a>)",
          [
            {
              "full_name": "MeasureTheory.analyticSet_range_of_polishSpace",
              "def_path": "Mathlib/MeasureTheory/Constructions/Polish.lean",
              "def_pos": [
                174,
                9
              ],
              "def_end_pos": [
                174,
                41
              ]
            },
            {
              "full_name": "continuous_subtype_val",
              "def_path": "Mathlib/Topology/Constructions.lean",
              "def_pos": [
                1092,
                9
              ],
              "def_end_pos": [
                1092,
                31
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\n\u03b2 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PolishSpace \u03b2\ns : Set \u03b2\nhs : IsOpen s\nf : \u03b2 \u2192 \u03b1\nf_cont : Continuous f\nthis : PolishSpace \u2191s\n\u22a2 AnalyticSet (range fun x => f \u2191x)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.9622914689825848,
    "entry_failed": false
  },
  "24330": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Sub/Canonical.lean",
    "full_name": "tsub_eq_tsub_min",
    "start": [
      431,
      1
    ],
    "end": [
      434,
      24
    ],
    "traced_tactics": [
      {
        "tactic": "rcases le_total a b with h | h",
        "annotated_tactic": [
          "rcases <a>le_total</a> a b with h | h",
          [
            {
              "full_name": "le_total",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                297,
                9
              ],
              "def_end_pos": [
                297,
                17
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CanonicallyLinearOrderedAddCommMonoid \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na\u271d b\u271d c d a b : \u03b1\n\u22a2 a - b = a - min a b",
        "state_after": "case inl\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CanonicallyLinearOrderedAddCommMonoid \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na\u271d b\u271d c d a b : \u03b1\nh : a \u2264 b\n\u22a2 a - b = a - min a b\n\ncase inr\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CanonicallyLinearOrderedAddCommMonoid \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na\u271d b\u271d c d a b : \u03b1\nh : b \u2264 a\n\u22a2 a - b = a - min a b"
      },
      {
        "tactic": "rw [min_eq_left h, tsub_self, tsub_eq_zero_of_le h]",
        "annotated_tactic": [
          "rw [<a>min_eq_left</a> h, <a>tsub_self</a>, <a>tsub_eq_zero_of_le</a> h]",
          [
            {
              "full_name": "min_eq_left",
              "def_path": "Mathlib/Init/Order/LinearOrder.lean",
              "def_pos": [
                100,
                9
              ],
              "def_end_pos": [
                100,
                20
              ]
            },
            {
              "full_name": "tsub_self",
              "def_path": "Mathlib/Algebra/Order/Sub/Canonical.lean",
              "def_pos": [
                342,
                9
              ],
              "def_end_pos": [
                342,
                18
              ]
            },
            {
              "full_name": "tsub_eq_zero_of_le",
              "def_path": "Mathlib/Algebra/Order/Sub/Canonical.lean",
              "def_pos": [
                337,
                11
              ],
              "def_end_pos": [
                337,
                29
              ]
            }
          ]
        ],
        "state_before": "case inl\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CanonicallyLinearOrderedAddCommMonoid \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na\u271d b\u271d c d a b : \u03b1\nh : a \u2264 b\n\u22a2 a - b = a - min a b",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [min_eq_right h]",
        "annotated_tactic": [
          "rw [<a>min_eq_right</a> h]",
          [
            {
              "full_name": "min_eq_right",
              "def_path": "Mathlib/Init/Order/LinearOrder.lean",
              "def_pos": [
                104,
                9
              ],
              "def_end_pos": [
                104,
                21
              ]
            }
          ]
        ],
        "state_before": "case inr\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CanonicallyLinearOrderedAddCommMonoid \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na\u271d b\u271d c d a b : \u03b1\nh : b \u2264 a\n\u22a2 a - b = a - min a b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.978249002015218,
    "entry_failed": false
  },
  "24360": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Homology/ShortComplex/Ab.lean",
    "full_name": "CategoryTheory.ShortComplex.abCyclesIso_inv_apply_iCycles",
    "start": [
      79,
      1
    ],
    "end": [
      83,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "dsimp only [abCyclesIso]",
        "annotated_tactic": [
          "dsimp only [<a>abCyclesIso</a>]",
          [
            {
              "full_name": "CategoryTheory.ShortComplex.abCyclesIso",
              "def_path": "Mathlib/Algebra/Homology/ShortComplex/Ab.lean",
              "def_pos": [
                71,
                19
              ],
              "def_end_pos": [
                71,
                30
              ]
            }
          ]
        ],
        "state_before": "S : ShortComplex Ab\nx : \u21a5(AddMonoidHom.ker S.g)\n\u22a2 S.iCycles (S.abCyclesIso.inv x) = \u2191x",
        "state_after": "S : ShortComplex Ab\nx : \u21a5(AddMonoidHom.ker S.g)\n\u22a2 S.iCycles (S.abLeftHomologyData.cyclesIso.inv x) = \u2191x"
      },
      {
        "tactic": "erw [\u2190 comp_apply, S.abLeftHomologyData.cyclesIso_inv_comp_iCycles]",
        "annotated_tactic": [
          "erw [\u2190 <a>comp_apply</a>, S.abLeftHomologyData.cyclesIso_inv_comp_iCycles]",
          [
            {
              "full_name": "CategoryTheory.comp_apply",
              "def_path": "Mathlib/CategoryTheory/ConcreteCategory/Basic.lean",
              "def_pos": [
                134,
                17
              ],
              "def_end_pos": [
                134,
                27
              ]
            }
          ]
        ],
        "state_before": "S : ShortComplex Ab\nx : \u21a5(AddMonoidHom.ker S.g)\n\u22a2 S.iCycles (S.abLeftHomologyData.cyclesIso.inv x) = \u2191x",
        "state_after": "S : ShortComplex Ab\nx : \u21a5(AddMonoidHom.ker S.g)\n\u22a2 S.abLeftHomologyData.i x = \u2191x"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "S : ShortComplex Ab\nx : \u21a5(AddMonoidHom.ker S.g)\n\u22a2 S.abLeftHomologyData.i x = \u2191x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.4902831569779664,
    "entry_failed": false
  },
  "24379": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/IncMatrix.lean",
    "full_name": "SimpleGraph.incMatrix_apply_mul_incMatrix_apply_of_not_adj",
    "start": [
      85,
      1
    ],
    "end": [
      89,
      28
    ],
    "traced_tactics": [
      {
        "tactic": "rw [incMatrix_apply_mul_incMatrix_apply, Set.indicator_of_not_mem]",
        "annotated_tactic": [
          "rw [<a>incMatrix_apply_mul_incMatrix_apply</a>, <a>Set.indicator_of_not_mem</a>]",
          [
            {
              "full_name": "SimpleGraph.incMatrix_apply_mul_incMatrix_apply",
              "def_path": "Mathlib/Combinatorics/SimpleGraph/IncMatrix.lean",
              "def_pos": [
                79,
                9
              ],
              "def_end_pos": [
                79,
                44
              ]
            },
            {
              "full_name": "Set.indicator_of_not_mem",
              "def_path": "Mathlib/Algebra/Group/Indicator.lean",
              "def_pos": [
                74,
                3
              ],
              "def_end_pos": [
                74,
                14
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\n\u03b1 : Type u_2\nG : SimpleGraph \u03b1\ninst\u271d : MulZeroOneClass R\na b : \u03b1\ne : Sym2 \u03b1\nhab : a \u2260 b\nh : \u00acG.Adj a b\n\u22a2 incMatrix R G a e * incMatrix R G b e = 0",
        "state_after": "case h\nR : Type u_1\n\u03b1 : Type u_2\nG : SimpleGraph \u03b1\ninst\u271d : MulZeroOneClass R\na b : \u03b1\ne : Sym2 \u03b1\nhab : a \u2260 b\nh : \u00acG.Adj a b\n\u22a2 e \u2209 G.incidenceSet a \u2229 G.incidenceSet b"
      },
      {
        "tactic": "rw [G.incidenceSet_inter_incidenceSet_of_not_adj h hab]",
        "annotated_tactic": [
          "rw [G.incidenceSet_inter_incidenceSet_of_not_adj h hab]",
          []
        ],
        "state_before": "case h\nR : Type u_1\n\u03b1 : Type u_2\nG : SimpleGraph \u03b1\ninst\u271d : MulZeroOneClass R\na b : \u03b1\ne : Sym2 \u03b1\nhab : a \u2260 b\nh : \u00acG.Adj a b\n\u22a2 e \u2209 G.incidenceSet a \u2229 G.incidenceSet b",
        "state_after": "case h\nR : Type u_1\n\u03b1 : Type u_2\nG : SimpleGraph \u03b1\ninst\u271d : MulZeroOneClass R\na b : \u03b1\ne : Sym2 \u03b1\nhab : a \u2260 b\nh : \u00acG.Adj a b\n\u22a2 e \u2209 \u2205"
      },
      {
        "tactic": "exact Set.not_mem_empty e",
        "annotated_tactic": [
          "exact <a>Set.not_mem_empty</a> e",
          [
            {
              "full_name": "Set.not_mem_empty",
              "def_path": "Mathlib/Data/Set/Basic.lean",
              "def_pos": [
                402,
                9
              ],
              "def_end_pos": [
                402,
                22
              ]
            }
          ]
        ],
        "state_before": "case h\nR : Type u_1\n\u03b1 : Type u_2\nG : SimpleGraph \u03b1\ninst\u271d : MulZeroOneClass R\na b : \u03b1\ne : Sym2 \u03b1\nhab : a \u2260 b\nh : \u00acG.Adj a b\n\u22a2 e \u2209 \u2205",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6045478320447728,
    "entry_failed": false
  },
  "24418": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RepresentationTheory/Character.lean",
    "full_name": "FdRep.char_iso",
    "start": [
      77,
      1
    ],
    "end": [
      78,
      87
    ],
    "traced_tactics": [
      {
        "tactic": "ext g",
        "annotated_tactic": [
          "ext g",
          []
        ],
        "state_before": "k : Type u\ninst\u271d\u00b9 : Field k\nG : Type u\ninst\u271d : Monoid G\nV W : FdRep k G\ni : V \u2245 W\n\u22a2 V.character = W.character",
        "state_after": "case h\nk : Type u\ninst\u271d\u00b9 : Field k\nG : Type u\ninst\u271d : Monoid G\nV W : FdRep k G\ni : V \u2245 W\ng : G\n\u22a2 V.character g = W.character g"
      },
      {
        "tactic": "simp only [character, FdRep.Iso.conj_\u03c1 i]",
        "annotated_tactic": [
          "simp only [<a>character</a>, <a>FdRep.Iso.conj_\u03c1</a> i]",
          [
            {
              "full_name": "FdRep.character",
              "def_path": "Mathlib/RepresentationTheory/Character.lean",
              "def_pos": [
                50,
                5
              ],
              "def_end_pos": [
                50,
                14
              ]
            },
            {
              "full_name": "FdRep.Iso.conj_\u03c1",
              "def_path": "Mathlib/RepresentationTheory/FdRep.lean",
              "def_pos": [
                95,
                9
              ],
              "def_end_pos": [
                95,
                19
              ]
            }
          ]
        ],
        "state_before": "case h\nk : Type u\ninst\u271d\u00b9 : Field k\nG : Type u\ninst\u271d : Monoid G\nV W : FdRep k G\ni : V \u2245 W\ng : G\n\u22a2 V.character g = W.character g",
        "state_after": "case h\nk : Type u\ninst\u271d\u00b9 : Field k\nG : Type u\ninst\u271d : Monoid G\nV W : FdRep k G\ni : V \u2245 W\ng : G\n\u22a2 (trace k (CoeSort.coe V)) (V.\u03c1 g) = (trace k (CoeSort.coe W)) ((isoToLinearEquiv i).conj (V.\u03c1 g))"
      },
      {
        "tactic": "exact (trace_conj' (V.\u03c1 g) _).symm",
        "annotated_tactic": [
          "exact (<a>trace_conj'</a> (V.\u03c1 g) _).<a>symm</a>",
          [
            {
              "full_name": "LinearMap.trace_conj'",
              "def_path": "Mathlib/LinearAlgebra/Trace.lean",
              "def_pos": [
                294,
                9
              ],
              "def_end_pos": [
                294,
                20
              ]
            },
            {
              "full_name": "Eq.symm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                323,
                9
              ],
              "def_end_pos": [
                323,
                16
              ]
            }
          ]
        ],
        "state_before": "case h\nk : Type u\ninst\u271d\u00b9 : Field k\nG : Type u\ninst\u271d : Monoid G\nV W : FdRep k G\ni : V \u2245 W\ng : G\n\u22a2 (trace k (CoeSort.coe V)) (V.\u03c1 g) = (trace k (CoeSort.coe W)) ((isoToLinearEquiv i).conj (V.\u03c1 g))",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.635093101998791,
    "entry_failed": false
  },
  "24445": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Rel.lean",
    "full_name": "Rel.comp_right_id",
    "start": [
      112,
      1
    ],
    "end": [
      115,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "unfold comp",
        "annotated_tactic": [
          "unfold <a>comp</a>",
          [
            {
              "full_name": "Rel.comp",
              "def_path": "Mathlib/Data/Rel.lean",
              "def_pos": [
                97,
                5
              ],
              "def_end_pos": [
                97,
                9
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr\u271d r : Rel \u03b1 \u03b2\n\u22a2 r \u2022 Eq = r",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr\u271d r : Rel \u03b1 \u03b2\n\u22a2 (fun x z => \u2203 y, r x y \u2227 y = z) = r"
      },
      {
        "tactic": "ext y",
        "annotated_tactic": [
          "ext y",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr\u271d r : Rel \u03b1 \u03b2\n\u22a2 (fun x z => \u2203 y, r x y \u2227 y = z) = r",
        "state_after": "case a.h.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr\u271d r : Rel \u03b1 \u03b2\ny : \u03b1\nx\u271d : \u03b2\n\u22a2 (\u2203 y_1, r y y_1 \u2227 y_1 = x\u271d) \u2194 r y x\u271d"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case a.h.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr\u271d r : Rel \u03b1 \u03b2\ny : \u03b1\nx\u271d : \u03b2\n\u22a2 (\u2203 y_1, r y y_1 \u2227 y_1 = x\u271d) \u2194 r y x\u271d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4687505039619282,
    "entry_failed": false
  },
  "24519": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Perm/Support.lean",
    "full_name": "Equiv.Perm.support_swap_iff",
    "start": [
      444,
      1
    ],
    "end": [
      447,
      29
    ],
    "traced_tactics": [
      {
        "tactic": "refine \u27e8fun h => ?_, fun h => support_swap h\u27e9",
        "annotated_tactic": [
          "refine \u27e8fun h => ?_, fun h => <a>support_swap</a> h\u27e9",
          [
            {
              "full_name": "Equiv.Perm.support_swap",
              "def_path": "Mathlib/GroupTheory/Perm/Support.lean",
              "def_pos": [
                435,
                9
              ],
              "def_end_pos": [
                435,
                21
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\nx y : \u03b1\n\u22a2 (swap x y).support = {x, y} \u2194 x \u2260 y",
        "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\nx y : \u03b1\nh : (swap x y).support = {x, y}\n\u22a2 x \u2260 y"
      },
      {
        "tactic": "rintro rfl",
        "annotated_tactic": [
          "rintro rfl",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\nx y : \u03b1\nh : (swap x y).support = {x, y}\n\u22a2 x \u2260 y",
        "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\nx : \u03b1\nh : (swap x x).support = {x, x}\n\u22a2 False"
      },
      {
        "tactic": "simp [Finset.ext_iff] at h",
        "annotated_tactic": [
          "simp [<a>Finset.ext_iff</a>] at h",
          [
            {
              "full_name": "Finset.ext_iff",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                234,
                9
              ],
              "def_end_pos": [
                234,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\nx : \u03b1\nh : (swap x x).support = {x, x}\n\u22a2 False",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.2757146389922127,
    "entry_failed": false
  },
  "24556": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",
    "full_name": "SimpleGraph.Subgraph.Connected.induce_verts",
    "start": [
      174,
      1
    ],
    "end": [
      177,
      50
    ],
    "traced_tactics": [
      {
        "tactic": "rw [connected_induce_iff]",
        "annotated_tactic": [
          "rw [<a>connected_induce_iff</a>]",
          [
            {
              "full_name": "SimpleGraph.connected_induce_iff",
              "def_path": "Mathlib/Combinatorics/SimpleGraph/Connectivity/Subgraph.lean",
              "def_pos": [
                158,
                7
              ],
              "def_end_pos": [
                158,
                27
              ]
            }
          ]
        ],
        "state_before": "V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nH : G.Subgraph\nh : H.Connected\n\u22a2 (SimpleGraph.induce H.verts G).Connected",
        "state_after": "V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nH : G.Subgraph\nh : H.Connected\n\u22a2 (\u22a4.induce H.verts).Connected"
      },
      {
        "tactic": "exact h.mono le_induce_top_verts (by exact rfl)",
        "annotated_tactic": [
          "exact h.mono <a>le_induce_top_verts</a> (by exact <a>rfl</a>)",
          [
            {
              "full_name": "SimpleGraph.Subgraph.le_induce_top_verts",
              "def_path": "Mathlib/Combinatorics/SimpleGraph/Subgraph.lean",
              "def_pos": [
                1202,
                7
              ],
              "def_end_pos": [
                1202,
                26
              ]
            },
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nH : G.Subgraph\nh : H.Connected\n\u22a2 (\u22a4.induce H.verts).Connected",
        "state_after": "no goals"
      },
      {
        "tactic": "exact rfl",
        "annotated_tactic": [
          "exact <a>rfl</a>",
          [
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nH : G.Subgraph\nh : H.Connected\n\u22a2 H.verts = (\u22a4.induce H.verts).verts",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6611114300321788,
    "entry_failed": false
  },
  "24566": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Instances/Real.lean",
    "full_name": "Int.tendsto_coe_cofinite",
    "start": [
      223,
      1
    ],
    "end": [
      226,
      17
    ],
    "traced_tactics": [
      {
        "tactic": "apply (castAddHom \u211d).tendsto_coe_cofinite_of_discrete cast_injective",
        "annotated_tactic": [
          "apply (<a>castAddHom</a> \u211d).<a>tendsto_coe_cofinite_of_discrete</a> <a>cast_injective</a>",
          [
            {
              "full_name": "Int.castAddHom",
              "def_path": "Mathlib/Data/Int/Cast/Lemmas.lean",
              "def_pos": [
                49,
                5
              ],
              "def_end_pos": [
                49,
                15
              ]
            },
            {
              "full_name": "AddMonoidHom.tendsto_coe_cofinite_of_discrete",
              "def_path": "Mathlib/Topology/Algebra/UniformGroup.lean",
              "def_pos": [
                612,
                3
              ],
              "def_end_pos": [
                612,
                14
              ]
            },
            {
              "full_name": "Int.cast_injective",
              "def_path": "Mathlib/Data/Int/Cast/Lemmas.lean",
              "def_pos": [
                79,
                7
              ],
              "def_end_pos": [
                79,
                21
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u22a2 Tendsto Int.cast Filter.cofinite (cocompact \u211d)",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u22a2 DiscreteTopology \u21a5(castAddHom \u211d).range"
      },
      {
        "tactic": "rw [range_castAddHom]",
        "annotated_tactic": [
          "rw [<a>range_castAddHom</a>]",
          [
            {
              "full_name": "Int.range_castAddHom",
              "def_path": "Mathlib/Algebra/Group/Subgroup/ZPowers.lean",
              "def_pos": [
                167,
                15
              ],
              "def_end_pos": [
                167,
                35
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u22a2 DiscreteTopology \u21a5(castAddHom \u211d).range",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u22a2 DiscreteTopology \u21a5(AddSubgroup.zmultiples 1)"
      },
      {
        "tactic": "infer_instance",
        "annotated_tactic": [
          "infer_instance",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u22a2 DiscreteTopology \u21a5(AddSubgroup.zmultiples 1)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.5753938290290534,
    "entry_failed": false
  },
  "24649": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Finset/Image.lean",
    "full_name": "Finset.mem_image_const",
    "start": [
      374,
      1
    ],
    "end": [
      377,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "rw [mem_image]",
        "annotated_tactic": [
          "rw [<a>mem_image</a>]",
          [
            {
              "full_name": "Finset.mem_image",
              "def_path": "Mathlib/Data/Finset/Image.lean",
              "def_pos": [
                357,
                9
              ],
              "def_end_pos": [
                357,
                18
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b2\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\nt : Finset \u03b2\na : \u03b1\nb c : \u03b2\n\u22a2 c \u2208 image (const \u03b1 b) s \u2194 s.Nonempty \u2227 b = c",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b2\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\nt : Finset \u03b2\na : \u03b1\nb c : \u03b2\n\u22a2 (\u2203 a \u2208 s, const \u03b1 b a = c) \u2194 s.Nonempty \u2227 b = c"
      },
      {
        "tactic": "simp only [exists_prop, const_apply, exists_and_right]",
        "annotated_tactic": [
          "simp only [<a>exists_prop</a>, <a>const_apply</a>, <a>exists_and_right</a>]",
          [
            {
              "full_name": "exists_prop",
              "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean",
              "def_pos": [
                307,
                17
              ],
              "def_end_pos": [
                307,
                28
              ]
            },
            {
              "full_name": "Function.const_apply",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                33,
                17
              ],
              "def_end_pos": [
                33,
                37
              ]
            },
            {
              "full_name": "exists_and_right",
              "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean",
              "def_pos": [
                291,
                17
              ],
              "def_end_pos": [
                291,
                33
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b2\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\nt : Finset \u03b2\na : \u03b1\nb c : \u03b2\n\u22a2 (\u2203 a \u2208 s, const \u03b1 b a = c) \u2194 s.Nonempty \u2227 b = c",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b2\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\nt : Finset \u03b2\na : \u03b1\nb c : \u03b2\n\u22a2 (\u2203 x, x \u2208 s) \u2227 b = c \u2194 s.Nonempty \u2227 b = c"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b2\nf g : \u03b1 \u2192 \u03b2\ns : Finset \u03b1\nt : Finset \u03b2\na : \u03b1\nb c : \u03b2\n\u22a2 (\u2203 x, x \u2208 s) \u2227 b = c \u2194 s.Nonempty \u2227 b = c",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.5449099160032347,
    "entry_failed": false
  },
  "24670": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/LinearAlgebra/CliffordAlgebra/Equivs.lean",
    "full_name": "CliffordAlgebraComplex.toComplex_comp_ofComplex",
    "start": [
      182,
      1
    ],
    "end": [
      185,
      42
    ],
    "traced_tactics": [
      {
        "tactic": "ext1",
        "annotated_tactic": [
          "ext1",
          []
        ],
        "state_before": "\u22a2 toComplex.comp ofComplex = AlgHom.id \u211d \u2102",
        "state_after": "case h\n\n\u22a2 (toComplex.comp ofComplex) Complex.I = (AlgHom.id \u211d \u2102) Complex.I"
      },
      {
        "tactic": "dsimp only [AlgHom.comp_apply, Subtype.coe_mk, AlgHom.id_apply]",
        "annotated_tactic": [
          "dsimp only [<a>AlgHom.comp_apply</a>, <a>Subtype.coe_mk</a>, <a>AlgHom.id_apply</a>]",
          [
            {
              "full_name": "AlgHom.comp_apply",
              "def_path": "Mathlib/Algebra/Algebra/Hom.lean",
              "def_pos": [
                324,
                9
              ],
              "def_end_pos": [
                324,
                19
              ]
            },
            {
              "full_name": "Subtype.coe_mk",
              "def_path": "Mathlib/Data/Subtype.lean",
              "def_pos": [
                108,
                9
              ],
              "def_end_pos": [
                108,
                15
              ]
            },
            {
              "full_name": "AlgHom.id_apply",
              "def_path": "Mathlib/Algebra/Algebra/Hom.lean",
              "def_pos": [
                309,
                9
              ],
              "def_end_pos": [
                309,
                17
              ]
            }
          ]
        ],
        "state_before": "case h\n\n\u22a2 (toComplex.comp ofComplex) Complex.I = (AlgHom.id \u211d \u2102) Complex.I",
        "state_after": "case h\n\n\u22a2 toComplex (ofComplex Complex.I) = Complex.I"
      },
      {
        "tactic": "rw [ofComplex_I, toComplex_\u03b9, one_smul]",
        "annotated_tactic": [
          "rw [<a>ofComplex_I</a>, <a>toComplex_\u03b9</a>, <a>one_smul</a>]",
          [
            {
              "full_name": "CliffordAlgebraComplex.ofComplex_I",
              "def_path": "Mathlib/LinearAlgebra/CliffordAlgebra/Equivs.lean",
              "def_pos": [
                176,
                9
              ],
              "def_end_pos": [
                176,
                20
              ]
            },
            {
              "full_name": "CliffordAlgebraComplex.toComplex_\u03b9",
              "def_path": "Mathlib/LinearAlgebra/CliffordAlgebra/Equivs.lean",
              "def_pos": [
                151,
                9
              ],
              "def_end_pos": [
                151,
                20
              ]
            },
            {
              "full_name": "one_smul",
              "def_path": "Mathlib/Algebra/Group/Action/Defs.lean",
              "def_pos": [
                453,
                7
              ],
              "def_end_pos": [
                453,
                15
              ]
            }
          ]
        ],
        "state_before": "case h\n\n\u22a2 toComplex (ofComplex Complex.I) = Complex.I",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.128216835903004,
    "entry_failed": false
  },
  "24767": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/HahnSeries/Addition.lean",
    "full_name": "HahnSeries.order_neg",
    "start": [
      177,
      1
    ],
    "end": [
      180,
      46
    ],
    "traced_tactics": [
      {
        "tactic": "by_cases hf : f = 0",
        "annotated_tactic": [
          "by_cases hf : f = 0",
          []
        ],
        "state_before": "\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : AddGroup R\ninst\u271d : Zero \u0393\nf : HahnSeries \u0393 R\n\u22a2 (-f).order = f.order",
        "state_after": "case pos\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : AddGroup R\ninst\u271d : Zero \u0393\nf : HahnSeries \u0393 R\nhf : f = 0\n\u22a2 (-f).order = f.order\n\ncase neg\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : AddGroup R\ninst\u271d : Zero \u0393\nf : HahnSeries \u0393 R\nhf : \u00acf = 0\n\u22a2 (-f).order = f.order"
      },
      {
        "tactic": "simp only [order, support_neg, neg_eq_zero]",
        "annotated_tactic": [
          "simp only [<a>order</a>, <a>support_neg</a>, <a>neg_eq_zero</a>]",
          [
            {
              "full_name": "HahnSeries.order",
              "def_path": "Mathlib/RingTheory/HahnSeries/Basic.lean",
              "def_pos": [
                296,
                5
              ],
              "def_end_pos": [
                296,
                10
              ]
            },
            {
              "full_name": "HahnSeries.support_neg",
              "def_path": "Mathlib/RingTheory/HahnSeries/Addition.lean",
              "def_pos": [
                161,
                9
              ],
              "def_end_pos": [
                161,
                20
              ]
            },
            {
              "full_name": "neg_eq_zero",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                634,
                3
              ],
              "def_end_pos": [
                634,
                14
              ]
            }
          ]
        ],
        "state_before": "case neg\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : AddGroup R\ninst\u271d : Zero \u0393\nf : HahnSeries \u0393 R\nhf : \u00acf = 0\n\u22a2 (-f).order = f.order",
        "state_after": "no goals"
      },
      {
        "tactic": "simp only [hf, neg_zero]",
        "annotated_tactic": [
          "simp only [hf, <a>neg_zero</a>]",
          [
            {
              "full_name": "neg_zero",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                1117,
                3
              ],
              "def_end_pos": [
                1117,
                14
              ]
            }
          ]
        ],
        "state_before": "case pos\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b2 : PartialOrder \u0393\ninst\u271d\u00b9 : AddGroup R\ninst\u271d : Zero \u0393\nf : HahnSeries \u0393 R\nhf : f = 0\n\u22a2 (-f).order = f.order",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.522372193983756,
    "entry_failed": false
  },
  "24804": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/PNat/Prime.lean",
    "full_name": "PNat.Coprime.symm",
    "start": [
      257,
      1
    ],
    "end": [
      260,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "unfold Coprime",
        "annotated_tactic": [
          "unfold <a>Coprime</a>",
          [
            {
              "full_name": "PNat.Coprime",
              "def_path": "Mathlib/Data/PNat/Prime.lean",
              "def_pos": [
                181,
                5
              ],
              "def_end_pos": [
                181,
                12
              ]
            }
          ]
        ],
        "state_before": "m n : \u2115+\n\u22a2 m.Coprime n \u2192 n.Coprime m",
        "state_after": "m n : \u2115+\n\u22a2 m.gcd n = 1 \u2192 n.gcd m = 1"
      },
      {
        "tactic": "rw [gcd_comm]",
        "annotated_tactic": [
          "rw [<a>gcd_comm</a>]",
          [
            {
              "full_name": "PNat.gcd_comm",
              "def_path": "Mathlib/Data/PNat/Prime.lean",
              "def_pos": [
                204,
                9
              ],
              "def_end_pos": [
                204,
                17
              ]
            }
          ]
        ],
        "state_before": "m n : \u2115+\n\u22a2 m.gcd n = 1 \u2192 n.gcd m = 1",
        "state_after": "m n : \u2115+\n\u22a2 n.gcd m = 1 \u2192 n.gcd m = 1"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "m n : \u2115+\n\u22a2 n.gcd m = 1 \u2192 n.gcd m = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7857136009261012,
    "entry_failed": false
  },
  "24824": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Probability/Distributions/Gamma.lean",
    "full_name": "ProbabilityTheory.gammaCDFReal_eq_lintegral",
    "start": [
      147,
      1
    ],
    "end": [
      151,
      75
    ],
    "traced_tactics": [
      {
        "tactic": "have : IsProbabilityMeasure (gammaMeasure a r) := isProbabilityMeasureGamma ha hr",
        "annotated_tactic": [
          "have : <a>IsProbabilityMeasure</a> (<a>gammaMeasure</a> a r) := <a>isProbabilityMeasureGamma</a> ha hr",
          [
            {
              "full_name": "MeasureTheory.IsProbabilityMeasure",
              "def_path": "Mathlib/MeasureTheory/Measure/Typeclasses.lean",
              "def_pos": [
                233,
                7
              ],
              "def_end_pos": [
                233,
                27
              ]
            },
            {
              "full_name": "ProbabilityTheory.gammaMeasure",
              "def_path": "Mathlib/Probability/Distributions/Gamma.lean",
              "def_pos": [
                125,
                5
              ],
              "def_end_pos": [
                125,
                17
              ]
            },
            {
              "full_name": "ProbabilityTheory.isProbabilityMeasureGamma",
              "def_path": "Mathlib/Probability/Distributions/Gamma.lean",
              "def_pos": [
                128,
                7
              ],
              "def_end_pos": [
                128,
                32
              ]
            }
          ]
        ],
        "state_before": "a r : \u211d\nha : 0 < a\nhr : 0 < r\nx : \u211d\n\u22a2 \u2191(gammaCDFReal a r) x = (\u222b\u207b (x : \u211d) in Iic x, gammaPDF a r x).toReal",
        "state_after": "a r : \u211d\nha : 0 < a\nhr : 0 < r\nx : \u211d\nthis : IsProbabilityMeasure (gammaMeasure a r)\n\u22a2 \u2191(gammaCDFReal a r) x = (\u222b\u207b (x : \u211d) in Iic x, gammaPDF a r x).toReal"
      },
      {
        "tactic": "simp only [gammaPDF, gammaCDFReal, cdf_eq_toReal]",
        "annotated_tactic": [
          "simp only [<a>gammaPDF</a>, <a>gammaCDFReal</a>, <a>cdf_eq_toReal</a>]",
          [
            {
              "full_name": "ProbabilityTheory.gammaPDF",
              "def_path": "Mathlib/Probability/Distributions/Gamma.lean",
              "def_pos": [
                48,
                5
              ],
              "def_end_pos": [
                48,
                13
              ]
            },
            {
              "full_name": "ProbabilityTheory.gammaCDFReal",
              "def_path": "Mathlib/Probability/Distributions/Gamma.lean",
              "def_pos": [
                136,
                5
              ],
              "def_end_pos": [
                136,
                17
              ]
            },
            {
              "full_name": "ProbabilityTheory.cdf_eq_toReal",
              "def_path": "Mathlib/Probability/Cdf.lean",
              "def_pos": [
                78,
                7
              ],
              "def_end_pos": [
                78,
                20
              ]
            }
          ]
        ],
        "state_before": "a r : \u211d\nha : 0 < a\nhr : 0 < r\nx : \u211d\nthis : IsProbabilityMeasure (gammaMeasure a r)\n\u22a2 \u2191(gammaCDFReal a r) x = (\u222b\u207b (x : \u211d) in Iic x, gammaPDF a r x).toReal",
        "state_after": "a r : \u211d\nha : 0 < a\nhr : 0 < r\nx : \u211d\nthis : IsProbabilityMeasure (gammaMeasure a r)\n\u22a2 ((gammaMeasure a r) (Iic x)).toReal = (\u222b\u207b (x : \u211d) in Iic x, ENNReal.ofReal (gammaPDFReal a r x)).toReal"
      },
      {
        "tactic": "simp only [gammaMeasure, measurableSet_Iic, withDensity_apply, gammaPDF]",
        "annotated_tactic": [
          "simp only [<a>gammaMeasure</a>, <a>measurableSet_Iic</a>, <a>withDensity_apply</a>, <a>gammaPDF</a>]",
          [
            {
              "full_name": "ProbabilityTheory.gammaMeasure",
              "def_path": "Mathlib/Probability/Distributions/Gamma.lean",
              "def_pos": [
                125,
                5
              ],
              "def_end_pos": [
                125,
                17
              ]
            },
            {
              "full_name": "measurableSet_Iic",
              "def_path": "Mathlib/MeasureTheory/Constructions/BorelSpace/Order.lean",
              "def_pos": [
                116,
                9
              ],
              "def_end_pos": [
                116,
                26
              ]
            },
            {
              "full_name": "MeasureTheory.withDensity_apply",
              "def_path": "Mathlib/MeasureTheory/Measure/WithDensity.lean",
              "def_pos": [
                39,
                9
              ],
              "def_end_pos": [
                39,
                26
              ]
            },
            {
              "full_name": "ProbabilityTheory.gammaPDF",
              "def_path": "Mathlib/Probability/Distributions/Gamma.lean",
              "def_pos": [
                48,
                5
              ],
              "def_end_pos": [
                48,
                13
              ]
            }
          ]
        ],
        "state_before": "a r : \u211d\nha : 0 < a\nhr : 0 < r\nx : \u211d\nthis : IsProbabilityMeasure (gammaMeasure a r)\n\u22a2 ((gammaMeasure a r) (Iic x)).toReal = (\u222b\u207b (x : \u211d) in Iic x, ENNReal.ofReal (gammaPDFReal a r x)).toReal",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.6458349330350757,
    "entry_failed": false
  },
  "24825": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean",
    "full_name": "Polynomial.cyclotomic.irreducible",
    "start": [
      199,
      1
    ],
    "end": [
      202,
      57
    ],
    "traced_tactics": [
      {
        "tactic": "rw [cyclotomic_eq_minpoly (isPrimitiveRoot_exp n hpos.ne') hpos]",
        "annotated_tactic": [
          "rw [<a>cyclotomic_eq_minpoly</a> (<a>isPrimitiveRoot_exp</a> n hpos.ne') hpos]",
          [
            {
              "full_name": "Polynomial.cyclotomic_eq_minpoly",
              "def_path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Roots.lean",
              "def_pos": [
                184,
                9
              ],
              "def_end_pos": [
                184,
                30
              ]
            },
            {
              "full_name": "Complex.isPrimitiveRoot_exp",
              "def_path": "Mathlib/RingTheory/RootsOfUnity/Complex.lean",
              "def_pos": [
                53,
                9
              ],
              "def_end_pos": [
                53,
                28
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d : CommRing R\nn\u271d n : \u2115\nhpos : 0 < n\n\u22a2 Irreducible (cyclotomic n \u2124)",
        "state_after": "R : Type u_1\ninst\u271d : CommRing R\nn\u271d n : \u2115\nhpos : 0 < n\n\u22a2 Irreducible (minpoly \u2124 (cexp (2 * \u2191Real.pi * I / \u2191n)))"
      },
      {
        "tactic": "apply minpoly.irreducible",
        "annotated_tactic": [
          "apply <a>minpoly.irreducible</a>",
          [
            {
              "full_name": "minpoly.irreducible",
              "def_path": "Mathlib/FieldTheory/Minpoly/Basic.lean",
              "def_pos": [
                275,
                9
              ],
              "def_end_pos": [
                275,
                20
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d : CommRing R\nn\u271d n : \u2115\nhpos : 0 < n\n\u22a2 Irreducible (minpoly \u2124 (cexp (2 * \u2191Real.pi * I / \u2191n)))",
        "state_after": "case hx\nR : Type u_1\ninst\u271d : CommRing R\nn\u271d n : \u2115\nhpos : 0 < n\n\u22a2 IsIntegral \u2124 (cexp (2 * \u2191Real.pi * I / \u2191n))"
      },
      {
        "tactic": "exact (isPrimitiveRoot_exp n hpos.ne').isIntegral hpos",
        "annotated_tactic": [
          "exact (<a>isPrimitiveRoot_exp</a> n hpos.ne').<a>isIntegral</a> hpos",
          [
            {
              "full_name": "Complex.isPrimitiveRoot_exp",
              "def_path": "Mathlib/RingTheory/RootsOfUnity/Complex.lean",
              "def_pos": [
                53,
                9
              ],
              "def_end_pos": [
                53,
                28
              ]
            },
            {
              "full_name": "IsPrimitiveRoot.isIntegral",
              "def_path": "Mathlib/RingTheory/RootsOfUnity/Minpoly.lean",
              "def_pos": [
                40,
                9
              ],
              "def_end_pos": [
                40,
                19
              ]
            }
          ]
        ],
        "state_before": "case hx\nR : Type u_1\ninst\u271d : CommRing R\nn\u271d n : \u2115\nhpos : 0 < n\n\u22a2 IsIntegral \u2124 (cexp (2 * \u2191Real.pi * I / \u2191n))",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.622191777918488,
    "entry_failed": false
  },
  "24868": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Quandle.lean",
    "full_name": "Rack.ad_conj",
    "start": [
      251,
      1
    ],
    "end": [
      253,
      26
    ],
    "traced_tactics": [
      {
        "tactic": "rw [eq_mul_inv_iff_mul_eq]",
        "annotated_tactic": [
          "rw [<a>eq_mul_inv_iff_mul_eq</a>]",
          [
            {
              "full_name": "eq_mul_inv_iff_mul_eq",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                944,
                9
              ],
              "def_end_pos": [
                944,
                30
              ]
            }
          ]
        ],
        "state_before": "R\u271d : Type u_1\ninst\u271d\u00b9 : Rack R\u271d\nR : Type u_2\ninst\u271d : Rack R\nx y : R\n\u22a2 act' (x \u25c3 y) = act' x * act' y * (act' x)\u207b\u00b9",
        "state_after": "R\u271d : Type u_1\ninst\u271d\u00b9 : Rack R\u271d\nR : Type u_2\ninst\u271d : Rack R\nx y : R\n\u22a2 act' (x \u25c3 y) * act' x = act' x * act' y"
      },
      {
        "tactic": "ext z",
        "annotated_tactic": [
          "ext z",
          []
        ],
        "state_before": "R\u271d : Type u_1\ninst\u271d\u00b9 : Rack R\u271d\nR : Type u_2\ninst\u271d : Rack R\nx y : R\n\u22a2 act' (x \u25c3 y) * act' x = act' x * act' y",
        "state_after": "case H\nR\u271d : Type u_1\ninst\u271d\u00b9 : Rack R\u271d\nR : Type u_2\ninst\u271d : Rack R\nx y z : R\n\u22a2 (act' (x \u25c3 y) * act' x) z = (act' x * act' y) z"
      },
      {
        "tactic": "apply self_distrib.symm",
        "annotated_tactic": [
          "apply self_distrib.symm",
          []
        ],
        "state_before": "case H\nR\u271d : Type u_1\ninst\u271d\u00b9 : Rack R\u271d\nR : Type u_2\ninst\u271d : Rack R\nx y z : R\n\u22a2 (act' (x \u25c3 y) * act' x) z = (act' x * act' y) z",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.001850137952715,
    "entry_failed": false
  },
  "24877": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/Groupoid/Subgroupoid.lean",
    "full_name": "CategoryTheory.Subgroupoid.subset_generated",
    "start": [
      384,
      1
    ],
    "end": [
      387,
      35
    ],
    "traced_tactics": [
      {
        "tactic": "dsimp only [generated, sInf]",
        "annotated_tactic": [
          "dsimp only [<a>generated</a>, <a>sInf</a>]",
          [
            {
              "full_name": "CategoryTheory.Subgroupoid.generated",
              "def_path": "Mathlib/CategoryTheory/Groupoid/Subgroupoid.lean",
              "def_pos": [
                380,
                5
              ],
              "def_end_pos": [
                380,
                14
              ]
            },
            {
              "full_name": "InfSet.sInf",
              "def_path": "Mathlib/Order/SetNotation.lean",
              "def_pos": [
                50,
                3
              ],
              "def_end_pos": [
                50,
                7
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d : Groupoid C\nS : Subgroupoid C\nX : (c d : C) \u2192 Set (c \u27f6 d)\nc d : C\n\u22a2 X c d \u2286 (generated X).arrows c d",
        "state_after": "C : Type u\ninst\u271d : Groupoid C\nS : Subgroupoid C\nX : (c d : C) \u2192 Set (c \u27f6 d)\nc d : C\n\u22a2 X c d \u2286 \u22c2 S \u2208 {S | \u2200 (c d : C), X c d \u2286 S.arrows c d}, S.arrows c d"
      },
      {
        "tactic": "simp only [subset_iInter\u2082_iff]",
        "annotated_tactic": [
          "simp only [<a>subset_iInter\u2082_iff</a>]",
          [
            {
              "full_name": "Set.subset_iInter\u2082_iff",
              "def_path": "Mathlib/Data/Set/Lattice.lean",
              "def_pos": [
                274,
                9
              ],
              "def_end_pos": [
                274,
                27
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d : Groupoid C\nS : Subgroupoid C\nX : (c d : C) \u2192 Set (c \u27f6 d)\nc d : C\n\u22a2 X c d \u2286 \u22c2 S \u2208 {S | \u2200 (c d : C), X c d \u2286 S.arrows c d}, S.arrows c d",
        "state_after": "C : Type u\ninst\u271d : Groupoid C\nS : Subgroupoid C\nX : (c d : C) \u2192 Set (c \u27f6 d)\nc d : C\n\u22a2 \u2200 i \u2208 {S | \u2200 (c d : C), X c d \u2286 S.arrows c d}, X c d \u2286 i.arrows c d"
      },
      {
        "tactic": "exact fun S hS f fS => hS _ _ fS",
        "annotated_tactic": [
          "exact fun S hS f fS => hS _ _ fS",
          []
        ],
        "state_before": "C : Type u\ninst\u271d : Groupoid C\nS : Subgroupoid C\nX : (c d : C) \u2192 Set (c \u27f6 d)\nc d : C\n\u22a2 \u2200 i \u2208 {S | \u2200 (c d : C), X c d \u2286 S.arrows c d}, X c d \u2286 i.arrows c d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.320770705933683,
    "entry_failed": false
  },
  "24878": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/CharP/ExpChar.lean",
    "full_name": "char_zero_of_expChar_one",
    "start": [
      105,
      1
    ],
    "end": [
      108,
      49
    ],
    "traced_tactics": [
      {
        "tactic": "cases hq",
        "annotated_tactic": [
          "cases hq",
          []
        ],
        "state_before": "R : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Nontrivial R\np : \u2115\nhp : CharP R p\nhq : ExpChar R 1\n\u22a2 p = 0",
        "state_after": "case zero\nR : Type u\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Nontrivial R\np : \u2115\nhp : CharP R p\ninst\u271d : CharZero R\n\u22a2 p = 0\n\ncase prime\nR : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Nontrivial R\np : \u2115\nhp : CharP R p\nhprime\u271d : Nat.Prime 1\nhchar\u271d : CharP R 1\n\u22a2 p = 0"
      },
      {
        "tactic": "exact CharP.eq R hp inferInstance",
        "annotated_tactic": [
          "exact <a>CharP.eq</a> R hp <a>inferInstance</a>",
          [
            {
              "full_name": "CharP.eq",
              "def_path": "Mathlib/Algebra/CharP/Defs.lean",
              "def_pos": [
                75,
                7
              ],
              "def_end_pos": [
                75,
                9
              ]
            },
            {
              "full_name": "inferInstance",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                99,
                8
              ],
              "def_end_pos": [
                99,
                21
              ]
            }
          ]
        ],
        "state_before": "case zero\nR : Type u\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : Nontrivial R\np : \u2115\nhp : CharP R p\ninst\u271d : CharZero R\n\u22a2 p = 0",
        "state_after": "no goals"
      },
      {
        "tactic": "exact False.elim (CharP.char_ne_one R 1 rfl)",
        "annotated_tactic": [
          "exact <a>False.elim</a> (<a>CharP.char_ne_one</a> R 1 <a>rfl</a>)",
          [
            {
              "full_name": "False.elim",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                236,
                21
              ],
              "def_end_pos": [
                236,
                31
              ]
            },
            {
              "full_name": "CharP.char_ne_one",
              "def_path": "Mathlib/Algebra/CharP/Defs.lean",
              "def_pos": [
                253,
                7
              ],
              "def_end_pos": [
                253,
                18
              ]
            },
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "case prime\nR : Type u\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Nontrivial R\np : \u2115\nhp : CharP R p\nhprime\u271d : Nat.Prime 1\nhchar\u271d : CharP R 1\n\u22a2 p = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8532864310545847,
    "entry_failed": false
  },
  "24955": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Category/Compactum.lean",
    "full_name": "Compactum.join_distrib",
    "start": [
      157,
      1
    ],
    "end": [
      161,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "change ((\u03b2 ).\u03bc.app _ \u226b X.a) _ = _",
        "annotated_tactic": [
          "change ((\u03b2 ).\u03bc.app _ \u226b X.a) _ = _",
          []
        ],
        "state_before": "X : Compactum\nuux : Ultrafilter (Ultrafilter X.A)\n\u22a2 X.str (X.join uux) = X.str (Ultrafilter.map X.str uux)",
        "state_after": "X : Compactum\nuux : Ultrafilter (Ultrafilter X.A)\n\u22a2 (\u03b2.\u03bc.app X.A \u226b X.a) uux = X.str (Ultrafilter.map X.str uux)"
      },
      {
        "tactic": "rw [Monad.Algebra.assoc]",
        "annotated_tactic": [
          "rw [<a>Monad.Algebra.assoc</a>]",
          [
            {
              "full_name": "CategoryTheory.Monad.Algebra.assoc",
              "def_path": "Mathlib/CategoryTheory/Monad/Algebra.lean",
              "def_pos": [
                48,
                3
              ],
              "def_end_pos": [
                48,
                8
              ]
            }
          ]
        ],
        "state_before": "X : Compactum\nuux : Ultrafilter (Ultrafilter X.A)\n\u22a2 (\u03b2.\u03bc.app X.A \u226b X.a) uux = X.str (Ultrafilter.map X.str uux)",
        "state_after": "X : Compactum\nuux : Ultrafilter (Ultrafilter X.A)\n\u22a2 (\u03b2.map X.a \u226b X.a) uux = X.str (Ultrafilter.map X.str uux)"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "X : Compactum\nuux : Ultrafilter (Ultrafilter X.A)\n\u22a2 (\u03b2.map X.a \u226b X.a) uux = X.str (Ultrafilter.map X.str uux)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.3019426650134847,
    "entry_failed": false
  },
  "25032": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/Convex/GaugeRescale.lean",
    "full_name": "gauge_gaugeRescale_le",
    "start": [
      69,
      1
    ],
    "end": [
      73,
      40
    ],
    "traced_tactics": [
      {
        "tactic": "by_cases hx : gauge t x = 0",
        "annotated_tactic": [
          "by_cases hx : <a>gauge</a> t x = 0",
          [
            {
              "full_name": "gauge",
              "def_path": "Mathlib/Analysis/Convex/Gauge.lean",
              "def_pos": [
                54,
                5
              ],
              "def_end_pos": [
                54,
                10
              ]
            }
          ]
        ],
        "state_before": "E : Type u_1\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \u211d E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : T1Space E\ns t : Set E\nx : E\n\u22a2 gauge t (gaugeRescale s t x) \u2264 gauge s x",
        "state_after": "case pos\nE : Type u_1\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \u211d E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : T1Space E\ns t : Set E\nx : E\nhx : gauge t x = 0\n\u22a2 gauge t (gaugeRescale s t x) \u2264 gauge s x\n\ncase neg\nE : Type u_1\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \u211d E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : T1Space E\ns t : Set E\nx : E\nhx : \u00acgauge t x = 0\n\u22a2 gauge t (gaugeRescale s t x) \u2264 gauge s x"
      },
      {
        "tactic": "simp [gaugeRescale, hx, gauge_nonneg]",
        "annotated_tactic": [
          "simp [<a>gaugeRescale</a>, hx, <a>gauge_nonneg</a>]",
          [
            {
              "full_name": "gaugeRescale",
              "def_path": "Mathlib/Analysis/Convex/GaugeRescale.lean",
              "def_pos": [
                33,
                5
              ],
              "def_end_pos": [
                33,
                17
              ]
            },
            {
              "full_name": "gauge_nonneg",
              "def_path": "Mathlib/Analysis/Convex/Gauge.lean",
              "def_pos": [
                125,
                9
              ],
              "def_end_pos": [
                125,
                21
              ]
            }
          ]
        ],
        "state_before": "case pos\nE : Type u_1\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \u211d E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : T1Space E\ns t : Set E\nx : E\nhx : gauge t x = 0\n\u22a2 gauge t (gaugeRescale s t x) \u2264 gauge s x",
        "state_after": "no goals"
      },
      {
        "tactic": "exact (gauge_gaugeRescale' s hx).le",
        "annotated_tactic": [
          "exact (<a>gauge_gaugeRescale'</a> s hx).<a>le</a>",
          [
            {
              "full_name": "gauge_gaugeRescale'",
              "def_path": "Mathlib/Analysis/Convex/GaugeRescale.lean",
              "def_pos": [
                58,
                9
              ],
              "def_end_pos": [
                58,
                28
              ]
            },
            {
              "full_name": "Eq.le",
              "def_path": "Mathlib/Order/Basic.lean",
              "def_pos": [
                154,
                7
              ],
              "def_end_pos": [
                154,
                12
              ]
            }
          ]
        ],
        "state_before": "case neg\nE : Type u_1\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \u211d E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : T1Space E\ns t : Set E\nx : E\nhx : \u00acgauge t x = 0\n\u22a2 gauge t (gaugeRescale s t x) \u2264 gauge s x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.539752926910296,
    "entry_failed": false
  },
  "25079": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/LinearAlgebra/Basis/Flag.lean",
    "full_name": "Basis.flag_covBy",
    "start": [
      94,
      1
    ],
    "end": [
      98,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "rw [flag_succ]",
        "annotated_tactic": [
          "rw [<a>flag_succ</a>]",
          [
            {
              "full_name": "Basis.flag_succ",
              "def_path": "Mathlib/LinearAlgebra/Basis/Flag.lean",
              "def_pos": [
                42,
                9
              ],
              "def_end_pos": [
                42,
                18
              ]
            }
          ]
        ],
        "state_before": "K : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nn : \u2115\nb : Basis (Fin n) K V\ni : Fin n\n\u22a2 b.flag i.castSucc \u22d6 b.flag i.succ",
        "state_after": "K : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nn : \u2115\nb : Basis (Fin n) K V\ni : Fin n\n\u22a2 b.flag i.castSucc \u22d6 span K {b i} \u2294 b.flag i.castSucc"
      },
      {
        "tactic": "apply covBy_span_singleton_sup",
        "annotated_tactic": [
          "apply <a>covBy_span_singleton_sup</a>",
          [
            {
              "full_name": "Submodule.covBy_span_singleton_sup",
              "def_path": "Mathlib/LinearAlgebra/Span.lean",
              "def_pos": [
                1001,
                9
              ],
              "def_end_pos": [
                1001,
                33
              ]
            }
          ]
        ],
        "state_before": "K : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nn : \u2115\nb : Basis (Fin n) K V\ni : Fin n\n\u22a2 b.flag i.castSucc \u22d6 span K {b i} \u2294 b.flag i.castSucc",
        "state_after": "case h\nK : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nn : \u2115\nb : Basis (Fin n) K V\ni : Fin n\n\u22a2 b i \u2209 b.flag i.castSucc"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case h\nK : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module K V\nn : \u2115\nb : Basis (Fin n) K V\ni : Fin n\n\u22a2 b i \u2209 b.flag i.castSucc",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.390411892090924,
    "entry_failed": false
  },
  "25118": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Bits.lean",
    "full_name": "Nat.pos_of_bit0_pos",
    "start": [
      403,
      1
    ],
    "end": [
      406,
      19
    ],
    "traced_tactics": [
      {
        "tactic": "cases n",
        "annotated_tactic": [
          "cases n",
          []
        ],
        "state_before": "m n\u271d n : \u2115\nh : 0 < bit0 n\n\u22a2 0 < n",
        "state_after": "case zero\nm n : \u2115\nh : 0 < bit0 0\n\u22a2 0 < 0\n\ncase succ\nm n n\u271d : \u2115\nh : 0 < bit0 (n\u271d + 1)\n\u22a2 0 < n\u271d + 1"
      },
      {
        "tactic": "cases h",
        "annotated_tactic": [
          "cases h",
          []
        ],
        "state_before": "case zero\nm n : \u2115\nh : 0 < bit0 0\n\u22a2 0 < 0",
        "state_after": "no goals"
      },
      {
        "tactic": "apply succ_pos",
        "annotated_tactic": [
          "apply <a>succ_pos</a>",
          [
            {
              "full_name": "Nat.succ_pos",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                1693,
                9
              ],
              "def_end_pos": [
                1693,
                21
              ]
            }
          ]
        ],
        "state_before": "case succ\nm n n\u271d : \u2115\nh : 0 < bit0 (n\u271d + 1)\n\u22a2 0 < n\u271d + 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.170760234934278,
    "entry_failed": false
  },
  "25129": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Ring/Parity.lean",
    "full_name": "Even.add_odd",
    "start": [
      129,
      1
    ],
    "end": [
      130,
      81
    ],
    "traced_tactics": [
      {
        "tactic": "rintro \u27e8a, rfl\u27e9 \u27e8b, rfl\u27e9",
        "annotated_tactic": [
          "rintro \u27e8a, rfl\u27e9 \u27e8b, rfl\u27e9",
          []
        ],
        "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : Semiring \u03b2\na b : \u03b1\nm n : \u2115\n\u22a2 Even a \u2192 Odd b \u2192 Odd (a + b)",
        "state_after": "case intro.intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : Semiring \u03b2\nm n : \u2115\na b : \u03b1\n\u22a2 Odd (a + a + (2 * b + 1))"
      },
      {
        "tactic": "exact \u27e8a + b, by rw [mul_add, \u2190 two_mul, add_assoc]\u27e9",
        "annotated_tactic": [
          "exact \u27e8a + b, by rw [<a>mul_add</a>, \u2190 <a>two_mul</a>, <a>add_assoc</a>]\u27e9",
          [
            {
              "full_name": "mul_add",
              "def_path": "Mathlib/Algebra/Ring/Defs.lean",
              "def_pos": [
                83,
                7
              ],
              "def_end_pos": [
                83,
                14
              ]
            },
            {
              "full_name": "two_mul",
              "def_path": "Mathlib/Algebra/Ring/Defs.lean",
              "def_pos": [
                179,
                9
              ],
              "def_end_pos": [
                179,
                16
              ]
            },
            {
              "full_name": "add_assoc",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                288,
                3
              ],
              "def_end_pos": [
                288,
                14
              ]
            }
          ]
        ],
        "state_before": "case intro.intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : Semiring \u03b2\nm n : \u2115\na b : \u03b1\n\u22a2 Odd (a + a + (2 * b + 1))",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [mul_add, \u2190 two_mul, add_assoc]",
        "annotated_tactic": [
          "rw [<a>mul_add</a>, \u2190 <a>two_mul</a>, <a>add_assoc</a>]",
          [
            {
              "full_name": "mul_add",
              "def_path": "Mathlib/Algebra/Ring/Defs.lean",
              "def_pos": [
                83,
                7
              ],
              "def_end_pos": [
                83,
                14
              ]
            },
            {
              "full_name": "two_mul",
              "def_path": "Mathlib/Algebra/Ring/Defs.lean",
              "def_pos": [
                179,
                9
              ],
              "def_end_pos": [
                179,
                16
              ]
            },
            {
              "full_name": "add_assoc",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                288,
                3
              ],
              "def_end_pos": [
                288,
                14
              ]
            }
          ]
        ],
        "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : Semiring \u03b2\nm n : \u2115\na b : \u03b1\n\u22a2 a + a + (2 * b + 1) = 2 * (a + b) + 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8720203569391742,
    "entry_failed": false
  },
  "25166": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/Abelian/Basic.lean",
    "full_name": "CategoryTheory.Abelian.epi_of_cokernel_\u03c0_eq_zero",
    "start": [
      332,
      1
    ],
    "end": [
      335,
      81
    ],
    "traced_tactics": [
      {
        "tactic": "apply NormalMonoCategory.epi_of_zero_cokernel _ (cokernel f)",
        "annotated_tactic": [
          "apply <a>NormalMonoCategory.epi_of_zero_cokernel</a> _ (<a>cokernel</a> f)",
          [
            {
              "full_name": "CategoryTheory.NormalMonoCategory.epi_of_zero_cokernel",
              "def_path": "Mathlib/CategoryTheory/Limits/Shapes/NormalMono/Equalizers.lean",
              "def_pos": [
                152,
                9
              ],
              "def_end_pos": [
                152,
                29
              ]
            },
            {
              "full_name": "CategoryTheory.Limits.cokernel",
              "def_path": "Mathlib/CategoryTheory/Limits/Shapes/Kernels.lean",
              "def_pos": [
                746,
                8
              ],
              "def_end_pos": [
                746,
                16
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Abelian C\nP Q : C\nf : P \u27f6 Q\nh : cokernel.\u03c0 f = 0\n\u22a2 Epi f",
        "state_after": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Abelian C\nP Q : C\nf : P \u27f6 Q\nh : cokernel.\u03c0 f = 0\n\u22a2 IsColimit (CokernelCofork.of\u03c0 0 \u22ef)"
      },
      {
        "tactic": "simp_rw [\u2190 h]",
        "annotated_tactic": [
          "simp_rw [\u2190 h]",
          []
        ],
        "state_before": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Abelian C\nP Q : C\nf : P \u27f6 Q\nh : cokernel.\u03c0 f = 0\n\u22a2 IsColimit (CokernelCofork.of\u03c0 0 \u22ef)",
        "state_after": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Abelian C\nP Q : C\nf : P \u27f6 Q\nh : cokernel.\u03c0 f = 0\n\u22a2 IsColimit (CokernelCofork.of\u03c0 (cokernel.\u03c0 f) \u22ef)"
      },
      {
        "tactic": "exact IsColimit.ofIsoColimit (colimit.isColimit (parallelPair f 0)) (isoOf\u03c0 _)",
        "annotated_tactic": [
          "exact <a>IsColimit.ofIsoColimit</a> (<a>colimit.isColimit</a> (<a>parallelPair</a> f 0)) (<a>isoOf\u03c0</a> _)",
          [
            {
              "full_name": "CategoryTheory.Limits.IsColimit.ofIsoColimit",
              "def_path": "Mathlib/CategoryTheory/Limits/IsLimit.lean",
              "def_pos": [
                689,
                5
              ],
              "def_end_pos": [
                689,
                17
              ]
            },
            {
              "full_name": "CategoryTheory.Limits.colimit.isColimit",
              "def_path": "Mathlib/CategoryTheory/Limits/HasLimits.lean",
              "def_pos": [
                764,
                5
              ],
              "def_end_pos": [
                764,
                22
              ]
            },
            {
              "full_name": "CategoryTheory.Limits.parallelPair",
              "def_path": "Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean",
              "def_pos": [
                209,
                5
              ],
              "def_end_pos": [
                209,
                17
              ]
            },
            {
              "full_name": "CategoryTheory.Limits.isoOf\u03c0",
              "def_path": "Mathlib/CategoryTheory/Limits/Shapes/Kernels.lean",
              "def_pos": [
                597,
                5
              ],
              "def_end_pos": [
                597,
                11
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : Abelian C\nP Q : C\nf : P \u27f6 Q\nh : cokernel.\u03c0 f = 0\n\u22a2 IsColimit (CokernelCofork.of\u03c0 (cokernel.\u03c0 f) \u22ef)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.167277744039893,
    "entry_failed": false
  },
  "25196": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Computability/EpsilonNFA.lean",
    "full_name": "\u03b5NFA.evalFrom_empty",
    "start": [
      116,
      1
    ],
    "end": [
      119,
      54
    ],
    "traced_tactics": [
      {
        "tactic": "induction' x using List.reverseRecOn with x a ih",
        "annotated_tactic": [
          "induction' x using <a>List.reverseRecOn</a> with x a ih",
          [
            {
              "full_name": "List.reverseRecOn",
              "def_path": "Mathlib/Data/List/Basic.lean",
              "def_pos": [
                921,
                5
              ],
              "def_end_pos": [
                921,
                17
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03c3 \u03c3' : Type v\nM : \u03b5NFA \u03b1 \u03c3\nS : Set \u03c3\nx\u271d : List \u03b1\ns : \u03c3\na : \u03b1\nx : List \u03b1\n\u22a2 M.evalFrom \u2205 x = \u2205",
        "state_after": "case nil\n\u03b1 : Type u\n\u03c3 \u03c3' : Type v\nM : \u03b5NFA \u03b1 \u03c3\nS : Set \u03c3\nx : List \u03b1\ns : \u03c3\na : \u03b1\n\u22a2 M.evalFrom \u2205 [] = \u2205\n\ncase append_singleton\n\u03b1 : Type u\n\u03c3 \u03c3' : Type v\nM : \u03b5NFA \u03b1 \u03c3\nS : Set \u03c3\nx\u271d : List \u03b1\ns : \u03c3\na\u271d : \u03b1\nx : List \u03b1\na : \u03b1\nih : M.evalFrom \u2205 x = \u2205\n\u22a2 M.evalFrom \u2205 (x ++ [a]) = \u2205"
      },
      {
        "tactic": "rw [evalFrom_nil, \u03b5Closure_empty]",
        "annotated_tactic": [
          "rw [<a>evalFrom_nil</a>, <a>\u03b5Closure_empty</a>]",
          [
            {
              "full_name": "\u03b5NFA.evalFrom_nil",
              "def_path": "Mathlib/Computability/EpsilonNFA.lean",
              "def_pos": [
                100,
                9
              ],
              "def_end_pos": [
                100,
                21
              ]
            },
            {
              "full_name": "\u03b5NFA.\u03b5Closure_empty",
              "def_path": "Mathlib/Computability/EpsilonNFA.lean",
              "def_pos": [
                65,
                9
              ],
              "def_end_pos": [
                65,
                23
              ]
            }
          ]
        ],
        "state_before": "case nil\n\u03b1 : Type u\n\u03c3 \u03c3' : Type v\nM : \u03b5NFA \u03b1 \u03c3\nS : Set \u03c3\nx : List \u03b1\ns : \u03c3\na : \u03b1\n\u22a2 M.evalFrom \u2205 [] = \u2205",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [evalFrom_append_singleton, ih, stepSet_empty]",
        "annotated_tactic": [
          "rw [<a>evalFrom_append_singleton</a>, ih, <a>stepSet_empty</a>]",
          [
            {
              "full_name": "\u03b5NFA.evalFrom_append_singleton",
              "def_path": "Mathlib/Computability/EpsilonNFA.lean",
              "def_pos": [
                110,
                9
              ],
              "def_end_pos": [
                110,
                34
              ]
            },
            {
              "full_name": "\u03b5NFA.stepSet_empty",
              "def_path": "Mathlib/Computability/EpsilonNFA.lean",
              "def_pos": [
                87,
                9
              ],
              "def_end_pos": [
                87,
                22
              ]
            }
          ]
        ],
        "state_before": "case append_singleton\n\u03b1 : Type u\n\u03c3 \u03c3' : Type v\nM : \u03b5NFA \u03b1 \u03c3\nS : Set \u03c3\nx\u271d : List \u03b1\ns : \u03c3\na\u271d : \u03b1\nx : List \u03b1\na : \u03b1\nih : M.evalFrom \u2205 x = \u2205\n\u22a2 M.evalFrom \u2205 (x ++ [a]) = \u2205",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4203594049904495,
    "entry_failed": false
  },
  "25208": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Partial.lean",
    "full_name": "rtendsto'_nhds",
    "start": [
      30,
      1
    ],
    "end": [
      34,
      26
    ],
    "traced_tactics": [
      {
        "tactic": "rw [rtendsto'_def]",
        "annotated_tactic": [
          "rw [<a>rtendsto'_def</a>]",
          [
            {
              "full_name": "Filter.rtendsto'_def",
              "def_path": "Mathlib/Order/Filter/Partial.lean",
              "def_pos": [
                188,
                9
              ],
              "def_end_pos": [
                188,
                22
              ]
            }
          ]
        ],
        "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nr : Rel Y X\nl : Filter Y\nx : X\n\u22a2 RTendsto' r l (\ud835\udcdd x) \u2194 \u2200 (s : Set X), IsOpen s \u2192 x \u2208 s \u2192 r.preimage s \u2208 l",
        "state_after": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nr : Rel Y X\nl : Filter Y\nx : X\n\u22a2 (\u2200 s \u2208 \ud835\udcdd x, r.preimage s \u2208 l) \u2194 \u2200 (s : Set X), IsOpen s \u2192 x \u2208 s \u2192 r.preimage s \u2208 l"
      },
      {
        "tactic": "apply all_mem_nhds_filter",
        "annotated_tactic": [
          "apply <a>all_mem_nhds_filter</a>",
          [
            {
              "full_name": "all_mem_nhds_filter",
              "def_path": "Mathlib/Topology/Basic.lean",
              "def_pos": [
                975,
                9
              ],
              "def_end_pos": [
                975,
                28
              ]
            }
          ]
        ],
        "state_before": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nr : Rel Y X\nl : Filter Y\nx : X\n\u22a2 (\u2200 s \u2208 \ud835\udcdd x, r.preimage s \u2208 l) \u2194 \u2200 (s : Set X), IsOpen s \u2192 x \u2208 s \u2192 r.preimage s \u2208 l",
        "state_after": "case hf\nX : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nr : Rel Y X\nl : Filter Y\nx : X\n\u22a2 \u2200 (s t : Set X), s \u2286 t \u2192 r.preimage s \u2286 r.preimage t"
      },
      {
        "tactic": "apply Rel.preimage_mono",
        "annotated_tactic": [
          "apply <a>Rel.preimage_mono</a>",
          [
            {
              "full_name": "Rel.preimage_mono",
              "def_path": "Mathlib/Data/Rel.lean",
              "def_pos": [
                238,
                9
              ],
              "def_end_pos": [
                238,
                22
              ]
            }
          ]
        ],
        "state_before": "case hf\nX : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nr : Rel Y X\nl : Filter Y\nx : X\n\u22a2 \u2200 (s t : Set X), s \u2286 t \u2192 r.preimage s \u2286 r.preimage t",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2499782500090078,
    "entry_failed": false
  },
  "25246": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Disjoint.lean",
    "full_name": "Codisjoint.ne_bot_of_ne_top'",
    "start": [
      316,
      1
    ],
    "end": [
      317,
      43
    ],
    "traced_tactics": [
      {
        "tactic": "rintro rfl",
        "annotated_tactic": [
          "rintro rfl",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : BoundedOrder \u03b1\na b : \u03b1\nh : Codisjoint a b\nhb : b \u2260 \u22a4\n\u22a2 a \u2260 \u22a5",
        "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : BoundedOrder \u03b1\nb : \u03b1\nhb : b \u2260 \u22a4\nh : Codisjoint \u22a5 b\n\u22a2 False"
      },
      {
        "tactic": "exact hb <| by simpa using h",
        "annotated_tactic": [
          "exact hb <| by simpa using h",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : BoundedOrder \u03b1\nb : \u03b1\nhb : b \u2260 \u22a4\nh : Codisjoint \u22a5 b\n\u22a2 False",
        "state_after": "no goals"
      },
      {
        "tactic": "simpa using h",
        "annotated_tactic": [
          "simpa using h",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : BoundedOrder \u03b1\nb : \u03b1\nhb : b \u2260 \u22a4\nh : Codisjoint \u22a5 b\n\u22a2 b = \u22a4",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.037195059005171,
    "entry_failed": false
  },
  "25285": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Prod.lean",
    "full_name": "SimpleGraph.Connected.ofBoxProdLeft",
    "start": [
      204,
      11
    ],
    "end": [
      207,
      39
    ],
    "traced_tactics": [
      {
        "tactic": "haveI := (nonempty_prod.1 h.nonempty).1",
        "annotated_tactic": [
          "haveI := (<a>nonempty_prod</a>.1 h.nonempty).1",
          [
            {
              "full_name": "nonempty_prod",
              "def_path": "Mathlib/Logic/Nonempty.lean",
              "def_pos": [
                175,
                9
              ],
              "def_end_pos": [
                175,
                22
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nh : (G \u25a1 H).Connected\n\u22a2 G.Connected",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nh : (G \u25a1 H).Connected\nthis : Nonempty \u03b1\n\u22a2 G.Connected"
      },
      {
        "tactic": "haveI := (nonempty_prod.1 h.nonempty).2",
        "annotated_tactic": [
          "haveI := (<a>nonempty_prod</a>.1 h.nonempty).2",
          [
            {
              "full_name": "nonempty_prod",
              "def_path": "Mathlib/Logic/Nonempty.lean",
              "def_pos": [
                175,
                9
              ],
              "def_end_pos": [
                175,
                22
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nh : (G \u25a1 H).Connected\nthis : Nonempty \u03b1\n\u22a2 G.Connected",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nh : (G \u25a1 H).Connected\nthis\u271d : Nonempty \u03b1\nthis : Nonempty \u03b2\n\u22a2 G.Connected"
      },
      {
        "tactic": "exact \u27e8h.preconnected.ofBoxProdLeft\u27e9",
        "annotated_tactic": [
          "exact \u27e8h.preconnected.ofBoxProdLeft\u27e9",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nG : SimpleGraph \u03b1\nH : SimpleGraph \u03b2\nh : (G \u25a1 H).Connected\nthis\u271d : Nonempty \u03b1\nthis : Nonempty \u03b2\n\u22a2 G.Connected",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.0261383729521185,
    "entry_failed": false
  },
  "25286": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/PNat/Factors.lean",
    "full_name": "PNat.factorMultiset_ofPrime",
    "start": [
      311,
      1
    ],
    "end": [
      315,
      64
    ],
    "traced_tactics": [
      {
        "tactic": "apply factorMultisetEquiv.symm.injective",
        "annotated_tactic": [
          "apply factorMultisetEquiv.symm.injective",
          []
        ],
        "state_before": "p : Nat.Primes\n\u22a2 (\u2191p).factorMultiset = PrimeMultiset.ofPrime p",
        "state_after": "case a\np : Nat.Primes\n\u22a2 factorMultisetEquiv.symm (\u2191p).factorMultiset = factorMultisetEquiv.symm (PrimeMultiset.ofPrime p)"
      },
      {
        "tactic": "change (p : \u2115+).factorMultiset.prod = (PrimeMultiset.ofPrime p).prod",
        "annotated_tactic": [
          "change (p : \u2115+).factorMultiset.prod = (<a>PrimeMultiset.ofPrime</a> p).<a>prod</a>",
          [
            {
              "full_name": "PrimeMultiset.ofPrime",
              "def_path": "Mathlib/Data/PNat/Factors.lean",
              "def_pos": [
                47,
                5
              ],
              "def_end_pos": [
                47,
                12
              ]
            },
            {
              "full_name": "PrimeMultiset.prod",
              "def_path": "Mathlib/Data/PNat/Factors.lean",
              "def_pos": [
                137,
                5
              ],
              "def_end_pos": [
                137,
                9
              ]
            }
          ]
        ],
        "state_before": "case a\np : Nat.Primes\n\u22a2 factorMultisetEquiv.symm (\u2191p).factorMultiset = factorMultisetEquiv.symm (PrimeMultiset.ofPrime p)",
        "state_after": "case a\np : Nat.Primes\n\u22a2 (\u2191p).factorMultiset.prod = (PrimeMultiset.ofPrime p).prod"
      },
      {
        "tactic": "rw [(p : \u2115+).prod_factorMultiset, PrimeMultiset.prod_ofPrime]",
        "annotated_tactic": [
          "rw [(p : \u2115+).<a>prod_factorMultiset</a>, <a>PrimeMultiset.prod_ofPrime</a>]",
          [
            {
              "full_name": "PNat.prod_factorMultiset",
              "def_path": "Mathlib/Data/PNat/Factors.lean",
              "def_pos": [
                241,
                9
              ],
              "def_end_pos": [
                241,
                28
              ]
            },
            {
              "full_name": "PrimeMultiset.prod_ofPrime",
              "def_path": "Mathlib/Data/PNat/Factors.lean",
              "def_pos": [
                149,
                9
              ],
              "def_end_pos": [
                149,
                21
              ]
            }
          ]
        ],
        "state_before": "case a\np : Nat.Primes\n\u22a2 (\u2191p).factorMultiset.prod = (PrimeMultiset.ofPrime p).prod",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.285446783993393,
    "entry_failed": false
  },
  "25311": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Antidiag/Prod.lean",
    "full_name": "Finset.antidiagonal.fst_le",
    "start": [
      134,
      1
    ],
    "end": [
      137,
      41
    ],
    "traced_tactics": [
      {
        "tactic": "rw [le_iff_exists_add]",
        "annotated_tactic": [
          "rw [<a>le_iff_exists_add</a>]",
          [
            {
              "full_name": "le_iff_exists_add",
              "def_path": "Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean",
              "def_pos": [
                190,
                3
              ],
              "def_end_pos": [
                190,
                14
              ]
            }
          ]
        ],
        "state_before": "A : Type u_1\ninst\u271d\u00b9 : CanonicallyOrderedAddCommMonoid A\ninst\u271d : HasAntidiagonal A\nn : A\nkl : A \u00d7 A\nhlk : kl \u2208 antidiagonal n\n\u22a2 kl.1 \u2264 n",
        "state_after": "A : Type u_1\ninst\u271d\u00b9 : CanonicallyOrderedAddCommMonoid A\ninst\u271d : HasAntidiagonal A\nn : A\nkl : A \u00d7 A\nhlk : kl \u2208 antidiagonal n\n\u22a2 \u2203 c, n = kl.1 + c"
      },
      {
        "tactic": "use kl.2",
        "annotated_tactic": [
          "use kl.2",
          []
        ],
        "state_before": "A : Type u_1\ninst\u271d\u00b9 : CanonicallyOrderedAddCommMonoid A\ninst\u271d : HasAntidiagonal A\nn : A\nkl : A \u00d7 A\nhlk : kl \u2208 antidiagonal n\n\u22a2 \u2203 c, n = kl.1 + c",
        "state_after": "case h\nA : Type u_1\ninst\u271d\u00b9 : CanonicallyOrderedAddCommMonoid A\ninst\u271d : HasAntidiagonal A\nn : A\nkl : A \u00d7 A\nhlk : kl \u2208 antidiagonal n\n\u22a2 n = kl.1 + kl.2"
      },
      {
        "tactic": "rwa [mem_antidiagonal, eq_comm] at hlk",
        "annotated_tactic": [
          "rwa [<a>mem_antidiagonal</a>, <a>eq_comm</a>] at hlk",
          [
            {
              "full_name": "Finset.HasAntidiagonal.mem_antidiagonal",
              "def_path": "Mathlib/Algebra/Order/Antidiag/Prod.lean",
              "def_pos": [
                58,
                3
              ],
              "def_end_pos": [
                58,
                19
              ]
            },
            {
              "full_name": "eq_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                811,
                9
              ],
              "def_end_pos": [
                811,
                16
              ]
            }
          ]
        ],
        "state_before": "case h\nA : Type u_1\ninst\u271d\u00b9 : CanonicallyOrderedAddCommMonoid A\ninst\u271d : HasAntidiagonal A\nn : A\nkl : A \u00d7 A\nhlk : kl \u2208 antidiagonal n\n\u22a2 n = kl.1 + kl.2",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.455939383013174,
    "entry_failed": false
  },
  "25335": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/PrimeFin.lean",
    "full_name": "Nat.primeFactors_pow",
    "start": [
      114,
      1
    ],
    "end": [
      117,
      29
    ],
    "traced_tactics": [
      {
        "tactic": "cases k",
        "annotated_tactic": [
          "cases k",
          []
        ],
        "state_before": "a b k m n\u271d p n : \u2115\nhk : k \u2260 0\n\u22a2 (n ^ k).primeFactors = n.primeFactors",
        "state_after": "case zero\na b m n\u271d p n : \u2115\nhk : 0 \u2260 0\n\u22a2 (n ^ 0).primeFactors = n.primeFactors\n\ncase succ\na b m n\u271d\u00b9 p n n\u271d : \u2115\nhk : n\u271d + 1 \u2260 0\n\u22a2 (n ^ (n\u271d + 1)).primeFactors = n.primeFactors"
      },
      {
        "tactic": "rw [primeFactors_pow_succ]",
        "annotated_tactic": [
          "rw [<a>primeFactors_pow_succ</a>]",
          [
            {
              "full_name": "Nat.primeFactors_pow_succ",
              "def_path": "Mathlib/Data/Nat/PrimeFin.lean",
              "def_pos": [
                106,
                7
              ],
              "def_end_pos": [
                106,
                28
              ]
            }
          ]
        ],
        "state_before": "case succ\na b m n\u271d\u00b9 p n n\u271d : \u2115\nhk : n\u271d + 1 \u2260 0\n\u22a2 (n ^ (n\u271d + 1)).primeFactors = n.primeFactors",
        "state_after": "no goals"
      },
      {
        "tactic": "simp at hk",
        "annotated_tactic": [
          "simp at hk",
          []
        ],
        "state_before": "case zero\na b m n\u271d p n : \u2115\nhk : 0 \u2260 0\n\u22a2 (n ^ 0).primeFactors = n.primeFactors",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.70057467604056,
    "entry_failed": false
  },
  "25342": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/LSeries/Convergence.lean",
    "full_name": "LSeries.abscissaOfAbsConv_le_one_of_isBigO_one",
    "start": [
      116,
      1
    ],
    "end": [
      121,
      40
    ],
    "traced_tactics": [
      {
        "tactic": "convert abscissaOfAbsConv_le_of_isBigO_rpow (x := 0) ?_",
        "annotated_tactic": [
          "convert <a>abscissaOfAbsConv_le_of_isBigO_rpow</a> (x := 0) ?_",
          [
            {
              "full_name": "LSeries.abscissaOfAbsConv_le_of_isBigO_rpow",
              "def_path": "Mathlib/NumberTheory/LSeries/Convergence.lean",
              "def_pos": [
                99,
                7
              ],
              "def_end_pos": [
                99,
                50
              ]
            }
          ]
        ],
        "state_before": "f : \u2115 \u2192 \u2102\nh : f =O[atTop] 1\n\u22a2 abscissaOfAbsConv f \u2264 1",
        "state_after": "case h.e'_4\nf : \u2115 \u2192 \u2102\nh : f =O[atTop] 1\n\u22a2 1 = \u21910 + 1\n\ncase convert_2\nf : \u2115 \u2192 \u2102\nh : f =O[atTop] 1\n\u22a2 f =O[atTop] fun n => \u2191n ^ 0"
      },
      {
        "tactic": "simp only [EReal.coe_zero, zero_add]",
        "annotated_tactic": [
          "simp only [<a>EReal.coe_zero</a>, <a>zero_add</a>]",
          [
            {
              "full_name": "EReal.coe_zero",
              "def_path": "Mathlib/Data/Real/EReal.lean",
              "def_pos": [
                133,
                9
              ],
              "def_end_pos": [
                133,
                17
              ]
            },
            {
              "full_name": "zero_add",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                476,
                3
              ],
              "def_end_pos": [
                476,
                14
              ]
            }
          ]
        ],
        "state_before": "case h.e'_4\nf : \u2115 \u2192 \u2102\nh : f =O[atTop] 1\n\u22a2 1 = \u21910 + 1",
        "state_after": "no goals"
      },
      {
        "tactic": "simpa only [Real.rpow_zero] using h",
        "annotated_tactic": [
          "simpa only [<a>Real.rpow_zero</a>] using h",
          [
            {
              "full_name": "Real.rpow_zero",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean",
              "def_pos": [
                125,
                9
              ],
              "def_end_pos": [
                125,
                18
              ]
            }
          ]
        ],
        "state_before": "case convert_2\nf : \u2115 \u2192 \u2102\nh : f =O[atTop] 1\n\u22a2 f =O[atTop] fun n => \u2191n ^ 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.240113110980019,
    "entry_failed": false
  },
  "25348": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Seq/Seq.lean",
    "full_name": "Stream'.Seq.ofStream_cons",
    "start": [
      806,
      1
    ],
    "end": [
      807,
      70
    ],
    "traced_tactics": [
      {
        "tactic": "apply Subtype.eq",
        "annotated_tactic": [
          "apply <a>Subtype.eq</a>",
          [
            {
              "full_name": "Subtype.eq",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1110,
                19
              ],
              "def_end_pos": [
                1110,
                21
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\na : \u03b1\ns : Stream' \u03b1\n\u22a2 \u2191(a :: s) = cons a \u2191s",
        "state_after": "case a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\na : \u03b1\ns : Stream' \u03b1\n\u22a2 \u2191\u2191(a :: s) = \u2191(cons a \u2191s)"
      },
      {
        "tactic": "simp only [ofStream, cons]",
        "annotated_tactic": [
          "simp only [<a>ofStream</a>, <a>cons</a>]",
          [
            {
              "full_name": "Stream'.Seq.ofStream",
              "def_path": "Mathlib/Data/Seq/Seq.lean",
              "def_pos": [
                458,
                5
              ],
              "def_end_pos": [
                458,
                13
              ]
            },
            {
              "full_name": "Stream'.Seq.cons",
              "def_path": "Mathlib/Data/Seq/Seq.lean",
              "def_pos": [
                59,
                5
              ],
              "def_end_pos": [
                59,
                9
              ]
            }
          ]
        ],
        "state_before": "case a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\na : \u03b1\ns : Stream' \u03b1\n\u22a2 \u2191\u2191(a :: s) = \u2191(cons a \u2191s)",
        "state_after": "case a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\na : \u03b1\ns : Stream' \u03b1\n\u22a2 Stream'.map some (a :: s) = some a :: Stream'.map some s"
      },
      {
        "tactic": "rw [Stream'.map_cons]",
        "annotated_tactic": [
          "rw [<a>Stream'.map_cons</a>]",
          [
            {
              "full_name": "Stream'.map_cons",
              "def_path": "Mathlib/Data/Stream/Init.lean",
              "def_pos": [
                166,
                9
              ],
              "def_end_pos": [
                166,
                17
              ]
            }
          ]
        ],
        "state_before": "case a\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\na : \u03b1\ns : Stream' \u03b1\n\u22a2 Stream'.map some (a :: s) = some a :: Stream'.map some s",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.5642484209965914,
    "entry_failed": false
  },
  "25351": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Nilpotent/Defs.lean",
    "full_name": "IsNilpotent.of_pow",
    "start": [
      64,
      1
    ],
    "end": [
      68,
      26
    ],
    "traced_tactics": [
      {
        "tactic": "obtain \u27e8n, h\u27e9 := h",
        "annotated_tactic": [
          "obtain \u27e8n, h\u27e9 := h",
          []
        ],
        "state_before": "R : Type u_1\nS : Type u_2\nx\u271d y : R\ninst\u271d : MonoidWithZero R\nx : R\nm : \u2115\nh : IsNilpotent (x ^ m)\n\u22a2 IsNilpotent x",
        "state_after": "case intro\nR : Type u_1\nS : Type u_2\nx\u271d y : R\ninst\u271d : MonoidWithZero R\nx : R\nm n : \u2115\nh : (x ^ m) ^ n = 0\n\u22a2 IsNilpotent x"
      },
      {
        "tactic": "use m*n",
        "annotated_tactic": [
          "use m*n",
          []
        ],
        "state_before": "case intro\nR : Type u_1\nS : Type u_2\nx\u271d y : R\ninst\u271d : MonoidWithZero R\nx : R\nm n : \u2115\nh : (x ^ m) ^ n = 0\n\u22a2 IsNilpotent x",
        "state_after": "case h\nR : Type u_1\nS : Type u_2\nx\u271d y : R\ninst\u271d : MonoidWithZero R\nx : R\nm n : \u2115\nh : (x ^ m) ^ n = 0\n\u22a2 x ^ (m * n) = 0"
      },
      {
        "tactic": "rw [\u2190 h, pow_mul x m n]",
        "annotated_tactic": [
          "rw [\u2190 h, <a>pow_mul</a> x m n]",
          [
            {
              "full_name": "pow_mul",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                713,
                32
              ],
              "def_end_pos": [
                713,
                39
              ]
            }
          ]
        ],
        "state_before": "case h\nR : Type u_1\nS : Type u_2\nx\u271d y : R\ninst\u271d : MonoidWithZero R\nx : R\nm n : \u2115\nh : (x ^ m) ^ n = 0\n\u22a2 x ^ (m * n) = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.3701012060046196,
    "entry_failed": false
  },
  "25369": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Perm/Cycle/Concrete.lean",
    "full_name": "Equiv.Perm.pow_apply_mem_toList_iff_mem_support",
    "start": [
      346,
      1
    ],
    "end": [
      349,
      26
    ],
    "traced_tactics": [
      {
        "tactic": "rw [mem_toList_iff, and_iff_right_iff_imp]",
        "annotated_tactic": [
          "rw [<a>mem_toList_iff</a>, <a>and_iff_right_iff_imp</a>]",
          [
            {
              "full_name": "Equiv.Perm.mem_toList_iff",
              "def_path": "Mathlib/GroupTheory/Perm/Cycle/Concrete.lean",
              "def_pos": [
                265,
                9
              ],
              "def_end_pos": [
                265,
                23
              ]
            },
            {
              "full_name": "and_iff_right_iff_imp",
              "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean",
              "def_pos": [
                165,
                17
              ],
              "def_end_pos": [
                165,
                38
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\np : Perm \u03b1\nx : \u03b1\nn : \u2115\n\u22a2 (p ^ n) x \u2208 p.toList x \u2194 x \u2208 p.support",
        "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\np : Perm \u03b1\nx : \u03b1\nn : \u2115\n\u22a2 x \u2208 p.support \u2192 p.SameCycle x ((p ^ n) x)"
      },
      {
        "tactic": "refine fun _ => SameCycle.symm ?_",
        "annotated_tactic": [
          "refine fun _ => <a>SameCycle.symm</a> ?_",
          [
            {
              "full_name": "Equiv.Perm.SameCycle.symm",
              "def_path": "Mathlib/GroupTheory/Perm/Cycle/Basic.lean",
              "def_pos": [
                68,
                9
              ],
              "def_end_pos": [
                68,
                23
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\np : Perm \u03b1\nx : \u03b1\nn : \u2115\n\u22a2 x \u2208 p.support \u2192 p.SameCycle x ((p ^ n) x)",
        "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\np : Perm \u03b1\nx : \u03b1\nn : \u2115\nx\u271d : x \u2208 p.support\n\u22a2 p.SameCycle ((p ^ n) x) x"
      },
      {
        "tactic": "rw [sameCycle_pow_left]",
        "annotated_tactic": [
          "rw [<a>sameCycle_pow_left</a>]",
          [
            {
              "full_name": "Equiv.Perm.sameCycle_pow_left",
              "def_path": "Mathlib/GroupTheory/Perm/Cycle/Basic.lean",
              "def_pos": [
                157,
                9
              ],
              "def_end_pos": [
                157,
                27
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\np : Perm \u03b1\nx : \u03b1\nn : \u2115\nx\u271d : x \u2208 p.support\n\u22a2 p.SameCycle ((p ^ n) x) x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.5207644859328866,
    "entry_failed": false
  },
  "25430": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": ".lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "full_name": "String.prev_of_valid",
    "start": [
      235,
      1
    ],
    "end": [
      239,
      37
    ],
    "traced_tactics": [
      {
        "tactic": "simp only [prev]",
        "annotated_tactic": [
          "simp only [<a>prev</a>]",
          [
            {
              "full_name": "String.prev",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/String/Basic.lean",
              "def_pos": [
                220,
                5
              ],
              "def_end_pos": [
                220,
                9
              ]
            }
          ]
        ],
        "state_before": "cs : List Char\nc : Char\ncs' : List Char\n\u22a2 { data := cs ++ c :: cs' }.prev { byteIdx := utf8Len cs + c.utf8Size } = { byteIdx := utf8Len cs }",
        "state_after": "cs : List Char\nc : Char\ncs' : List Char\n\u22a2 (if { byteIdx := utf8Len cs + c.utf8Size } = 0 then 0\n    else utf8PrevAux (cs ++ c :: cs') 0 { byteIdx := utf8Len cs + c.utf8Size }) =\n    { byteIdx := utf8Len cs }"
      },
      {
        "tactic": "refine (if_neg (Pos.ne_of_gt add_csize_pos)).trans ?_",
        "annotated_tactic": [
          "refine (<a>if_neg</a> (<a>Pos.ne_of_gt</a> <a>add_csize_pos</a>)).<a>trans</a> ?_",
          [
            {
              "full_name": "if_neg",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                937,
                9
              ],
              "def_end_pos": [
                937,
                15
              ]
            },
            {
              "full_name": "String.Pos.ne_of_gt",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/String/Basic.lean",
              "def_pos": [
                1160,
                9
              ],
              "def_end_pos": [
                1160,
                17
              ]
            },
            {
              "full_name": "_private.\u00ab.lake\u00bb.packages.batteries.Batteries.Data.String.Lemmas.0.String.add_csize_pos",
              "def_path": ".lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
              "def_pos": [
                37,
                17
              ],
              "def_end_pos": [
                37,
                30
              ]
            },
            {
              "full_name": "Eq.trans",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                335,
                9
              ],
              "def_end_pos": [
                335,
                17
              ]
            }
          ]
        ],
        "state_before": "cs : List Char\nc : Char\ncs' : List Char\n\u22a2 (if { byteIdx := utf8Len cs + c.utf8Size } = 0 then 0\n    else utf8PrevAux (cs ++ c :: cs') 0 { byteIdx := utf8Len cs + c.utf8Size }) =\n    { byteIdx := utf8Len cs }",
        "state_after": "cs : List Char\nc : Char\ncs' : List Char\n\u22a2 utf8PrevAux (cs ++ c :: cs') 0 { byteIdx := utf8Len cs + c.utf8Size } = { byteIdx := utf8Len cs }"
      },
      {
        "tactic": "rw [utf8PrevAux_of_valid] <;> simp",
        "annotated_tactic": [
          "rw [<a>utf8PrevAux_of_valid</a>] <;> simp",
          [
            {
              "full_name": "String.utf8PrevAux_of_valid",
              "def_path": ".lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
              "def_pos": [
                220,
                9
              ],
              "def_end_pos": [
                220,
                29
              ]
            }
          ]
        ],
        "state_before": "cs : List Char\nc : Char\ncs' : List Char\n\u22a2 utf8PrevAux (cs ++ c :: cs') 0 { byteIdx := utf8Len cs + c.utf8Size } = { byteIdx := utf8Len cs }",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.8263337989337742,
    "entry_failed": false
  },
  "25444": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Ordinal/FixedPoint.lean",
    "full_name": "Ordinal.nfpFamily_le_apply",
    "start": [
      102,
      1
    ],
    "end": [
      106,
      33
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 not_iff_not]",
        "annotated_tactic": [
          "rw [\u2190 <a>not_iff_not</a>]",
          [
            {
              "full_name": "not_iff_not",
              "def_path": "Mathlib/Logic/Basic.lean",
              "def_pos": [
                447,
                9
              ],
              "def_end_pos": [
                447,
                20
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\ninst\u271d : Nonempty \u03b9\nH : \u2200 (i : \u03b9), IsNormal (f i)\na b : Ordinal.{max u v}\n\u22a2 (\u2203 i, nfpFamily f a \u2264 f i b) \u2194 nfpFamily f a \u2264 b",
        "state_after": "\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\ninst\u271d : Nonempty \u03b9\nH : \u2200 (i : \u03b9), IsNormal (f i)\na b : Ordinal.{max u v}\n\u22a2 (\u00ac\u2203 i, nfpFamily f a \u2264 f i b) \u2194 \u00acnfpFamily f a \u2264 b"
      },
      {
        "tactic": "push_neg",
        "annotated_tactic": [
          "push_neg",
          []
        ],
        "state_before": "\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\ninst\u271d : Nonempty \u03b9\nH : \u2200 (i : \u03b9), IsNormal (f i)\na b : Ordinal.{max u v}\n\u22a2 (\u00ac\u2203 i, nfpFamily f a \u2264 f i b) \u2194 \u00acnfpFamily f a \u2264 b",
        "state_after": "\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\ninst\u271d : Nonempty \u03b9\nH : \u2200 (i : \u03b9), IsNormal (f i)\na b : Ordinal.{max u v}\n\u22a2 (\u2200 (i : \u03b9), f i b < nfpFamily f a) \u2194 b < nfpFamily f a"
      },
      {
        "tactic": "exact apply_lt_nfpFamily_iff H",
        "annotated_tactic": [
          "exact <a>apply_lt_nfpFamily_iff</a> H",
          [
            {
              "full_name": "Ordinal.apply_lt_nfpFamily_iff",
              "def_path": "Mathlib/SetTheory/Ordinal/FixedPoint.lean",
              "def_pos": [
                93,
                9
              ],
              "def_end_pos": [
                93,
                31
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}\ninst\u271d : Nonempty \u03b9\nH : \u2200 (i : \u03b9), IsNormal (f i)\na b : Ordinal.{max u v}\n\u22a2 (\u2200 (i : \u03b9), f i b < nfpFamily f a) \u2194 b < nfpFamily f a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9300636190455407,
    "entry_failed": false
  },
  "25563": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/Abelian/NonPreadditive.lean",
    "full_name": "CategoryTheory.NonPreadditiveAbelian.neg_sub'",
    "start": [
      405,
      1
    ],
    "end": [
      408,
      37
    ],
    "traced_tactics": [
      {
        "tactic": "rw [neg_def, neg_def]",
        "annotated_tactic": [
          "rw [<a>neg_def</a>, <a>neg_def</a>]",
          [
            {
              "full_name": "CategoryTheory.NonPreadditiveAbelian.neg_def",
              "def_path": "Mathlib/CategoryTheory/Abelian/NonPreadditive.lean",
              "def_pos": [
                347,
                9
              ],
              "def_end_pos": [
                347,
                16
              ]
            },
            {
              "full_name": "CategoryTheory.NonPreadditiveAbelian.neg_def",
              "def_path": "Mathlib/CategoryTheory/Abelian/NonPreadditive.lean",
              "def_pos": [
                347,
                9
              ],
              "def_end_pos": [
                347,
                16
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : NonPreadditiveAbelian C\nX Y : C\na b : X \u27f6 Y\n\u22a2 -(a - b) = -a + b",
        "state_after": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : NonPreadditiveAbelian C\nX Y : C\na b : X \u27f6 Y\n\u22a2 0 - (a - b) = 0 - a + b"
      },
      {
        "tactic": "conv_lhs => rw [\u2190 sub_self (0 : X \u27f6 Y)]",
        "annotated_tactic": [
          "conv_lhs => rw [\u2190 <a>sub_self</a> (0 : X \u27f6 Y)]",
          [
            {
              "full_name": "CategoryTheory.NonPreadditiveAbelian.sub_self",
              "def_path": "Mathlib/CategoryTheory/Abelian/NonPreadditive.lean",
              "def_pos": [
                358,
                9
              ],
              "def_end_pos": [
                358,
                17
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : NonPreadditiveAbelian C\nX Y : C\na b : X \u27f6 Y\n\u22a2 0 - (a - b) = 0 - a + b",
        "state_after": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : NonPreadditiveAbelian C\nX Y : C\na b : X \u27f6 Y\n\u22a2 0 - 0 - (a - b) = 0 - a + b"
      },
      {
        "tactic": "rw [sub_sub_sub, add_def, neg_def]",
        "annotated_tactic": [
          "rw [<a>sub_sub_sub</a>, <a>add_def</a>, <a>neg_def</a>]",
          [
            {
              "full_name": "CategoryTheory.NonPreadditiveAbelian.sub_sub_sub",
              "def_path": "Mathlib/CategoryTheory/Abelian/NonPreadditive.lean",
              "def_pos": [
                370,
                9
              ],
              "def_end_pos": [
                370,
                20
              ]
            },
            {
              "full_name": "CategoryTheory.NonPreadditiveAbelian.add_def",
              "def_path": "Mathlib/CategoryTheory/Abelian/NonPreadditive.lean",
              "def_pos": [
                344,
                9
              ],
              "def_end_pos": [
                344,
                16
              ]
            },
            {
              "full_name": "CategoryTheory.NonPreadditiveAbelian.neg_def",
              "def_path": "Mathlib/CategoryTheory/Abelian/NonPreadditive.lean",
              "def_pos": [
                347,
                9
              ],
              "def_end_pos": [
                347,
                16
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : NonPreadditiveAbelian C\nX Y : C\na b : X \u27f6 Y\n\u22a2 0 - 0 - (a - b) = 0 - a + b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.810139227076434,
    "entry_failed": false
  },
  "25642": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Real/GoldenRatio.lean",
    "full_name": "gold_mul_goldConj",
    "start": [
      57,
      1
    ],
    "end": [
      60,
      11
    ],
    "traced_tactics": [
      {
        "tactic": "field_simp",
        "annotated_tactic": [
          "field_simp",
          []
        ],
        "state_before": "\u22a2 \u03c6 * \u03c8 = -1",
        "state_after": "\u22a2 (1 + \u221a5) * (1 - \u221a5) = -(2 * 2)"
      },
      {
        "tactic": "rw [\u2190 sq_sub_sq]",
        "annotated_tactic": [
          "rw [\u2190 <a>sq_sub_sq</a>]",
          [
            {
              "full_name": "sq_sub_sq",
              "def_path": "Mathlib/Algebra/Ring/Commute.lean",
              "def_pos": [
                259,
                7
              ],
              "def_end_pos": [
                259,
                16
              ]
            }
          ]
        ],
        "state_before": "\u22a2 (1 + \u221a5) * (1 - \u221a5) = -(2 * 2)",
        "state_after": "\u22a2 1 ^ 2 - \u221a5 ^ 2 = -(2 * 2)"
      },
      {
        "tactic": "norm_num",
        "annotated_tactic": [
          "norm_num",
          []
        ],
        "state_before": "\u22a2 1 ^ 2 - \u221a5 ^ 2 = -(2 * 2)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.378398414934054,
    "entry_failed": false
  },
  "25653": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Real/Sign.lean",
    "full_name": "Real.sign_mul_pos_of_ne_zero",
    "start": [
      102,
      1
    ],
    "end": [
      105,
      32
    ],
    "traced_tactics": [
      {
        "tactic": "refine lt_of_le_of_ne (sign_mul_nonneg r) fun h => hr ?_",
        "annotated_tactic": [
          "refine <a>lt_of_le_of_ne</a> (<a>sign_mul_nonneg</a> r) fun h => hr ?_",
          [
            {
              "full_name": "lt_of_le_of_ne",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                198,
                9
              ],
              "def_end_pos": [
                198,
                23
              ]
            },
            {
              "full_name": "Real.sign_mul_nonneg",
              "def_path": "Mathlib/Data/Real/Sign.lean",
              "def_pos": [
                93,
                9
              ],
              "def_end_pos": [
                93,
                24
              ]
            }
          ]
        ],
        "state_before": "r : \u211d\nhr : r \u2260 0\n\u22a2 0 < r.sign * r",
        "state_after": "r : \u211d\nhr : r \u2260 0\nh : 0 = r.sign * r\n\u22a2 r = 0"
      },
      {
        "tactic": "have hs0 := (zero_eq_mul.mp h).resolve_right hr",
        "annotated_tactic": [
          "have hs0 := (zero_eq_mul.mp h).<a>resolve_right</a> hr",
          [
            {
              "full_name": "Or.resolve_right",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                556,
                9
              ],
              "def_end_pos": [
                556,
                25
              ]
            }
          ]
        ],
        "state_before": "r : \u211d\nhr : r \u2260 0\nh : 0 = r.sign * r\n\u22a2 r = 0",
        "state_after": "r : \u211d\nhr : r \u2260 0\nh : 0 = r.sign * r\nhs0 : r.sign = 0\n\u22a2 r = 0"
      },
      {
        "tactic": "exact sign_eq_zero_iff.mp hs0",
        "annotated_tactic": [
          "exact sign_eq_zero_iff.mp hs0",
          []
        ],
        "state_before": "r : \u211d\nhr : r \u2260 0\nh : 0 = r.sign * r\nhs0 : r.sign = 0\n\u22a2 r = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.440330743091181,
    "entry_failed": false
  },
  "25677": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Regular/Basic.lean",
    "full_name": "IsLeftRegular.mul_left_eq_zero_iff",
    "start": [
      288,
      1
    ],
    "end": [
      290,
      44
    ],
    "traced_tactics": [
      {
        "tactic": "nth_rw 1 [\u2190 mul_zero b]",
        "annotated_tactic": [
          "nth_rw 1 [\u2190 <a>mul_zero</a> b]",
          [
            {
              "full_name": "MulZeroClass.mul_zero",
              "def_path": "Mathlib/Algebra/GroupWithZero/Defs.lean",
              "def_pos": [
                39,
                3
              ],
              "def_end_pos": [
                39,
                11
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d : MulZeroClass R\na b : R\nhb : IsLeftRegular b\n\u22a2 b * a = 0 \u2194 a = 0",
        "state_after": "R : Type u_1\ninst\u271d : MulZeroClass R\na b : R\nhb : IsLeftRegular b\n\u22a2 b * a = b * 0 \u2194 a = 0"
      },
      {
        "tactic": "exact \u27e8fun h \u21a6 hb h, fun ha \u21a6 by rw [ha]\u27e9",
        "annotated_tactic": [
          "exact \u27e8fun h \u21a6 hb h, fun ha \u21a6 by rw [ha]\u27e9",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d : MulZeroClass R\na b : R\nhb : IsLeftRegular b\n\u22a2 b * a = b * 0 \u2194 a = 0",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [ha]",
        "annotated_tactic": [
          "rw [ha]",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d : MulZeroClass R\na b : R\nhb : IsLeftRegular b\nha : a = 0\n\u22a2 b * a = b * 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7139036890584975,
    "entry_failed": false
  },
  "25723": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/BigOperators/Group/Multiset.lean",
    "full_name": "Multiset.le_prod_of_mem",
    "start": [
      173,
      1
    ],
    "end": [
      176,
      40
    ],
    "traced_tactics": [
      {
        "tactic": "obtain \u27e8t, rfl\u27e9 := exists_cons_of_mem ha",
        "annotated_tactic": [
          "obtain \u27e8t, rfl\u27e9 := <a>exists_cons_of_mem</a> ha",
          [
            {
              "full_name": "Multiset.exists_cons_of_mem",
              "def_path": "Mathlib/Data/Multiset/Basic.lean",
              "def_pos": [
                267,
                9
              ],
              "def_end_pos": [
                267,
                27
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : CanonicallyOrderedCommMonoid \u03b1\nm : Multiset \u03b1\na : \u03b1\nha : a \u2208 m\n\u22a2 a \u2264 m.prod",
        "state_after": "case intro\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : CanonicallyOrderedCommMonoid \u03b1\na : \u03b1\nt : Multiset \u03b1\nha : a \u2208 a ::\u2098 t\n\u22a2 a \u2264 (a ::\u2098 t).prod"
      },
      {
        "tactic": "rw [prod_cons]",
        "annotated_tactic": [
          "rw [<a>prod_cons</a>]",
          [
            {
              "full_name": "Multiset.prod_cons",
              "def_path": "Mathlib/Algebra/BigOperators/Group/Multiset.lean",
              "def_pos": [
                79,
                9
              ],
              "def_end_pos": [
                79,
                18
              ]
            }
          ]
        ],
        "state_before": "case intro\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : CanonicallyOrderedCommMonoid \u03b1\na : \u03b1\nt : Multiset \u03b1\nha : a \u2208 a ::\u2098 t\n\u22a2 a \u2264 (a ::\u2098 t).prod",
        "state_after": "case intro\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : CanonicallyOrderedCommMonoid \u03b1\na : \u03b1\nt : Multiset \u03b1\nha : a \u2208 a ::\u2098 t\n\u22a2 a \u2264 a * t.prod"
      },
      {
        "tactic": "exact _root_.le_mul_right (le_refl a)",
        "annotated_tactic": [
          "exact <a>_root_.le_mul_right</a> (<a>le_refl</a> a)",
          [
            {
              "full_name": "le_mul_right",
              "def_path": "Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean",
              "def_pos": [
                265,
                9
              ],
              "def_end_pos": [
                265,
                21
              ]
            },
            {
              "full_name": "le_refl",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                45,
                9
              ],
              "def_end_pos": [
                45,
                16
              ]
            }
          ]
        ],
        "state_before": "case intro\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : CanonicallyOrderedCommMonoid \u03b1\na : \u03b1\nt : Multiset \u03b1\nha : a \u2208 a ::\u2098 t\n\u22a2 a \u2264 a * t.prod",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.109557860996574,
    "entry_failed": false
  },
  "25738": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/LegendreSymbol/Basic.lean",
    "full_name": "legendreSym.eq_one_iff'",
    "start": [
      195,
      1
    ],
    "end": [
      199,
      27
    ],
    "traced_tactics": [
      {
        "tactic": "rw [eq_one_iff]",
        "annotated_tactic": [
          "rw [<a>eq_one_iff</a>]",
          [
            {
              "full_name": "legendreSym.eq_one_iff",
              "def_path": "Mathlib/NumberTheory/LegendreSymbol/Basic.lean",
              "def_pos": [
                191,
                9
              ],
              "def_end_pos": [
                191,
                19
              ]
            }
          ]
        ],
        "state_before": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : \u2115\nha0 : \u2191a \u2260 0\n\u22a2 legendreSym p \u2191a = 1 \u2194 IsSquare \u2191a",
        "state_after": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : \u2115\nha0 : \u2191a \u2260 0\n\u22a2 IsSquare \u2191\u2191a \u2194 IsSquare \u2191a\n\ncase ha0\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : \u2115\nha0 : \u2191a \u2260 0\n\u22a2 \u2191\u2191a \u2260 0"
      },
      {
        "tactic": "norm_cast",
        "annotated_tactic": [
          "norm_cast",
          []
        ],
        "state_before": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : \u2115\nha0 : \u2191a \u2260 0\n\u22a2 IsSquare \u2191\u2191a \u2194 IsSquare \u2191a",
        "state_after": "no goals"
      },
      {
        "tactic": "exact mod_cast ha0",
        "annotated_tactic": [
          "exact mod_cast ha0",
          []
        ],
        "state_before": "case ha0\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : \u2115\nha0 : \u2191a \u2260 0\n\u22a2 \u2191\u2191a \u2260 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.848385622026399,
    "entry_failed": false
  },
  "25784": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/ToIntervalMod.lean",
    "full_name": "toIcoMod_apply_left",
    "start": [
      203,
      1
    ],
    "end": [
      205,
      47
    ],
    "traced_tactics": [
      {
        "tactic": "rw [toIcoMod_eq_iff hp, Set.left_mem_Ico]",
        "annotated_tactic": [
          "rw [<a>toIcoMod_eq_iff</a> hp, <a>Set.left_mem_Ico</a>]",
          [
            {
              "full_name": "toIcoMod_eq_iff",
              "def_path": "Mathlib/Algebra/Order/ToIntervalMod.lean",
              "def_pos": [
                172,
                9
              ],
              "def_end_pos": [
                172,
                24
              ]
            },
            {
              "full_name": "Set.left_mem_Ico",
              "def_path": "Mathlib/Order/Interval/Set/Basic.lean",
              "def_pos": [
                186,
                9
              ],
              "def_end_pos": [
                186,
                21
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na\u271d b c : \u03b1\nn : \u2124\na : \u03b1\n\u22a2 toIcoMod hp a a = a",
        "state_after": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na\u271d b c : \u03b1\nn : \u2124\na : \u03b1\n\u22a2 a < a + p \u2227 \u2203 z, a = a + z \u2022 p"
      },
      {
        "tactic": "exact \u27e8lt_add_of_pos_right _ hp, 0, by simp\u27e9",
        "annotated_tactic": [
          "exact \u27e8<a>lt_add_of_pos_right</a> _ hp, 0, by simp\u27e9",
          [
            {
              "full_name": "lt_add_of_pos_right",
              "def_path": "Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean",
              "def_pos": [
                495,
                15
              ],
              "def_end_pos": [
                495,
                34
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na\u271d b c : \u03b1\nn : \u2124\na : \u03b1\n\u22a2 a < a + p \u2227 \u2203 z, a = a + z \u2022 p",
        "state_after": "no goals"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedAddCommGroup \u03b1\nh\u03b1 : Archimedean \u03b1\np : \u03b1\nhp : 0 < p\na\u271d b c : \u03b1\nn : \u2124\na : \u03b1\n\u22a2 a = a + 0 \u2022 p",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.810617785900831,
    "entry_failed": false
  },
  "25814": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Perm.lean",
    "full_name": "List.length_permutations'Aux",
    "start": [
      802,
      1
    ],
    "end": [
      806,
      19
    ],
    "traced_tactics": [
      {
        "tactic": "induction' s with y s IH",
        "annotated_tactic": [
          "induction' s with y s IH",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081 l\u2082 : List \u03b1\na : \u03b1\ns : List \u03b1\nx : \u03b1\n\u22a2 (permutations'Aux x s).length = s.length + 1",
        "state_after": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081 l\u2082 : List \u03b1\na x : \u03b1\n\u22a2 (permutations'Aux x []).length = [].length + 1\n\ncase cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081 l\u2082 : List \u03b1\na x y : \u03b1\ns : List \u03b1\nIH : (permutations'Aux x s).length = s.length + 1\n\u22a2 (permutations'Aux x (y :: s)).length = (y :: s).length + 1"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case nil\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081 l\u2082 : List \u03b1\na x : \u03b1\n\u22a2 (permutations'Aux x []).length = [].length + 1",
        "state_after": "no goals"
      },
      {
        "tactic": "simpa using IH",
        "annotated_tactic": [
          "simpa using IH",
          []
        ],
        "state_before": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nl l\u2081 l\u2082 : List \u03b1\na x y : \u03b1\ns : List \u03b1\nIH : (permutations'Aux x s).length = s.length + 1\n\u22a2 (permutations'Aux x (y :: s)).length = (y :: s).length + 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.25080815795809,
    "entry_failed": false
  },
  "25826": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Polynomial/Coeff.lean",
    "full_name": "Polynomial.coeff_C_mul_X_pow",
    "start": [
      160,
      1
    ],
    "end": [
      164,
      17
    ],
    "traced_tactics": [
      {
        "tactic": "rw [C_mul_X_pow_eq_monomial, coeff_monomial]",
        "annotated_tactic": [
          "rw [<a>C_mul_X_pow_eq_monomial</a>, <a>coeff_monomial</a>]",
          [
            {
              "full_name": "Polynomial.C_mul_X_pow_eq_monomial",
              "def_path": "Mathlib/Algebra/Polynomial/Basic.lean",
              "def_pos": [
                770,
                9
              ],
              "def_end_pos": [
                770,
                32
              ]
            },
            {
              "full_name": "Polynomial.coeff_monomial",
              "def_path": "Mathlib/Algebra/Polynomial/Basic.lean",
              "def_pos": [
                684,
                9
              ],
              "def_end_pos": [
                684,
                23
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nx : R\nk n : \u2115\n\u22a2 (C x * X ^ k).coeff n = if n = k then x else 0",
        "state_after": "R : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nx : R\nk n : \u2115\n\u22a2 (if k = n then x else 0) = if n = k then x else 0"
      },
      {
        "tactic": "congr 1",
        "annotated_tactic": [
          "congr 1",
          []
        ],
        "state_before": "R : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nx : R\nk n : \u2115\n\u22a2 (if k = n then x else 0) = if n = k then x else 0",
        "state_after": "case e_c\nR : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nx : R\nk n : \u2115\n\u22a2 (k = n) = (n = k)"
      },
      {
        "tactic": "simp [eq_comm]",
        "annotated_tactic": [
          "simp [<a>eq_comm</a>]",
          [
            {
              "full_name": "eq_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                811,
                9
              ],
              "def_end_pos": [
                811,
                16
              ]
            }
          ]
        ],
        "state_before": "case e_c\nR : Type u\nS : Type v\na b : R\nn\u271d m : \u2115\ninst\u271d : Semiring R\np q r : R[X]\nx : R\nk n : \u2115\n\u22a2 (k = n) = (n = k)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.5827947510406375,
    "entry_failed": false
  },
  "25828": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Int/CharZero.lean",
    "full_name": "Int.cast_div_charZero",
    "start": [
      24,
      1
    ],
    "end": [
      28,
      47
    ],
    "traced_tactics": [
      {
        "tactic": "rcases eq_or_ne n 0 with (rfl | hn)",
        "annotated_tactic": [
          "rcases <a>eq_or_ne</a> n 0 with (rfl | hn)",
          [
            {
              "full_name": "eq_or_ne",
              "def_path": "Mathlib/Logic/Basic.lean",
              "def_pos": [
                212,
                9
              ],
              "def_end_pos": [
                212,
                17
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : Type u_3\ninst\u271d\u00b9 : DivisionRing k\ninst\u271d : CharZero k\nm n : \u2124\nn_dvd : n \u2223 m\n\u22a2 \u2191(m / n) = \u2191m / \u2191n",
        "state_after": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : Type u_3\ninst\u271d\u00b9 : DivisionRing k\ninst\u271d : CharZero k\nm : \u2124\nn_dvd : 0 \u2223 m\n\u22a2 \u2191(m / 0) = \u2191m / \u21910\n\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : Type u_3\ninst\u271d\u00b9 : DivisionRing k\ninst\u271d : CharZero k\nm n : \u2124\nn_dvd : n \u2223 m\nhn : n \u2260 0\n\u22a2 \u2191(m / n) = \u2191m / \u2191n"
      },
      {
        "tactic": "simp [Int.ediv_zero]",
        "annotated_tactic": [
          "simp [<a>Int.ediv_zero</a>]",
          [
            {
              "full_name": "Int.ediv_zero",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/DivModLemmas.lean",
              "def_pos": [
                139,
                27
              ],
              "def_end_pos": [
                139,
                36
              ]
            }
          ]
        ],
        "state_before": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : Type u_3\ninst\u271d\u00b9 : DivisionRing k\ninst\u271d : CharZero k\nm : \u2124\nn_dvd : 0 \u2223 m\n\u22a2 \u2191(m / 0) = \u2191m / \u21910",
        "state_after": "no goals"
      },
      {
        "tactic": "exact cast_div n_dvd (cast_ne_zero.mpr hn)",
        "annotated_tactic": [
          "exact <a>cast_div</a> n_dvd (cast_ne_zero.mpr hn)",
          [
            {
              "full_name": "Int.cast_div",
              "def_path": "Mathlib/Data/Int/Cast/Field.lean",
              "def_pos": [
                38,
                9
              ],
              "def_end_pos": [
                38,
                17
              ]
            }
          ]
        ],
        "state_before": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nk : Type u_3\ninst\u271d\u00b9 : DivisionRing k\ninst\u271d : CharZero k\nm n : \u2124\nn_dvd : n \u2223 m\nhn : n \u2260 0\n\u22a2 \u2191(m / n) = \u2191m / \u2191n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.0141807029722258,
    "entry_failed": false
  },
  "25845": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/LegendreSymbol/ZModChar.lean",
    "full_name": "ZMod.\u03c7\u2088'_int_eq_\u03c7\u2084_mul_\u03c7\u2088",
    "start": [
      212,
      1
    ],
    "end": [
      214,
      27
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 @cast_intCast 8 (ZMod 4) _ 4 _ (by omega) a]",
        "annotated_tactic": [
          "rw [\u2190 @<a>cast_intCast</a> 8 (<a>ZMod</a> 4) _ 4 _ (by omega) a]",
          [
            {
              "full_name": "ZMod.cast_intCast",
              "def_path": "Mathlib/Data/ZMod/Basic.lean",
              "def_pos": [
                410,
                9
              ],
              "def_end_pos": [
                410,
                21
              ]
            },
            {
              "full_name": "ZMod",
              "def_path": "Mathlib/Data/ZMod/Defs.lean",
              "def_pos": [
                95,
                5
              ],
              "def_end_pos": [
                95,
                9
              ]
            }
          ]
        ],
        "state_before": "a : \u2124\n\u22a2 \u03c7\u2088' \u2191a = \u03c7\u2084 \u2191a * \u03c7\u2088 \u2191a",
        "state_after": "a : \u2124\n\u22a2 \u03c7\u2088' \u2191a = \u03c7\u2084 (\u2191a).cast * \u03c7\u2088 \u2191a"
      },
      {
        "tactic": "exact \u03c7\u2088'_eq_\u03c7\u2084_mul_\u03c7\u2088 a",
        "annotated_tactic": [
          "exact <a>\u03c7\u2088'_eq_\u03c7\u2084_mul_\u03c7\u2088</a> a",
          [
            {
              "full_name": "ZMod.\u03c7\u2088'_eq_\u03c7\u2084_mul_\u03c7\u2088",
              "def_path": "Mathlib/NumberTheory/LegendreSymbol/ZModChar.lean",
              "def_pos": [
                208,
                9
              ],
              "def_end_pos": [
                208,
                25
              ]
            }
          ]
        ],
        "state_before": "a : \u2124\n\u22a2 \u03c7\u2088' \u2191a = \u03c7\u2084 (\u2191a).cast * \u03c7\u2088 \u2191a",
        "state_after": "no goals"
      },
      {
        "tactic": "omega",
        "annotated_tactic": [
          "omega",
          []
        ],
        "state_before": "a : \u2124\n\u22a2 4 \u2223 8",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.583186733070761,
    "entry_failed": false
  },
  "25863": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Ideal/Prod.lean",
    "full_name": "Ideal.isPrime_of_isPrime_prod_top'",
    "start": [
      121,
      1
    ],
    "end": [
      126,
      68
    ],
    "traced_tactics": [
      {
        "tactic": "apply isPrime_of_isPrime_prod_top (S := R)",
        "annotated_tactic": [
          "apply <a>isPrime_of_isPrime_prod_top</a> (S := R)",
          [
            {
              "full_name": "Ideal.isPrime_of_isPrime_prod_top",
              "def_path": "Mathlib/RingTheory/Ideal/Prod.lean",
              "def_pos": [
                108,
                9
              ],
              "def_end_pos": [
                108,
                36
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nI\u271d I' : Ideal R\nJ J' I : Ideal S\nh : (\u22a4.prod I).IsPrime\n\u22a2 I.IsPrime",
        "state_after": "R : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nI\u271d I' : Ideal R\nJ J' I : Ideal S\nh : (\u22a4.prod I).IsPrime\n\u22a2 (I.prod \u22a4).IsPrime"
      },
      {
        "tactic": "rw [\u2190 map_prodComm_prod]",
        "annotated_tactic": [
          "rw [\u2190 <a>map_prodComm_prod</a>]",
          [
            {
              "full_name": "Ideal.map_prodComm_prod",
              "def_path": "Mathlib/RingTheory/Ideal/Prod.lean",
              "def_pos": [
                82,
                9
              ],
              "def_end_pos": [
                82,
                26
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nI\u271d I' : Ideal R\nJ J' I : Ideal S\nh : (\u22a4.prod I).IsPrime\n\u22a2 (I.prod \u22a4).IsPrime",
        "state_after": "R : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nI\u271d I' : Ideal R\nJ J' I : Ideal S\nh : (\u22a4.prod I).IsPrime\n\u22a2 (map (\u2191RingEquiv.prodComm) (\u22a4.prod I)).IsPrime"
      },
      {
        "tactic": "exact map_isPrime_of_equiv (RingEquiv.prodComm (R := R) (S := S))",
        "annotated_tactic": [
          "exact <a>map_isPrime_of_equiv</a> (<a>RingEquiv.prodComm</a> (R := R) (S := S))",
          [
            {
              "full_name": "Ideal.map_isPrime_of_equiv",
              "def_path": "Mathlib/RingTheory/Ideal/Maps.lean",
              "def_pos": [
                723,
                9
              ],
              "def_end_pos": [
                723,
                29
              ]
            },
            {
              "full_name": "RingEquiv.prodComm",
              "def_path": "Mathlib/Algebra/Ring/Prod.lean",
              "def_pos": [
                285,
                5
              ],
              "def_end_pos": [
                285,
                13
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\ninst\u271d\u00b9 : Semiring R\ninst\u271d : Semiring S\nI\u271d I' : Ideal R\nJ J' I : Ideal S\nh : (\u22a4.prod I).IsPrime\n\u22a2 (map (\u2191RingEquiv.prodComm) (\u22a4.prod I)).IsPrime",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.3703131680376828,
    "entry_failed": false
  },
  "25919": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/ContinuedFractions/Computation/CorrectnessTerminating.lean",
    "full_name": "GeneralizedContinuedFraction.compExactValue_correctness_of_stream_eq_some_aux_comp",
    "start": [
      78,
      11
    ],
    "end": [
      83,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "field_simp [fract_a_ne_zero]",
        "annotated_tactic": [
          "field_simp [fract_a_ne_zero]",
          []
        ],
        "state_before": "K : Type u_1\ninst\u271d\u00b9 : LinearOrderedField K\nv : K\nn : \u2115\ninst\u271d : FloorRing K\na b c : K\nfract_a_ne_zero : Int.fract a \u2260 0\n\u22a2 (\u2191\u230aa\u230b * b + c) / Int.fract a + b = (b * a + c) / Int.fract a",
        "state_after": "K : Type u_1\ninst\u271d\u00b9 : LinearOrderedField K\nv : K\nn : \u2115\ninst\u271d : FloorRing K\na b c : K\nfract_a_ne_zero : Int.fract a \u2260 0\n\u22a2 \u2191\u230aa\u230b * b + c + b * Int.fract a = b * a + c"
      },
      {
        "tactic": "rw [Int.fract]",
        "annotated_tactic": [
          "rw [<a>Int.fract</a>]",
          [
            {
              "full_name": "Int.fract",
              "def_path": "Mathlib/Algebra/Order/Floor.lean",
              "def_pos": [
                651,
                5
              ],
              "def_end_pos": [
                651,
                10
              ]
            }
          ]
        ],
        "state_before": "K : Type u_1\ninst\u271d\u00b9 : LinearOrderedField K\nv : K\nn : \u2115\ninst\u271d : FloorRing K\na b c : K\nfract_a_ne_zero : Int.fract a \u2260 0\n\u22a2 \u2191\u230aa\u230b * b + c + b * Int.fract a = b * a + c",
        "state_after": "K : Type u_1\ninst\u271d\u00b9 : LinearOrderedField K\nv : K\nn : \u2115\ninst\u271d : FloorRing K\na b c : K\nfract_a_ne_zero : Int.fract a \u2260 0\n\u22a2 \u2191\u230aa\u230b * b + c + b * (a - \u2191\u230aa\u230b) = b * a + c"
      },
      {
        "tactic": "ring",
        "annotated_tactic": [
          "ring",
          []
        ],
        "state_before": "K : Type u_1\ninst\u271d\u00b9 : LinearOrderedField K\nv : K\nn : \u2115\ninst\u271d : FloorRing K\na b c : K\nfract_a_ne_zero : Int.fract a \u2260 0\n\u22a2 \u2191\u230aa\u230b * b + c + b * (a - \u2191\u230aa\u230b) = b * a + c",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.359760649036616,
    "entry_failed": false
  },
  "25927": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Field/Basic.lean",
    "full_name": "mul_le_of_nonneg_of_le_div",
    "start": [
      158,
      1
    ],
    "end": [
      162,
      29
    ],
    "traced_tactics": [
      {
        "tactic": "obtain rfl | hc := hc.eq_or_lt",
        "annotated_tactic": [
          "obtain rfl | hc := hc.eq_or_lt",
          []
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nhb : 0 \u2264 b\nhc : 0 \u2264 c\nh : a \u2264 b / c\n\u22a2 a * c \u2264 b",
        "state_after": "case inl\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b d e : \u03b1\nm n : \u2124\nhb : 0 \u2264 b\nhc : 0 \u2264 0\nh : a \u2264 b / 0\n\u22a2 a * 0 \u2264 b\n\ncase inr\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nhb : 0 \u2264 b\nhc\u271d : 0 \u2264 c\nh : a \u2264 b / c\nhc : 0 < c\n\u22a2 a * c \u2264 b"
      },
      {
        "tactic": "simpa using hb",
        "annotated_tactic": [
          "simpa using hb",
          []
        ],
        "state_before": "case inl\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b d e : \u03b1\nm n : \u2124\nhb : 0 \u2264 b\nhc : 0 \u2264 0\nh : a \u2264 b / 0\n\u22a2 a * 0 \u2264 b",
        "state_after": "no goals"
      },
      {
        "tactic": "rwa [le_div_iff hc] at h",
        "annotated_tactic": [
          "rwa [<a>le_div_iff</a> hc] at h",
          [
            {
              "full_name": "le_div_iff",
              "def_path": "Mathlib/Algebra/Order/Field/Basic.lean",
              "def_pos": [
                49,
                9
              ],
              "def_end_pos": [
                49,
                19
              ]
            }
          ]
        ],
        "state_before": "case inr\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nhb : 0 \u2264 b\nhc\u271d : 0 \u2264 c\nh : a \u2264 b / c\nhc : 0 < c\n\u22a2 a * c \u2264 b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.8115416100481525,
    "entry_failed": false
  },
  "25933": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Group/Int.lean",
    "full_name": "Int.natAbs_le_self_sq",
    "start": [
      64,
      1
    ],
    "end": [
      67,
      24
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 Int.natAbs_sq a, sq]",
        "annotated_tactic": [
          "rw [\u2190 <a>Int.natAbs_sq</a> a, <a>sq</a>]",
          [
            {
              "full_name": "Int.natAbs_sq",
              "def_path": "Mathlib/Data/Int/Defs.lean",
              "def_pos": [
                438,
                7
              ],
              "def_end_pos": [
                438,
                16
              ]
            },
            {
              "full_name": "sq",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                684,
                41
              ],
              "def_end_pos": [
                684,
                43
              ]
            }
          ]
        ],
        "state_before": "a : \u2124\n\u22a2 \u2191a.natAbs \u2264 a ^ 2",
        "state_after": "a : \u2124\n\u22a2 \u2191a.natAbs \u2264 \u2191a.natAbs * \u2191a.natAbs"
      },
      {
        "tactic": "norm_cast",
        "annotated_tactic": [
          "norm_cast",
          []
        ],
        "state_before": "a : \u2124\n\u22a2 \u2191a.natAbs \u2264 \u2191a.natAbs * \u2191a.natAbs",
        "state_after": "a : \u2124\n\u22a2 a.natAbs \u2264 a.natAbs * a.natAbs"
      },
      {
        "tactic": "apply Nat.le_mul_self",
        "annotated_tactic": [
          "apply <a>Nat.le_mul_self</a>",
          [
            {
              "full_name": "Nat.le_mul_self",
              "def_path": "Mathlib/Data/Nat/Defs.lean",
              "def_pos": [
                486,
                7
              ],
              "def_end_pos": [
                486,
                18
              ]
            }
          ]
        ],
        "state_before": "a : \u2124\n\u22a2 a.natAbs \u2264 a.natAbs * a.natAbs",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.0907458970323205,
    "entry_failed": false
  },
  "25950": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/InsertNth.lean",
    "full_name": "List.insertNth_length_self",
    "start": [
      116,
      1
    ],
    "end": [
      119,
      19
    ],
    "traced_tactics": [
      {
        "tactic": "induction' l with hd tl IH",
        "annotated_tactic": [
          "induction' l with hd tl IH",
          []
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\na : \u03b1\nl : List \u03b1\nx : \u03b1\n\u22a2 insertNth l.length x l = l ++ [x]",
        "state_after": "case nil\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\na x : \u03b1\n\u22a2 insertNth [].length x [] = [] ++ [x]\n\ncase cons\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\na x hd : \u03b1\ntl : List \u03b1\nIH : insertNth tl.length x tl = tl ++ [x]\n\u22a2 insertNth (hd :: tl).length x (hd :: tl) = hd :: tl ++ [x]"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case nil\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\na x : \u03b1\n\u22a2 insertNth [].length x [] = [] ++ [x]",
        "state_after": "no goals"
      },
      {
        "tactic": "simpa using IH",
        "annotated_tactic": [
          "simpa using IH",
          []
        ],
        "state_before": "case cons\n\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\nl\u2081 l\u2082 : List \u03b1\na x hd : \u03b1\ntl : List \u03b1\nIH : insertNth tl.length x tl = tl ++ [x]\n\u22a2 insertNth (hd :: tl).length x (hd :: tl) = hd :: tl ++ [x]",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.3476251749088988,
    "entry_failed": false
  },
  "25964": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Rotate.lean",
    "full_name": "List.rotate'_length_mul",
    "start": [
      93,
      1
    ],
    "end": [
      100,
      62
    ],
    "traced_tactics": [
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "\u03b1 : Type u\nl : List \u03b1\n\u22a2 l.rotate' (l.length * 0) = l",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [-rotate'_length, Nat.mul_succ, rotate'_rotate']",
        "annotated_tactic": [
          "simp [-<a>rotate'_length</a>, <a>Nat.mul_succ</a>, <a>rotate'_rotate'</a>]",
          [
            {
              "full_name": "List.rotate'_length",
              "def_path": "Mathlib/Data/List/Rotate.lean",
              "def_pos": [
                88,
                9
              ],
              "def_end_pos": [
                88,
                23
              ]
            },
            {
              "full_name": "Nat.mul_succ",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean",
              "def_pos": [
                200,
                9
              ],
              "def_end_pos": [
                200,
                17
              ]
            },
            {
              "full_name": "List.rotate'_rotate'",
              "def_path": "Mathlib/Data/List/Rotate.lean",
              "def_pos": [
                79,
                9
              ],
              "def_end_pos": [
                79,
                24
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\nl : List \u03b1\nn : \u2115\n\u22a2 l.rotate' (l.length * (n + 1)) = (l.rotate' (l.length * n)).rotate' (l.rotate' (l.length * n)).length",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [rotate'_length, rotate'_length_mul l n]",
        "annotated_tactic": [
          "rw [<a>rotate'_length</a>, rotate'_length_mul l n]",
          [
            {
              "full_name": "List.rotate'_length",
              "def_path": "Mathlib/Data/List/Rotate.lean",
              "def_pos": [
                88,
                9
              ],
              "def_end_pos": [
                88,
                23
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\nl : List \u03b1\nn : \u2115\n\u22a2 (l.rotate' (l.length * n)).rotate' (l.rotate' (l.length * n)).length = l",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7011131669860333,
    "entry_failed": false
  },
  "25975": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Bool/Basic.lean",
    "full_name": "Bool.bne_eq_xor",
    "start": [
      167,
      1
    ],
    "end": [
      167,
      68
    ],
    "traced_tactics": [
      {
        "tactic": "funext a b",
        "annotated_tactic": [
          "funext a b",
          []
        ],
        "state_before": "\u22a2 bne = xor",
        "state_after": "case h.h\na b : Bool\n\u22a2 (a != b) = xor a b"
      },
      {
        "tactic": "revert a b",
        "annotated_tactic": [
          "revert a b",
          []
        ],
        "state_before": "case h.h\na b : Bool\n\u22a2 (a != b) = xor a b",
        "state_after": "case h.h\n\n\u22a2 \u2200 (a b : Bool), (a != b) = xor a b"
      },
      {
        "tactic": "decide",
        "annotated_tactic": [
          "decide",
          []
        ],
        "state_before": "case h.h\n\n\u22a2 \u2200 (a b : Bool), (a != b) = xor a b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.0246927299303934,
    "entry_failed": false
  },
  "25981": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Polynomial/Pochhammer.lean",
    "full_name": "ascPochhammer_eval_zero",
    "start": [
      110,
      1
    ],
    "end": [
      113,
      60
    ],
    "traced_tactics": [
      {
        "tactic": "cases n",
        "annotated_tactic": [
          "cases n",
          []
        ],
        "state_before": "S : Type u\ninst\u271d : Semiring S\nn : \u2115\n\u22a2 eval 0 (ascPochhammer S n) = if n = 0 then 1 else 0",
        "state_after": "case zero\nS : Type u\ninst\u271d : Semiring S\n\u22a2 eval 0 (ascPochhammer S 0) = if 0 = 0 then 1 else 0\n\ncase succ\nS : Type u\ninst\u271d : Semiring S\nn\u271d : \u2115\n\u22a2 eval 0 (ascPochhammer S (n\u271d + 1)) = if n\u271d + 1 = 0 then 1 else 0"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case zero\nS : Type u\ninst\u271d : Semiring S\n\u22a2 eval 0 (ascPochhammer S 0) = if 0 = 0 then 1 else 0",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [X_mul, Nat.succ_ne_zero, ascPochhammer_succ_left]",
        "annotated_tactic": [
          "simp [<a>X_mul</a>, <a>Nat.succ_ne_zero</a>, <a>ascPochhammer_succ_left</a>]",
          [
            {
              "full_name": "Polynomial.X_mul",
              "def_path": "Mathlib/Algebra/Polynomial/Basic.lean",
              "def_pos": [
                584,
                9
              ],
              "def_end_pos": [
                584,
                14
              ]
            },
            {
              "full_name": "Nat.succ_ne_zero",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean",
              "def_pos": [
                708,
                17
              ],
              "def_end_pos": [
                708,
                29
              ]
            },
            {
              "full_name": "ascPochhammer_succ_left",
              "def_path": "Mathlib/RingTheory/Polynomial/Pochhammer.lean",
              "def_pos": [
                64,
                9
              ],
              "def_end_pos": [
                64,
                32
              ]
            }
          ]
        ],
        "state_before": "case succ\nS : Type u\ninst\u271d : Semiring S\nn\u271d : \u2115\n\u22a2 eval 0 (ascPochhammer S (n\u271d + 1)) = if n\u271d + 1 = 0 then 1 else 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.825625995057635,
    "entry_failed": false
  },
  "26186": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Nilpotent/Defs.lean",
    "full_name": "IsNilpotent.pow_succ",
    "start": [
      58,
      1
    ],
    "end": [
      62,
      54
    ],
    "traced_tactics": [
      {
        "tactic": "obtain \u27e8N,hN\u27e9 := hx",
        "annotated_tactic": [
          "obtain \u27e8N,hN\u27e9 := hx",
          []
        ],
        "state_before": "R : Type u_1\nS\u271d : Type u_2\nx\u271d y : R\nn : \u2115\nS : Type u_3\ninst\u271d : MonoidWithZero S\nx : S\nhx : IsNilpotent x\n\u22a2 IsNilpotent (x ^ n.succ)",
        "state_after": "case intro\nR : Type u_1\nS\u271d : Type u_2\nx\u271d y : R\nn : \u2115\nS : Type u_3\ninst\u271d : MonoidWithZero S\nx : S\nN : \u2115\nhN : x ^ N = 0\n\u22a2 IsNilpotent (x ^ n.succ)"
      },
      {
        "tactic": "use N",
        "annotated_tactic": [
          "use N",
          []
        ],
        "state_before": "case intro\nR : Type u_1\nS\u271d : Type u_2\nx\u271d y : R\nn : \u2115\nS : Type u_3\ninst\u271d : MonoidWithZero S\nx : S\nN : \u2115\nhN : x ^ N = 0\n\u22a2 IsNilpotent (x ^ n.succ)",
        "state_after": "case h\nR : Type u_1\nS\u271d : Type u_2\nx\u271d y : R\nn : \u2115\nS : Type u_3\ninst\u271d : MonoidWithZero S\nx : S\nN : \u2115\nhN : x ^ N = 0\n\u22a2 (x ^ n.succ) ^ N = 0"
      },
      {
        "tactic": "rw [\u2190 pow_mul, Nat.succ_mul, pow_add, hN, mul_zero]",
        "annotated_tactic": [
          "rw [\u2190 <a>pow_mul</a>, <a>Nat.succ_mul</a>, <a>pow_add</a>, hN, <a>mul_zero</a>]",
          [
            {
              "full_name": "pow_mul",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                713,
                32
              ],
              "def_end_pos": [
                713,
                39
              ]
            },
            {
              "full_name": "Nat.succ_mul",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean",
              "def_pos": [
                210,
                9
              ],
              "def_end_pos": [
                210,
                17
              ]
            },
            {
              "full_name": "pow_add",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                703,
                7
              ],
              "def_end_pos": [
                703,
                14
              ]
            },
            {
              "full_name": "MulZeroClass.mul_zero",
              "def_path": "Mathlib/Algebra/GroupWithZero/Defs.lean",
              "def_pos": [
                39,
                3
              ],
              "def_end_pos": [
                39,
                11
              ]
            }
          ]
        ],
        "state_before": "case h\nR : Type u_1\nS\u271d : Type u_2\nx\u271d y : R\nn : \u2115\nS : Type u_3\ninst\u271d : MonoidWithZero S\nx : S\nN : \u2115\nhN : x ^ N = 0\n\u22a2 (x ^ n.succ) ^ N = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2676289939554408,
    "entry_failed": false
  },
  "26224": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/ENNReal/Inv.lean",
    "full_name": "ENNReal.sub_div",
    "start": [
      204,
      11
    ],
    "end": [
      206,
      43
    ],
    "traced_tactics": [
      {
        "tactic": "simp_rw [div_eq_mul_inv]",
        "annotated_tactic": [
          "simp_rw [<a>div_eq_mul_inv</a>]",
          [
            {
              "full_name": "div_eq_mul_inv",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                1059,
                9
              ],
              "def_end_pos": [
                1059,
                23
              ]
            }
          ]
        ],
        "state_before": "a b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nh : 0 < b \u2192 b < a \u2192 c \u2260 0\n\u22a2 (a - b) / c = a / c - b / c",
        "state_after": "a b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nh : 0 < b \u2192 b < a \u2192 c \u2260 0\n\u22a2 (a - b) * c\u207b\u00b9 = a * c\u207b\u00b9 - b * c\u207b\u00b9"
      },
      {
        "tactic": "exact ENNReal.sub_mul (by simpa using h)",
        "annotated_tactic": [
          "exact <a>ENNReal.sub_mul</a> (by simpa using h)",
          [
            {
              "full_name": "ENNReal.sub_mul",
              "def_path": "Mathlib/Data/ENNReal/Operations.lean",
              "def_pos": [
                461,
                9
              ],
              "def_end_pos": [
                461,
                16
              ]
            }
          ]
        ],
        "state_before": "a b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nh : 0 < b \u2192 b < a \u2192 c \u2260 0\n\u22a2 (a - b) * c\u207b\u00b9 = a * c\u207b\u00b9 - b * c\u207b\u00b9",
        "state_after": "no goals"
      },
      {
        "tactic": "simpa using h",
        "annotated_tactic": [
          "simpa using h",
          []
        ],
        "state_before": "a b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nh : 0 < b \u2192 b < a \u2192 c \u2260 0\n\u22a2 0 < b \u2192 b < a \u2192 c\u207b\u00b9 \u2260 \u22a4",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.578216928988695,
    "entry_failed": false
  },
  "26233": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/Limits/Shapes/StrictInitial.lean",
    "full_name": "CategoryTheory.Limits.IsInitial.strict_hom_ext",
    "start": [
      74,
      1
    ],
    "end": [
      77,
      54
    ],
    "traced_tactics": [
      {
        "tactic": "haveI := hI.isIso_to f",
        "annotated_tactic": [
          "haveI := hI.isIso_to f",
          []
        ],
        "state_before": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasStrictInitialObjects C\nI : C\nhI : IsInitial I\nA : C\nf g : A \u27f6 I\n\u22a2 f = g",
        "state_after": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasStrictInitialObjects C\nI : C\nhI : IsInitial I\nA : C\nf g : A \u27f6 I\nthis : IsIso f\n\u22a2 f = g"
      },
      {
        "tactic": "haveI := hI.isIso_to g",
        "annotated_tactic": [
          "haveI := hI.isIso_to g",
          []
        ],
        "state_before": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasStrictInitialObjects C\nI : C\nhI : IsInitial I\nA : C\nf g : A \u27f6 I\nthis : IsIso f\n\u22a2 f = g",
        "state_after": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasStrictInitialObjects C\nI : C\nhI : IsInitial I\nA : C\nf g : A \u27f6 I\nthis\u271d : IsIso f\nthis : IsIso g\n\u22a2 f = g"
      },
      {
        "tactic": "exact eq_of_inv_eq_inv (hI.hom_ext (inv f) (inv g))",
        "annotated_tactic": [
          "exact <a>eq_of_inv_eq_inv</a> (hI.hom_ext (<a>inv</a> f) (<a>inv</a> g))",
          [
            {
              "full_name": "CategoryTheory.eq_of_inv_eq_inv",
              "def_path": "Mathlib/CategoryTheory/Iso.lean",
              "def_pos": [
                490,
                9
              ],
              "def_end_pos": [
                490,
                25
              ]
            },
            {
              "full_name": "CategoryTheory.inv",
              "def_path": "Mathlib/CategoryTheory/Iso.lean",
              "def_pos": [
                279,
                19
              ],
              "def_end_pos": [
                279,
                22
              ]
            },
            {
              "full_name": "CategoryTheory.inv",
              "def_path": "Mathlib/CategoryTheory/Iso.lean",
              "def_pos": [
                279,
                19
              ],
              "def_end_pos": [
                279,
                22
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d\u00b9 : Category.{v, u} C\ninst\u271d : HasStrictInitialObjects C\nI : C\nhI : IsInitial I\nA : C\nf g : A \u27f6 I\nthis\u271d : IsIso f\nthis : IsIso g\n\u22a2 f = g",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.199150232016109,
    "entry_failed": false
  },
  "26245": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Semiquot.lean",
    "full_name": "Semiquot.blur_eq_blur'",
    "start": [
      90,
      1
    ],
    "end": [
      91,
      64
    ],
    "traced_tactics": [
      {
        "tactic": "unfold blur",
        "annotated_tactic": [
          "unfold <a>blur</a>",
          [
            {
              "full_name": "Semiquot.blur",
              "def_path": "Mathlib/Data/Semiquot.lean",
              "def_pos": [
                86,
                5
              ],
              "def_end_pos": [
                86,
                9
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nq : Semiquot \u03b1\ns : Set \u03b1\nh : q.s \u2286 s\n\u22a2 blur s q = q.blur' h",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nq : Semiquot \u03b1\ns : Set \u03b1\nh : q.s \u2286 s\n\u22a2 q.blur' \u22ef = q.blur' h"
      },
      {
        "tactic": "congr",
        "annotated_tactic": [
          "congr",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nq : Semiquot \u03b1\ns : Set \u03b1\nh : q.s \u2286 s\n\u22a2 q.blur' \u22ef = q.blur' h",
        "state_after": "case e_s\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nq : Semiquot \u03b1\ns : Set \u03b1\nh : q.s \u2286 s\n\u22a2 s \u222a q.s = s"
      },
      {
        "tactic": "exact Set.union_eq_self_of_subset_right h",
        "annotated_tactic": [
          "exact <a>Set.union_eq_self_of_subset_right</a> h",
          [
            {
              "full_name": "Set.union_eq_self_of_subset_right",
              "def_path": "Mathlib/Data/Set/Basic.lean",
              "def_pos": [
                791,
                9
              ],
              "def_end_pos": [
                791,
                38
              ]
            }
          ]
        ],
        "state_before": "case e_s\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nq : Semiquot \u03b1\ns : Set \u03b1\nh : q.s \u2286 s\n\u22a2 s \u222a q.s = s",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.182218077010475,
    "entry_failed": false
  },
  "26254": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/Measure/Trim.lean",
    "full_name": "MeasureTheory.Measure.AbsolutelyContinuous.trim",
    "start": [
      134,
      1
    ],
    "end": [
      138,
      16
    ],
    "traced_tactics": [
      {
        "tactic": "refine Measure.AbsolutelyContinuous.mk (fun s hs hs\u03bd \u21a6 ?_)",
        "annotated_tactic": [
          "refine <a>Measure.AbsolutelyContinuous.mk</a> (fun s hs hs\u03bd \u21a6 ?_)",
          [
            {
              "full_name": "MeasureTheory.Measure.AbsolutelyContinuous.mk",
              "def_path": "Mathlib/MeasureTheory/Measure/MeasureSpace.lean",
              "def_pos": [
                1629,
                9
              ],
              "def_end_pos": [
                1629,
                11
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nm m0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns : Set \u03b1\n\u03bd : Measure \u03b1\nh\u03bc\u03bd : \u03bc \u226a \u03bd\nhm : m \u2264 m0\n\u22a2 \u03bc.trim hm \u226a \u03bd.trim hm",
        "state_after": "\u03b1 : Type u_1\nm m0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns\u271d : Set \u03b1\n\u03bd : Measure \u03b1\nh\u03bc\u03bd : \u03bc \u226a \u03bd\nhm : m \u2264 m0\ns : Set \u03b1\nhs : MeasurableSet s\nhs\u03bd : (\u03bd.trim hm) s = 0\n\u22a2 (\u03bc.trim hm) s = 0"
      },
      {
        "tactic": "rw [trim_measurableSet_eq hm hs] at hs\u03bd \u22a2",
        "annotated_tactic": [
          "rw [<a>trim_measurableSet_eq</a> hm hs] at hs\u03bd \u22a2",
          [
            {
              "full_name": "MeasureTheory.trim_measurableSet_eq",
              "def_path": "Mathlib/MeasureTheory/Measure/Trim.lean",
              "def_pos": [
                53,
                9
              ],
              "def_end_pos": [
                53,
                30
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nm m0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns\u271d : Set \u03b1\n\u03bd : Measure \u03b1\nh\u03bc\u03bd : \u03bc \u226a \u03bd\nhm : m \u2264 m0\ns : Set \u03b1\nhs : MeasurableSet s\nhs\u03bd : (\u03bd.trim hm) s = 0\n\u22a2 (\u03bc.trim hm) s = 0",
        "state_after": "\u03b1 : Type u_1\nm m0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns\u271d : Set \u03b1\n\u03bd : Measure \u03b1\nh\u03bc\u03bd : \u03bc \u226a \u03bd\nhm : m \u2264 m0\ns : Set \u03b1\nhs : MeasurableSet s\nhs\u03bd : \u03bd s = 0\n\u22a2 \u03bc s = 0"
      },
      {
        "tactic": "exact h\u03bc\u03bd hs\u03bd",
        "annotated_tactic": [
          "exact h\u03bc\u03bd hs\u03bd",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nm m0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns\u271d : Set \u03b1\n\u03bd : Measure \u03b1\nh\u03bc\u03bd : \u03bc \u226a \u03bd\nhm : m \u2264 m0\ns : Set \u03b1\nhs : MeasurableSet s\nhs\u03bd : \u03bd s = 0\n\u22a2 \u03bc s = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9667864580405876,
    "entry_failed": false
  },
  "26257": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Real/ConjExponents.lean",
    "full_name": "NNReal.isConjExponent_coe",
    "start": [
      163,
      1
    ],
    "end": [
      164,
      70
    ],
    "traced_tactics": [
      {
        "tactic": "simp [Real.isConjExponent_iff, isConjExponent_iff]",
        "annotated_tactic": [
          "simp [<a>Real.isConjExponent_iff</a>, <a>isConjExponent_iff</a>]",
          [
            {
              "full_name": "Real.isConjExponent_iff",
              "def_path": "Mathlib/Data/Real/ConjExponents.lean",
              "def_pos": [
                39,
                3
              ],
              "def_end_pos": [
                39,
                9
              ]
            },
            {
              "full_name": "NNReal.isConjExponent_iff",
              "def_path": "Mathlib/Data/Real/ConjExponents.lean",
              "def_pos": [
                151,
                3
              ],
              "def_end_pos": [
                151,
                9
              ]
            }
          ]
        ],
        "state_before": "a b p q : \u211d\u22650\nh : p.IsConjExponent q\n\u22a2 (\u2191p).IsConjExponent \u2191q \u2194 p.IsConjExponent q",
        "state_after": "a b p q : \u211d\u22650\nh : p.IsConjExponent q\n\u22a2 1 < p \u2192 ((\u2191p)\u207b\u00b9 + (\u2191q)\u207b\u00b9 = 1 \u2194 p\u207b\u00b9 + q\u207b\u00b9 = 1)"
      },
      {
        "tactic": "norm_cast",
        "annotated_tactic": [
          "norm_cast",
          []
        ],
        "state_before": "a b p q : \u211d\u22650\nh : p.IsConjExponent q\n\u22a2 1 < p \u2192 ((\u2191p)\u207b\u00b9 + (\u2191q)\u207b\u00b9 = 1 \u2194 p\u207b\u00b9 + q\u207b\u00b9 = 1)",
        "state_after": "a b p q : \u211d\u22650\nh : p.IsConjExponent q\n\u22a2 1 < p \u2192 (p\u207b\u00b9 + q\u207b\u00b9 = 1 \u2194 p\u207b\u00b9 + q\u207b\u00b9 = 1)"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "a b p q : \u211d\u22650\nh : p.IsConjExponent q\n\u22a2 1 < p \u2192 (p\u207b\u00b9 + q\u207b\u00b9 = 1 \u2194 p\u207b\u00b9 + q\u207b\u00b9 = 1)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.135891528916545,
    "entry_failed": false
  },
  "26275": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Tropical/BigOperators.lean",
    "full_name": "List.untrop_prod",
    "start": [
      58,
      1
    ],
    "end": [
      62,
      16
    ],
    "traced_tactics": [
      {
        "tactic": "induction' l with hd tl IH",
        "annotated_tactic": [
          "induction' l with hd tl IH",
          []
        ],
        "state_before": "R : Type u_1\nS : Type u_2\ninst\u271d : AddMonoid R\nl : List (Tropical R)\n\u22a2 untrop l.prod = (map untrop l).sum",
        "state_after": "case nil\nR : Type u_1\nS : Type u_2\ninst\u271d : AddMonoid R\n\u22a2 untrop [].prod = (map untrop []).sum\n\ncase cons\nR : Type u_1\nS : Type u_2\ninst\u271d : AddMonoid R\nhd : Tropical R\ntl : List (Tropical R)\nIH : untrop tl.prod = (map untrop tl).sum\n\u22a2 untrop (hd :: tl).prod = (map untrop (hd :: tl)).sum"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case nil\nR : Type u_1\nS : Type u_2\ninst\u271d : AddMonoid R\n\u22a2 untrop [].prod = (map untrop []).sum",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [\u2190 IH]",
        "annotated_tactic": [
          "simp [\u2190 IH]",
          []
        ],
        "state_before": "case cons\nR : Type u_1\nS : Type u_2\ninst\u271d : AddMonoid R\nhd : Tropical R\ntl : List (Tropical R)\nIH : untrop tl.prod = (map untrop tl).sum\n\u22a2 untrop (hd :: tl).prod = (map untrop (hd :: tl)).sum",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5113194700097665,
    "entry_failed": false
  },
  "26367": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Instances/Sign.lean",
    "full_name": "continuousAt_sign_of_ne_zero",
    "start": [
      50,
      1
    ],
    "end": [
      53,
      41
    ],
    "traced_tactics": [
      {
        "tactic": "rcases h.lt_or_lt with (h_neg | h_pos)",
        "annotated_tactic": [
          "rcases h.lt_or_lt with (h_neg | h_pos)",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\nh : a \u2260 0\n\u22a2 ContinuousAt (\u21d1SignType.sign) a",
        "state_after": "case inl\n\u03b1 : Type u_1\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\nh : a \u2260 0\nh_neg : a < 0\n\u22a2 ContinuousAt (\u21d1SignType.sign) a\n\ncase inr\n\u03b1 : Type u_1\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\nh : a \u2260 0\nh_pos : 0 < a\n\u22a2 ContinuousAt (\u21d1SignType.sign) a"
      },
      {
        "tactic": "exact continuousAt_sign_of_neg h_neg",
        "annotated_tactic": [
          "exact <a>continuousAt_sign_of_neg</a> h_neg",
          [
            {
              "full_name": "continuousAt_sign_of_neg",
              "def_path": "Mathlib/Topology/Instances/Sign.lean",
              "def_pos": [
                38,
                9
              ],
              "def_end_pos": [
                38,
                33
              ]
            }
          ]
        ],
        "state_before": "case inl\n\u03b1 : Type u_1\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\nh : a \u2260 0\nh_neg : a < 0\n\u22a2 ContinuousAt (\u21d1SignType.sign) a",
        "state_after": "no goals"
      },
      {
        "tactic": "exact continuousAt_sign_of_pos h_pos",
        "annotated_tactic": [
          "exact <a>continuousAt_sign_of_pos</a> h_pos",
          [
            {
              "full_name": "continuousAt_sign_of_pos",
              "def_path": "Mathlib/Topology/Instances/Sign.lean",
              "def_pos": [
                32,
                9
              ],
              "def_end_pos": [
                32,
                33
              ]
            }
          ]
        ],
        "state_before": "case inr\n\u03b1 : Type u_1\ninst\u271d\u00b3 : Zero \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\na : \u03b1\nh : a \u2260 0\nh_pos : 0 < a\n\u22a2 ContinuousAt (\u21d1SignType.sign) a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.3040889549301937,
    "entry_failed": false
  },
  "26414": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Polynomial/Pochhammer.lean",
    "full_name": "descPochhammer_eval_zero",
    "start": [
      289,
      1
    ],
    "end": [
      293,
      61
    ],
    "traced_tactics": [
      {
        "tactic": "cases n",
        "annotated_tactic": [
          "cases n",
          []
        ],
        "state_before": "R : Type u\ninst\u271d : Ring R\nn : \u2115\n\u22a2 eval 0 (descPochhammer R n) = if n = 0 then 1 else 0",
        "state_after": "case zero\nR : Type u\ninst\u271d : Ring R\n\u22a2 eval 0 (descPochhammer R 0) = if 0 = 0 then 1 else 0\n\ncase succ\nR : Type u\ninst\u271d : Ring R\nn\u271d : \u2115\n\u22a2 eval 0 (descPochhammer R (n\u271d + 1)) = if n\u271d + 1 = 0 then 1 else 0"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case zero\nR : Type u\ninst\u271d : Ring R\n\u22a2 eval 0 (descPochhammer R 0) = if 0 = 0 then 1 else 0",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [X_mul, Nat.succ_ne_zero, descPochhammer_succ_left]",
        "annotated_tactic": [
          "simp [<a>X_mul</a>, <a>Nat.succ_ne_zero</a>, <a>descPochhammer_succ_left</a>]",
          [
            {
              "full_name": "Polynomial.X_mul",
              "def_path": "Mathlib/Algebra/Polynomial/Basic.lean",
              "def_pos": [
                584,
                9
              ],
              "def_end_pos": [
                584,
                14
              ]
            },
            {
              "full_name": "Nat.succ_ne_zero",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean",
              "def_pos": [
                708,
                17
              ],
              "def_end_pos": [
                708,
                29
              ]
            },
            {
              "full_name": "descPochhammer_succ_left",
              "def_path": "Mathlib/RingTheory/Polynomial/Pochhammer.lean",
              "def_pos": [
                258,
                9
              ],
              "def_end_pos": [
                258,
                33
              ]
            }
          ]
        ],
        "state_before": "case succ\nR : Type u\ninst\u271d : Ring R\nn\u271d : \u2115\n\u22a2 eval 0 (descPochhammer R (n\u271d + 1)) = if n\u271d + 1 = 0 then 1 else 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.6631494590546936,
    "entry_failed": false
  },
  "26430": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Matroid/Restrict.lean",
    "full_name": "Matroid.StrictRestriction.ne",
    "start": [
      299,
      1
    ],
    "end": [
      300,
      54
    ],
    "traced_tactics": [
      {
        "tactic": "rintro rfl",
        "annotated_tactic": [
          "rintro rfl",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nM : Matroid \u03b1\nR I J X Y : Set \u03b1\nN : Matroid \u03b1\nh : N <r M\n\u22a2 N \u2260 M",
        "state_after": "\u03b1 : Type u_1\nR I J X Y : Set \u03b1\nN : Matroid \u03b1\nh : N <r N\n\u22a2 False"
      },
      {
        "tactic": "rw [\u2190 ofMatroid_lt_iff] at h",
        "annotated_tactic": [
          "rw [\u2190 <a>ofMatroid_lt_iff</a>] at h",
          [
            {
              "full_name": "Matroid.ofMatroid_lt_iff",
              "def_path": "Mathlib/Data/Matroid/Restrict.lean",
              "def_pos": [
                264,
                9
              ],
              "def_end_pos": [
                264,
                25
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nR I J X Y : Set \u03b1\nN : Matroid \u03b1\nh : N <r N\n\u22a2 False",
        "state_after": "\u03b1 : Type u_1\nR I J X Y : Set \u03b1\nN : Matroid \u03b1\nh : { toMatroid := N } < { toMatroid := N }\n\u22a2 False"
      },
      {
        "tactic": "simp at h",
        "annotated_tactic": [
          "simp at h",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nR I J X Y : Set \u03b1\nN : Matroid \u03b1\nh : { toMatroid := N } < { toMatroid := N }\n\u22a2 False",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.634411261067726,
    "entry_failed": false
  },
  "26548": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean",
    "full_name": "Real.pi_div_four_le_arcsin",
    "start": [
      274,
      1
    ],
    "end": [
      277,
      27
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 sin_pi_div_four, le_arcsin_iff_sin_le']",
        "annotated_tactic": [
          "rw [\u2190 <a>sin_pi_div_four</a>, <a>le_arcsin_iff_sin_le'</a>]",
          [
            {
              "full_name": "Real.sin_pi_div_four",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean",
              "def_pos": [
                827,
                9
              ],
              "def_end_pos": [
                827,
                24
              ]
            },
            {
              "full_name": "Real.le_arcsin_iff_sin_le'",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean",
              "def_pos": [
                169,
                9
              ],
              "def_end_pos": [
                169,
                30
              ]
            }
          ]
        ],
        "state_before": "x\u271d y x : \u211d\n\u22a2 \u03c0 / 4 \u2264 arcsin x \u2194 \u221a2 / 2 \u2264 x",
        "state_after": "x\u271d y x : \u211d\n\u22a2 \u03c0 / 4 \u2208 Ioc (-(\u03c0 / 2)) (\u03c0 / 2)"
      },
      {
        "tactic": "have := pi_pos",
        "annotated_tactic": [
          "have := <a>pi_pos</a>",
          [
            {
              "full_name": "Real.pi_pos",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean",
              "def_pos": [
                169,
                9
              ],
              "def_end_pos": [
                169,
                15
              ]
            }
          ]
        ],
        "state_before": "x\u271d y x : \u211d\n\u22a2 \u03c0 / 4 \u2208 Ioc (-(\u03c0 / 2)) (\u03c0 / 2)",
        "state_after": "x\u271d y x : \u211d\nthis : 0 < \u03c0\n\u22a2 \u03c0 / 4 \u2208 Ioc (-(\u03c0 / 2)) (\u03c0 / 2)"
      },
      {
        "tactic": "constructor <;> linarith",
        "annotated_tactic": [
          "constructor <;> linarith",
          []
        ],
        "state_before": "x\u271d y x : \u211d\nthis : 0 < \u03c0\n\u22a2 \u03c0 / 4 \u2208 Ioc (-(\u03c0 / 2)) (\u03c0 / 2)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.2944040610454977,
    "entry_failed": false
  },
  "26549": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/PNat/Prime.lean",
    "full_name": "PNat.dvd_prime",
    "start": [
      144,
      1
    ],
    "end": [
      147,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "rw [PNat.dvd_iff]",
        "annotated_tactic": [
          "rw [<a>PNat.dvd_iff</a>]",
          [
            {
              "full_name": "PNat.dvd_iff",
              "def_path": "Mathlib/Data/PNat/Basic.lean",
              "def_pos": [
                369,
                9
              ],
              "def_end_pos": [
                369,
                16
              ]
            }
          ]
        ],
        "state_before": "p m : \u2115+\npp : p.Prime\n\u22a2 m \u2223 p \u2194 m = 1 \u2228 m = p",
        "state_after": "p m : \u2115+\npp : p.Prime\n\u22a2 \u2191m \u2223 \u2191p \u2194 m = 1 \u2228 m = p"
      },
      {
        "tactic": "rw [Nat.dvd_prime pp]",
        "annotated_tactic": [
          "rw [<a>Nat.dvd_prime</a> pp]",
          [
            {
              "full_name": "Nat.dvd_prime",
              "def_path": "Mathlib/Data/Nat/Prime.lean",
              "def_pos": [
                202,
                9
              ],
              "def_end_pos": [
                202,
                18
              ]
            }
          ]
        ],
        "state_before": "p m : \u2115+\npp : p.Prime\n\u22a2 \u2191m \u2223 \u2191p \u2194 m = 1 \u2228 m = p",
        "state_after": "p m : \u2115+\npp : p.Prime\n\u22a2 \u2191m = 1 \u2228 \u2191m = \u2191p \u2194 m = 1 \u2228 m = p"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "p m : \u2115+\npp : p.Prime\n\u22a2 \u2191m = 1 \u2228 \u2191m = \u2191p \u2194 m = 1 \u2228 m = p",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5293298489414155,
    "entry_failed": false
  },
  "26551": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Filter/Cofinite.lean",
    "full_name": "Filter.countable_compl_ker",
    "start": [
      143,
      1
    ],
    "end": [
      146,
      71
    ],
    "traced_tactics": [
      {
        "tactic": "rcases exists_antitone_basis l with \u27e8s, hs\u27e9",
        "annotated_tactic": [
          "rcases <a>exists_antitone_basis</a> l with \u27e8s, hs\u27e9",
          [
            {
              "full_name": "Filter.exists_antitone_basis",
              "def_path": "Mathlib/Order/Filter/Bases.lean",
              "def_pos": [
                1118,
                9
              ],
              "def_end_pos": [
                1118,
                30
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\ninst\u271d : l.IsCountablyGenerated\nh : cofinite \u2264 l\n\u22a2 l.ker\u1d9c.Countable",
        "state_after": "case intro\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\ninst\u271d : l.IsCountablyGenerated\nh : cofinite \u2264 l\ns : \u2115 \u2192 Set \u03b1\nhs : l.HasAntitoneBasis s\n\u22a2 l.ker\u1d9c.Countable"
      },
      {
        "tactic": "simp only [hs.ker, iInter_true, compl_iInter]",
        "annotated_tactic": [
          "simp only [hs.ker, <a>iInter_true</a>, <a>compl_iInter</a>]",
          [
            {
              "full_name": "Set.iInter_true",
              "def_path": "Mathlib/Data/Set/Lattice.lean",
              "def_pos": [
                626,
                9
              ],
              "def_end_pos": [
                626,
                20
              ]
            },
            {
              "full_name": "Set.compl_iInter",
              "def_path": "Mathlib/Data/Set/Lattice.lean",
              "def_pos": [
                462,
                9
              ],
              "def_end_pos": [
                462,
                21
              ]
            }
          ]
        ],
        "state_before": "case intro\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\ninst\u271d : l.IsCountablyGenerated\nh : cofinite \u2264 l\ns : \u2115 \u2192 Set \u03b1\nhs : l.HasAntitoneBasis s\n\u22a2 l.ker\u1d9c.Countable",
        "state_after": "case intro\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\ninst\u271d : l.IsCountablyGenerated\nh : cofinite \u2264 l\ns : \u2115 \u2192 Set \u03b1\nhs : l.HasAntitoneBasis s\n\u22a2 (\u22c3 i, (s i)\u1d9c).Countable"
      },
      {
        "tactic": "exact countable_iUnion fun n \u21a6 Set.Finite.countable <| h <| hs.mem _",
        "annotated_tactic": [
          "exact <a>countable_iUnion</a> fun n \u21a6 <a>Set.Finite.countable</a> <| h <| hs.mem _",
          [
            {
              "full_name": "Set.countable_iUnion",
              "def_path": "Mathlib/Data/Set/Countable.lean",
              "def_pos": [
                222,
                9
              ],
              "def_end_pos": [
                222,
                25
              ]
            },
            {
              "full_name": "Set.Finite.countable",
              "def_path": "Mathlib/Data/Set/Countable.lean",
              "def_pos": [
                272,
                9
              ],
              "def_end_pos": [
                272,
                25
              ]
            }
          ]
        ],
        "state_before": "case intro\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl : Filter \u03b1\ninst\u271d : l.IsCountablyGenerated\nh : cofinite \u2264 l\ns : \u2115 \u2192 Set \u03b1\nhs : l.HasAntitoneBasis s\n\u22a2 (\u22c3 i, (s i)\u1d9c).Countable",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5647634260822088,
    "entry_failed": false
  },
  "26583": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/Measure/GiryMonad.lean",
    "full_name": "MeasureTheory.Measure.measurable_map",
    "start": [
      78,
      1
    ],
    "end": [
      82,
      31
    ],
    "traced_tactics": [
      {
        "tactic": "refine measurable_of_measurable_coe _ fun s hs => ?_",
        "annotated_tactic": [
          "refine <a>measurable_of_measurable_coe</a> _ fun s hs => ?_",
          [
            {
              "full_name": "MeasureTheory.Measure.measurable_of_measurable_coe",
              "def_path": "Mathlib/MeasureTheory/Measure/GiryMonad.lean",
              "def_pos": [
                58,
                9
              ],
              "def_end_pos": [
                58,
                37
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Measurable f\n\u22a2 Measurable fun \u03bc => map f \u03bc",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Measurable f\ns : Set \u03b2\nhs : MeasurableSet s\n\u22a2 Measurable fun b => (map f b) s"
      },
      {
        "tactic": "simp_rw [map_apply hf hs]",
        "annotated_tactic": [
          "simp_rw [<a>map_apply</a> hf hs]",
          [
            {
              "full_name": "MeasureTheory.Measure.map_apply",
              "def_path": "Mathlib/MeasureTheory/Measure/MeasureSpace.lean",
              "def_pos": [
                1291,
                9
              ],
              "def_end_pos": [
                1291,
                18
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Measurable f\ns : Set \u03b2\nhs : MeasurableSet s\n\u22a2 Measurable fun b => (map f b) s",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Measurable f\ns : Set \u03b2\nhs : MeasurableSet s\n\u22a2 Measurable fun b => b (f \u207b\u00b9' s)"
      },
      {
        "tactic": "exact measurable_coe (hf hs)",
        "annotated_tactic": [
          "exact <a>measurable_coe</a> (hf hs)",
          [
            {
              "full_name": "MeasureTheory.Measure.measurable_coe",
              "def_path": "Mathlib/MeasureTheory/Measure/GiryMonad.lean",
              "def_pos": [
                54,
                9
              ],
              "def_end_pos": [
                54,
                23
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Measurable f\ns : Set \u03b2\nhs : MeasurableSet s\n\u22a2 Measurable fun b => b (f \u207b\u00b9' s)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7907366009894758,
    "entry_failed": false
  },
  "26671": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Ordinal/Principal.lean",
    "full_name": "Ordinal.op_eq_self_of_principal",
    "start": [
      77,
      1
    ],
    "end": [
      81,
      37
    ],
    "traced_tactics": [
      {
        "tactic": "refine le_antisymm ?_ (H.self_le _)",
        "annotated_tactic": [
          "refine <a>le_antisymm</a> ?_ (H.self_le _)",
          [
            {
              "full_name": "le_antisymm",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                188,
                9
              ],
              "def_end_pos": [
                188,
                20
              ]
            }
          ]
        ],
        "state_before": "op : Ordinal.{u} \u2192 Ordinal.{u} \u2192 Ordinal.{u}\na o : Ordinal.{u}\nhao : a < o\nH : IsNormal (op a)\nho : Principal op o\nho' : o.IsLimit\n\u22a2 op a o = o",
        "state_after": "op : Ordinal.{u} \u2192 Ordinal.{u} \u2192 Ordinal.{u}\na o : Ordinal.{u}\nhao : a < o\nH : IsNormal (op a)\nho : Principal op o\nho' : o.IsLimit\n\u22a2 op a o \u2264 o"
      },
      {
        "tactic": "rw [\u2190 IsNormal.bsup_eq.{u, u} H ho', bsup_le_iff]",
        "annotated_tactic": [
          "rw [\u2190 <a>IsNormal.bsup_eq</a>.{u, u} H ho', <a>bsup_le_iff</a>]",
          [
            {
              "full_name": "Ordinal.IsNormal.bsup_eq",
              "def_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean",
              "def_pos": [
                1958,
                9
              ],
              "def_end_pos": [
                1958,
                25
              ]
            },
            {
              "full_name": "Ordinal.bsup_le_iff",
              "def_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean",
              "def_pos": [
                1484,
                9
              ],
              "def_end_pos": [
                1484,
                20
              ]
            }
          ]
        ],
        "state_before": "op : Ordinal.{u} \u2192 Ordinal.{u} \u2192 Ordinal.{u}\na o : Ordinal.{u}\nhao : a < o\nH : IsNormal (op a)\nho : Principal op o\nho' : o.IsLimit\n\u22a2 op a o \u2264 o",
        "state_after": "op : Ordinal.{u} \u2192 Ordinal.{u} \u2192 Ordinal.{u}\na o : Ordinal.{u}\nhao : a < o\nH : IsNormal (op a)\nho : Principal op o\nho' : o.IsLimit\n\u22a2 \u2200 i < o, op a i \u2264 o"
      },
      {
        "tactic": "exact fun b hbo => (ho hao hbo).le",
        "annotated_tactic": [
          "exact fun b hbo => (ho hao hbo).<a>le</a>",
          [
            {
              "full_name": "LT.lt.le",
              "def_path": "Mathlib/Order/Basic.lean",
              "def_pos": [
                137,
                7
              ],
              "def_end_pos": [
                137,
                15
              ]
            }
          ]
        ],
        "state_before": "op : Ordinal.{u} \u2192 Ordinal.{u} \u2192 Ordinal.{u}\na o : Ordinal.{u}\nhao : a < o\nH : IsNormal (op a)\nho : Principal op o\nho' : o.IsLimit\n\u22a2 \u2200 i < o, op a i \u2264 o",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5749897389905527,
    "entry_failed": false
  },
  "26700": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Rel.lean",
    "full_name": "Rel.image_bot",
    "start": [
      215,
      1
    ],
    "end": [
      218,
      33
    ],
    "traced_tactics": [
      {
        "tactic": "rw [Set.eq_empty_iff_forall_not_mem]",
        "annotated_tactic": [
          "rw [<a>Set.eq_empty_iff_forall_not_mem</a>]",
          [
            {
              "full_name": "Set.eq_empty_iff_forall_not_mem",
              "def_path": "Mathlib/Data/Set/Basic.lean",
              "def_pos": [
                552,
                9
              ],
              "def_end_pos": [
                552,
                36
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : Rel \u03b1 \u03b2\ns : Set \u03b1\n\u22a2 \u22a5.image s = \u2205",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : Rel \u03b1 \u03b2\ns : Set \u03b1\n\u22a2 \u2200 (x : \u03b2), x \u2209 \u22a5.image s"
      },
      {
        "tactic": "intro x h",
        "annotated_tactic": [
          "intro x h",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : Rel \u03b1 \u03b2\ns : Set \u03b1\n\u22a2 \u2200 (x : \u03b2), x \u2209 \u22a5.image s",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : Rel \u03b1 \u03b2\ns : Set \u03b1\nx : \u03b2\nh : x \u2208 \u22a5.image s\n\u22a2 False"
      },
      {
        "tactic": "simp [mem_image, Bot.bot] at h",
        "annotated_tactic": [
          "simp [<a>mem_image</a>, <a>Bot.bot</a>] at h",
          [
            {
              "full_name": "Rel.mem_image",
              "def_path": "Mathlib/Data/Rel.lean",
              "def_pos": [
                169,
                9
              ],
              "def_end_pos": [
                169,
                18
              ]
            },
            {
              "full_name": "Bot.bot",
              "def_path": "Mathlib/Order/Notation.lean",
              "def_pos": [
                107,
                3
              ],
              "def_end_pos": [
                107,
                6
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : Rel \u03b1 \u03b2\ns : Set \u03b1\nx : \u03b2\nh : x \u2208 \u22a5.image s\n\u22a2 False",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9487557340180501,
    "entry_failed": false
  },
  "26801": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/NormedSpace/WeakDual.lean",
    "full_name": "NormedSpace.Dual.dual_norm_topology_le_weak_dual_topology",
    "start": [
      141,
      1
    ],
    "end": [
      145,
      24
    ],
    "traced_tactics": [
      {
        "tactic": "convert (@toWeakDual_continuous _ _ _ _ (by assumption)).le_induced",
        "annotated_tactic": [
          "convert (@<a>toWeakDual_continuous</a> _ _ _ _ (by assumption)).<a>le_induced</a>",
          [
            {
              "full_name": "NormedSpace.Dual.toWeakDual_continuous",
              "def_path": "Mathlib/Analysis/NormedSpace/WeakDual.lean",
              "def_pos": [
                129,
                9
              ],
              "def_end_pos": [
                129,
                30
              ]
            },
            {
              "full_name": "Continuous.le_induced",
              "def_path": "Mathlib/Topology/Order.lean",
              "def_pos": [
                419,
                9
              ],
              "def_end_pos": [
                419,
                30
              ]
            }
          ]
        ],
        "state_before": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\n\u22a2 UniformSpace.toTopologicalSpace \u2264 WeakDual.instTopologicalSpace",
        "state_after": "case h.e'_4\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\n\u22a2 WeakDual.instTopologicalSpace = TopologicalSpace.induced (fun x' => toWeakDual x') WeakDual.instTopologicalSpace"
      },
      {
        "tactic": "exact induced_id.symm",
        "annotated_tactic": [
          "exact induced_id.symm",
          []
        ],
        "state_before": "case h.e'_4\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\n\u22a2 WeakDual.instTopologicalSpace = TopologicalSpace.induced (fun x' => toWeakDual x') WeakDual.instTopologicalSpace",
        "state_after": "no goals"
      },
      {
        "tactic": "assumption",
        "annotated_tactic": [
          "assumption",
          []
        ],
        "state_before": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\n\u22a2 NormedSpace ?m.21778 ?m.21780",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.077292488072999,
    "entry_failed": false
  },
  "26813": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/OmegaCompletePartialOrder.lean",
    "full_name": "CompleteLattice.sup_continuous",
    "start": [
      541,
      1
    ],
    "end": [
      544,
      42
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 sSup_pair]",
        "annotated_tactic": [
          "rw [\u2190 <a>sSup_pair</a>]",
          [
            {
              "full_name": "sSup_pair",
              "def_path": "Mathlib/Order/CompleteLattice.lean",
              "def_pos": [
                468,
                9
              ],
              "def_end_pos": [
                468,
                18
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : OmegaCompletePartialOrder \u03b1\ninst\u271d : CompleteLattice \u03b2\nf g : \u03b1 \u2192o \u03b2\nhf : Continuous f\nhg : Continuous g\n\u22a2 Continuous (f \u2294 g)",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : OmegaCompletePartialOrder \u03b1\ninst\u271d : CompleteLattice \u03b2\nf g : \u03b1 \u2192o \u03b2\nhf : Continuous f\nhg : Continuous g\n\u22a2 Continuous (sSup {f, g})"
      },
      {
        "tactic": "apply sSup_continuous",
        "annotated_tactic": [
          "apply <a>sSup_continuous</a>",
          [
            {
              "full_name": "CompleteLattice.sSup_continuous",
              "def_path": "Mathlib/Order/OmegaCompletePartialOrder.lean",
              "def_pos": [
                518,
                9
              ],
              "def_end_pos": [
                518,
                24
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : OmegaCompletePartialOrder \u03b1\ninst\u271d : CompleteLattice \u03b2\nf g : \u03b1 \u2192o \u03b2\nhf : Continuous f\nhg : Continuous g\n\u22a2 Continuous (sSup {f, g})",
        "state_after": "case hs\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : OmegaCompletePartialOrder \u03b1\ninst\u271d : CompleteLattice \u03b2\nf g : \u03b1 \u2192o \u03b2\nhf : Continuous f\nhg : Continuous g\n\u22a2 \u2200 f_1 \u2208 {f, g}, Continuous f_1"
      },
      {
        "tactic": "rintro f (rfl | rfl | _) <;> assumption",
        "annotated_tactic": [
          "rintro f (rfl | rfl | _) <;> assumption",
          []
        ],
        "state_before": "case hs\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : OmegaCompletePartialOrder \u03b1\ninst\u271d : CompleteLattice \u03b2\nf g : \u03b1 \u2192o \u03b2\nhf : Continuous f\nhg : Continuous g\n\u22a2 \u2200 f_1 \u2208 {f, g}, Continuous f_1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.4115947319660336,
    "entry_failed": false
  },
  "26893": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Bounds.lean",
    "full_name": "Real.sin_le",
    "start": [
      52,
      1
    ],
    "end": [
      55,
      25
    ],
    "traced_tactics": [
      {
        "tactic": "obtain rfl | hx := hx.eq_or_lt",
        "annotated_tactic": [
          "obtain rfl | hx := hx.eq_or_lt",
          []
        ],
        "state_before": "x : \u211d\nhx : 0 \u2264 x\n\u22a2 sin x \u2264 x",
        "state_after": "case inl\nhx : 0 \u2264 0\n\u22a2 sin 0 \u2264 0\n\ncase inr\nx : \u211d\nhx\u271d : 0 \u2264 x\nhx : 0 < x\n\u22a2 sin x \u2264 x"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case inl\nhx : 0 \u2264 0\n\u22a2 sin 0 \u2264 0",
        "state_after": "no goals"
      },
      {
        "tactic": "exact (sin_lt hx).le",
        "annotated_tactic": [
          "exact (<a>sin_lt</a> hx).<a>le</a>",
          [
            {
              "full_name": "Real.sin_lt",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Bounds.lean",
              "def_pos": [
                39,
                9
              ],
              "def_end_pos": [
                39,
                15
              ]
            },
            {
              "full_name": "LT.lt.le",
              "def_path": "Mathlib/Order/Basic.lean",
              "def_pos": [
                137,
                7
              ],
              "def_end_pos": [
                137,
                15
              ]
            }
          ]
        ],
        "state_before": "case inr\nx : \u211d\nhx\u271d : 0 \u2264 x\nhx : 0 < x\n\u22a2 sin x \u2264 x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.097808885970153,
    "entry_failed": false
  },
  "26933": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Ends/Defs.lean",
    "full_name": "SimpleGraph.componentComplMk_eq_of_adj",
    "start": [
      71,
      1
    ],
    "end": [
      75,
      10
    ],
    "traced_tactics": [
      {
        "tactic": "rw [ConnectedComponent.eq]",
        "annotated_tactic": [
          "rw [<a>ConnectedComponent.eq</a>]",
          [
            {
              "full_name": "SimpleGraph.ConnectedComponent.eq",
              "def_path": "Mathlib/Combinatorics/SimpleGraph/Connectivity.lean",
              "def_pos": [
                2191,
                19
              ],
              "def_end_pos": [
                2191,
                21
              ]
            }
          ]
        ],
        "state_before": "V : Type u\nG\u271d : SimpleGraph V\nK L L' M : Set V\nG : SimpleGraph V\nv w : V\nvK : v \u2209 K\nwK : w \u2209 K\na : G.Adj v w\n\u22a2 G.componentComplMk vK = G.componentComplMk wK",
        "state_after": "V : Type u\nG\u271d : SimpleGraph V\nK L L' M : Set V\nG : SimpleGraph V\nv w : V\nvK : v \u2209 K\nwK : w \u2209 K\na : G.Adj v w\n\u22a2 (induce K\u1d9c G).Reachable \u27e8v, vK\u27e9 \u27e8w, wK\u27e9"
      },
      {
        "tactic": "apply Adj.reachable",
        "annotated_tactic": [
          "apply <a>Adj.reachable</a>",
          [
            {
              "full_name": "SimpleGraph.Adj.reachable",
              "def_path": "Mathlib/Combinatorics/SimpleGraph/Connectivity.lean",
              "def_pos": [
                2017,
                19
              ],
              "def_end_pos": [
                2017,
                32
              ]
            }
          ]
        ],
        "state_before": "V : Type u\nG\u271d : SimpleGraph V\nK L L' M : Set V\nG : SimpleGraph V\nv w : V\nvK : v \u2209 K\nwK : w \u2209 K\na : G.Adj v w\n\u22a2 (induce K\u1d9c G).Reachable \u27e8v, vK\u27e9 \u27e8w, wK\u27e9",
        "state_after": "case h\nV : Type u\nG\u271d : SimpleGraph V\nK L L' M : Set V\nG : SimpleGraph V\nv w : V\nvK : v \u2209 K\nwK : w \u2209 K\na : G.Adj v w\n\u22a2 (induce K\u1d9c G).Adj \u27e8v, vK\u27e9 \u27e8w, wK\u27e9"
      },
      {
        "tactic": "exact a",
        "annotated_tactic": [
          "exact a",
          []
        ],
        "state_before": "case h\nV : Type u\nG\u271d : SimpleGraph V\nK L L' M : Set V\nG : SimpleGraph V\nv w : V\nvK : v \u2209 K\nwK : w \u2209 K\na : G.Adj v w\n\u22a2 (induce K\u1d9c G).Adj \u27e8v, vK\u27e9 \u27e8w, wK\u27e9",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5195511119673029,
    "entry_failed": false
  },
  "26966": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/Fourier/AddCircle.lean",
    "full_name": "fourier_zero",
    "start": [
      132,
      1
    ],
    "end": [
      135,
      11
    ],
    "traced_tactics": [
      {
        "tactic": "induction x using QuotientAddGroup.induction_on'",
        "annotated_tactic": [
          "induction x using <a>QuotientAddGroup.induction_on'</a>",
          [
            {
              "full_name": "QuotientAddGroup.induction_on'",
              "def_path": "Mathlib/GroupTheory/Coset.lean",
              "def_pos": [
                467,
                3
              ],
              "def_end_pos": [
                467,
                14
              ]
            }
          ]
        ],
        "state_before": "T : \u211d\nx : AddCircle T\n\u22a2 (fourier 0) x = 1",
        "state_after": "case H\nT z\u271d : \u211d\n\u22a2 (fourier 0) \u2191z\u271d = 1"
      },
      {
        "tactic": "simp only [fourier_coe_apply]",
        "annotated_tactic": [
          "simp only [<a>fourier_coe_apply</a>]",
          [
            {
              "full_name": "fourier_coe_apply",
              "def_path": "Mathlib/Analysis/Fourier/AddCircle.lean",
              "def_pos": [
                117,
                9
              ],
              "def_end_pos": [
                117,
                26
              ]
            }
          ]
        ],
        "state_before": "case H\nT z\u271d : \u211d\n\u22a2 (fourier 0) \u2191z\u271d = 1",
        "state_after": "case H\nT z\u271d : \u211d\n\u22a2 Complex.exp (2 * \u2191\u03c0 * Complex.I * \u21910 * \u2191z\u271d / \u2191T) = 1"
      },
      {
        "tactic": "norm_num",
        "annotated_tactic": [
          "norm_num",
          []
        ],
        "state_before": "case H\nT z\u271d : \u211d\n\u22a2 Complex.exp (2 * \u2191\u03c0 * Complex.I * \u21910 * \u2191z\u271d / \u2191T) = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.186651308904402,
    "entry_failed": false
  },
  "26969": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/Divisors.lean",
    "full_name": "Nat.sum_divisors_eq_sum_properDivisors_add_self",
    "start": [
      342,
      1
    ],
    "end": [
      346,
      66
    ],
    "traced_tactics": [
      {
        "tactic": "rcases Decidable.eq_or_ne n 0 with (rfl | hn)",
        "annotated_tactic": [
          "rcases <a>Decidable.eq_or_ne</a> n 0 with (rfl | hn)",
          [
            {
              "full_name": "Decidable.eq_or_ne",
              "def_path": "Mathlib/Logic/Basic.lean",
              "def_pos": [
                204,
                9
              ],
              "def_end_pos": [
                204,
                27
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\n\u22a2 \u2211 i \u2208 n.divisors, i = \u2211 i \u2208 n.properDivisors, i + n",
        "state_after": "case inl\n\n\u22a2 \u2211 i \u2208 divisors 0, i = \u2211 i \u2208 properDivisors 0, i + 0\n\ncase inr\nn : \u2115\nhn : n \u2260 0\n\u22a2 \u2211 i \u2208 n.divisors, i = \u2211 i \u2208 n.properDivisors, i + n"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case inl\n\n\u22a2 \u2211 i \u2208 divisors 0, i = \u2211 i \u2208 properDivisors 0, i + 0",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [\u2190 cons_self_properDivisors hn, Finset.sum_cons, add_comm]",
        "annotated_tactic": [
          "rw [\u2190 <a>cons_self_properDivisors</a> hn, <a>Finset.sum_cons</a>, <a>add_comm</a>]",
          [
            {
              "full_name": "Nat.cons_self_properDivisors",
              "def_path": "Mathlib/NumberTheory/Divisors.lean",
              "def_pos": [
                89,
                9
              ],
              "def_end_pos": [
                89,
                33
              ]
            },
            {
              "full_name": "Finset.sum_cons",
              "def_path": "Mathlib/Algebra/BigOperators/Group/Finset.lean",
              "def_pos": [
                344,
                3
              ],
              "def_end_pos": [
                344,
                14
              ]
            },
            {
              "full_name": "add_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                331,
                3
              ],
              "def_end_pos": [
                331,
                14
              ]
            }
          ]
        ],
        "state_before": "case inr\nn : \u2115\nhn : n \u2260 0\n\u22a2 \u2211 i \u2208 n.divisors, i = \u2211 i \u2208 n.properDivisors, i + n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.837257372913882,
    "entry_failed": false
  },
  "27066": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/Harmonic/GammaDeriv.lean",
    "full_name": "Complex.HasDerivAt.complex_of_real",
    "start": [
      154,
      1
    ],
    "end": [
      159,
      29
    ],
    "traced_tactics": [
      {
        "tactic": "refine HasDerivAt.congr_deriv hf.hasDerivAt ?_",
        "annotated_tactic": [
          "refine <a>HasDerivAt.congr_deriv</a> hf.hasDerivAt ?_",
          [
            {
              "full_name": "HasDerivAt.congr_deriv",
              "def_path": "Mathlib/Analysis/Calculus/Deriv/Basic.lean",
              "def_pos": [
                623,
                9
              ],
              "def_end_pos": [
                623,
                31
              ]
            }
          ]
        ],
        "state_before": "f : \u2102 \u2192 \u2102\ng : \u211d \u2192 \u211d\ng' s : \u211d\nhf : DifferentiableAt \u2102 f \u2191s\nhg : HasDerivAt g g' s\nhfg : \u2200 (s : \u211d), f \u2191s = \u2191(g s)\n\u22a2 HasDerivAt f \u2191g' \u2191s",
        "state_after": "f : \u2102 \u2192 \u2102\ng : \u211d \u2192 \u211d\ng' s : \u211d\nhf : DifferentiableAt \u2102 f \u2191s\nhg : HasDerivAt g g' s\nhfg : \u2200 (s : \u211d), f \u2191s = \u2191(g s)\n\u22a2 deriv f \u2191s = \u2191g'"
      },
      {
        "tactic": "rw [\u2190 (funext hfg \u25b8 hf.hasDerivAt.comp_ofReal.deriv :)]",
        "annotated_tactic": [
          "rw [\u2190 (<a>funext</a> hfg \u25b8 hf.hasDerivAt.comp_ofReal.deriv :)]",
          [
            {
              "full_name": "funext",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1817,
                9
              ],
              "def_end_pos": [
                1817,
                15
              ]
            }
          ]
        ],
        "state_before": "f : \u2102 \u2192 \u2102\ng : \u211d \u2192 \u211d\ng' s : \u211d\nhf : DifferentiableAt \u2102 f \u2191s\nhg : HasDerivAt g g' s\nhfg : \u2200 (s : \u211d), f \u2191s = \u2191(g s)\n\u22a2 deriv f \u2191s = \u2191g'",
        "state_after": "f : \u2102 \u2192 \u2102\ng : \u211d \u2192 \u211d\ng' s : \u211d\nhf : DifferentiableAt \u2102 f \u2191s\nhg : HasDerivAt g g' s\nhfg : \u2200 (s : \u211d), f \u2191s = \u2191(g s)\n\u22a2 deriv (fun x => \u2191(g x)) s = \u2191g'"
      },
      {
        "tactic": "exact hg.ofReal_comp.deriv",
        "annotated_tactic": [
          "exact hg.ofReal_comp.deriv",
          []
        ],
        "state_before": "f : \u2102 \u2192 \u2102\ng : \u211d \u2192 \u211d\ng' s : \u211d\nhf : DifferentiableAt \u2102 f \u2191s\nhg : HasDerivAt g g' s\nhfg : \u2200 (s : \u211d), f \u2191s = \u2191(g s)\n\u22a2 deriv (fun x => \u2191(g x)) s = \u2191g'",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.656729601090774,
    "entry_failed": false
  },
  "27097": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/PNat/Factors.lean",
    "full_name": "PrimeMultiset.prod_dvd_iff'",
    "start": [
      350,
      1
    ],
    "end": [
      353,
      10
    ],
    "traced_tactics": [
      {
        "tactic": "let h := @prod_dvd_iff u n.factorMultiset",
        "annotated_tactic": [
          "let h := @<a>prod_dvd_iff</a> u n.factorMultiset",
          [
            {
              "full_name": "PrimeMultiset.prod_dvd_iff",
              "def_path": "Mathlib/Data/PNat/Factors.lean",
              "def_pos": [
                344,
                9
              ],
              "def_end_pos": [
                344,
                21
              ]
            }
          ]
        ],
        "state_before": "u : PrimeMultiset\nn : \u2115+\n\u22a2 u.prod \u2223 n \u2194 u \u2264 n.factorMultiset",
        "state_after": "u : PrimeMultiset\nn : \u2115+\nh : u.prod \u2223 n.factorMultiset.prod \u2194 u \u2264 n.factorMultiset := prod_dvd_iff\n\u22a2 u.prod \u2223 n \u2194 u \u2264 n.factorMultiset"
      },
      {
        "tactic": "rw [n.prod_factorMultiset] at h",
        "annotated_tactic": [
          "rw [n.prod_factorMultiset] at h",
          []
        ],
        "state_before": "u : PrimeMultiset\nn : \u2115+\nh : u.prod \u2223 n.factorMultiset.prod \u2194 u \u2264 n.factorMultiset := prod_dvd_iff\n\u22a2 u.prod \u2223 n \u2194 u \u2264 n.factorMultiset",
        "state_after": "u : PrimeMultiset\nn : \u2115+\nh : u.prod \u2223 n \u2194 u \u2264 n.factorMultiset\n\u22a2 u.prod \u2223 n \u2194 u \u2264 n.factorMultiset"
      },
      {
        "tactic": "exact h",
        "annotated_tactic": [
          "exact h",
          []
        ],
        "state_before": "u : PrimeMultiset\nn : \u2115+\nh : u.prod \u2223 n \u2194 u \u2264 n.factorMultiset\n\u22a2 u.prod \u2223 n \u2194 u \u2264 n.factorMultiset",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.512544314027764,
    "entry_failed": false
  },
  "27174": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/PNat/Factors.lean",
    "full_name": "PNat.factorMultiset_le_iff'",
    "start": [
      333,
      1
    ],
    "end": [
      337,
      10
    ],
    "traced_tactics": [
      {
        "tactic": "let h := @factorMultiset_le_iff m v.prod",
        "annotated_tactic": [
          "let h := @<a>factorMultiset_le_iff</a> m v.prod",
          [
            {
              "full_name": "PNat.factorMultiset_le_iff",
              "def_path": "Mathlib/Data/PNat/Factors.lean",
              "def_pos": [
                321,
                9
              ],
              "def_end_pos": [
                321,
                30
              ]
            }
          ]
        ],
        "state_before": "m : \u2115+\nv : PrimeMultiset\n\u22a2 m.factorMultiset \u2264 v \u2194 m \u2223 v.prod",
        "state_after": "m : \u2115+\nv : PrimeMultiset\nh : m.factorMultiset \u2264 v.prod.factorMultiset \u2194 m \u2223 v.prod := factorMultiset_le_iff\n\u22a2 m.factorMultiset \u2264 v \u2194 m \u2223 v.prod"
      },
      {
        "tactic": "rw [v.factorMultiset_prod] at h",
        "annotated_tactic": [
          "rw [v.factorMultiset_prod] at h",
          []
        ],
        "state_before": "m : \u2115+\nv : PrimeMultiset\nh : m.factorMultiset \u2264 v.prod.factorMultiset \u2194 m \u2223 v.prod := factorMultiset_le_iff\n\u22a2 m.factorMultiset \u2264 v \u2194 m \u2223 v.prod",
        "state_after": "m : \u2115+\nv : PrimeMultiset\nh : m.factorMultiset \u2264 v \u2194 m \u2223 v.prod\n\u22a2 m.factorMultiset \u2264 v \u2194 m \u2223 v.prod"
      },
      {
        "tactic": "exact h",
        "annotated_tactic": [
          "exact h",
          []
        ],
        "state_before": "m : \u2115+\nv : PrimeMultiset\nh : m.factorMultiset \u2264 v \u2194 m \u2223 v.prod\n\u22a2 m.factorMultiset \u2264 v \u2194 m \u2223 v.prod",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.5470908479765058,
    "entry_failed": false
  },
  "27175": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Multiset/Functor.lean",
    "full_name": "Multiset.id_traverse",
    "start": [
      96,
      1
    ],
    "end": [
      99,
      27
    ],
    "traced_tactics": [
      {
        "tactic": "refine Quotient.inductionOn x ?_",
        "annotated_tactic": [
          "refine <a>Quotient.inductionOn</a> x ?_",
          [
            {
              "full_name": "Quotient.inductionOn",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1629,
                19
              ],
              "def_end_pos": [
                1629,
                30
              ]
            }
          ]
        ],
        "state_before": "F : Type u \u2192 Type u\ninst\u271d\u00b9 : Applicative F\ninst\u271d : CommApplicative F\n\u03b1' \u03b2' : Type u\nf : \u03b1' \u2192 F \u03b2'\n\u03b1 : Type u_1\nx : Multiset \u03b1\n\u22a2 traverse pure x = x",
        "state_after": "F : Type u \u2192 Type u\ninst\u271d\u00b9 : Applicative F\ninst\u271d : CommApplicative F\n\u03b1' \u03b2' : Type u\nf : \u03b1' \u2192 F \u03b2'\n\u03b1 : Type u_1\nx : Multiset \u03b1\n\u22a2 \u2200 (a : List \u03b1), traverse pure \u27e6a\u27e7 = \u27e6a\u27e7"
      },
      {
        "tactic": "intro",
        "annotated_tactic": [
          "intro",
          []
        ],
        "state_before": "F : Type u \u2192 Type u\ninst\u271d\u00b9 : Applicative F\ninst\u271d : CommApplicative F\n\u03b1' \u03b2' : Type u\nf : \u03b1' \u2192 F \u03b2'\n\u03b1 : Type u_1\nx : Multiset \u03b1\n\u22a2 \u2200 (a : List \u03b1), traverse pure \u27e6a\u27e7 = \u27e6a\u27e7",
        "state_after": "F : Type u \u2192 Type u\ninst\u271d\u00b9 : Applicative F\ninst\u271d : CommApplicative F\n\u03b1' \u03b2' : Type u\nf : \u03b1' \u2192 F \u03b2'\n\u03b1 : Type u_1\nx : Multiset \u03b1\na\u271d : List \u03b1\n\u22a2 traverse pure \u27e6a\u271d\u27e7 = \u27e6a\u271d\u27e7"
      },
      {
        "tactic": "simp [traverse, Coe.coe]",
        "annotated_tactic": [
          "simp [<a>traverse</a>, <a>Coe.coe</a>]",
          [
            {
              "full_name": "Multiset.traverse",
              "def_path": "Mathlib/Data/Multiset/Functor.lean",
              "def_pos": [
                43,
                5
              ],
              "def_end_pos": [
                43,
                13
              ]
            },
            {
              "full_name": "Coe.coe",
              "def_path": ".lake/packages/lean4/src/lean/Init/Coe.lean",
              "def_pos": [
                129,
                3
              ],
              "def_end_pos": [
                129,
                6
              ]
            }
          ]
        ],
        "state_before": "F : Type u \u2192 Type u\ninst\u271d\u00b9 : Applicative F\ninst\u271d : CommApplicative F\n\u03b1' \u03b2' : Type u\nf : \u03b1' \u2192 F \u03b2'\n\u03b1 : Type u_1\nx : Multiset \u03b1\na\u271d : List \u03b1\n\u22a2 traverse pure \u27e6a\u271d\u27e7 = \u27e6a\u271d\u27e7",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5160921319620684,
    "entry_failed": false
  },
  "27183": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/PiSystem.lean",
    "full_name": "generateFrom_generatePiSystem_eq",
    "start": [
      270,
      1
    ],
    "end": [
      274,
      78
    ],
    "traced_tactics": [
      {
        "tactic": "apply le_antisymm <;> apply generateFrom_le",
        "annotated_tactic": [
          "apply <a>le_antisymm</a> <;> apply <a>generateFrom_le</a>",
          [
            {
              "full_name": "le_antisymm",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                188,
                9
              ],
              "def_end_pos": [
                188,
                20
              ]
            },
            {
              "full_name": "MeasurableSpace.generateFrom_le",
              "def_path": "Mathlib/MeasureTheory/MeasurableSpace/Defs.lean",
              "def_pos": [
                390,
                9
              ],
              "def_end_pos": [
                390,
                24
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ng : Set (Set \u03b1)\n\u22a2 generateFrom (generatePiSystem g) = generateFrom g",
        "state_after": "case a.h\n\u03b1 : Type u_1\ng : Set (Set \u03b1)\n\u22a2 \u2200 t \u2208 generatePiSystem g, MeasurableSet t\n\ncase a.h\n\u03b1 : Type u_1\ng : Set (Set \u03b1)\n\u22a2 \u2200 t \u2208 g, MeasurableSet t"
      },
      {
        "tactic": "exact fun t h_t => generateFrom_measurableSet_of_generatePiSystem t h_t",
        "annotated_tactic": [
          "exact fun t h_t => <a>generateFrom_measurableSet_of_generatePiSystem</a> t h_t",
          [
            {
              "full_name": "generateFrom_measurableSet_of_generatePiSystem",
              "def_path": "Mathlib/MeasureTheory/PiSystem.lean",
              "def_pos": [
                264,
                9
              ],
              "def_end_pos": [
                264,
                55
              ]
            }
          ]
        ],
        "state_before": "case a.h\n\u03b1 : Type u_1\ng : Set (Set \u03b1)\n\u22a2 \u2200 t \u2208 generatePiSystem g, MeasurableSet t",
        "state_after": "no goals"
      },
      {
        "tactic": "exact fun t h_t => measurableSet_generateFrom (generatePiSystem.base h_t)",
        "annotated_tactic": [
          "exact fun t h_t => <a>measurableSet_generateFrom</a> (<a>generatePiSystem.base</a> h_t)",
          [
            {
              "full_name": "MeasurableSpace.measurableSet_generateFrom",
              "def_path": "Mathlib/MeasureTheory/MeasurableSpace/Defs.lean",
              "def_pos": [
                376,
                9
              ],
              "def_end_pos": [
                376,
                35
              ]
            },
            {
              "full_name": "generatePiSystem.base",
              "def_path": "Mathlib/MeasureTheory/PiSystem.lean",
              "def_pos": [
                225,
                5
              ],
              "def_end_pos": [
                225,
                9
              ]
            }
          ]
        ],
        "state_before": "case a.h\n\u03b1 : Type u_1\ng : Set (Set \u03b1)\n\u22a2 \u2200 t \u2208 g, MeasurableSet t",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.587592837982811,
    "entry_failed": false
  },
  "27196": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/MetricSpace/Thickening.lean",
    "full_name": "Metric.thickening_subset_cthickening",
    "start": [
      297,
      1
    ],
    "end": [
      300,
      14
    ],
    "traced_tactics": [
      {
        "tactic": "intro x hx",
        "annotated_tactic": [
          "intro x hx",
          []
        ],
        "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4\u271d \u03b5 : \u211d\ns t : Set \u03b1\nx : \u03b1\n\u03b4 : \u211d\nE : Set \u03b1\n\u22a2 thickening \u03b4 E \u2286 cthickening \u03b4 E",
        "state_after": "\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4\u271d \u03b5 : \u211d\ns t : Set \u03b1\nx\u271d : \u03b1\n\u03b4 : \u211d\nE : Set \u03b1\nx : \u03b1\nhx : x \u2208 thickening \u03b4 E\n\u22a2 x \u2208 cthickening \u03b4 E"
      },
      {
        "tactic": "rw [thickening, mem_setOf_eq] at hx",
        "annotated_tactic": [
          "rw [<a>thickening</a>, <a>mem_setOf_eq</a>] at hx",
          [
            {
              "full_name": "Metric.thickening",
              "def_path": "Mathlib/Topology/MetricSpace/Thickening.lean",
              "def_pos": [
                51,
                5
              ],
              "def_end_pos": [
                51,
                15
              ]
            },
            {
              "full_name": "Set.mem_setOf_eq",
              "def_path": "Mathlib/Data/Set/Defs.lean",
              "def_pos": [
                79,
                29
              ],
              "def_end_pos": [
                79,
                41
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4\u271d \u03b5 : \u211d\ns t : Set \u03b1\nx\u271d : \u03b1\n\u03b4 : \u211d\nE : Set \u03b1\nx : \u03b1\nhx : x \u2208 thickening \u03b4 E\n\u22a2 x \u2208 cthickening \u03b4 E",
        "state_after": "\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4\u271d \u03b5 : \u211d\ns t : Set \u03b1\nx\u271d : \u03b1\n\u03b4 : \u211d\nE : Set \u03b1\nx : \u03b1\nhx : infEdist x E < ENNReal.ofReal \u03b4\n\u22a2 x \u2208 cthickening \u03b4 E"
      },
      {
        "tactic": "exact hx.le",
        "annotated_tactic": [
          "exact hx.le",
          []
        ],
        "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b4\u271d \u03b5 : \u211d\ns t : Set \u03b1\nx\u271d : \u03b1\n\u03b4 : \u211d\nE : Set \u03b1\nx : \u03b1\nhx : infEdist x E < ENNReal.ofReal \u03b4\n\u22a2 x \u2208 cthickening \u03b4 E",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.2656673240708187,
    "entry_failed": false
  },
  "27233": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Sym/Basic.lean",
    "full_name": "Sym.map_id'",
    "start": [
      384,
      1
    ],
    "end": [
      385,
      67
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\nn\u271d n' m : \u2115\ns\u271d : Sym \u03b1\u271d n\u271d\na b : \u03b1\u271d\n\u03b1 : Type u_3\nn : \u2115\ns : Sym \u03b1 n\n\u22a2 map (fun x => x) s = s",
        "state_after": "case h\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\nn\u271d n' m : \u2115\ns\u271d : Sym \u03b1\u271d n\u271d\na b : \u03b1\u271d\n\u03b1 : Type u_3\nn : \u2115\ns : Sym \u03b1 n\n\u22a2 \u2191(map (fun x => x) s) = \u2191s"
      },
      {
        "tactic": "simp only [map, val_eq_coe, Multiset.map_id', coe_inj]",
        "annotated_tactic": [
          "simp only [<a>map</a>, <a>val_eq_coe</a>, <a>Multiset.map_id'</a>, <a>coe_inj</a>]",
          [
            {
              "full_name": "Sym.map",
              "def_path": "Mathlib/Data/Sym/Basic.lean",
              "def_pos": [
                372,
                5
              ],
              "def_end_pos": [
                372,
                8
              ]
            },
            {
              "full_name": "Sym.val_eq_coe",
              "def_path": "Mathlib/Data/Sym/Basic.lean",
              "def_pos": [
                88,
                9
              ],
              "def_end_pos": [
                88,
                19
              ]
            },
            {
              "full_name": "Multiset.map_id'",
              "def_path": "Mathlib/Data/Multiset/Basic.lean",
              "def_pos": [
                1341,
                9
              ],
              "def_end_pos": [
                1341,
                16
              ]
            },
            {
              "full_name": "Sym.coe_inj",
              "def_path": "Mathlib/Data/Sym/Basic.lean",
              "def_pos": [
                80,
                9
              ],
              "def_end_pos": [
                80,
                16
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\nn\u271d n' m : \u2115\ns\u271d : Sym \u03b1\u271d n\u271d\na b : \u03b1\u271d\n\u03b1 : Type u_3\nn : \u2115\ns : Sym \u03b1 n\n\u22a2 \u2191(map (fun x => x) s) = \u2191s",
        "state_after": "case h\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\nn\u271d n' m : \u2115\ns\u271d : Sym \u03b1\u271d n\u271d\na b : \u03b1\u271d\n\u03b1 : Type u_3\nn : \u2115\ns : Sym \u03b1 n\n\u22a2 \u27e8\u2191s, \u22ef\u27e9 = s"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case h\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\nn\u271d n' m : \u2115\ns\u271d : Sym \u03b1\u271d n\u271d\na b : \u03b1\u271d\n\u03b1 : Type u_3\nn : \u2115\ns : Sym \u03b1 n\n\u22a2 \u27e8\u2191s, \u22ef\u27e9 = s",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.56871910195332,
    "entry_failed": false
  },
  "27235": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Polynomial/EraseLead.lean",
    "full_name": "Polynomial.card_support_eraseLead",
    "start": [
      127,
      1
    ],
    "end": [
      130,
      68
    ],
    "traced_tactics": [
      {
        "tactic": "by_cases hf : f = 0",
        "annotated_tactic": [
          "by_cases hf : f = 0",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d : Semiring R\nf : R[X]\n\u22a2 f.eraseLead.support.card = f.support.card - 1",
        "state_after": "case pos\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nhf : f = 0\n\u22a2 f.eraseLead.support.card = f.support.card - 1\n\ncase neg\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nhf : \u00acf = 0\n\u22a2 f.eraseLead.support.card = f.support.card - 1"
      },
      {
        "tactic": "rw [hf, eraseLead_zero, support_zero, card_empty]",
        "annotated_tactic": [
          "rw [hf, <a>eraseLead_zero</a>, <a>support_zero</a>, <a>card_empty</a>]",
          [
            {
              "full_name": "Polynomial.eraseLead_zero",
              "def_path": "Mathlib/Algebra/Polynomial/EraseLead.lean",
              "def_pos": [
                60,
                9
              ],
              "def_end_pos": [
                60,
                23
              ]
            },
            {
              "full_name": "Polynomial.support_zero",
              "def_path": "Mathlib/Algebra/Polynomial/Basic.lean",
              "def_pos": [
                417,
                9
              ],
              "def_end_pos": [
                417,
                21
              ]
            },
            {
              "full_name": "Finset.card_empty",
              "def_path": "Mathlib/Data/Finset/Card.lean",
              "def_pos": [
                59,
                9
              ],
              "def_end_pos": [
                59,
                19
              ]
            }
          ]
        ],
        "state_before": "case pos\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nhf : f = 0\n\u22a2 f.eraseLead.support.card = f.support.card - 1",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [\u2190 card_support_eraseLead_add_one hf, add_tsub_cancel_right]",
        "annotated_tactic": [
          "rw [\u2190 <a>card_support_eraseLead_add_one</a> hf, <a>add_tsub_cancel_right</a>]",
          [
            {
              "full_name": "Polynomial.card_support_eraseLead_add_one",
              "def_path": "Mathlib/Algebra/Polynomial/EraseLead.lean",
              "def_pos": [
                115,
                9
              ],
              "def_end_pos": [
                115,
                39
              ]
            },
            {
              "full_name": "add_tsub_cancel_right",
              "def_path": "Mathlib/Algebra/Order/Sub/Defs.lean",
              "def_pos": [
                356,
                9
              ],
              "def_end_pos": [
                356,
                30
              ]
            }
          ]
        ],
        "state_before": "case neg\nR : Type u_1\ninst\u271d : Semiring R\nf : R[X]\nhf : \u00acf = 0\n\u22a2 f.eraseLead.support.card = f.support.card - 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8837085819104686,
    "entry_failed": false
  },
  "27337": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Fintype/Card.lean",
    "full_name": "Fintype.card_of_finset'",
    "start": [
      139,
      1
    ],
    "end": [
      140,
      91
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 card_ofFinset s H]",
        "annotated_tactic": [
          "rw [\u2190 <a>card_ofFinset</a> s H]",
          [
            {
              "full_name": "Fintype.card_ofFinset",
              "def_path": "Mathlib/Data/Fintype/Card.lean",
              "def_pos": [
                134,
                9
              ],
              "def_end_pos": [
                134,
                22
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np : Set \u03b1\ns : Finset \u03b1\nH : \u2200 (x : \u03b1), x \u2208 s \u2194 x \u2208 p\ninst\u271d : Fintype \u2191p\n\u22a2 card \u2191p = s.card",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np : Set \u03b1\ns : Finset \u03b1\nH : \u2200 (x : \u03b1), x \u2208 s \u2194 x \u2208 p\ninst\u271d : Fintype \u2191p\n\u22a2 card \u2191p = card \u2191p"
      },
      {
        "tactic": "congr",
        "annotated_tactic": [
          "congr",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np : Set \u03b1\ns : Finset \u03b1\nH : \u2200 (x : \u03b1), x \u2208 s \u2194 x \u2208 p\ninst\u271d : Fintype \u2191p\n\u22a2 card \u2191p = card \u2191p",
        "state_after": "case h.e_2.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np : Set \u03b1\ns : Finset \u03b1\nH : \u2200 (x : \u03b1), x \u2208 s \u2194 x \u2208 p\ninst\u271d : Fintype \u2191p\n\u22a2 inst\u271d = ofFinset s H"
      },
      {
        "tactic": "apply Subsingleton.elim",
        "annotated_tactic": [
          "apply <a>Subsingleton.elim</a>",
          [
            {
              "full_name": "Subsingleton.elim",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1015,
                19
              ],
              "def_end_pos": [
                1015,
                36
              ]
            }
          ]
        ],
        "state_before": "case h.e_2.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\np : Set \u03b1\ns : Finset \u03b1\nH : \u2200 (x : \u03b1), x \u2208 s \u2194 x \u2208 p\ninst\u271d : Fintype \u2191p\n\u22a2 inst\u271d = ofFinset s H",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.639923781971447,
    "entry_failed": false
  },
  "27362": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Vector/Snoc.lean",
    "full_name": "Vector.reverse_cons",
    "start": [
      42,
      1
    ],
    "end": [
      45,
      8
    ],
    "traced_tactics": [
      {
        "tactic": "cases xs",
        "annotated_tactic": [
          "cases xs",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nn : \u2115\nxs : Vector \u03b1 n\nx : \u03b1\n\u22a2 (x ::\u1d65 xs).reverse = xs.reverse.snoc x",
        "state_after": "case mk\n\u03b1 : Type u_1\nn : \u2115\nx : \u03b1\nval\u271d : List \u03b1\nproperty\u271d : val\u271d.length = n\n\u22a2 (x ::\u1d65 \u27e8val\u271d, property\u271d\u27e9).reverse = (reverse \u27e8val\u271d, property\u271d\u27e9).snoc x"
      },
      {
        "tactic": "simp only [reverse, cons, toList_mk, List.reverse_cons, snoc]",
        "annotated_tactic": [
          "simp only [<a>reverse</a>, <a>cons</a>, <a>toList_mk</a>, <a>List.reverse_cons</a>, <a>snoc</a>]",
          [
            {
              "full_name": "Vector.reverse",
              "def_path": "Mathlib/Data/Vector/Basic.lean",
              "def_pos": [
                242,
                5
              ],
              "def_end_pos": [
                242,
                12
              ]
            },
            {
              "full_name": "Vector.cons",
              "def_path": "Mathlib/Data/Vector/Defs.lean",
              "def_pos": [
                40,
                5
              ],
              "def_end_pos": [
                40,
                9
              ]
            },
            {
              "full_name": "Vector.toList_mk",
              "def_path": "Mathlib/Data/Vector/Defs.lean",
              "def_pos": [
                234,
                9
              ],
              "def_end_pos": [
                234,
                18
              ]
            },
            {
              "full_name": "List.reverse_cons",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean",
              "def_pos": [
                522,
                17
              ],
              "def_end_pos": [
                522,
                29
              ]
            },
            {
              "full_name": "Vector.snoc",
              "def_path": "Mathlib/Data/Vector/Snoc.lean",
              "def_pos": [
                24,
                5
              ],
              "def_end_pos": [
                24,
                9
              ]
            }
          ]
        ],
        "state_before": "case mk\n\u03b1 : Type u_1\nn : \u2115\nx : \u03b1\nval\u271d : List \u03b1\nproperty\u271d : val\u271d.length = n\n\u22a2 (x ::\u1d65 \u27e8val\u271d, property\u271d\u27e9).reverse = (reverse \u27e8val\u271d, property\u271d\u27e9).snoc x",
        "state_after": "case mk\n\u03b1 : Type u_1\nn : \u2115\nx : \u03b1\nval\u271d : List \u03b1\nproperty\u271d : val\u271d.length = n\n\u22a2 \u27e8val\u271d.reverse ++ [x], \u22ef\u27e9 = append \u27e8val\u271d.reverse, \u22ef\u27e9 \u27e8[x], \u22ef\u27e9"
      },
      {
        "tactic": "congr",
        "annotated_tactic": [
          "congr",
          []
        ],
        "state_before": "case mk\n\u03b1 : Type u_1\nn : \u2115\nx : \u03b1\nval\u271d : List \u03b1\nproperty\u271d : val\u271d.length = n\n\u22a2 \u27e8val\u271d.reverse ++ [x], \u22ef\u27e9 = append \u27e8val\u271d.reverse, \u22ef\u27e9 \u27e8[x], \u22ef\u27e9",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.1831263810163364,
    "entry_failed": false
  },
  "27380": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Logic/Basic.lean",
    "full_name": "congr_heq",
    "start": [
      59,
      1
    ],
    "end": [
      61,
      26
    ],
    "traced_tactics": [
      {
        "tactic": "cases h\u2082",
        "annotated_tactic": [
          "cases h\u2082",
          []
        ],
        "state_before": "\u03b1\u271d : Sort u_1\n\u03b1 \u03b2 : Sort u_2\n\u03b3 : Sort u_3\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b3\nx : \u03b1\ny : \u03b2\nh\u2081 : HEq f g\nh\u2082 : HEq x y\n\u22a2 f x = g y",
        "state_after": "case refl\n\u03b1\u271d : Sort u_1\n\u03b1 : Sort u_2\n\u03b3 : Sort u_3\nf : \u03b1 \u2192 \u03b3\nx : \u03b1\ng : \u03b1 \u2192 \u03b3\nh\u2081 : HEq f g\n\u22a2 f x = g x"
      },
      {
        "tactic": "cases h\u2081",
        "annotated_tactic": [
          "cases h\u2081",
          []
        ],
        "state_before": "case refl\n\u03b1\u271d : Sort u_1\n\u03b1 : Sort u_2\n\u03b3 : Sort u_3\nf : \u03b1 \u2192 \u03b3\nx : \u03b1\ng : \u03b1 \u2192 \u03b3\nh\u2081 : HEq f g\n\u22a2 f x = g x",
        "state_after": "case refl.refl\n\u03b1\u271d : Sort u_1\n\u03b1 : Sort u_2\n\u03b3 : Sort u_3\nf : \u03b1 \u2192 \u03b3\nx : \u03b1\n\u22a2 f x = f x"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case refl.refl\n\u03b1\u271d : Sort u_1\n\u03b1 : Sort u_2\n\u03b3 : Sort u_3\nf : \u03b1 \u2192 \u03b3\nx : \u03b1\n\u22a2 f x = f x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.59705355996266,
    "entry_failed": false
  },
  "27434": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/MinMax.lean",
    "full_name": "List.not_lt_maximum_of_mem'",
    "start": [
      337,
      1
    ],
    "end": [
      340,
      53
    ],
    "traced_tactics": [
      {
        "tactic": "cases h : l.maximum",
        "annotated_tactic": [
          "cases h : l.maximum",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : DecidableRel fun x x_1 => x < x_1\nl : List \u03b1\na m : \u03b1\nha : a \u2208 l\n\u22a2 \u00acl.maximum < \u2191a",
        "state_after": "case bot\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : DecidableRel fun x x_1 => x < x_1\nl : List \u03b1\na m : \u03b1\nha : a \u2208 l\nh : l.maximum = \u22a5\n\u22a2 \u00ac\u22a5 < \u2191a\n\ncase coe\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : DecidableRel fun x x_1 => x < x_1\nl : List \u03b1\na m : \u03b1\nha : a \u2208 l\na\u271d : \u03b1\nh : l.maximum = \u2191a\u271d\n\u22a2 \u00ac\u2191a\u271d < \u2191a"
      },
      {
        "tactic": "simp_all",
        "annotated_tactic": [
          "simp_all",
          []
        ],
        "state_before": "case bot\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : DecidableRel fun x x_1 => x < x_1\nl : List \u03b1\na m : \u03b1\nha : a \u2208 l\nh : l.maximum = \u22a5\n\u22a2 \u00ac\u22a5 < \u2191a",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [not_lt_maximum_of_mem ha h, not_false_iff]",
        "annotated_tactic": [
          "simp [<a>not_lt_maximum_of_mem</a> ha h, <a>not_false_iff</a>]",
          [
            {
              "full_name": "List.not_lt_maximum_of_mem",
              "def_path": "Mathlib/Data/List/MinMax.lean",
              "def_pos": [
                329,
                9
              ],
              "def_end_pos": [
                329,
                30
              ]
            },
            {
              "full_name": "not_false_iff",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1371,
                9
              ],
              "def_end_pos": [
                1371,
                22
              ]
            }
          ]
        ],
        "state_before": "case coe\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : DecidableRel fun x x_1 => x < x_1\nl : List \u03b1\na m : \u03b1\nha : a \u2208 l\na\u271d : \u03b1\nh : l.maximum = \u2191a\u271d\n\u22a2 \u00ac\u2191a\u271d < \u2191a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.2681161729851738,
    "entry_failed": false
  },
  "27439": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Tactic/LinearCombination.lean",
    "full_name": "Mathlib.Tactic.LinearCombination.eq_of_add_pow",
    "start": [
      114,
      1
    ],
    "end": [
      116,
      83
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 sub_eq_zero] at p \u22a2",
        "annotated_tactic": [
          "rw [\u2190 <a>sub_eq_zero</a>] at p \u22a2",
          [
            {
              "full_name": "sub_eq_zero",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                1070,
                3
              ],
              "def_end_pos": [
                1070,
                14
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\na b a' b' : \u03b1\ninst\u271d\u00b9 : Ring \u03b1\ninst\u271d : NoZeroDivisors \u03b1\nn : \u2115\np : a = b\nH : (a' - b') ^ n - (a - b) = 0\n\u22a2 a' = b'",
        "state_after": "\u03b1 : Type u_1\na b a' b' : \u03b1\ninst\u271d\u00b9 : Ring \u03b1\ninst\u271d : NoZeroDivisors \u03b1\nn : \u2115\np : a - b = 0\nH : (a' - b') ^ n - (a - b) = 0\n\u22a2 a' - b' = 0"
      },
      {
        "tactic": "apply pow_eq_zero (n := n)",
        "annotated_tactic": [
          "apply <a>pow_eq_zero</a> (n := n)",
          [
            {
              "full_name": "pow_eq_zero",
              "def_path": "Mathlib/Algebra/GroupWithZero/Basic.lean",
              "def_pos": [
                186,
                7
              ],
              "def_end_pos": [
                186,
                18
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\na b a' b' : \u03b1\ninst\u271d\u00b9 : Ring \u03b1\ninst\u271d : NoZeroDivisors \u03b1\nn : \u2115\np : a - b = 0\nH : (a' - b') ^ n - (a - b) = 0\n\u22a2 a' - b' = 0",
        "state_after": "\u03b1 : Type u_1\na b a' b' : \u03b1\ninst\u271d\u00b9 : Ring \u03b1\ninst\u271d : NoZeroDivisors \u03b1\nn : \u2115\np : a - b = 0\nH : (a' - b') ^ n - (a - b) = 0\n\u22a2 (a' - b') ^ n = 0"
      },
      {
        "tactic": "rwa [sub_eq_zero, p] at H",
        "annotated_tactic": [
          "rwa [<a>sub_eq_zero</a>, p] at H",
          [
            {
              "full_name": "sub_eq_zero",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                1070,
                3
              ],
              "def_end_pos": [
                1070,
                14
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\na b a' b' : \u03b1\ninst\u271d\u00b9 : Ring \u03b1\ninst\u271d : NoZeroDivisors \u03b1\nn : \u2115\np : a - b = 0\nH : (a' - b') ^ n - (a - b) = 0\n\u22a2 (a' - b') ^ n = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.1611441971035674,
    "entry_failed": false
  },
  "27472": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Group/Conj.lean",
    "full_name": "conj_pow",
    "start": [
      110,
      1
    ],
    "end": [
      113,
      24
    ],
    "traced_tactics": [
      {
        "tactic": "induction' i with i hi",
        "annotated_tactic": [
          "induction' i with i hi",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Group \u03b1\ni : \u2115\na b : \u03b1\n\u22a2 (a * b * a\u207b\u00b9) ^ i = a * b ^ i * a\u207b\u00b9",
        "state_after": "case zero\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Group \u03b1\na b : \u03b1\n\u22a2 (a * b * a\u207b\u00b9) ^ 0 = a * b ^ 0 * a\u207b\u00b9\n\ncase succ\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Group \u03b1\na b : \u03b1\ni : \u2115\nhi : (a * b * a\u207b\u00b9) ^ i = a * b ^ i * a\u207b\u00b9\n\u22a2 (a * b * a\u207b\u00b9) ^ (i + 1) = a * b ^ (i + 1) * a\u207b\u00b9"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case zero\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Group \u03b1\na b : \u03b1\n\u22a2 (a * b * a\u207b\u00b9) ^ 0 = a * b ^ 0 * a\u207b\u00b9",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [pow_succ, hi]",
        "annotated_tactic": [
          "simp [<a>pow_succ</a>, hi]",
          [
            {
              "full_name": "pow_succ",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                657,
                9
              ],
              "def_end_pos": [
                657,
                17
              ]
            }
          ]
        ],
        "state_before": "case succ\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Group \u03b1\na b : \u03b1\ni : \u2115\nhi : (a * b * a\u207b\u00b9) ^ i = a * b ^ i * a\u207b\u00b9\n\u22a2 (a * b * a\u207b\u00b9) ^ (i + 1) = a * b ^ (i + 1) * a\u207b\u00b9",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.451912750955671,
    "entry_failed": false
  },
  "27473": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Seq/Seq.lean",
    "full_name": "Stream'.Seq.mem_append_left",
    "start": [
      881,
      1
    ],
    "end": [
      882,
      39
    ],
    "traced_tactics": [
      {
        "tactic": "apply mem_rec_on h",
        "annotated_tactic": [
          "apply <a>mem_rec_on</a> h",
          [
            {
              "full_name": "Stream'.Seq.mem_rec_on",
              "def_path": "Mathlib/Data/Seq/Seq.lean",
              "def_pos": [
                287,
                9
              ],
              "def_end_pos": [
                287,
                19
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u2081 s\u2082 : Seq \u03b1\na : \u03b1\nh : a \u2208 s\u2081\n\u22a2 a \u2208 s\u2081.append s\u2082",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u2081 s\u2082 : Seq \u03b1\na : \u03b1\nh : a \u2208 s\u2081\n\u22a2 \u2200 (b : \u03b1) (s' : Seq \u03b1), a = b \u2228 a \u2208 s'.append s\u2082 \u2192 a \u2208 (cons b s').append s\u2082"
      },
      {
        "tactic": "intros",
        "annotated_tactic": [
          "intros",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u2081 s\u2082 : Seq \u03b1\na : \u03b1\nh : a \u2208 s\u2081\n\u22a2 \u2200 (b : \u03b1) (s' : Seq \u03b1), a = b \u2228 a \u2208 s'.append s\u2082 \u2192 a \u2208 (cons b s').append s\u2082",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u2081 s\u2082 : Seq \u03b1\na : \u03b1\nh : a \u2208 s\u2081\nb\u271d : \u03b1\ns'\u271d : Seq \u03b1\na\u271d : a = b\u271d \u2228 a \u2208 s'\u271d.append s\u2082\n\u22a2 a \u2208 (cons b\u271d s'\u271d).append s\u2082"
      },
      {
        "tactic": "simp [*]",
        "annotated_tactic": [
          "simp [*]",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns\u2081 s\u2082 : Seq \u03b1\na : \u03b1\nh : a \u2208 s\u2081\nb\u271d : \u03b1\ns'\u271d : Seq \u03b1\na\u271d : a = b\u271d \u2228 a \u2208 s'\u271d.append s\u2082\n\u22a2 a \u2208 (cons b\u271d s'\u271d).append s\u2082",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.827635567984544,
    "entry_failed": false
  },
  "27576": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/ENNReal/Real.lean",
    "full_name": "ENNReal.toReal_lt_toReal",
    "start": [
      93,
      1
    ],
    "end": [
      96,
      12
    ],
    "traced_tactics": [
      {
        "tactic": "lift a to \u211d\u22650 using ha",
        "annotated_tactic": [
          "lift a to \u211d\u22650 using ha",
          []
        ],
        "state_before": "a b c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nha : a \u2260 \u22a4\nhb : b \u2260 \u22a4\n\u22a2 a.toReal < b.toReal \u2194 a < b",
        "state_after": "case intro\nb c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nhb : b \u2260 \u22a4\na : \u211d\u22650\n\u22a2 (\u2191a).toReal < b.toReal \u2194 \u2191a < b"
      },
      {
        "tactic": "lift b to \u211d\u22650 using hb",
        "annotated_tactic": [
          "lift b to \u211d\u22650 using hb",
          []
        ],
        "state_before": "case intro\nb c d : \u211d\u22650\u221e\nr p q : \u211d\u22650\nhb : b \u2260 \u22a4\na : \u211d\u22650\n\u22a2 (\u2191a).toReal < b.toReal \u2194 \u2191a < b",
        "state_after": "case intro.intro\nc d : \u211d\u22650\u221e\nr p q a b : \u211d\u22650\n\u22a2 (\u2191a).toReal < (\u2191b).toReal \u2194 \u2191a < \u2191b"
      },
      {
        "tactic": "norm_cast",
        "annotated_tactic": [
          "norm_cast",
          []
        ],
        "state_before": "case intro.intro\nc d : \u211d\u22650\u221e\nr p q a b : \u211d\u22650\n\u22a2 (\u2191a).toReal < (\u2191b).toReal \u2194 \u2191a < \u2191b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.272267531021498,
    "entry_failed": false
  },
  "27620": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Category/LightProfinite/Limits.lean",
    "full_name": "LightProfinite.finiteCoproduct.\u03b9_desc_apply",
    "start": [
      220,
      1
    ],
    "end": [
      224,
      21
    ],
    "traced_tactics": [
      {
        "tactic": "intro x",
        "annotated_tactic": [
          "intro x",
          []
        ],
        "state_before": "\u03b1 : Type w\ninst\u271d : Finite \u03b1\nX : \u03b1 \u2192 LightProfinite\nB : LightProfinite\n\u03c0 : (a : \u03b1) \u2192 X a \u27f6 B\na : \u03b1\n\u22a2 \u2200 (x : (forget LightProfinite).obj (X a)), (desc X \u03c0) ((\u03b9 X a) x) = (\u03c0 a) x",
        "state_after": "\u03b1 : Type w\ninst\u271d : Finite \u03b1\nX : \u03b1 \u2192 LightProfinite\nB : LightProfinite\n\u03c0 : (a : \u03b1) \u2192 X a \u27f6 B\na : \u03b1\nx : (forget LightProfinite).obj (X a)\n\u22a2 (desc X \u03c0) ((\u03b9 X a) x) = (\u03c0 a) x"
      },
      {
        "tactic": "change (\u03b9 X a \u226b desc X \u03c0) _ = _",
        "annotated_tactic": [
          "change (<a>\u03b9</a> X a \u226b <a>desc</a> X \u03c0) _ = _",
          [
            {
              "full_name": "LightProfinite.finiteCoproduct.\u03b9",
              "def_path": "Mathlib/Topology/Category/LightProfinite/Limits.lean",
              "def_pos": [
                148,
                5
              ],
              "def_end_pos": [
                148,
                22
              ]
            },
            {
              "full_name": "LightProfinite.finiteCoproduct.desc",
              "def_path": "Mathlib/Topology/Category/LightProfinite/Limits.lean",
              "def_pos": [
                156,
                5
              ],
              "def_end_pos": [
                156,
                25
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type w\ninst\u271d : Finite \u03b1\nX : \u03b1 \u2192 LightProfinite\nB : LightProfinite\n\u03c0 : (a : \u03b1) \u2192 X a \u27f6 B\na : \u03b1\nx : (forget LightProfinite).obj (X a)\n\u22a2 (desc X \u03c0) ((\u03b9 X a) x) = (\u03c0 a) x",
        "state_after": "\u03b1 : Type w\ninst\u271d : Finite \u03b1\nX : \u03b1 \u2192 LightProfinite\nB : LightProfinite\n\u03c0 : (a : \u03b1) \u2192 X a \u27f6 B\na : \u03b1\nx : (forget LightProfinite).obj (X a)\n\u22a2 (\u03b9 X a \u226b desc X \u03c0) x = (\u03c0 a) x"
      },
      {
        "tactic": "simp only [\u03b9_desc]",
        "annotated_tactic": [
          "simp only [<a>\u03b9_desc</a>]",
          [
            {
              "full_name": "LightProfinite.finiteCoproduct.\u03b9_desc",
              "def_path": "Mathlib/Topology/Category/LightProfinite/Limits.lean",
              "def_pos": [
                165,
                7
              ],
              "def_end_pos": [
                165,
                29
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type w\ninst\u271d : Finite \u03b1\nX : \u03b1 \u2192 LightProfinite\nB : LightProfinite\n\u03c0 : (a : \u03b1) \u2192 X a \u27f6 B\na : \u03b1\nx : (forget LightProfinite).obj (X a)\n\u22a2 (\u03b9 X a \u226b desc X \u03c0) x = (\u03c0 a) x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.278598174918443,
    "entry_failed": false
  },
  "27625": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Coprime/Lemmas.lean",
    "full_name": "IsCoprime.pow_left_iff",
    "start": [
      213,
      1
    ],
    "end": [
      216,
      51
    ],
    "traced_tactics": [
      {
        "tactic": "refine \u27e8fun h \u21a6 ?_, IsCoprime.pow_left\u27e9",
        "annotated_tactic": [
          "refine \u27e8fun h \u21a6 ?_, <a>IsCoprime.pow_left</a>\u27e9",
          [
            {
              "full_name": "IsCoprime.pow_left",
              "def_path": "Mathlib/RingTheory/Coprime/Lemmas.lean",
              "def_pos": [
                199,
                9
              ],
              "def_end_pos": [
                199,
                27
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nI : Type v\ninst\u271d : CommSemiring R\nx y z : R\ns : I \u2192 R\nt : Finset I\nm n : \u2115\nhm : 0 < m\n\u22a2 IsCoprime (x ^ m) y \u2194 IsCoprime x y",
        "state_after": "R : Type u\nI : Type v\ninst\u271d : CommSemiring R\nx y z : R\ns : I \u2192 R\nt : Finset I\nm n : \u2115\nhm : 0 < m\nh : IsCoprime (x ^ m) y\n\u22a2 IsCoprime x y"
      },
      {
        "tactic": "rw [\u2190 Finset.card_range m, \u2190 Finset.prod_const] at h",
        "annotated_tactic": [
          "rw [\u2190 <a>Finset.card_range</a> m, \u2190 <a>Finset.prod_const</a>] at h",
          [
            {
              "full_name": "Finset.card_range",
              "def_path": "Mathlib/Data/Finset/Card.lean",
              "def_pos": [
                206,
                9
              ],
              "def_end_pos": [
                206,
                19
              ]
            },
            {
              "full_name": "Finset.prod_const",
              "def_path": "Mathlib/Algebra/BigOperators/Group/Finset.lean",
              "def_pos": [
                1737,
                9
              ],
              "def_end_pos": [
                1737,
                19
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nI : Type v\ninst\u271d : CommSemiring R\nx y z : R\ns : I \u2192 R\nt : Finset I\nm n : \u2115\nhm : 0 < m\nh : IsCoprime (x ^ m) y\n\u22a2 IsCoprime x y",
        "state_after": "R : Type u\nI : Type v\ninst\u271d : CommSemiring R\nx y z : R\ns : I \u2192 R\nt : Finset I\nm n : \u2115\nhm : 0 < m\nh : IsCoprime (\u220f _x \u2208 range m, x) y\n\u22a2 IsCoprime x y"
      },
      {
        "tactic": "exact h.of_prod_left 0 (Finset.mem_range.mpr hm)",
        "annotated_tactic": [
          "exact h.of_prod_left 0 (Finset.mem_range.mpr hm)",
          []
        ],
        "state_before": "R : Type u\nI : Type v\ninst\u271d : CommSemiring R\nx y z : R\ns : I \u2192 R\nt : Finset I\nm n : \u2115\nhm : 0 < m\nh : IsCoprime (\u220f _x \u2208 range m, x) y\n\u22a2 IsCoprime x y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.4130976629676297,
    "entry_failed": false
  },
  "27632": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Matching.lean",
    "full_name": "SimpleGraph.Subgraph.IsMatching.support_eq_verts",
    "start": [
      90,
      1
    ],
    "end": [
      93,
      17
    ],
    "traced_tactics": [
      {
        "tactic": "refine M.support_subset_verts.antisymm fun v hv => ?_",
        "annotated_tactic": [
          "refine M.support_subset_verts.antisymm fun v hv => ?_",
          []
        ],
        "state_before": "V : Type u\nG : SimpleGraph V\nM\u271d M : G.Subgraph\nh : M.IsMatching\n\u22a2 M.support = M.verts",
        "state_after": "V : Type u\nG : SimpleGraph V\nM\u271d M : G.Subgraph\nh : M.IsMatching\nv : V\nhv : v \u2208 M.verts\n\u22a2 v \u2208 M.support"
      },
      {
        "tactic": "obtain \u27e8w, hvw, -\u27e9 := h hv",
        "annotated_tactic": [
          "obtain \u27e8w, hvw, -\u27e9 := h hv",
          []
        ],
        "state_before": "V : Type u\nG : SimpleGraph V\nM\u271d M : G.Subgraph\nh : M.IsMatching\nv : V\nhv : v \u2208 M.verts\n\u22a2 v \u2208 M.support",
        "state_after": "case intro.intro\nV : Type u\nG : SimpleGraph V\nM\u271d M : G.Subgraph\nh : M.IsMatching\nv : V\nhv : v \u2208 M.verts\nw : V\nhvw : M.Adj v w\n\u22a2 v \u2208 M.support"
      },
      {
        "tactic": "exact \u27e8_, hvw\u27e9",
        "annotated_tactic": [
          "exact \u27e8_, hvw\u27e9",
          []
        ],
        "state_before": "case intro.intro\nV : Type u\nG : SimpleGraph V\nM\u271d M : G.Subgraph\nh : M.IsMatching\nv : V\nhv : v \u2208 M.verts\nw : V\nhvw : M.Adj v w\n\u22a2 v \u2208 M.support",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5022721390705556,
    "entry_failed": false
  },
  "27657": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Clique.lean",
    "full_name": "SimpleGraph.isNClique_zero",
    "start": [
      235,
      1
    ],
    "end": [
      236,
      90
    ],
    "traced_tactics": [
      {
        "tactic": "simp only [isNClique_iff, Finset.card_eq_zero, and_iff_right_iff_imp]",
        "annotated_tactic": [
          "simp only [<a>isNClique_iff</a>, <a>Finset.card_eq_zero</a>, <a>and_iff_right_iff_imp</a>]",
          [
            {
              "full_name": "SimpleGraph.isNClique_iff",
              "def_path": "Mathlib/Combinatorics/SimpleGraph/Clique.lean",
              "def_pos": [
                189,
                9
              ],
              "def_end_pos": [
                189,
                22
              ]
            },
            {
              "full_name": "Finset.card_eq_zero",
              "def_path": "Mathlib/Data/Finset/Card.lean",
              "def_pos": [
                72,
                15
              ],
              "def_end_pos": [
                72,
                27
              ]
            },
            {
              "full_name": "and_iff_right_iff_imp",
              "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean",
              "def_pos": [
                165,
                17
              ],
              "def_end_pos": [
                165,
                38
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG H : SimpleGraph \u03b1\nn : \u2115\ns : Finset \u03b1\na b c : \u03b1\n\u22a2 G.IsNClique 0 s \u2194 s = \u2205",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG H : SimpleGraph \u03b1\nn : \u2115\ns : Finset \u03b1\na b c : \u03b1\n\u22a2 s = \u2205 \u2192 G.IsClique \u2191s"
      },
      {
        "tactic": "rintro rfl",
        "annotated_tactic": [
          "rintro rfl",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG H : SimpleGraph \u03b1\nn : \u2115\ns : Finset \u03b1\na b c : \u03b1\n\u22a2 s = \u2205 \u2192 G.IsClique \u2191s",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG H : SimpleGraph \u03b1\nn : \u2115\na b c : \u03b1\n\u22a2 G.IsClique \u2191\u2205"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG H : SimpleGraph \u03b1\nn : \u2115\na b c : \u03b1\n\u22a2 G.IsClique \u2191\u2205",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.1918358319671825,
    "entry_failed": false
  },
  "27742": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/Measure/Content.lean",
    "full_name": "MeasureTheory.Content.sup_le",
    "start": [
      108,
      1
    ],
    "end": [
      111,
      22
    ],
    "traced_tactics": [
      {
        "tactic": "simp only [apply_eq_coe_toFun]",
        "annotated_tactic": [
          "simp only [<a>apply_eq_coe_toFun</a>]",
          [
            {
              "full_name": "MeasureTheory.Content.apply_eq_coe_toFun",
              "def_path": "Mathlib/MeasureTheory/Measure/Content.lean",
              "def_pos": [
                94,
                9
              ],
              "def_end_pos": [
                94,
                27
              ]
            }
          ]
        ],
        "state_before": "G : Type w\ninst\u271d : TopologicalSpace G\n\u03bc : Content G\nK\u2081 K\u2082 : Compacts G\n\u22a2 (fun s => \u2191(\u03bc.toFun s)) (K\u2081 \u2294 K\u2082) \u2264 (fun s => \u2191(\u03bc.toFun s)) K\u2081 + (fun s => \u2191(\u03bc.toFun s)) K\u2082",
        "state_after": "G : Type w\ninst\u271d : TopologicalSpace G\n\u03bc : Content G\nK\u2081 K\u2082 : Compacts G\n\u22a2 \u2191(\u03bc.toFun (K\u2081 \u2294 K\u2082)) \u2264 \u2191(\u03bc.toFun K\u2081) + \u2191(\u03bc.toFun K\u2082)"
      },
      {
        "tactic": "norm_cast",
        "annotated_tactic": [
          "norm_cast",
          []
        ],
        "state_before": "G : Type w\ninst\u271d : TopologicalSpace G\n\u03bc : Content G\nK\u2081 K\u2082 : Compacts G\n\u22a2 \u2191(\u03bc.toFun (K\u2081 \u2294 K\u2082)) \u2264 \u2191(\u03bc.toFun K\u2081) + \u2191(\u03bc.toFun K\u2082)",
        "state_after": "G : Type w\ninst\u271d : TopologicalSpace G\n\u03bc : Content G\nK\u2081 K\u2082 : Compacts G\n\u22a2 \u03bc.toFun (K\u2081 \u2294 K\u2082) \u2264 \u03bc.toFun K\u2081 + \u03bc.toFun K\u2082"
      },
      {
        "tactic": "exact \u03bc.sup_le' _ _",
        "annotated_tactic": [
          "exact \u03bc.sup_le' _ _",
          []
        ],
        "state_before": "G : Type w\ninst\u271d : TopologicalSpace G\n\u03bc : Content G\nK\u2081 K\u2082 : Compacts G\n\u22a2 \u03bc.toFun (K\u2081 \u2294 K\u2082) \u2264 \u03bc.toFun K\u2081 + \u03bc.toFun K\u2082",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.2117217580089346,
    "entry_failed": false
  },
  "27787": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Homology/HomotopyCategory.lean",
    "full_name": "HomotopyCategory.quotient_inverts_homotopyEquivalences",
    "start": [
      171,
      1
    ],
    "end": [
      175,
      17
    ],
    "traced_tactics": [
      {
        "tactic": "rintro K L _ \u27e8e, rfl\u27e9",
        "annotated_tactic": [
          "rintro K L _ \u27e8e, rfl\u27e9",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d\u00b2 : Semiring R\n\u03b9 : Type u_2\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nc : ComplexShape \u03b9\n\u22a2 (homotopyEquivalences V c).IsInvertedBy (quotient V c)",
        "state_after": "case intro\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\n\u03b9 : Type u_2\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nc : ComplexShape \u03b9\nK L : HomologicalComplex V c\ne : HomotopyEquiv K L\n\u22a2 IsIso ((quotient V c).map e.hom)"
      },
      {
        "tactic": "change IsIso (isoOfHomotopyEquiv e).hom",
        "annotated_tactic": [
          "change <a>IsIso</a> (<a>isoOfHomotopyEquiv</a> e).<a>hom</a>",
          [
            {
              "full_name": "CategoryTheory.IsIso",
              "def_path": "Mathlib/CategoryTheory/Iso.lean",
              "def_pos": [
                272,
                7
              ],
              "def_end_pos": [
                272,
                12
              ]
            },
            {
              "full_name": "HomotopyCategory.isoOfHomotopyEquiv",
              "def_path": "Mathlib/Algebra/Homology/HomotopyCategory.lean",
              "def_pos": [
                144,
                5
              ],
              "def_end_pos": [
                144,
                23
              ]
            },
            {
              "full_name": "CategoryTheory.Iso.hom",
              "def_path": "Mathlib/CategoryTheory/Iso.lean",
              "def_pos": [
                53,
                3
              ],
              "def_end_pos": [
                53,
                6
              ]
            }
          ]
        ],
        "state_before": "case intro\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\n\u03b9 : Type u_2\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nc : ComplexShape \u03b9\nK L : HomologicalComplex V c\ne : HomotopyEquiv K L\n\u22a2 IsIso ((quotient V c).map e.hom)",
        "state_after": "case intro\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\n\u03b9 : Type u_2\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nc : ComplexShape \u03b9\nK L : HomologicalComplex V c\ne : HomotopyEquiv K L\n\u22a2 IsIso (isoOfHomotopyEquiv e).hom"
      },
      {
        "tactic": "infer_instance",
        "annotated_tactic": [
          "infer_instance",
          []
        ],
        "state_before": "case intro\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\n\u03b9 : Type u_2\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : Preadditive V\nc : ComplexShape \u03b9\nK L : HomologicalComplex V c\ne : HomotopyEquiv K L\n\u22a2 IsIso (isoOfHomotopyEquiv e).hom",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.7649579549906775,
    "entry_failed": false
  },
  "27815": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Exponent.lean",
    "full_name": "Monoid.lcm_orderOf_dvd_exponent",
    "start": [
      250,
      1
    ],
    "end": [
      254,
      29
    ],
    "traced_tactics": [
      {
        "tactic": "apply Finset.lcm_dvd",
        "annotated_tactic": [
          "apply <a>Finset.lcm_dvd</a>",
          [
            {
              "full_name": "Finset.lcm_dvd",
              "def_path": "Mathlib/Algebra/GCDMonoid/Finset.lean",
              "def_pos": [
                68,
                9
              ],
              "def_end_pos": [
                68,
                16
              ]
            }
          ]
        ],
        "state_before": "G : Type u\ninst\u271d\u00b9 : Monoid G\ninst\u271d : Fintype G\n\u22a2 Finset.univ.lcm orderOf \u2223 exponent G",
        "state_after": "case a\nG : Type u\ninst\u271d\u00b9 : Monoid G\ninst\u271d : Fintype G\n\u22a2 \u2200 b \u2208 Finset.univ, orderOf b \u2223 exponent G"
      },
      {
        "tactic": "intro g _",
        "annotated_tactic": [
          "intro g _",
          []
        ],
        "state_before": "case a\nG : Type u\ninst\u271d\u00b9 : Monoid G\ninst\u271d : Fintype G\n\u22a2 \u2200 b \u2208 Finset.univ, orderOf b \u2223 exponent G",
        "state_after": "case a\nG : Type u\ninst\u271d\u00b9 : Monoid G\ninst\u271d : Fintype G\ng : G\na\u271d : g \u2208 Finset.univ\n\u22a2 orderOf g \u2223 exponent G"
      },
      {
        "tactic": "exact order_dvd_exponent g",
        "annotated_tactic": [
          "exact <a>order_dvd_exponent</a> g",
          [
            {
              "full_name": "Monoid.order_dvd_exponent",
              "def_path": "Mathlib/GroupTheory/Exponent.lean",
              "def_pos": [
                207,
                9
              ],
              "def_end_pos": [
                207,
                27
              ]
            }
          ]
        ],
        "state_before": "case a\nG : Type u\ninst\u271d\u00b9 : Monoid G\ninst\u271d : Fintype G\ng : G\na\u271d : g \u2208 Finset.univ\n\u22a2 orderOf g \u2223 exponent G",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.7133197019575164,
    "entry_failed": false
  },
  "27844": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/OrderOfElement.lean",
    "full_name": "isPeriodicPt_mul_iff_pow_eq_one",
    "start": [
      48,
      1
    ],
    "end": [
      49,
      76
    ],
    "traced_tactics": [
      {
        "tactic": "rw [IsPeriodicPt, IsFixedPt, mul_left_iterate]",
        "annotated_tactic": [
          "rw [<a>IsPeriodicPt</a>, <a>IsFixedPt</a>, <a>mul_left_iterate</a>]",
          [
            {
              "full_name": "Function.IsPeriodicPt",
              "def_path": "Mathlib/Dynamics/PeriodicPts.lean",
              "def_pos": [
                59,
                5
              ],
              "def_end_pos": [
                59,
                17
              ]
            },
            {
              "full_name": "Function.IsFixedPt",
              "def_path": "Mathlib/Dynamics/FixedPoints/Basic.lean",
              "def_pos": [
                39,
                5
              ],
              "def_end_pos": [
                39,
                14
              ]
            },
            {
              "full_name": "mul_left_iterate",
              "def_path": "Mathlib/Algebra/GroupPower/IterateHom.lean",
              "def_pos": [
                99,
                9
              ],
              "def_end_pos": [
                99,
                25
              ]
            }
          ]
        ],
        "state_before": "G : Type u_1\nH : Type u_2\nA : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d : Monoid G\na b x\u271d y : G\nn m : \u2115\nx : G\n\u22a2 IsPeriodicPt (fun x_1 => x * x_1) n 1 \u2194 x ^ n = 1",
        "state_after": "G : Type u_1\nH : Type u_2\nA : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d : Monoid G\na b x\u271d y : G\nn m : \u2115\nx : G\n\u22a2 (fun x_1 => x ^ n * x_1) 1 = 1 \u2194 x ^ n = 1"
      },
      {
        "tactic": "beta_reduce",
        "annotated_tactic": [
          "beta_reduce",
          []
        ],
        "state_before": "G : Type u_1\nH : Type u_2\nA : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d : Monoid G\na b x\u271d y : G\nn m : \u2115\nx : G\n\u22a2 (fun x_1 => x ^ n * x_1) 1 = 1 \u2194 x ^ n = 1",
        "state_after": "G : Type u_1\nH : Type u_2\nA : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d : Monoid G\na b x\u271d y : G\nn m : \u2115\nx : G\n\u22a2 x ^ n * 1 = 1 \u2194 x ^ n = 1"
      },
      {
        "tactic": "rw [mul_one]",
        "annotated_tactic": [
          "rw [<a>mul_one</a>]",
          [
            {
              "full_name": "mul_one",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                483,
                9
              ],
              "def_end_pos": [
                483,
                16
              ]
            }
          ]
        ],
        "state_before": "G : Type u_1\nH : Type u_2\nA : Type u_3\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d : Monoid G\na b x\u271d y : G\nn m : \u2115\nx : G\n\u22a2 x ^ n * 1 = 1 \u2194 x ^ n = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.7124674989609048,
    "entry_failed": false
  },
  "27878": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/ModularLattice.lean",
    "full_name": "Disjoint.disjoint_sup_left_of_disjoint_sup_right",
    "start": [
      402,
      1
    ],
    "end": [
      407,
      40
    ],
    "traced_tactics": [
      {
        "tactic": "rw [disjoint_comm, sup_comm]",
        "annotated_tactic": [
          "rw [<a>disjoint_comm</a>, <a>sup_comm</a>]",
          [
            {
              "full_name": "disjoint_comm",
              "def_path": "Mathlib/Order/Disjoint.lean",
              "def_pos": [
                50,
                9
              ],
              "def_end_pos": [
                50,
                22
              ]
            },
            {
              "full_name": "sup_comm",
              "def_path": "Mathlib/Order/Lattice.lean",
              "def_pos": [
                224,
                9
              ],
              "def_end_pos": [
                224,
                17
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\na b c : \u03b1\ninst\u271d\u00b2 : Lattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : IsModularLattice \u03b1\nh : Disjoint b c\nhsup : Disjoint a (b \u2294 c)\n\u22a2 Disjoint (a \u2294 b) c",
        "state_after": "\u03b1 : Type u_1\na b c : \u03b1\ninst\u271d\u00b2 : Lattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : IsModularLattice \u03b1\nh : Disjoint b c\nhsup : Disjoint a (b \u2294 c)\n\u22a2 Disjoint c (b \u2294 a)"
      },
      {
        "tactic": "apply Disjoint.disjoint_sup_right_of_disjoint_sup_left h.symm",
        "annotated_tactic": [
          "apply <a>Disjoint.disjoint_sup_right_of_disjoint_sup_left</a> h.symm",
          [
            {
              "full_name": "Disjoint.disjoint_sup_right_of_disjoint_sup_left",
              "def_path": "Mathlib/Order/ModularLattice.lean",
              "def_pos": [
                393,
                9
              ],
              "def_end_pos": [
                393,
                48
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\na b c : \u03b1\ninst\u271d\u00b2 : Lattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : IsModularLattice \u03b1\nh : Disjoint b c\nhsup : Disjoint a (b \u2294 c)\n\u22a2 Disjoint c (b \u2294 a)",
        "state_after": "\u03b1 : Type u_1\na b c : \u03b1\ninst\u271d\u00b2 : Lattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : IsModularLattice \u03b1\nh : Disjoint b c\nhsup : Disjoint a (b \u2294 c)\n\u22a2 Disjoint (c \u2294 b) a"
      },
      {
        "tactic": "rwa [sup_comm, disjoint_comm] at hsup",
        "annotated_tactic": [
          "rwa [<a>sup_comm</a>, <a>disjoint_comm</a>] at hsup",
          [
            {
              "full_name": "sup_comm",
              "def_path": "Mathlib/Order/Lattice.lean",
              "def_pos": [
                224,
                9
              ],
              "def_end_pos": [
                224,
                17
              ]
            },
            {
              "full_name": "disjoint_comm",
              "def_path": "Mathlib/Order/Disjoint.lean",
              "def_pos": [
                50,
                9
              ],
              "def_end_pos": [
                50,
                22
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\na b c : \u03b1\ninst\u271d\u00b2 : Lattice \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : IsModularLattice \u03b1\nh : Disjoint b c\nhsup : Disjoint a (b \u2294 c)\n\u22a2 Disjoint (c \u2294 b) a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.457021208014339,
    "entry_failed": false
  },
  "27940": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Defs.lean",
    "full_name": "Nat.exists_lt_succ",
    "start": [
      224,
      1
    ],
    "end": [
      227,
      23
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 not_iff_not]",
        "annotated_tactic": [
          "rw [\u2190 <a>not_iff_not</a>]",
          [
            {
              "full_name": "not_iff_not",
              "def_path": "Mathlib/Logic/Basic.lean",
              "def_pos": [
                447,
                9
              ],
              "def_end_pos": [
                447,
                20
              ]
            }
          ]
        ],
        "state_before": "a b c d m n k : \u2115\np q : \u2115 \u2192 Prop\n\u22a2 (\u2203 m, m < n + 1 \u2227 p m) \u2194 (\u2203 m, m < n \u2227 p m) \u2228 p n",
        "state_after": "a b c d m n k : \u2115\np q : \u2115 \u2192 Prop\n\u22a2 (\u00ac\u2203 m, m < n + 1 \u2227 p m) \u2194 \u00ac((\u2203 m, m < n \u2227 p m) \u2228 p n)"
      },
      {
        "tactic": "push_neg",
        "annotated_tactic": [
          "push_neg",
          []
        ],
        "state_before": "a b c d m n k : \u2115\np q : \u2115 \u2192 Prop\n\u22a2 (\u00ac\u2203 m, m < n + 1 \u2227 p m) \u2194 \u00ac((\u2203 m, m < n \u2227 p m) \u2228 p n)",
        "state_after": "a b c d m n k : \u2115\np q : \u2115 \u2192 Prop\n\u22a2 (\u2200 (m : \u2115), m < n + 1 \u2192 \u00acp m) \u2194 (\u2200 (m : \u2115), m < n \u2192 \u00acp m) \u2227 \u00acp n"
      },
      {
        "tactic": "exact forall_lt_succ",
        "annotated_tactic": [
          "exact <a>forall_lt_succ</a>",
          [
            {
              "full_name": "Nat.forall_lt_succ",
              "def_path": "Mathlib/Data/Nat/Defs.lean",
              "def_pos": [
                220,
                7
              ],
              "def_end_pos": [
                220,
                21
              ]
            }
          ]
        ],
        "state_before": "a b c d m n k : \u2115\np q : \u2115 \u2192 Prop\n\u22a2 (\u2200 (m : \u2115), m < n + 1 \u2192 \u00acp m) \u2194 (\u2200 (m : \u2115), m < n \u2192 \u00acp m) \u2227 \u00acp n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.563708934001625,
    "entry_failed": false
  },
  "27951": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/Idempotents/Basic.lean",
    "full_name": "CategoryTheory.Idempotents.isIdempotentComplete_iff_of_equivalence",
    "start": [
      177,
      1
    ],
    "end": [
      181,
      50
    ],
    "traced_tactics": [
      {
        "tactic": "constructor",
        "annotated_tactic": [
          "constructor",
          []
        ],
        "state_before": "C : Type u_1\ninst\u271d\u00b9 : Category.{u_4, u_1} C\nD : Type u_2\ninst\u271d : Category.{u_3, u_2} D\n\u03b5 : C \u224c D\n\u22a2 IsIdempotentComplete C \u2194 IsIdempotentComplete D",
        "state_after": "case mp\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_4, u_1} C\nD : Type u_2\ninst\u271d : Category.{u_3, u_2} D\n\u03b5 : C \u224c D\n\u22a2 IsIdempotentComplete C \u2192 IsIdempotentComplete D\n\ncase mpr\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_4, u_1} C\nD : Type u_2\ninst\u271d : Category.{u_3, u_2} D\n\u03b5 : C \u224c D\n\u22a2 IsIdempotentComplete D \u2192 IsIdempotentComplete C"
      },
      {
        "tactic": "exact Equivalence.isIdempotentComplete \u03b5",
        "annotated_tactic": [
          "exact <a>Equivalence.isIdempotentComplete</a> \u03b5",
          [
            {
              "full_name": "CategoryTheory.Idempotents.Equivalence.isIdempotentComplete",
              "def_path": "Mathlib/CategoryTheory/Idempotents/Basic.lean",
              "def_pos": [
                157,
                9
              ],
              "def_end_pos": [
                157,
                41
              ]
            }
          ]
        ],
        "state_before": "case mp\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_4, u_1} C\nD : Type u_2\ninst\u271d : Category.{u_3, u_2} D\n\u03b5 : C \u224c D\n\u22a2 IsIdempotentComplete C \u2192 IsIdempotentComplete D",
        "state_after": "no goals"
      },
      {
        "tactic": "exact Equivalence.isIdempotentComplete \u03b5.symm",
        "annotated_tactic": [
          "exact <a>Equivalence.isIdempotentComplete</a> \u03b5.symm",
          [
            {
              "full_name": "CategoryTheory.Idempotents.Equivalence.isIdempotentComplete",
              "def_path": "Mathlib/CategoryTheory/Idempotents/Basic.lean",
              "def_pos": [
                157,
                9
              ],
              "def_end_pos": [
                157,
                41
              ]
            }
          ]
        ],
        "state_before": "case mpr\nC : Type u_1\ninst\u271d\u00b9 : Category.{u_4, u_1} C\nD : Type u_2\ninst\u271d : Category.{u_3, u_2} D\n\u03b5 : C \u224c D\n\u22a2 IsIdempotentComplete D \u2192 IsIdempotentComplete C",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.037875027046539,
    "entry_failed": false
  },
  "27954": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/LocallyConstant/Basic.lean",
    "full_name": "IsLocallyConstant.range_finite",
    "start": [
      181,
      1
    ],
    "end": [
      184,
      59
    ],
    "traced_tactics": [
      {
        "tactic": "letI : TopologicalSpace Y := \u22a5",
        "annotated_tactic": [
          "letI : <a>TopologicalSpace</a> Y := \u22a5",
          [
            {
              "full_name": "TopologicalSpace",
              "def_path": "Mathlib/Topology/Defs/Basic.lean",
              "def_pos": [
                63,
                7
              ],
              "def_end_pos": [
                63,
                23
              ]
            }
          ]
        ],
        "state_before": "X : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : CompactSpace X\nf : X \u2192 Y\nhf : IsLocallyConstant f\n\u22a2 (range f).Finite",
        "state_after": "X : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : CompactSpace X\nf : X \u2192 Y\nhf : IsLocallyConstant f\nthis : TopologicalSpace Y := \u22a5\n\u22a2 (range f).Finite"
      },
      {
        "tactic": "haveI := discreteTopology_bot Y",
        "annotated_tactic": [
          "haveI := <a>discreteTopology_bot</a> Y",
          [
            {
              "full_name": "discreteTopology_bot",
              "def_path": "Mathlib/Topology/Order.lean",
              "def_pos": [
                273,
                9
              ],
              "def_end_pos": [
                273,
                29
              ]
            }
          ]
        ],
        "state_before": "X : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : CompactSpace X\nf : X \u2192 Y\nhf : IsLocallyConstant f\nthis : TopologicalSpace Y := \u22a5\n\u22a2 (range f).Finite",
        "state_after": "X : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : CompactSpace X\nf : X \u2192 Y\nhf : IsLocallyConstant f\nthis\u271d : TopologicalSpace Y := \u22a5\nthis : DiscreteTopology Y\n\u22a2 (range f).Finite"
      },
      {
        "tactic": "exact (isCompact_range hf.continuous).finite_of_discrete",
        "annotated_tactic": [
          "exact (<a>isCompact_range</a> hf.continuous).<a>finite_of_discrete</a>",
          [
            {
              "full_name": "isCompact_range",
              "def_path": "Mathlib/Topology/Compactness/Compact.lean",
              "def_pos": [
                959,
                9
              ],
              "def_end_pos": [
                959,
                24
              ]
            },
            {
              "full_name": "IsCompact.finite_of_discrete",
              "def_path": "Mathlib/Topology/Compactness/Compact.lean",
              "def_pos": [
                511,
                9
              ],
              "def_end_pos": [
                511,
                37
              ]
            }
          ]
        ],
        "state_before": "X : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : CompactSpace X\nf : X \u2192 Y\nhf : IsLocallyConstant f\nthis\u271d : TopologicalSpace Y := \u22a5\nthis : DiscreteTopology Y\n\u22a2 (range f).Finite",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.0164662059396505,
    "entry_failed": false
  },
  "27972": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/Groupoid/Subgroupoid.lean",
    "full_name": "CategoryTheory.Subgroupoid.id_mem_of_nonempty_isotropy",
    "start": [
      123,
      1
    ],
    "end": [
      126,
      43
    ],
    "traced_tactics": [
      {
        "tactic": "rintro \u27e8\u03b3, h\u03b3\u27e9",
        "annotated_tactic": [
          "rintro \u27e8\u03b3, h\u03b3\u27e9",
          []
        ],
        "state_before": "C : Type u\ninst\u271d : Groupoid C\nS : Subgroupoid C\nc : C\n\u22a2 c \u2208 S.objs \u2192 \ud835\udfd9 c \u2208 S.arrows c c",
        "state_after": "case intro\nC : Type u\ninst\u271d : Groupoid C\nS : Subgroupoid C\nc : C\n\u03b3 : c \u27f6 c\nh\u03b3 : \u03b3 \u2208 S.arrows c c\n\u22a2 \ud835\udfd9 c \u2208 S.arrows c c"
      },
      {
        "tactic": "convert S.mul h\u03b3 (S.inv h\u03b3)",
        "annotated_tactic": [
          "convert S.mul h\u03b3 (S.inv h\u03b3)",
          []
        ],
        "state_before": "case intro\nC : Type u\ninst\u271d : Groupoid C\nS : Subgroupoid C\nc : C\n\u03b3 : c \u27f6 c\nh\u03b3 : \u03b3 \u2208 S.arrows c c\n\u22a2 \ud835\udfd9 c \u2208 S.arrows c c",
        "state_after": "case h.e'_4\nC : Type u\ninst\u271d : Groupoid C\nS : Subgroupoid C\nc : C\n\u03b3 : c \u27f6 c\nh\u03b3 : \u03b3 \u2208 S.arrows c c\n\u22a2 \ud835\udfd9 c = \u03b3 \u226b Groupoid.inv \u03b3"
      },
      {
        "tactic": "simp only [inv_eq_inv, IsIso.hom_inv_id]",
        "annotated_tactic": [
          "simp only [<a>inv_eq_inv</a>, <a>IsIso.hom_inv_id</a>]",
          [
            {
              "full_name": "CategoryTheory.Groupoid.inv_eq_inv",
              "def_path": "Mathlib/CategoryTheory/Groupoid.lean",
              "def_pos": [
                76,
                9
              ],
              "def_end_pos": [
                76,
                28
              ]
            },
            {
              "full_name": "CategoryTheory.IsIso.hom_inv_id",
              "def_path": "Mathlib/CategoryTheory/Iso.lean",
              "def_pos": [
                286,
                9
              ],
              "def_end_pos": [
                286,
                19
              ]
            }
          ]
        ],
        "state_before": "case h.e'_4\nC : Type u\ninst\u271d : Groupoid C\nS : Subgroupoid C\nc : C\n\u03b3 : c \u27f6 c\nh\u03b3 : \u03b3 \u2208 S.arrows c c\n\u22a2 \ud835\udfd9 c = \u03b3 \u226b Groupoid.inv \u03b3",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9267675670562312,
    "entry_failed": false
  },
  "27976": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Real/Hyperreal.lean",
    "full_name": "Hyperreal.IsSt.unique",
    "start": [
      276,
      1
    ],
    "end": [
      279,
      34
    ],
    "traced_tactics": [
      {
        "tactic": "rcases ofSeq_surjective x with \u27e8f, rfl\u27e9",
        "annotated_tactic": [
          "rcases <a>ofSeq_surjective</a> x with \u27e8f, rfl\u27e9",
          [
            {
              "full_name": "Hyperreal.ofSeq_surjective",
              "def_path": "Mathlib/Data/Real/Hyperreal.lean",
              "def_pos": [
                153,
                9
              ],
              "def_end_pos": [
                153,
                25
              ]
            }
          ]
        ],
        "state_before": "x : \u211d*\nr s : \u211d\nhr : x.IsSt r\nhs : x.IsSt s\n\u22a2 r = s",
        "state_after": "case intro\nr s : \u211d\nf : \u2115 \u2192 \u211d\nhr : (ofSeq f).IsSt r\nhs : (ofSeq f).IsSt s\n\u22a2 r = s"
      },
      {
        "tactic": "rw [isSt_ofSeq_iff_tendsto] at hr hs",
        "annotated_tactic": [
          "rw [<a>isSt_ofSeq_iff_tendsto</a>] at hr hs",
          [
            {
              "full_name": "Hyperreal.isSt_ofSeq_iff_tendsto",
              "def_path": "Mathlib/Data/Real/Hyperreal.lean",
              "def_pos": [
                254,
                9
              ],
              "def_end_pos": [
                254,
                31
              ]
            }
          ]
        ],
        "state_before": "case intro\nr s : \u211d\nf : \u2115 \u2192 \u211d\nhr : (ofSeq f).IsSt r\nhs : (ofSeq f).IsSt s\n\u22a2 r = s",
        "state_after": "case intro\nr s : \u211d\nf : \u2115 \u2192 \u211d\nhr : Tendsto f (\u2191(hyperfilter \u2115)) (\ud835\udcdd r)\nhs : Tendsto f (\u2191(hyperfilter \u2115)) (\ud835\udcdd s)\n\u22a2 r = s"
      },
      {
        "tactic": "exact tendsto_nhds_unique hr hs",
        "annotated_tactic": [
          "exact <a>tendsto_nhds_unique</a> hr hs",
          [
            {
              "full_name": "tendsto_nhds_unique",
              "def_path": "Mathlib/Topology/Separation.lean",
              "def_pos": [
                1508,
                9
              ],
              "def_end_pos": [
                1508,
                28
              ]
            }
          ]
        ],
        "state_before": "case intro\nr s : \u211d\nf : \u2115 \u2192 \u211d\nhr : Tendsto f (\u2191(hyperfilter \u2115)) (\ud835\udcdd r)\nhs : Tendsto f (\u2191(hyperfilter \u2115)) (\ud835\udcdd s)\n\u22a2 r = s",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.47538632794749,
    "entry_failed": false
  },
  "28015": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Int/Defs.lean",
    "full_name": "Int.neg_emod_two",
    "start": [
      534,
      1
    ],
    "end": [
      537,
      39
    ],
    "traced_tactics": [
      {
        "tactic": "apply Int.emod_eq_emod_iff_emod_sub_eq_zero.mpr",
        "annotated_tactic": [
          "apply Int.emod_eq_emod_iff_emod_sub_eq_zero.mpr",
          []
        ],
        "state_before": "a b c d m n i : \u2124\n\u22a2 -i % 2 = i % 2",
        "state_after": "a b c d m n i : \u2124\n\u22a2 (-i - i) % 2 = 0"
      },
      {
        "tactic": "convert Int.mul_emod_right 2 (-i) using 2",
        "annotated_tactic": [
          "convert <a>Int.mul_emod_right</a> 2 (-i) using 2",
          [
            {
              "full_name": "Int.mul_emod_right",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/DivModLemmas.lean",
              "def_pos": [
                492,
                17
              ],
              "def_end_pos": [
                492,
                31
              ]
            }
          ]
        ],
        "state_before": "a b c d m n i : \u2124\n\u22a2 (-i - i) % 2 = 0",
        "state_after": "case h.e'_2.h.e'_5\na b c d m n i : \u2124\n\u22a2 -i - i = 2 * -i"
      },
      {
        "tactic": "rw [Int.two_mul, Int.sub_eq_add_neg]",
        "annotated_tactic": [
          "rw [<a>Int.two_mul</a>, <a>Int.sub_eq_add_neg</a>]",
          [
            {
              "full_name": "Int.two_mul",
              "def_path": "Mathlib/Data/Int/Defs.lean",
              "def_pos": [
                165,
                17
              ],
              "def_end_pos": [
                165,
                24
              ]
            },
            {
              "full_name": "Int.sub_eq_add_neg",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Lemmas.lean",
              "def_pos": [
                87,
                19
              ],
              "def_end_pos": [
                87,
                33
              ]
            }
          ]
        ],
        "state_before": "case h.e'_2.h.e'_5\na b c d m n i : \u2124\n\u22a2 -i - i = 2 * -i",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.423564380966127,
    "entry_failed": false
  },
  "28064": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/EqToHom.lean",
    "full_name": "CategoryTheory.eqToHom_trans",
    "start": [
      52,
      1
    ],
    "end": [
      56,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "cases p",
        "annotated_tactic": [
          "cases p",
          []
        ],
        "state_before": "C : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nX Y Z : C\np : X = Y\nq : Y = Z\n\u22a2 eqToHom p \u226b eqToHom q = eqToHom \u22ef",
        "state_after": "case refl\nC : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nX Z : C\nq : X = Z\n\u22a2 eqToHom \u22ef \u226b eqToHom q = eqToHom \u22ef"
      },
      {
        "tactic": "cases q",
        "annotated_tactic": [
          "cases q",
          []
        ],
        "state_before": "case refl\nC : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nX Z : C\nq : X = Z\n\u22a2 eqToHom \u22ef \u226b eqToHom q = eqToHom \u22ef",
        "state_after": "case refl.refl\nC : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nX : C\n\u22a2 eqToHom \u22ef \u226b eqToHom \u22ef = eqToHom \u22ef"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case refl.refl\nC : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nX : C\n\u22a2 eqToHom \u22ef \u226b eqToHom \u22ef = eqToHom \u22ef",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.1309021749766544,
    "entry_failed": false
  },
  "28076": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Polynomial/Monic.lean",
    "full_name": "Polynomial.monic_mul_C_of_leadingCoeff_mul_eq_one",
    "start": [
      84,
      1
    ],
    "end": [
      88,
      59
    ],
    "traced_tactics": [
      {
        "tactic": "unfold Monic",
        "annotated_tactic": [
          "unfold <a>Monic</a>",
          [
            {
              "full_name": "Polynomial.Monic",
              "def_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
              "def_pos": [
                77,
                5
              ],
              "def_end_pos": [
                77,
                10
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\na b\u271d : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nb : R\nhp : p.leadingCoeff * b = 1\n\u22a2 (p * C b).Monic",
        "state_after": "R : Type u\nS : Type v\na b\u271d : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nb : R\nhp : p.leadingCoeff * b = 1\n\u22a2 (p * C b).leadingCoeff = 1"
      },
      {
        "tactic": "nontriviality",
        "annotated_tactic": [
          "nontriviality",
          []
        ],
        "state_before": "R : Type u\nS : Type v\na b\u271d : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nb : R\nhp : p.leadingCoeff * b = 1\n\u22a2 (p * C b).leadingCoeff = 1",
        "state_after": "R : Type u\nS : Type v\na b\u271d : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nb : R\nhp : p.leadingCoeff * b = 1\na\u271d : Nontrivial R\n\u22a2 (p * C b).leadingCoeff = 1"
      },
      {
        "tactic": "rw [leadingCoeff_mul' _] <;> simp [leadingCoeff_C b, hp]",
        "annotated_tactic": [
          "rw [<a>leadingCoeff_mul'</a> _] <;> simp [<a>leadingCoeff_C</a> b, hp]",
          [
            {
              "full_name": "Polynomial.leadingCoeff_mul'",
              "def_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
              "def_pos": [
                1020,
                9
              ],
              "def_end_pos": [
                1020,
                26
              ]
            },
            {
              "full_name": "Polynomial.leadingCoeff_C",
              "def_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
              "def_pos": [
                875,
                9
              ],
              "def_end_pos": [
                875,
                23
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\na b\u271d : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nb : R\nhp : p.leadingCoeff * b = 1\na\u271d : Nontrivial R\n\u22a2 (p * C b).leadingCoeff = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.226369997020811,
    "entry_failed": false
  },
  "28079": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/ENat/Basic.lean",
    "full_name": "ENat.toNat_add",
    "start": [
      220,
      1
    ],
    "end": [
      223,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "lift m to \u2115 using hm",
        "annotated_tactic": [
          "lift m to \u2115 using hm",
          []
        ],
        "state_before": "m\u271d n\u271d m n : \u2115\u221e\nhm : m \u2260 \u22a4\nhn : n \u2260 \u22a4\n\u22a2 (m + n).toNat = m.toNat + n.toNat",
        "state_after": "case intro\nm\u271d n\u271d n : \u2115\u221e\nhn : n \u2260 \u22a4\nm : \u2115\n\u22a2 (\u2191m + n).toNat = (\u2191m).toNat + n.toNat"
      },
      {
        "tactic": "lift n to \u2115 using hn",
        "annotated_tactic": [
          "lift n to \u2115 using hn",
          []
        ],
        "state_before": "case intro\nm\u271d n\u271d n : \u2115\u221e\nhn : n \u2260 \u22a4\nm : \u2115\n\u22a2 (\u2191m + n).toNat = (\u2191m).toNat + n.toNat",
        "state_after": "case intro.intro\nm\u271d n\u271d : \u2115\u221e\nm n : \u2115\n\u22a2 (\u2191m + \u2191n).toNat = (\u2191m).toNat + (\u2191n).toNat"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case intro.intro\nm\u271d n\u271d : \u2115\u221e\nm n : \u2115\n\u22a2 (\u2191m + \u2191n).toNat = (\u2191m).toNat + (\u2191n).toNat",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9745220280019566,
    "entry_failed": false
  },
  "28121": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/FieldTheory/KummerExtension.lean",
    "full_name": "ne_zero_of_irreducible_X_pow_sub_C",
    "start": [
      110,
      1
    ],
    "end": [
      114,
      30
    ],
    "traced_tactics": [
      {
        "tactic": "rintro rfl",
        "annotated_tactic": [
          "rintro rfl",
          []
        ],
        "state_before": "K : Type u\ninst\u271d : Field K\nn : \u2115\na : K\nH : Irreducible (X ^ n - C a)\n\u22a2 n \u2260 0",
        "state_after": "K : Type u\ninst\u271d : Field K\na : K\nH : Irreducible (X ^ 0 - C a)\n\u22a2 False"
      },
      {
        "tactic": "rw [pow_zero, \u2190 C.map_one, \u2190 map_sub] at H",
        "annotated_tactic": [
          "rw [<a>pow_zero</a>, \u2190 C.map_one, \u2190 <a>map_sub</a>] at H",
          [
            {
              "full_name": "pow_zero",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                651,
                9
              ],
              "def_end_pos": [
                651,
                17
              ]
            },
            {
              "full_name": "map_sub",
              "def_path": "Mathlib/Algebra/Group/Hom/Defs.lean",
              "def_pos": [
                461,
                3
              ],
              "def_end_pos": [
                461,
                14
              ]
            }
          ]
        ],
        "state_before": "K : Type u\ninst\u271d : Field K\na : K\nH : Irreducible (X ^ 0 - C a)\n\u22a2 False",
        "state_after": "K : Type u\ninst\u271d : Field K\na : K\nH : Irreducible (C (1 - a))\n\u22a2 False"
      },
      {
        "tactic": "exact not_irreducible_C _ H",
        "annotated_tactic": [
          "exact <a>not_irreducible_C</a> _ H",
          [
            {
              "full_name": "Polynomial.not_irreducible_C",
              "def_path": "Mathlib/Algebra/Polynomial/FieldDivision.lean",
              "def_pos": [
                598,
                9
              ],
              "def_end_pos": [
                598,
                26
              ]
            }
          ]
        ],
        "state_before": "K : Type u\ninst\u271d : Field K\na : K\nH : Irreducible (C (1 - a))\n\u22a2 False",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.5538709319662303,
    "entry_failed": false
  },
  "28133": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Computability/Ackermann.lean",
    "full_name": "ack_one",
    "start": [
      82,
      1
    ],
    "end": [
      85,
      14
    ],
    "traced_tactics": [
      {
        "tactic": "induction' n with n IH",
        "annotated_tactic": [
          "induction' n with n IH",
          []
        ],
        "state_before": "n : \u2115\n\u22a2 ack 1 n = n + 2",
        "state_after": "case zero\n\n\u22a2 ack 1 0 = 0 + 2\n\ncase succ\nn : \u2115\nIH : ack 1 n = n + 2\n\u22a2 ack 1 (n + 1) = n + 1 + 2"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case zero\n\n\u22a2 ack 1 0 = 0 + 2",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [IH]",
        "annotated_tactic": [
          "simp [IH]",
          []
        ],
        "state_before": "case succ\nn : \u2115\nIH : ack 1 n = n + 2\n\u22a2 ack 1 (n + 1) = n + 1 + 2",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6964255400234833,
    "entry_failed": false
  },
  "28206": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/IsWellOrderLimitElement.lean",
    "full_name": "Nat.not_isWellOrderLimitElement",
    "start": [
      89,
      1
    ],
    "end": [
      92,
      78
    ],
    "traced_tactics": [
      {
        "tactic": "obtain _|a := a",
        "annotated_tactic": [
          "obtain _|a := a",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsWellOrder \u03b1 fun x x_1 => x < x_1\na\u271d : \u03b1\nha : IsWellOrderLimitElement a\u271d\na : \u2115\ninst\u271d : IsWellOrderLimitElement a\n\u22a2 False",
        "state_after": "case zero\n\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsWellOrder \u03b1 fun x x_1 => x < x_1\na : \u03b1\nha : IsWellOrderLimitElement a\ninst\u271d : IsWellOrderLimitElement 0\n\u22a2 False\n\ncase succ\n\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsWellOrder \u03b1 fun x x_1 => x < x_1\na\u271d : \u03b1\nha : IsWellOrderLimitElement a\u271d\na : \u2115\ninst\u271d : IsWellOrderLimitElement (a + 1)\n\u22a2 False"
      },
      {
        "tactic": "simpa using IsWellOrderLimitElement.neq_bot (0 : \u2115)",
        "annotated_tactic": [
          "simpa using <a>IsWellOrderLimitElement.neq_bot</a> (0 : \u2115)",
          [
            {
              "full_name": "IsWellOrderLimitElement.neq_bot",
              "def_path": "Mathlib/Order/IsWellOrderLimitElement.lean",
              "def_pos": [
                55,
                7
              ],
              "def_end_pos": [
                55,
                38
              ]
            }
          ]
        ],
        "state_before": "case zero\n\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsWellOrder \u03b1 fun x x_1 => x < x_1\na : \u03b1\nha : IsWellOrderLimitElement a\ninst\u271d : IsWellOrderLimitElement 0\n\u22a2 False",
        "state_after": "no goals"
      },
      {
        "tactic": "simpa using IsWellOrderLimitElement.wellOrderSucc_lt (Nat.lt_succ_self a)",
        "annotated_tactic": [
          "simpa using <a>IsWellOrderLimitElement.wellOrderSucc_lt</a> (<a>Nat.lt_succ_self</a> a)",
          [
            {
              "full_name": "IsWellOrderLimitElement.wellOrderSucc_lt",
              "def_path": "Mathlib/Order/IsWellOrderLimitElement.lean",
              "def_pos": [
                67,
                7
              ],
              "def_end_pos": [
                67,
                47
              ]
            },
            {
              "full_name": "Nat.lt_succ_self",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean",
              "def_pos": [
                358,
                17
              ],
              "def_end_pos": [
                358,
                29
              ]
            }
          ]
        ],
        "state_before": "case succ\n\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsWellOrder \u03b1 fun x x_1 => x < x_1\na\u271d : \u03b1\nha : IsWellOrderLimitElement a\u271d\na : \u2115\ninst\u271d : IsWellOrderLimitElement (a + 1)\n\u22a2 False",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.521950974012725,
    "entry_failed": false
  },
  "28256": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/Padics/RingHoms.lean",
    "full_name": "PadicInt.modPart_lt_p",
    "start": [
      72,
      1
    ],
    "end": [
      75,
      38
    ],
    "traced_tactics": [
      {
        "tactic": "convert Int.emod_lt _ _",
        "annotated_tactic": [
          "convert <a>Int.emod_lt</a> _ _",
          [
            {
              "full_name": "Int.emod_lt",
              "def_path": "Mathlib/Algebra/Order/Group/Int.lean",
              "def_pos": [
                115,
                9
              ],
              "def_end_pos": [
                115,
                16
              ]
            }
          ]
        ],
        "state_before": "p : \u2115\nhp_prime : Fact (Nat.Prime p)\nr : \u211a\n\u22a2 modPart p r < \u2191p",
        "state_after": "case h.e'_4\np : \u2115\nhp_prime : Fact (Nat.Prime p)\nr : \u211a\n\u22a2 \u2191p = |\u2191p|\n\ncase convert_3\np : \u2115\nhp_prime : Fact (Nat.Prime p)\nr : \u211a\n\u22a2 \u2191p \u2260 0"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case h.e'_4\np : \u2115\nhp_prime : Fact (Nat.Prime p)\nr : \u211a\n\u22a2 \u2191p = |\u2191p|",
        "state_after": "no goals"
      },
      {
        "tactic": "exact mod_cast hp_prime.1.ne_zero",
        "annotated_tactic": [
          "exact mod_cast hp_prime.1.<a>ne_zero</a>",
          [
            {
              "full_name": "Nat.Prime.ne_zero",
              "def_path": "Mathlib/Data/Nat/Prime.lean",
              "def_pos": [
                61,
                9
              ],
              "def_end_pos": [
                61,
                22
              ]
            }
          ]
        ],
        "state_before": "case convert_3\np : \u2115\nhp_prime : Fact (Nat.Prime p)\nr : \u211a\n\u22a2 \u2191p \u2260 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.053438429022208,
    "entry_failed": false
  },
  "28282": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Tropical/BigOperators.lean",
    "full_name": "untrop_prod",
    "start": [
      70,
      1
    ],
    "end": [
      74,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "convert Multiset.untrop_prod (s.val.map f)",
        "annotated_tactic": [
          "convert <a>Multiset.untrop_prod</a> (s.val.map f)",
          [
            {
              "full_name": "Multiset.untrop_prod",
              "def_path": "Mathlib/Algebra/Tropical/BigOperators.lean",
              "def_pos": [
                65,
                9
              ],
              "def_end_pos": [
                65,
                29
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\nS : Type u_2\ninst\u271d : AddCommMonoid R\ns : Finset S\nf : S \u2192 Tropical R\n\u22a2 untrop (\u220f i \u2208 s, f i) = \u2211 i \u2208 s, untrop (f i)",
        "state_after": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d : AddCommMonoid R\ns : Finset S\nf : S \u2192 Tropical R\n\u22a2 \u2211 i \u2208 s, untrop (f i) = (Multiset.map untrop (Multiset.map f s.val)).sum"
      },
      {
        "tactic": "simp only [Multiset.map_map, Function.comp_apply]",
        "annotated_tactic": [
          "simp only [<a>Multiset.map_map</a>, <a>Function.comp_apply</a>]",
          [
            {
              "full_name": "Multiset.map_map",
              "def_path": "Mathlib/Data/Multiset/Basic.lean",
              "def_pos": [
                1332,
                9
              ],
              "def_end_pos": [
                1332,
                16
              ]
            },
            {
              "full_name": "Function.comp_apply",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                35,
                17
              ],
              "def_end_pos": [
                35,
                36
              ]
            }
          ]
        ],
        "state_before": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d : AddCommMonoid R\ns : Finset S\nf : S \u2192 Tropical R\n\u22a2 \u2211 i \u2208 s, untrop (f i) = (Multiset.map untrop (Multiset.map f s.val)).sum",
        "state_after": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d : AddCommMonoid R\ns : Finset S\nf : S \u2192 Tropical R\n\u22a2 \u2211 i \u2208 s, untrop (f i) = (Multiset.map (fun i => untrop (f i)) s.val).sum"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d : AddCommMonoid R\ns : Finset S\nf : S \u2192 Tropical R\n\u22a2 \u2211 i \u2208 s, untrop (f i) = (Multiset.map (fun i => untrop (f i)) s.val).sum",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5845128899673,
    "entry_failed": false
  },
  "28436": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Nth.lean",
    "full_name": "Nat.nth_lt_of_lt_count",
    "start": [
      364,
      1
    ],
    "end": [
      367,
      50
    ],
    "traced_tactics": [
      {
        "tactic": "refine (count_monotone p).reflect_lt ?_",
        "annotated_tactic": [
          "refine (<a>count_monotone</a> p).<a>reflect_lt</a> ?_",
          [
            {
              "full_name": "Nat.count_monotone",
              "def_path": "Mathlib/Data/Nat/Count.lean",
              "def_pos": [
                70,
                9
              ],
              "def_end_pos": [
                70,
                23
              ]
            },
            {
              "full_name": "Monotone.reflect_lt",
              "def_path": "Mathlib/Order/Monotone/Basic.lean",
              "def_pos": [
                809,
                9
              ],
              "def_end_pos": [
                809,
                28
              ]
            }
          ]
        ],
        "state_before": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn k : \u2115\nh : k < count p n\n\u22a2 nth p k < n",
        "state_after": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn k : \u2115\nh : k < count p n\n\u22a2 count p (nth p k) < count p n"
      },
      {
        "tactic": "rwa [count_nth]",
        "annotated_tactic": [
          "rwa [<a>count_nth</a>]",
          [
            {
              "full_name": "Nat.count_nth",
              "def_path": "Mathlib/Data/Nat/Nth.lean",
              "def_pos": [
                336,
                9
              ],
              "def_end_pos": [
                336,
                18
              ]
            }
          ]
        ],
        "state_before": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn k : \u2115\nh : k < count p n\n\u22a2 count p (nth p k) < count p n",
        "state_after": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn k : \u2115\nh : k < count p n\n\u22a2 \u2200 (hf : (setOf p).Finite), k < hf.toFinset.card"
      },
      {
        "tactic": "exact fun hf => h.trans_le (count_le_card hf n)",
        "annotated_tactic": [
          "exact fun hf => h.trans_le (<a>count_le_card</a> hf n)",
          [
            {
              "full_name": "Nat.count_le_card",
              "def_path": "Mathlib/Data/Nat/Count.lean",
              "def_pos": [
                140,
                9
              ],
              "def_end_pos": [
                140,
                22
              ]
            }
          ]
        ],
        "state_before": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn k : \u2115\nh : k < count p n\n\u22a2 \u2200 (hf : (setOf p).Finite), k < hf.toFinset.card",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.43641438591294,
    "entry_failed": false
  },
  "28466": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/MetricSpace/Infsep.lean",
    "full_name": "Set.Nontrivial.infsep_lt_iff",
    "start": [
      393,
      1
    ],
    "end": [
      397,
      25
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 not_iff_not]",
        "annotated_tactic": [
          "rw [\u2190 <a>not_iff_not</a>]",
          [
            {
              "full_name": "not_iff_not",
              "def_path": "Mathlib/Logic/Basic.lean",
              "def_pos": [
                447,
                9
              ],
              "def_end_pos": [
                447,
                20
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nd : \u211d\nhs : s.Nontrivial\n\u22a2 s.infsep < d \u2194 \u2203 x \u2208 s, \u2203 y \u2208 s, x \u2260 y \u2227 dist x y < d",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nd : \u211d\nhs : s.Nontrivial\n\u22a2 \u00acs.infsep < d \u2194 \u00ac\u2203 x \u2208 s, \u2203 y \u2208 s, x \u2260 y \u2227 dist x y < d"
      },
      {
        "tactic": "push_neg",
        "annotated_tactic": [
          "push_neg",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nd : \u211d\nhs : s.Nontrivial\n\u22a2 \u00acs.infsep < d \u2194 \u00ac\u2203 x \u2208 s, \u2203 y \u2208 s, x \u2260 y \u2227 dist x y < d",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nd : \u211d\nhs : s.Nontrivial\n\u22a2 d \u2264 s.infsep \u2194 \u2200 x \u2208 s, \u2200 y \u2208 s, x \u2260 y \u2192 d \u2264 dist x y"
      },
      {
        "tactic": "exact hs.le_infsep_iff",
        "annotated_tactic": [
          "exact hs.le_infsep_iff",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\nd : \u211d\nhs : s.Nontrivial\n\u22a2 d \u2264 s.infsep \u2194 \u2200 x \u2208 s, \u2200 y \u2208 s, x \u2260 y \u2192 d \u2264 dist x y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.6495224749669433,
    "entry_failed": false
  },
  "28499": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Matroid/Constructions.lean",
    "full_name": "Matroid.ground_eq_empty_iff",
    "start": [
      57,
      1
    ],
    "end": [
      59,
      46
    ],
    "traced_tactics": [
      {
        "tactic": "simp only [emptyOn, eq_iff_indep_iff_indep_forall, iff_self_and]",
        "annotated_tactic": [
          "simp only [<a>emptyOn</a>, <a>eq_iff_indep_iff_indep_forall</a>, <a>iff_self_and</a>]",
          [
            {
              "full_name": "Matroid.emptyOn",
              "def_path": "Mathlib/Data/Matroid/Constructions.lean",
              "def_pos": [
                41,
                5
              ],
              "def_end_pos": [
                41,
                12
              ]
            },
            {
              "full_name": "Matroid.eq_iff_indep_iff_indep_forall",
              "def_path": "Mathlib/Data/Matroid/Basic.lean",
              "def_pos": [
                659,
                9
              ],
              "def_end_pos": [
                659,
                38
              ]
            },
            {
              "full_name": "iff_self_and",
              "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean",
              "def_pos": [
                167,
                17
              ],
              "def_end_pos": [
                167,
                29
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nM : Matroid \u03b1\nE B I X R J : Set \u03b1\n\u22a2 M.E = \u2205 \u2194 M = emptyOn \u03b1",
        "state_after": "\u03b1 : Type u_1\nM : Matroid \u03b1\nE B I X R J : Set \u03b1\n\u22a2 M.E = \u2205 \u2192 \u2200 I \u2286 M.E, M.Indep I \u2194 I = \u2205"
      },
      {
        "tactic": "exact fun h \u21a6 by simp [h, subset_empty_iff]",
        "annotated_tactic": [
          "exact fun h \u21a6 by simp [h, <a>subset_empty_iff</a>]",
          [
            {
              "full_name": "Set.subset_empty_iff",
              "def_path": "Mathlib/Data/Set/Basic.lean",
              "def_pos": [
                548,
                9
              ],
              "def_end_pos": [
                548,
                25
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nM : Matroid \u03b1\nE B I X R J : Set \u03b1\n\u22a2 M.E = \u2205 \u2192 \u2200 I \u2286 M.E, M.Indep I \u2194 I = \u2205",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [h, subset_empty_iff]",
        "annotated_tactic": [
          "simp [h, <a>subset_empty_iff</a>]",
          [
            {
              "full_name": "Set.subset_empty_iff",
              "def_path": "Mathlib/Data/Set/Basic.lean",
              "def_pos": [
                548,
                9
              ],
              "def_end_pos": [
                548,
                25
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nM : Matroid \u03b1\nE B I X R J : Set \u03b1\nh : M.E = \u2205\n\u22a2 \u2200 I \u2286 M.E, M.Indep I \u2194 I = \u2205",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4863619720563293,
    "entry_failed": false
  },
  "28558": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/ZMod/Basic.lean",
    "full_name": "Prod.fst_zmod_cast",
    "start": [
      192,
      1
    ],
    "end": [
      195,
      21
    ],
    "traced_tactics": [
      {
        "tactic": "cases n",
        "annotated_tactic": [
          "cases n",
          []
        ],
        "state_before": "n : \u2115\nR : Type u_1\ninst\u271d\u00b9 : AddGroupWithOne R\nS : Type u_2\ninst\u271d : AddGroupWithOne S\na : ZMod n\n\u22a2 a.cast.1 = a.cast",
        "state_after": "case zero\nR : Type u_1\ninst\u271d\u00b9 : AddGroupWithOne R\nS : Type u_2\ninst\u271d : AddGroupWithOne S\na : ZMod 0\n\u22a2 a.cast.1 = a.cast\n\ncase succ\nR : Type u_1\ninst\u271d\u00b9 : AddGroupWithOne R\nS : Type u_2\ninst\u271d : AddGroupWithOne S\nn\u271d : \u2115\na : ZMod (n\u271d + 1)\n\u22a2 a.cast.1 = a.cast"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case zero\nR : Type u_1\ninst\u271d\u00b9 : AddGroupWithOne R\nS : Type u_2\ninst\u271d : AddGroupWithOne S\na : ZMod 0\n\u22a2 a.cast.1 = a.cast",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [ZMod.cast]",
        "annotated_tactic": [
          "simp [<a>ZMod.cast</a>]",
          [
            {
              "full_name": "ZMod.cast",
              "def_path": "Mathlib/Data/ZMod/Basic.lean",
              "def_pos": [
                169,
                5
              ],
              "def_end_pos": [
                169,
                9
              ]
            }
          ]
        ],
        "state_before": "case succ\nR : Type u_1\ninst\u271d\u00b9 : AddGroupWithOne R\nS : Type u_2\ninst\u271d : AddGroupWithOne S\nn\u271d : \u2115\na : ZMod (n\u271d + 1)\n\u22a2 a.cast.1 = a.cast",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.7307038130238652,
    "entry_failed": false
  },
  "28596": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/Sites/IsSheafFor.lean",
    "full_name": "CategoryTheory.Presieve.isSheafFor_top_sieve",
    "start": [
      654,
      1
    ],
    "end": [
      657,
      33
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 generate_of_singleton_isSplitEpi (\ud835\udfd9 X)]",
        "annotated_tactic": [
          "rw [\u2190 <a>generate_of_singleton_isSplitEpi</a> (\ud835\udfd9 X)]",
          [
            {
              "full_name": "CategoryTheory.Sieve.generate_of_singleton_isSplitEpi",
              "def_path": "Mathlib/CategoryTheory/Sites/Sieves.lean",
              "def_pos": [
                456,
                9
              ],
              "def_end_pos": [
                456,
                41
              ]
            }
          ]
        ],
        "state_before": "C : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nP\u271d Q U : C\u1d52\u1d56 \u2964 Type w\nX Y : C\nS : Sieve X\nR : Presieve X\nP : C\u1d52\u1d56 \u2964 Type w\n\u22a2 IsSheafFor P \u22a4.arrows",
        "state_after": "C : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nP\u271d Q U : C\u1d52\u1d56 \u2964 Type w\nX Y : C\nS : Sieve X\nR : Presieve X\nP : C\u1d52\u1d56 \u2964 Type w\n\u22a2 IsSheafFor P (generate (singleton (\ud835\udfd9 X))).arrows"
      },
      {
        "tactic": "rw [\u2190 isSheafFor_iff_generate]",
        "annotated_tactic": [
          "rw [\u2190 <a>isSheafFor_iff_generate</a>]",
          [
            {
              "full_name": "CategoryTheory.Presieve.isSheafFor_iff_generate",
              "def_path": "Mathlib/CategoryTheory/Sites/IsSheafFor.lean",
              "def_pos": [
                620,
                9
              ],
              "def_end_pos": [
                620,
                32
              ]
            }
          ]
        ],
        "state_before": "C : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nP\u271d Q U : C\u1d52\u1d56 \u2964 Type w\nX Y : C\nS : Sieve X\nR : Presieve X\nP : C\u1d52\u1d56 \u2964 Type w\n\u22a2 IsSheafFor P (generate (singleton (\ud835\udfd9 X))).arrows",
        "state_after": "C : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nP\u271d Q U : C\u1d52\u1d56 \u2964 Type w\nX Y : C\nS : Sieve X\nR : Presieve X\nP : C\u1d52\u1d56 \u2964 Type w\n\u22a2 IsSheafFor P (singleton (\ud835\udfd9 X))"
      },
      {
        "tactic": "apply isSheafFor_singleton_iso",
        "annotated_tactic": [
          "apply <a>isSheafFor_singleton_iso</a>",
          [
            {
              "full_name": "CategoryTheory.Presieve.isSheafFor_singleton_iso",
              "def_path": "Mathlib/CategoryTheory/Sites/IsSheafFor.lean",
              "def_pos": [
                641,
                9
              ],
              "def_end_pos": [
                641,
                33
              ]
            }
          ]
        ],
        "state_before": "C : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nP\u271d Q U : C\u1d52\u1d56 \u2964 Type w\nX Y : C\nS : Sieve X\nR : Presieve X\nP : C\u1d52\u1d56 \u2964 Type w\n\u22a2 IsSheafFor P (singleton (\ud835\udfd9 X))",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.113223718944937,
    "entry_failed": false
  },
  "28723": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Ordinal/NaturalOps.lean",
    "full_name": "Ordinal.nadd_le_nadd_right",
    "start": [
      259,
      1
    ],
    "end": [
      262,
      17
    ],
    "traced_tactics": [
      {
        "tactic": "rcases lt_or_eq_of_le h with (h | rfl)",
        "annotated_tactic": [
          "rcases <a>lt_or_eq_of_le</a> h with (h | rfl)",
          [
            {
              "full_name": "lt_or_eq_of_le",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                230,
                9
              ],
              "def_end_pos": [
                230,
                23
              ]
            }
          ]
        ],
        "state_before": "a\u271d b c : Ordinal.{u}\nh : b \u2264 c\na : Ordinal.{u}\n\u22a2 b \u266f a \u2264 c \u266f a",
        "state_after": "case inl\na\u271d b c : Ordinal.{u}\nh\u271d : b \u2264 c\na : Ordinal.{u}\nh : b < c\n\u22a2 b \u266f a \u2264 c \u266f a\n\ncase inr\na\u271d b a : Ordinal.{u}\nh : b \u2264 b\n\u22a2 b \u266f a \u2264 b \u266f a"
      },
      {
        "tactic": "exact (nadd_lt_nadd_right h a).le",
        "annotated_tactic": [
          "exact (<a>nadd_lt_nadd_right</a> h a).<a>le</a>",
          [
            {
              "full_name": "Ordinal.nadd_lt_nadd_right",
              "def_path": "Mathlib/SetTheory/Ordinal/NaturalOps.lean",
              "def_pos": [
                249,
                9
              ],
              "def_end_pos": [
                249,
                27
              ]
            },
            {
              "full_name": "LT.lt.le",
              "def_path": "Mathlib/Order/Basic.lean",
              "def_pos": [
                137,
                7
              ],
              "def_end_pos": [
                137,
                15
              ]
            }
          ]
        ],
        "state_before": "case inl\na\u271d b c : Ordinal.{u}\nh\u271d : b \u2264 c\na : Ordinal.{u}\nh : b < c\n\u22a2 b \u266f a \u2264 c \u266f a",
        "state_after": "no goals"
      },
      {
        "tactic": "exact le_rfl",
        "annotated_tactic": [
          "exact <a>le_rfl</a>",
          [
            {
              "full_name": "le_rfl",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                50,
                9
              ],
              "def_end_pos": [
                50,
                15
              ]
            }
          ]
        ],
        "state_before": "case inr\na\u271d b a : Ordinal.{u}\nh : b \u2264 b\n\u22a2 b \u266f a \u2264 b \u266f a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.028483083937317,
    "entry_failed": false
  },
  "20953": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Subgroup/Center.lean",
    "full_name": "IsConj.eq_of_left_mem_center",
    "start": [
      131,
      1
    ],
    "end": [
      132,
      59
    ],
    "traced_tactics": [
      {
        "tactic": "rcases H with \u27e8u, hu\u27e9",
        "annotated_tactic": [
          "rcases H with \u27e8u, hu\u27e9",
          []
        ],
        "state_before": "G : Type u_1\ninst\u271d\u00b9 : Group G\nM : Type u_2\ninst\u271d : Monoid M\ng h : M\nH : IsConj g h\nHg : g \u2208 Set.center M\n\u22a2 g = h",
        "state_after": "case intro\nG : Type u_1\ninst\u271d\u00b9 : Group G\nM : Type u_2\ninst\u271d : Monoid M\ng h : M\nHg : g \u2208 Set.center M\nu : M\u02e3\nhu : SemiconjBy (\u2191u) g h\n\u22a2 g = h"
      },
      {
        "tactic": "rwa [\u2190 u.mul_left_inj, Hg.comm u]",
        "annotated_tactic": [
          "rwa [\u2190 u.mul_left_inj, Hg.comm u]",
          []
        ],
        "state_before": "case intro\nG : Type u_1\ninst\u271d\u00b9 : Group G\nM : Type u_2\ninst\u271d : Monoid M\ng h : M\nHg : g \u2208 Set.center M\nu : M\u02e3\nhu : SemiconjBy (\u2191u) g h\n\u22a2 g = h",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6740428860066459,
    "entry_failed": false
  },
  "26798": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Polynomial/Monic.lean",
    "full_name": "Polynomial.Monic.natDegree_mul'",
    "start": [
      190,
      8
    ],
    "end": [
      193,
      48
    ],
    "traced_tactics": [
      {
        "tactic": "rw [natDegree_mul']",
        "annotated_tactic": [
          "rw [<a>natDegree_mul'</a>]",
          [
            {
              "full_name": "Polynomial.natDegree_mul'",
              "def_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
              "def_pos": [
                1012,
                9
              ],
              "def_end_pos": [
                1012,
                23
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : p.Monic\nhq : q \u2260 0\n\u22a2 (p * q).natDegree = p.natDegree + q.natDegree",
        "state_after": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : p.Monic\nhq : q \u2260 0\n\u22a2 p.leadingCoeff * q.leadingCoeff \u2260 0"
      },
      {
        "tactic": "simpa [hp.leadingCoeff, leadingCoeff_ne_zero]",
        "annotated_tactic": [
          "simpa [hp.leadingCoeff, <a>leadingCoeff_ne_zero</a>]",
          [
            {
              "full_name": "Polynomial.leadingCoeff_ne_zero",
              "def_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
              "def_pos": [
                695,
                9
              ],
              "def_end_pos": [
                695,
                29
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\na b : R\nm n : \u2115\n\u03b9 : Type y\ninst\u271d : Semiring R\np q r : R[X]\nhp : p.Monic\nhq : q \u2260 0\n\u22a2 p.leadingCoeff * q.leadingCoeff \u2260 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.946384168113582,
    "entry_failed": false
  },
  "3745": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/Asymptotics/AsymptoticEquivalent.lean",
    "full_name": "Asymptotics.isEquivalent_zero_iff_eventually_zero",
    "start": [
      128,
      1
    ],
    "end": [
      130,
      33
    ],
    "traced_tactics": [
      {
        "tactic": "rw [IsEquivalent, sub_zero]",
        "annotated_tactic": [
          "rw [<a>IsEquivalent</a>, <a>sub_zero</a>]",
          [
            {
              "full_name": "Asymptotics.IsEquivalent",
              "def_path": "Mathlib/Analysis/Asymptotics/AsymptoticEquivalent.lean",
              "def_pos": [
                73,
                5
              ],
              "def_end_pos": [
                73,
                17
              ]
            },
            {
              "full_name": "sub_zero",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                489,
                3
              ],
              "def_end_pos": [
                489,
                14
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : NormedAddCommGroup \u03b2\nu v w : \u03b1 \u2192 \u03b2\nl : Filter \u03b1\n\u22a2 u ~[l] 0 \u2194 u =\u1da0[l] 0",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : NormedAddCommGroup \u03b2\nu v w : \u03b1 \u2192 \u03b2\nl : Filter \u03b1\n\u22a2 u =o[l] 0 \u2194 u =\u1da0[l] 0"
      },
      {
        "tactic": "exact isLittleO_zero_right_iff",
        "annotated_tactic": [
          "exact <a>isLittleO_zero_right_iff</a>",
          [
            {
              "full_name": "Asymptotics.isLittleO_zero_right_iff",
              "def_path": "Mathlib/Analysis/Asymptotics/Asymptotics.lean",
              "def_pos": [
                1270,
                9
              ],
              "def_end_pos": [
                1270,
                33
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : NormedAddCommGroup \u03b2\nu v w : \u03b1 \u2192 \u03b2\nl : Filter \u03b1\n\u22a2 u =o[l] 0 \u2194 u =\u1da0[l] 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.2429246139945462,
    "entry_failed": false
  },
  "11278": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Irreducible.lean",
    "full_name": "SupIrred.ne_bot",
    "start": [
      104,
      1
    ],
    "end": [
      104,
      94
    ],
    "traced_tactics": [
      {
        "tactic": "rintro rfl",
        "annotated_tactic": [
          "rintro rfl",
          []
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : SemilatticeSup \u03b1\na b c : \u03b1\ninst\u271d : OrderBot \u03b1\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nha : SupIrred a\n\u22a2 a \u2260 \u22a5",
        "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : SemilatticeSup \u03b1\nb c : \u03b1\ninst\u271d : OrderBot \u03b1\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nha : SupIrred \u22a5\n\u22a2 False"
      },
      {
        "tactic": "exact not_supIrred_bot ha",
        "annotated_tactic": [
          "exact <a>not_supIrred_bot</a> ha",
          [
            {
              "full_name": "not_supIrred_bot",
              "def_path": "Mathlib/Order/Irreducible.lean",
              "def_pos": [
                95,
                9
              ],
              "def_end_pos": [
                95,
                25
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : SemilatticeSup \u03b1\nb c : \u03b1\ninst\u271d : OrderBot \u03b1\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nha : SupIrred \u22a5\n\u22a2 False",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6199014709563926,
    "entry_failed": false
  },
  "15293": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/Constructions/Polish.lean",
    "full_name": "MeasureTheory.analyticSet_empty",
    "start": [
      169,
      1
    ],
    "end": [
      171,
      19
    ],
    "traced_tactics": [
      {
        "tactic": "rw [AnalyticSet]",
        "annotated_tactic": [
          "rw [<a>AnalyticSet</a>]",
          [
            {
              "full_name": "MeasureTheory.AnalyticSet",
              "def_path": "Mathlib/MeasureTheory/Constructions/Polish.lean",
              "def_pos": [
                165,
                17
              ],
              "def_end_pos": [
                165,
                28
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 AnalyticSet \u2205",
        "state_after": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 \u2205 = \u2205 \u2228 \u2203 f, Continuous f \u2227 range f = \u2205"
      },
      {
        "tactic": "exact Or.inl rfl",
        "annotated_tactic": [
          "exact <a>Or.inl</a> <a>rfl</a>",
          [
            {
              "full_name": "Or.inl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                534,
                5
              ],
              "def_end_pos": [
                534,
                8
              ]
            },
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 \u2205 = \u2205 \u2228 \u2203 f, Continuous f \u2227 range f = \u2205",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.976014547981322,
    "entry_failed": false
  },
  "16899": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Intervals.lean",
    "full_name": "List.Ico.succ_singleton",
    "start": [
      120,
      1
    ],
    "end": [
      122,
      41
    ],
    "traced_tactics": [
      {
        "tactic": "dsimp [Ico]",
        "annotated_tactic": [
          "dsimp [<a>Ico</a>]",
          [
            {
              "full_name": "List.Ico",
              "def_path": "Mathlib/Data/List/Intervals.lean",
              "def_pos": [
                36,
                5
              ],
              "def_end_pos": [
                36,
                8
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\n\u22a2 Ico n (n + 1) = [n]",
        "state_after": "n : \u2115\n\u22a2 range' n (n + 1 - n) = [n]"
      },
      {
        "tactic": "simp [range', Nat.add_sub_cancel_left]",
        "annotated_tactic": [
          "simp [<a>range'</a>, <a>Nat.add_sub_cancel_left</a>]",
          [
            {
              "full_name": "List.range'",
              "def_path": ".lake/packages/batteries/Batteries/Data/List/Basic.lean",
              "def_pos": [
                899,
                5
              ],
              "def_end_pos": [
                899,
                11
              ]
            },
            {
              "full_name": "Nat.add_sub_cancel_left",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean",
              "def_pos": [
                908,
                19
              ],
              "def_end_pos": [
                908,
                38
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\n\u22a2 range' n (n + 1 - n) = [n]",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4234561109915376,
    "entry_failed": false
  },
  "11589": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Nilpotent/Basic.lean",
    "full_name": "IsNilpotent.isUnit_add_one",
    "start": [
      68,
      1
    ],
    "end": [
      70,
      32
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 IsUnit.neg_iff, neg_add']",
        "annotated_tactic": [
          "rw [\u2190 <a>IsUnit.neg_iff</a>, <a>neg_add'</a>]",
          [
            {
              "full_name": "IsUnit.neg_iff",
              "def_path": "Mathlib/Algebra/Ring/Units.lean",
              "def_pos": [
                110,
                9
              ],
              "def_end_pos": [
                110,
                23
              ]
            },
            {
              "full_name": "neg_add'",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                745,
                3
              ],
              "def_end_pos": [
                745,
                14
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\nS : Type u_2\nx y : R\ninst\u271d : Ring R\nr : R\nhnil : IsNilpotent r\n\u22a2 IsUnit (r + 1)",
        "state_after": "R : Type u_1\nS : Type u_2\nx y : R\ninst\u271d : Ring R\nr : R\nhnil : IsNilpotent r\n\u22a2 IsUnit (-r - 1)"
      },
      {
        "tactic": "exact isUnit_sub_one hnil.neg",
        "annotated_tactic": [
          "exact <a>isUnit_sub_one</a> hnil.neg",
          [
            {
              "full_name": "IsNilpotent.isUnit_sub_one",
              "def_path": "Mathlib/RingTheory/Nilpotent/Basic.lean",
              "def_pos": [
                58,
                9
              ],
              "def_end_pos": [
                58,
                35
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\nS : Type u_2\nx y : R\ninst\u271d : Ring R\nr : R\nhnil : IsNilpotent r\n\u22a2 IsUnit (-r - 1)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6724430840695277,
    "entry_failed": false
  },
  "10070": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/Basic.lean",
    "full_name": "InnerProductGeometry.cos_angle_mul_norm_mul_norm",
    "start": [
      183,
      1
    ],
    "end": [
      185,
      51
    ],
    "traced_tactics": [
      {
        "tactic": "rw [cos_angle, div_mul_cancel_of_imp]",
        "annotated_tactic": [
          "rw [<a>cos_angle</a>, <a>div_mul_cancel_of_imp</a>]",
          [
            {
              "full_name": "InnerProductGeometry.cos_angle",
              "def_path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/Basic.lean",
              "def_pos": [
                77,
                9
              ],
              "def_end_pos": [
                77,
                18
              ]
            },
            {
              "full_name": "div_mul_cancel_of_imp",
              "def_path": "Mathlib/Algebra/GroupWithZero/Units/Basic.lean",
              "def_pos": [
                400,
                7
              ],
              "def_end_pos": [
                400,
                28
              ]
            }
          ]
        ],
        "state_before": "V : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : InnerProductSpace \u211d V\nx\u271d y\u271d x y : V\n\u22a2 cos (angle x y) * (\u2016x\u2016 * \u2016y\u2016) = \u27eax, y\u27eb_\u211d",
        "state_after": "V : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : InnerProductSpace \u211d V\nx\u271d y\u271d x y : V\n\u22a2 \u2016x\u2016 * \u2016y\u2016 = 0 \u2192 \u27eax, y\u27eb_\u211d = 0"
      },
      {
        "tactic": "simp (config := { contextual := true }) [or_imp]",
        "annotated_tactic": [
          "simp (config := { contextual := <a>true</a> }) [<a>or_imp</a>]",
          [
            {
              "full_name": "Bool.true",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                571,
                5
              ],
              "def_end_pos": [
                571,
                9
              ]
            },
            {
              "full_name": "or_imp",
              "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean",
              "def_pos": [
                120,
                9
              ],
              "def_end_pos": [
                120,
                15
              ]
            }
          ]
        ],
        "state_before": "V : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : InnerProductSpace \u211d V\nx\u271d y\u271d x y : V\n\u22a2 \u2016x\u2016 * \u2016y\u2016 = 0 \u2192 \u27eax, y\u27eb_\u211d = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.4520689588971436,
    "entry_failed": false
  },
  "26751": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Interval/Finset.lean",
    "full_name": "Finset.map_add_right_Ioc",
    "start": [
      54,
      1
    ],
    "end": [
      57,
      38
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 coe_inj, coe_map, coe_Ioc, coe_Ioc]",
        "annotated_tactic": [
          "rw [\u2190 <a>coe_inj</a>, <a>coe_map</a>, <a>coe_Ioc</a>, <a>coe_Ioc</a>]",
          [
            {
              "full_name": "Finset.coe_inj",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                244,
                9
              ],
              "def_end_pos": [
                244,
                16
              ]
            },
            {
              "full_name": "Finset.coe_map",
              "def_path": "Mathlib/Data/Finset/Image.lean",
              "def_pos": [
                114,
                9
              ],
              "def_end_pos": [
                114,
                16
              ]
            },
            {
              "full_name": "Finset.coe_Ioc",
              "def_path": "Mathlib/Order/Interval/Finset/Defs.lean",
              "def_pos": [
                343,
                9
              ],
              "def_end_pos": [
                343,
                16
              ]
            },
            {
              "full_name": "Finset.coe_Ioc",
              "def_path": "Mathlib/Order/Interval/Finset/Defs.lean",
              "def_pos": [
                343,
                9
              ],
              "def_end_pos": [
                343,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : OrderedCancelAddCommMonoid \u03b1\ninst\u271d\u00b9 : ExistsAddOfLE \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\na b c : \u03b1\n\u22a2 map (addRightEmbedding c) (Ioc a b) = Ioc (a + c) (b + c)",
        "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : OrderedCancelAddCommMonoid \u03b1\ninst\u271d\u00b9 : ExistsAddOfLE \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\na b c : \u03b1\n\u22a2 \u21d1(addRightEmbedding c) '' Set.Ioc a b = Set.Ioc (a + c) (b + c)"
      },
      {
        "tactic": "exact Set.image_add_const_Ioc _ _ _",
        "annotated_tactic": [
          "exact <a>Set.image_add_const_Ioc</a> _ _ _",
          [
            {
              "full_name": "Set.image_add_const_Ioc",
              "def_path": "Mathlib/Algebra/Order/Interval/Set/Monoid.lean",
              "def_pos": [
                98,
                9
              ],
              "def_end_pos": [
                98,
                28
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : OrderedCancelAddCommMonoid \u03b1\ninst\u271d\u00b9 : ExistsAddOfLE \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\na b c : \u03b1\n\u22a2 \u21d1(addRightEmbedding c) '' Set.Ioc a b = Set.Ioc (a + c) (b + c)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5113229339476675,
    "entry_failed": false
  },
  "14852": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Interval/Finset/Nat.lean",
    "full_name": "Nat.Icc_pred_right",
    "start": [
      163,
      1
    ],
    "end": [
      165,
      42
    ],
    "traced_tactics": [
      {
        "tactic": "ext x",
        "annotated_tactic": [
          "ext x",
          []
        ],
        "state_before": "a b\u271d c b : \u2115\nh : 0 < b\n\u22a2 Icc a (b - 1) = Ico a b",
        "state_after": "case a\na b\u271d c b : \u2115\nh : 0 < b\nx : \u2115\n\u22a2 x \u2208 Icc a (b - 1) \u2194 x \u2208 Ico a b"
      },
      {
        "tactic": "rw [mem_Icc, mem_Ico, lt_iff_le_pred h]",
        "annotated_tactic": [
          "rw [<a>mem_Icc</a>, <a>mem_Ico</a>, <a>lt_iff_le_pred</a> h]",
          [
            {
              "full_name": "Finset.mem_Icc",
              "def_path": "Mathlib/Order/Interval/Finset/Defs.lean",
              "def_pos": [
                313,
                9
              ],
              "def_end_pos": [
                313,
                16
              ]
            },
            {
              "full_name": "Finset.mem_Ico",
              "def_path": "Mathlib/Order/Interval/Finset/Defs.lean",
              "def_pos": [
                318,
                9
              ],
              "def_end_pos": [
                318,
                16
              ]
            },
            {
              "full_name": "Nat.lt_iff_le_pred",
              "def_path": "Mathlib/Data/Nat/Defs.lean",
              "def_pos": [
                144,
                7
              ],
              "def_end_pos": [
                144,
                21
              ]
            }
          ]
        ],
        "state_before": "case a\na b\u271d c b : \u2115\nh : 0 < b\nx : \u2115\n\u22a2 x \u2208 Icc a (b - 1) \u2194 x \u2208 Ico a b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.4376354140695184,
    "entry_failed": false
  },
  "27568": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/EqToHom.lean",
    "full_name": "CategoryTheory.eqToHom_map",
    "start": [
      301,
      1
    ],
    "end": [
      302,
      72
    ],
    "traced_tactics": [
      {
        "tactic": "cases p",
        "annotated_tactic": [
          "cases p",
          []
        ],
        "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\n\u03b2 : Sort u_1\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nX Y : C\np : X = Y\n\u22a2 F.map (eqToHom p) = eqToHom \u22ef",
        "state_after": "case refl\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\n\u03b2 : Sort u_1\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nX : C\n\u22a2 F.map (eqToHom \u22ef) = eqToHom \u22ef"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case refl\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\n\u03b2 : Sort u_1\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nF : C \u2964 D\nX : C\n\u22a2 F.map (eqToHom \u22ef) = eqToHom \u22ef",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.1605428130133078,
    "entry_failed": false
  },
  "19038": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Ring/Divisibility/Basic.lean",
    "full_name": "dvd_add_right",
    "start": [
      129,
      1
    ],
    "end": [
      129,
      96
    ],
    "traced_tactics": [
      {
        "tactic": "rw [add_comm]",
        "annotated_tactic": [
          "rw [<a>add_comm</a>]",
          [
            {
              "full_name": "add_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                331,
                3
              ],
              "def_end_pos": [
                331,
                14
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : NonUnitalRing \u03b1\na b c : \u03b1\nh : a \u2223 b\n\u22a2 a \u2223 b + c \u2194 a \u2223 c",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : NonUnitalRing \u03b1\na b c : \u03b1\nh : a \u2223 b\n\u22a2 a \u2223 c + b \u2194 a \u2223 c"
      },
      {
        "tactic": "exact dvd_add_left h",
        "annotated_tactic": [
          "exact <a>dvd_add_left</a> h",
          [
            {
              "full_name": "dvd_add_left",
              "def_path": "Mathlib/Algebra/Ring/Divisibility/Basic.lean",
              "def_pos": [
                123,
                9
              ],
              "def_end_pos": [
                123,
                21
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : NonUnitalRing \u03b1\na b c : \u03b1\nh : a \u2223 b\n\u22a2 a \u2223 c + b \u2194 a \u2223 c",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8124984939349815,
    "entry_failed": false
  },
  "14135": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": ".lake/packages/batteries/Batteries/Data/RBMap/Lemmas.lean",
    "full_name": "Batteries.RBNode.All.lowerBound?_lb",
    "start": [
      442,
      1
    ],
    "end": [
      445,
      48
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 reverse_reverse t, lowerBound?_reverse]",
        "annotated_tactic": [
          "rw [\u2190 <a>reverse_reverse</a> t, <a>lowerBound?_reverse</a>]",
          [
            {
              "full_name": "Batteries.RBNode.reverse_reverse",
              "def_path": ".lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
              "def_pos": [
                48,
                17
              ],
              "def_end_pos": [
                48,
                32
              ]
            },
            {
              "full_name": "Batteries.RBNode.lowerBound?_reverse",
              "def_path": ".lake/packages/batteries/Batteries/Data/RBMap/Lemmas.lean",
              "def_pos": [
                386,
                17
              ],
              "def_end_pos": [
                386,
                36
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\nlb : Option \u03b1\ncut : \u03b1 \u2192 Ordering\nx : \u03b1\nt : RBNode \u03b1\nhp : All p t\nH : \u2200 {x : \u03b1}, lb = some x \u2192 p x\n\u22a2 lowerBound? cut t lb = some x \u2192 p x",
        "state_after": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\nlb : Option \u03b1\ncut : \u03b1 \u2192 Ordering\nx : \u03b1\nt : RBNode \u03b1\nhp : All p t\nH : \u2200 {x : \u03b1}, lb = some x \u2192 p x\n\u22a2 RBNode.upperBound? (fun x => (cut x).swap) t.reverse lb = some x \u2192 p x"
      },
      {
        "tactic": "exact All.upperBound?_ub (All.reverse.2 hp) H",
        "annotated_tactic": [
          "exact <a>All.upperBound?_ub</a> (<a>All.reverse</a>.2 hp) H",
          [
            {
              "full_name": "Batteries.RBNode.All.upperBound?_ub",
              "def_path": ".lake/packages/batteries/Batteries/Data/RBMap/Lemmas.lean",
              "def_pos": [
                429,
                9
              ],
              "def_end_pos": [
                429,
                27
              ]
            },
            {
              "full_name": "Batteries.RBNode.All.reverse",
              "def_path": ".lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
              "def_pos": [
                64,
                17
              ],
              "def_end_pos": [
                64,
                28
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\nlb : Option \u03b1\ncut : \u03b1 \u2192 Ordering\nx : \u03b1\nt : RBNode \u03b1\nhp : All p t\nH : \u2200 {x : \u03b1}, lb = some x \u2192 p x\n\u22a2 RBNode.upperBound? (fun x => (cut x).swap) t.reverse lb = some x \u2192 p x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.790474761975929,
    "entry_failed": false
  },
  "11892": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/SetSemiring.lean",
    "full_name": "MeasureTheory.IsSetSemiring.disjoint_sUnion_diffFinset\u2080",
    "start": [
      239,
      1
    ],
    "end": [
      241,
      78
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 hC.diff_sUnion_eq_sUnion_diffFinset\u2080]",
        "annotated_tactic": [
          "rw [\u2190 hC.diff_sUnion_eq_sUnion_diffFinset\u2080]",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nC : Set (Set \u03b1)\ns t : Set \u03b1\nI : Finset (Set \u03b1)\nhC : IsSetSemiring C\nhs : s \u2208 C\nhI : \u2191I \u2286 C\n\u22a2 Disjoint (\u22c3\u2080 \u2191I) (\u22c3\u2080 \u2191(hC.diffFinset\u2080 hs hI))",
        "state_after": "\u03b1 : Type u_1\nC : Set (Set \u03b1)\ns t : Set \u03b1\nI : Finset (Set \u03b1)\nhC : IsSetSemiring C\nhs : s \u2208 C\nhI : \u2191I \u2286 C\n\u22a2 Disjoint (\u22c3\u2080 \u2191I) (s \\ \u22c3\u2080 \u2191I)"
      },
      {
        "tactic": "exact Set.disjoint_sdiff_right",
        "annotated_tactic": [
          "exact <a>Set.disjoint_sdiff_right</a>",
          [
            {
              "full_name": "Set.disjoint_sdiff_right",
              "def_path": "Mathlib/Data/Set/Basic.lean",
              "def_pos": [
                1553,
                7
              ],
              "def_end_pos": [
                1553,
                27
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nC : Set (Set \u03b1)\ns t : Set \u03b1\nI : Finset (Set \u03b1)\nhC : IsSetSemiring C\nhs : s \u2208 C\nhI : \u2191I \u2286 C\n\u22a2 Disjoint (\u22c3\u2080 \u2191I) (s \\ \u22c3\u2080 \u2191I)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.2658269749954343,
    "entry_failed": false
  },
  "11361": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/FintypeCat.lean",
    "full_name": "FintypeCat.hom_ext",
    "start": [
      96,
      1
    ],
    "end": [
      99,
      10
    ],
    "traced_tactics": [
      {
        "tactic": "funext",
        "annotated_tactic": [
          "funext",
          []
        ],
        "state_before": "X Y : FintypeCat\nf g : X \u27f6 Y\nh : \u2200 (x : \u2191X), f x = g x\n\u22a2 f = g",
        "state_after": "case h\nX Y : FintypeCat\nf g : X \u27f6 Y\nh : \u2200 (x : \u2191X), f x = g x\nx\u271d : \u2191X\n\u22a2 f x\u271d = g x\u271d"
      },
      {
        "tactic": "apply h",
        "annotated_tactic": [
          "apply h",
          []
        ],
        "state_before": "case h\nX Y : FintypeCat\nf g : X \u27f6 Y\nh : \u2200 (x : \u2191X), f x = g x\nx\u271d : \u2191X\n\u22a2 f x\u271d = g x\u271d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2543795380042866,
    "entry_failed": false
  },
  "22753": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Part.lean",
    "full_name": "Part.mod_mem_mod",
    "start": [
      785,
      1
    ],
    "end": [
      786,
      48
    ],
    "traced_tactics": [
      {
        "tactic": "simp [mod_def]",
        "annotated_tactic": [
          "simp [<a>mod_def</a>]",
          [
            {
              "full_name": "Part.mod_def",
              "def_path": "Mathlib/Data/Part.lean",
              "def_pos": [
                704,
                9
              ],
              "def_end_pos": [
                704,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : Mod \u03b1\na b : Part \u03b1\nma mb : \u03b1\nha : ma \u2208 a\nhb : mb \u2208 b\n\u22a2 ma % mb \u2208 a % b",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : Mod \u03b1\na b : Part \u03b1\nma mb : \u03b1\nha : ma \u2208 a\nhb : mb \u2208 b\n\u22a2 \u2203 a_1 \u2208 a, \u2203 a \u2208 b, a_1 % a = ma % mb"
      },
      {
        "tactic": "aesop",
        "annotated_tactic": [
          "aesop",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : Mod \u03b1\na b : Part \u03b1\nma mb : \u03b1\nha : ma \u2208 a\nhb : mb \u2208 b\n\u22a2 \u2203 a_1 \u2208 a, \u2203 a \u2208 b, a_1 % a = ma % mb",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.7260758379707113,
    "entry_failed": false
  },
  "2821": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Sym.lean",
    "full_name": "List.mem_sym2_iff",
    "start": [
      89,
      1
    ],
    "end": [
      92,
      25
    ],
    "traced_tactics": [
      {
        "tactic": "refine z.ind (fun a b => ?_)",
        "annotated_tactic": [
          "refine z.ind (fun a b => ?_)",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nxs : List \u03b1\nz : Sym2 \u03b1\n\u22a2 z \u2208 xs.sym2 \u2194 \u2200 y \u2208 z, y \u2208 xs",
        "state_after": "\u03b1 : Type u_1\nxs : List \u03b1\nz : Sym2 \u03b1\na b : \u03b1\n\u22a2 s(a, b) \u2208 xs.sym2 \u2194 \u2200 y \u2208 s(a, b), y \u2208 xs"
      },
      {
        "tactic": "simp [mk_mem_sym2_iff]",
        "annotated_tactic": [
          "simp [<a>mk_mem_sym2_iff</a>]",
          [
            {
              "full_name": "List.mk_mem_sym2_iff",
              "def_path": "Mathlib/Data/List/Sym.lean",
              "def_pos": [
                81,
                9
              ],
              "def_end_pos": [
                81,
                24
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nxs : List \u03b1\nz : Sym2 \u03b1\na b : \u03b1\n\u22a2 s(a, b) \u2208 xs.sym2 \u2194 \u2200 y \u2208 s(a, b), y \u2208 xs",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2217566469917074,
    "entry_failed": false
  },
  "25542": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Filter/Archimedean.lean",
    "full_name": "Filter.Eventually.intCast_atTop",
    "start": [
      93,
      1
    ],
    "end": [
      95,
      56
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 Int.comap_cast_atTop (R := R)]",
        "annotated_tactic": [
          "rw [\u2190 <a>Int.comap_cast_atTop</a> (R := R)]",
          [
            {
              "full_name": "Int.comap_cast_atTop",
              "def_path": "Mathlib/Order/Filter/Archimedean.lean",
              "def_pos": [
                55,
                17
              ],
              "def_end_pos": [
                55,
                37
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : StrictOrderedRing R\ninst\u271d : Archimedean R\np : R \u2192 Prop\nh : \u2200\u1da0 (x : R) in atTop, p x\n\u22a2 \u2200\u1da0 (n : \u2124) in atTop, p \u2191n",
        "state_after": "\u03b1 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : StrictOrderedRing R\ninst\u271d : Archimedean R\np : R \u2192 Prop\nh : \u2200\u1da0 (x : R) in atTop, p x\n\u22a2 \u2200\u1da0 (n : \u2124) in Filter.comap Int.cast atTop, p \u2191n"
      },
      {
        "tactic": "exact h.comap _",
        "annotated_tactic": [
          "exact h.comap _",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : StrictOrderedRing R\ninst\u271d : Archimedean R\np : R \u2192 Prop\nh : \u2200\u1da0 (x : R) in atTop, p x\n\u22a2 \u2200\u1da0 (n : \u2124) in Filter.comap Int.cast atTop, p \u2191n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.977217196021229,
    "entry_failed": false
  },
  "23606": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Bounds/Basic.lean",
    "full_name": "isLUB_le_iff",
    "start": [
      320,
      1
    ],
    "end": [
      322,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "rw [h.upperBounds_eq]",
        "annotated_tactic": [
          "rw [h.upperBounds_eq]",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns t : Set \u03b1\na b : \u03b1\nh : IsLUB s a\n\u22a2 a \u2264 b \u2194 b \u2208 upperBounds s",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns t : Set \u03b1\na b : \u03b1\nh : IsLUB s a\n\u22a2 a \u2264 b \u2194 b \u2208 Ici a"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Sort x\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ns t : Set \u03b1\na b : \u03b1\nh : IsLUB s a\n\u22a2 a \u2264 b \u2194 b \u2208 Ici a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.7050097279716283,
    "entry_failed": false
  },
  "25053": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Tactic/Ring/Basic.lean",
    "full_name": "Mathlib.Tactic.Ring.add_overlap_pf",
    "start": [
      280,
      1
    ],
    "end": [
      281,
      71
    ],
    "traced_tactics": [
      {
        "tactic": "subst_vars",
        "annotated_tactic": [
          "subst_vars",
          []
        ],
        "state_before": "u : Lean.Level\nR : Type u_1\n\u03b1 : Q(Type u)\ns\u03b1 : Q(CommSemiring \u00ab$\u03b1\u00bb)\ninst\u271d : CommSemiring R\na b c x : R\ne : \u2115\npq_pf : a + b = c\n\u22a2 x ^ e * a + x ^ e * b = x ^ e * c",
        "state_after": "u : Lean.Level\nR : Type u_1\n\u03b1 : Q(Type u)\ns\u03b1 : Q(CommSemiring \u00ab$\u03b1\u00bb)\ninst\u271d : CommSemiring R\na b x : R\ne : \u2115\n\u22a2 x ^ e * a + x ^ e * b = x ^ e * (a + b)"
      },
      {
        "tactic": "simp [mul_add]",
        "annotated_tactic": [
          "simp [<a>mul_add</a>]",
          [
            {
              "full_name": "mul_add",
              "def_path": "Mathlib/Algebra/Ring/Defs.lean",
              "def_pos": [
                83,
                7
              ],
              "def_end_pos": [
                83,
                14
              ]
            }
          ]
        ],
        "state_before": "u : Lean.Level\nR : Type u_1\n\u03b1 : Q(Type u)\ns\u03b1 : Q(CommSemiring \u00ab$\u03b1\u00bb)\ninst\u271d : CommSemiring R\na b x : R\ne : \u2115\n\u22a2 x ^ e * a + x ^ e * b = x ^ e * (a + b)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.3499773510266095,
    "entry_failed": false
  },
  "6522": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Intervals.lean",
    "full_name": "List.Ico.eq_cons",
    "start": [
      130,
      1
    ],
    "end": [
      132,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 append_consecutive (Nat.le_succ n) h, succ_singleton]",
        "annotated_tactic": [
          "rw [\u2190 <a>append_consecutive</a> (<a>Nat.le_succ</a> n) h, <a>succ_singleton</a>]",
          [
            {
              "full_name": "List.Ico.append_consecutive",
              "def_path": "Mathlib/Data/List/Intervals.lean",
              "def_pos": [
                95,
                9
              ],
              "def_end_pos": [
                95,
                27
              ]
            },
            {
              "full_name": "Nat.le_succ",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                1684,
                9
              ],
              "def_end_pos": [
                1684,
                20
              ]
            },
            {
              "full_name": "List.Ico.succ_singleton",
              "def_path": "Mathlib/Data/List/Intervals.lean",
              "def_pos": [
                120,
                9
              ],
              "def_end_pos": [
                120,
                23
              ]
            }
          ]
        ],
        "state_before": "n m : \u2115\nh : n < m\n\u22a2 Ico n m = n :: Ico (n + 1) m",
        "state_after": "n m : \u2115\nh : n < m\n\u22a2 [n] ++ Ico n.succ m = n :: Ico (n + 1) m"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "n m : \u2115\nh : n < m\n\u22a2 [n] ++ Ico n.succ m = n :: Ico (n + 1) m",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.431905195931904,
    "entry_failed": false
  },
  "14503": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Count.lean",
    "full_name": "Nat.count_mono_left",
    "start": [
      165,
      1
    ],
    "end": [
      167,
      59
    ],
    "traced_tactics": [
      {
        "tactic": "simp only [count_eq_card_filter_range]",
        "annotated_tactic": [
          "simp only [<a>count_eq_card_filter_range</a>]",
          [
            {
              "full_name": "Nat.count_eq_card_filter_range",
              "def_path": "Mathlib/Data/Nat/Count.lean",
              "def_pos": [
                54,
                9
              ],
              "def_end_pos": [
                54,
                35
              ]
            }
          ]
        ],
        "state_before": "p : \u2115 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\nq : \u2115 \u2192 Prop\ninst\u271d : DecidablePred q\nn : \u2115\nhpq : \u2200 (k : \u2115), p k \u2192 q k\n\u22a2 count p n \u2264 count q n",
        "state_after": "p : \u2115 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\nq : \u2115 \u2192 Prop\ninst\u271d : DecidablePred q\nn : \u2115\nhpq : \u2200 (k : \u2115), p k \u2192 q k\n\u22a2 (filter p (range n)).card \u2264 (filter q (range n)).card"
      },
      {
        "tactic": "exact card_le_card ((range n).monotone_filter_right hpq)",
        "annotated_tactic": [
          "exact <a>card_le_card</a> ((<a>range</a> n).<a>monotone_filter_right</a> hpq)",
          [
            {
              "full_name": "Finset.card_le_card",
              "def_path": "Mathlib/Data/Finset/Card.lean",
              "def_pos": [
                64,
                9
              ],
              "def_end_pos": [
                64,
                21
              ]
            },
            {
              "full_name": "Finset.range",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                2925,
                5
              ],
              "def_end_pos": [
                2925,
                10
              ]
            },
            {
              "full_name": "Finset.monotone_filter_right",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                2678,
                9
              ],
              "def_end_pos": [
                2678,
                30
              ]
            }
          ]
        ],
        "state_before": "p : \u2115 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\nq : \u2115 \u2192 Prop\ninst\u271d : DecidablePred q\nn : \u2115\nhpq : \u2200 (k : \u2115), p k \u2192 q k\n\u22a2 (filter p (range n)).card \u2264 (filter q (range n)).card",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7913781040115282,
    "entry_failed": false
  },
  "11935": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Ordinal/FixedPoint.lean",
    "full_name": "Ordinal.iterate_le_nfp",
    "start": [
      435,
      1
    ],
    "end": [
      437,
      19
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 sup_iterate_eq_nfp]",
        "annotated_tactic": [
          "rw [\u2190 <a>sup_iterate_eq_nfp</a>]",
          [
            {
              "full_name": "Ordinal.sup_iterate_eq_nfp",
              "def_path": "Mathlib/SetTheory/Ordinal/FixedPoint.lean",
              "def_pos": [
                424,
                9
              ],
              "def_end_pos": [
                424,
                27
              ]
            }
          ]
        ],
        "state_before": "f\u271d : Ordinal.{u} \u2192 Ordinal.{u}\nf : Ordinal.{u_1} \u2192 Ordinal.{u_1}\na : Ordinal.{u_1}\nn : \u2115\n\u22a2 f^[n] a \u2264 nfp f a",
        "state_after": "f\u271d : Ordinal.{u} \u2192 Ordinal.{u}\nf : Ordinal.{u_1} \u2192 Ordinal.{u_1}\na : Ordinal.{u_1}\nn : \u2115\n\u22a2 f^[n] a \u2264 (fun a => sup fun n => f^[n] a) a"
      },
      {
        "tactic": "exact le_sup _ n",
        "annotated_tactic": [
          "exact <a>le_sup</a> _ n",
          [
            {
              "full_name": "Ordinal.le_sup",
              "def_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean",
              "def_pos": [
                1259,
                9
              ],
              "def_end_pos": [
                1259,
                15
              ]
            }
          ]
        ],
        "state_before": "f\u271d : Ordinal.{u} \u2192 Ordinal.{u}\nf : Ordinal.{u_1} \u2192 Ordinal.{u_1}\na : Ordinal.{u_1}\nn : \u2115\n\u22a2 f^[n] a \u2264 (fun a => sup fun n => f^[n] a) a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.993890894926153,
    "entry_failed": false
  },
  "14681": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Trails.lean",
    "full_name": "SimpleGraph.Walk.IsEulerian.edgesFinset_eq",
    "start": [
      128,
      1
    ],
    "end": [
      131,
      25
    ],
    "traced_tactics": [
      {
        "tactic": "ext e",
        "annotated_tactic": [
          "ext e",
          []
        ],
        "state_before": "V : Type u_1\nG : SimpleGraph V\ninst\u271d\u00b9 : DecidableEq V\ninst\u271d : Fintype \u2191G.edgeSet\nu v : V\np : G.Walk u v\nh : p.IsEulerian\n\u22a2 \u22ef.edgesFinset = G.edgeFinset",
        "state_after": "case a\nV : Type u_1\nG : SimpleGraph V\ninst\u271d\u00b9 : DecidableEq V\ninst\u271d : Fintype \u2191G.edgeSet\nu v : V\np : G.Walk u v\nh : p.IsEulerian\ne : Sym2 V\n\u22a2 e \u2208 \u22ef.edgesFinset \u2194 e \u2208 G.edgeFinset"
      },
      {
        "tactic": "simp [h.mem_edges_iff]",
        "annotated_tactic": [
          "simp [h.mem_edges_iff]",
          []
        ],
        "state_before": "case a\nV : Type u_1\nG : SimpleGraph V\ninst\u271d\u00b9 : DecidableEq V\ninst\u271d : Fintype \u2191G.edgeSet\nu v : V\np : G.Walk u v\nh : p.IsEulerian\ne : Sym2 V\n\u22a2 e \u2208 \u22ef.edgesFinset \u2194 e \u2208 G.edgeFinset",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5434986829059198,
    "entry_failed": false
  },
  "23909": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/PathCategory.lean",
    "full_name": "CategoryTheory.Paths.lift_toPath",
    "start": [
      87,
      1
    ],
    "end": [
      90,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "dsimp [Quiver.Hom.toPath, lift]",
        "annotated_tactic": [
          "dsimp [<a>Quiver.Hom.toPath</a>, <a>lift</a>]",
          [
            {
              "full_name": "Quiver.Hom.toPath",
              "def_path": "Mathlib/Combinatorics/Quiver/Path.lean",
              "def_pos": [
                34,
                5
              ],
              "def_end_pos": [
                34,
                15
              ]
            },
            {
              "full_name": "CategoryTheory.Paths.lift",
              "def_path": "Mathlib/CategoryTheory/PathCategory.lean",
              "def_pos": [
                60,
                5
              ],
              "def_end_pos": [
                60,
                9
              ]
            }
          ]
        ],
        "state_before": "V : Type u\u2081\ninst\u271d\u00b9 : Quiver V\nC : Type u_1\ninst\u271d : Category.{u_2, u_1} C\n\u03c6 : V \u2964q C\nX Y : V\nf : X \u27f6 Y\n\u22a2 (lift \u03c6).map f.toPath = \u03c6.map f",
        "state_after": "V : Type u\u2081\ninst\u271d\u00b9 : Quiver V\nC : Type u_1\ninst\u271d : Category.{u_2, u_1} C\n\u03c6 : V \u2964q C\nX Y : V\nf : X \u27f6 Y\n\u22a2 \ud835\udfd9 (\u03c6.obj X) \u226b \u03c6.map f = \u03c6.map f"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "V : Type u\u2081\ninst\u271d\u00b9 : Quiver V\nC : Type u_1\ninst\u271d : Category.{u_2, u_1} C\n\u03c6 : V \u2964q C\nX Y : V\nf : X \u27f6 Y\n\u22a2 \ud835\udfd9 (\u03c6.obj X) \u226b \u03c6.map f = \u03c6.map f",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.1995833539403975,
    "entry_failed": false
  },
  "6062": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Probability/Kernel/Disintegration/MeasurableStieltjes.lean",
    "full_name": "ProbabilityTheory.defaultRatCDF_le_one",
    "start": [
      163,
      1
    ],
    "end": [
      165,
      21
    ],
    "traced_tactics": [
      {
        "tactic": "unfold defaultRatCDF",
        "annotated_tactic": [
          "unfold <a>defaultRatCDF</a>",
          [
            {
              "full_name": "ProbabilityTheory.defaultRatCDF",
              "def_path": "Mathlib/Probability/Kernel/Disintegration/MeasurableStieltjes.lean",
              "def_pos": [
                149,
                5
              ],
              "def_end_pos": [
                149,
                18
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\ninst\u271d : MeasurableSpace \u03b1\nq : \u211a\n\u22a2 defaultRatCDF q \u2264 1",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\ninst\u271d : MeasurableSpace \u03b1\nq : \u211a\n\u22a2 (if q < 0 then 0 else 1) \u2264 1"
      },
      {
        "tactic": "split_ifs <;> simp",
        "annotated_tactic": [
          "split_ifs <;> simp",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\ninst\u271d : MeasurableSpace \u03b1\nq : \u211a\n\u22a2 (if q < 0 then 0 else 1) \u2264 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.2258151799906045,
    "entry_failed": false
  },
  "20732": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Ideal/QuotientOperations.lean",
    "full_name": "Ideal.map_mk_eq_bot_of_le",
    "start": [
      136,
      1
    ],
    "end": [
      138,
      10
    ],
    "traced_tactics": [
      {
        "tactic": "rw [map_eq_bot_iff_le_ker, mk_ker]",
        "annotated_tactic": [
          "rw [<a>map_eq_bot_iff_le_ker</a>, <a>mk_ker</a>]",
          [
            {
              "full_name": "Ideal.map_eq_bot_iff_le_ker",
              "def_path": "Mathlib/RingTheory/Ideal/Maps.lean",
              "def_pos": [
                715,
                9
              ],
              "def_end_pos": [
                715,
                30
              ]
            },
            {
              "full_name": "Ideal.mk_ker",
              "def_path": "Mathlib/RingTheory/Ideal/QuotientOperations.lean",
              "def_pos": [
                131,
                9
              ],
              "def_end_pos": [
                131,
                15
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\nF : Type w\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Semiring S\nI J : Ideal R\nh : I \u2264 J\n\u22a2 map (Quotient.mk J) I = \u22a5",
        "state_after": "R : Type u\nS : Type v\nF : Type w\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Semiring S\nI J : Ideal R\nh : I \u2264 J\n\u22a2 I \u2264 J"
      },
      {
        "tactic": "exact h",
        "annotated_tactic": [
          "exact h",
          []
        ],
        "state_before": "R : Type u\nS : Type v\nF : Type w\ninst\u271d\u00b9 : CommRing R\ninst\u271d : Semiring S\nI J : Ideal R\nh : I \u2264 J\n\u22a2 I \u2264 J",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.7274769749492407,
    "entry_failed": false
  },
  "21513": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/MvPolynomial/Degrees.lean",
    "full_name": "MvPolynomial.degreeOf_C",
    "start": [
      269,
      1
    ],
    "end": [
      270,
      43
    ],
    "traced_tactics": [
      {
        "tactic": "classical simp [degreeOf_def, degrees_C]",
        "annotated_tactic": [
          "classical simp [<a>degreeOf_def</a>, <a>degrees_C</a>]",
          [
            {
              "full_name": "MvPolynomial.degreeOf_def",
              "def_path": "Mathlib/Algebra/MvPolynomial/Degrees.lean",
              "def_pos": [
                241,
                9
              ],
              "def_end_pos": [
                241,
                21
              ]
            },
            {
              "full_name": "MvPolynomial.degrees_C",
              "def_path": "Mathlib/Algebra/MvPolynomial/Degrees.lean",
              "def_pos": [
                101,
                9
              ],
              "def_end_pos": [
                101,
                18
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\na : R\nx : \u03c3\n\u22a2 degreeOf x (C a) = 0",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [degreeOf_def, degrees_C]",
        "annotated_tactic": [
          "simp [<a>degreeOf_def</a>, <a>degrees_C</a>]",
          [
            {
              "full_name": "MvPolynomial.degreeOf_def",
              "def_path": "Mathlib/Algebra/MvPolynomial/Degrees.lean",
              "def_pos": [
                241,
                9
              ],
              "def_end_pos": [
                241,
                21
              ]
            },
            {
              "full_name": "MvPolynomial.degrees_C",
              "def_path": "Mathlib/Algebra/MvPolynomial/Degrees.lean",
              "def_pos": [
                101,
                9
              ],
              "def_end_pos": [
                101,
                18
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\na : R\nx : \u03c3\n\u22a2 degreeOf x (C a) = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.2602254119701684,
    "entry_failed": false
  },
  "26767": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Factorization/Basic.lean",
    "full_name": "Nat.factorization_eq_zero_of_remainder",
    "start": [
      170,
      1
    ],
    "end": [
      173,
      50
    ],
    "traced_tactics": [
      {
        "tactic": "apply factorization_eq_zero_of_not_dvd",
        "annotated_tactic": [
          "apply <a>factorization_eq_zero_of_not_dvd</a>",
          [
            {
              "full_name": "Nat.factorization_eq_zero_of_not_dvd",
              "def_path": "Mathlib/Data/Nat/Factorization/Basic.lean",
              "def_pos": [
                143,
                9
              ],
              "def_end_pos": [
                143,
                41
              ]
            }
          ]
        ],
        "state_before": "a b m n p\u271d p r i : \u2115\nhr : \u00acp \u2223 r\n\u22a2 (p * i + r).factorization p = 0",
        "state_after": "case h\na b m n p\u271d p r i : \u2115\nhr : \u00acp \u2223 r\n\u22a2 \u00acp \u2223 p * i + r"
      },
      {
        "tactic": "rwa [\u2190 Nat.dvd_add_iff_right (Dvd.intro i rfl)]",
        "annotated_tactic": [
          "rwa [\u2190 <a>Nat.dvd_add_iff_right</a> (<a>Dvd.intro</a> i <a>rfl</a>)]",
          [
            {
              "full_name": "Nat.dvd_add_iff_right",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Dvd.lean",
              "def_pos": [
                33,
                19
              ],
              "def_end_pos": [
                33,
                36
              ]
            },
            {
              "full_name": "Dvd.intro",
              "def_path": "Mathlib/Algebra/Divisibility/Basic.lean",
              "def_pos": [
                49,
                9
              ],
              "def_end_pos": [
                49,
                18
              ]
            },
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "case h\na b m n p\u271d p r i : \u2115\nhr : \u00acp \u2223 r\n\u22a2 \u00acp \u2223 p * i + r",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.1955866389907897,
    "entry_failed": false
  },
  "579": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Count.lean",
    "full_name": "Nat.count_le_cardinal",
    "start": [
      120,
      1
    ],
    "end": [
      122,
      49
    ],
    "traced_tactics": [
      {
        "tactic": "rw [count_eq_card_fintype, \u2190 Cardinal.mk_fintype]",
        "annotated_tactic": [
          "rw [<a>count_eq_card_fintype</a>, \u2190 <a>Cardinal.mk_fintype</a>]",
          [
            {
              "full_name": "Nat.count_eq_card_fintype",
              "def_path": "Mathlib/Data/Nat/Count.lean",
              "def_pos": [
                60,
                9
              ],
              "def_end_pos": [
                60,
                30
              ]
            },
            {
              "full_name": "Cardinal.mk_fintype",
              "def_path": "Mathlib/SetTheory/Cardinal/Basic.lean",
              "def_pos": [
                461,
                9
              ],
              "def_end_pos": [
                461,
                19
              ]
            }
          ]
        ],
        "state_before": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\n\u22a2 \u2191(count p n) \u2264 Cardinal.mk \u2191{k | p k}",
        "state_after": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\n\u22a2 Cardinal.mk { k // k < n \u2227 p k } \u2264 Cardinal.mk \u2191{k | p k}"
      },
      {
        "tactic": "exact Cardinal.mk_subtype_mono fun x hx \u21a6 hx.2",
        "annotated_tactic": [
          "exact <a>Cardinal.mk_subtype_mono</a> fun x hx \u21a6 hx.2",
          [
            {
              "full_name": "Cardinal.mk_subtype_mono",
              "def_path": "Mathlib/SetTheory/Cardinal/Basic.lean",
              "def_pos": [
                2131,
                9
              ],
              "def_end_pos": [
                2131,
                24
              ]
            }
          ]
        ],
        "state_before": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\n\u22a2 Cardinal.mk { k // k < n \u2227 p k } \u2264 Cardinal.mk \u2191{k | p k}",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.845862334012054,
    "entry_failed": false
  },
  "13916": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Coset.lean",
    "full_name": "mem_rightCoset_rightCoset",
    "start": [
      169,
      1
    ],
    "end": [
      170,
      61
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 SetLike.mem_coe, \u2190 ha]",
        "annotated_tactic": [
          "rw [\u2190 <a>SetLike.mem_coe</a>, \u2190 ha]",
          [
            {
              "full_name": "SetLike.mem_coe",
              "def_path": "Mathlib/Data/SetLike/Basic.lean",
              "def_pos": [
                180,
                9
              ],
              "def_end_pos": [
                180,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\ns : Submonoid \u03b1\na : \u03b1\nha : op a \u2022 \u2191s = \u2191s\n\u22a2 a \u2208 s",
        "state_after": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\ns : Submonoid \u03b1\na : \u03b1\nha : op a \u2022 \u2191s = \u2191s\n\u22a2 a \u2208 op a \u2022 \u2191s"
      },
      {
        "tactic": "exact mem_own_rightCoset s a",
        "annotated_tactic": [
          "exact <a>mem_own_rightCoset</a> s a",
          [
            {
              "full_name": "mem_own_rightCoset",
              "def_path": "Mathlib/GroupTheory/Coset.lean",
              "def_pos": [
                156,
                9
              ],
              "def_end_pos": [
                156,
                27
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\ns : Submonoid \u03b1\na : \u03b1\nha : op a \u2022 \u2191s = \u2191s\n\u22a2 a \u2208 op a \u2022 \u2191s",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.0843839560402557,
    "entry_failed": false
  },
  "1541": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/ContinuousFunction/StoneWeierstrass.lean",
    "full_name": "ContinuousMap.polynomial_comp_attachBound_mem",
    "start": [
      88,
      1
    ],
    "end": [
      91,
      24
    ],
    "traced_tactics": [
      {
        "tactic": "rw [polynomial_comp_attachBound]",
        "annotated_tactic": [
          "rw [<a>polynomial_comp_attachBound</a>]",
          [
            {
              "full_name": "ContinuousMap.polynomial_comp_attachBound",
              "def_path": "Mathlib/Topology/ContinuousFunction/StoneWeierstrass.lean",
              "def_pos": [
                69,
                9
              ],
              "def_end_pos": [
                69,
                36
              ]
            }
          ]
        ],
        "state_before": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : CompactSpace X\nA : Subalgebra \u211d C(X, \u211d)\nf : \u21a5A\ng : \u211d[X]\n\u22a2 (g.toContinuousMapOn (Set.Icc (-\u2016f\u2016) \u2016f\u2016)).comp (\u2191f).attachBound \u2208 A",
        "state_after": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : CompactSpace X\nA : Subalgebra \u211d C(X, \u211d)\nf : \u21a5A\ng : \u211d[X]\n\u22a2 \u2191((Polynomial.aeval f) g) \u2208 A"
      },
      {
        "tactic": "apply SetLike.coe_mem",
        "annotated_tactic": [
          "apply <a>SetLike.coe_mem</a>",
          [
            {
              "full_name": "SetLike.coe_mem",
              "def_path": "Mathlib/Data/SetLike/Basic.lean",
              "def_pos": [
                193,
                9
              ],
              "def_end_pos": [
                193,
                16
              ]
            }
          ]
        ],
        "state_before": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : CompactSpace X\nA : Subalgebra \u211d C(X, \u211d)\nf : \u21a5A\ng : \u211d[X]\n\u22a2 \u2191((Polynomial.aeval f) g) \u2208 A",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.7133091549621895,
    "entry_failed": false
  },
  "500": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/FieldTheory/Separable.lean",
    "full_name": "Polynomial.separable_X_add_C",
    "start": [
      70,
      1
    ],
    "end": [
      72,
      28
    ],
    "traced_tactics": [
      {
        "tactic": "rw [separable_def, derivative_add, derivative_X, derivative_C, add_zero]",
        "annotated_tactic": [
          "rw [<a>separable_def</a>, <a>derivative_add</a>, <a>derivative_X</a>, <a>derivative_C</a>, <a>add_zero</a>]",
          [
            {
              "full_name": "Polynomial.separable_def",
              "def_path": "Mathlib/FieldTheory/Separable.lean",
              "def_pos": [
                44,
                9
              ],
              "def_end_pos": [
                44,
                22
              ]
            },
            {
              "full_name": "Polynomial.derivative_add",
              "def_path": "Mathlib/Algebra/Polynomial/Derivative.lean",
              "def_pos": [
                144,
                9
              ],
              "def_end_pos": [
                144,
                23
              ]
            },
            {
              "full_name": "Polynomial.derivative_X",
              "def_path": "Mathlib/Algebra/Polynomial/Derivative.lean",
              "def_pos": [
                130,
                9
              ],
              "def_end_pos": [
                130,
                21
              ]
            },
            {
              "full_name": "Polynomial.derivative_C",
              "def_path": "Mathlib/Algebra/Polynomial/Derivative.lean",
              "def_pos": [
                121,
                9
              ],
              "def_end_pos": [
                121,
                21
              ]
            },
            {
              "full_name": "add_zero",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                482,
                3
              ],
              "def_end_pos": [
                482,
                14
              ]
            }
          ]
        ],
        "state_before": "R : Type u\ninst\u271d\u00b9 : CommSemiring R\nS : Type v\ninst\u271d : CommSemiring S\na : R\n\u22a2 (X + C a).Separable",
        "state_after": "R : Type u\ninst\u271d\u00b9 : CommSemiring R\nS : Type v\ninst\u271d : CommSemiring S\na : R\n\u22a2 IsCoprime (X + C a) 1"
      },
      {
        "tactic": "exact isCoprime_one_right",
        "annotated_tactic": [
          "exact <a>isCoprime_one_right</a>",
          [
            {
              "full_name": "isCoprime_one_right",
              "def_path": "Mathlib/RingTheory/Coprime/Basic.lean",
              "def_pos": [
                98,
                9
              ],
              "def_end_pos": [
                98,
                28
              ]
            }
          ]
        ],
        "state_before": "R : Type u\ninst\u271d\u00b9 : CommSemiring R\nS : Type v\ninst\u271d : CommSemiring S\na : R\n\u22a2 IsCoprime (X + C a) 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.175416386919096,
    "entry_failed": false
  },
  "14777": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Finset/Option.lean",
    "full_name": "Finset.eraseNone_eq_biUnion",
    "start": [
      105,
      1
    ],
    "end": [
      108,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\ns : Finset (Option \u03b1)\n\u22a2 eraseNone s = s.biUnion Option.toFinset",
        "state_after": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\ns : Finset (Option \u03b1)\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 eraseNone s \u2194 a\u271d \u2208 s.biUnion Option.toFinset"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : DecidableEq \u03b1\ns : Finset (Option \u03b1)\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 eraseNone s \u2194 a\u271d \u2208 s.biUnion Option.toFinset",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6968780579045415,
    "entry_failed": false
  },
  "27935": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/FreeAbelianGroupFinsupp.lean",
    "full_name": "FreeAbelianGroup.not_mem_support_iff",
    "start": [
      154,
      1
    ],
    "end": [
      156,
      16
    ],
    "traced_tactics": [
      {
        "tactic": "rw [support, Finsupp.not_mem_support_iff]",
        "annotated_tactic": [
          "rw [<a>support</a>, <a>Finsupp.not_mem_support_iff</a>]",
          [
            {
              "full_name": "FreeAbelianGroup.support",
              "def_path": "Mathlib/GroupTheory/FreeAbelianGroupFinsupp.lean",
              "def_pos": [
                145,
                5
              ],
              "def_end_pos": [
                145,
                12
              ]
            },
            {
              "full_name": "Finsupp.not_mem_support_iff",
              "def_path": "Mathlib/Data/Finsupp/Defs.lean",
              "def_pos": [
                180,
                9
              ],
              "def_end_pos": [
                180,
                28
              ]
            }
          ]
        ],
        "state_before": "X : Type u_1\nx : X\na : FreeAbelianGroup X\n\u22a2 x \u2209 a.support \u2194 (coeff x) a = 0",
        "state_after": "X : Type u_1\nx : X\na : FreeAbelianGroup X\n\u22a2 (toFinsupp a) x = 0 \u2194 (coeff x) a = 0"
      },
      {
        "tactic": "exact Iff.rfl",
        "annotated_tactic": [
          "exact <a>Iff.rfl</a>",
          [
            {
              "full_name": "Iff.rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                796,
                19
              ],
              "def_end_pos": [
                796,
                26
              ]
            }
          ]
        ],
        "state_before": "X : Type u_1\nx : X\na : FreeAbelianGroup X\n\u22a2 (toFinsupp a) x = 0 \u2194 (coeff x) a = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.175964954076335,
    "entry_failed": false
  },
  "9078": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/GlueData.lean",
    "full_name": "CategoryTheory.GlueData.t'_iji",
    "start": [
      93,
      1
    ],
    "end": [
      95,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 Category.assoc, \u2190 D.t_fac]",
        "annotated_tactic": [
          "rw [\u2190 <a>Category.assoc</a>, \u2190 D.t_fac]",
          [
            {
              "full_name": "CategoryTheory.Category.assoc",
              "def_path": "Mathlib/CategoryTheory/Category/Basic.lean",
              "def_pos": [
                181,
                3
              ],
              "def_end_pos": [
                181,
                8
              ]
            }
          ]
        ],
        "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v, u\u2081} C\nC' : Type u\u2082\ninst\u271d : Category.{v, u\u2082} C'\nD : GlueData C\ni j : D.J\n\u22a2 D.t' i j i = pullback.fst \u226b D.t i j \u226b inv pullback.snd",
        "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v, u\u2081} C\nC' : Type u\u2082\ninst\u271d : Category.{v, u\u2082} C'\nD : GlueData C\ni j : D.J\n\u22a2 D.t' i j i = (D.t' i j i \u226b pullback.snd) \u226b inv pullback.snd"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v, u\u2081} C\nC' : Type u\u2082\ninst\u271d : Category.{v, u\u2082} C'\nD : GlueData C\ni j : D.J\n\u22a2 D.t' i j i = (D.t' i j i \u226b pullback.snd) \u226b inv pullback.snd",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.64635322696995,
    "entry_failed": false
  },
  "5704": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Compactness/Lindelof.lean",
    "full_name": "cluster_point_of_Lindelof",
    "start": [
      491,
      1
    ],
    "end": [
      493,
      56
    ],
    "traced_tactics": [
      {
        "tactic": "simpa using isLindelof_univ (show f \u2264 \ud835\udcdf univ by simp)",
        "annotated_tactic": [
          "simpa using <a>isLindelof_univ</a> (show f \u2264 \ud835\udcdf <a>univ</a> by simp)",
          [
            {
              "full_name": "isLindelof_univ",
              "def_path": "Mathlib/Topology/Compactness/Lindelof.lean",
              "def_pos": [
                488,
                9
              ],
              "def_end_pos": [
                488,
                24
              ]
            },
            {
              "full_name": "Set.univ",
              "def_path": "Mathlib/Init/Set.lean",
              "def_pos": [
                153,
                5
              ],
              "def_end_pos": [
                153,
                9
              ]
            }
          ]
        ],
        "state_before": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : TopologicalSpace Y\ns t : Set X\ninst\u271d\u00b2 : LindelofSpace X\nf : Filter X\ninst\u271d\u00b9 : f.NeBot\ninst\u271d : CountableInterFilter f\n\u22a2 \u2203 x, ClusterPt x f",
        "state_after": "no goals"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "X : Type u\nY : Type v\n\u03b9 : Type u_1\ninst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : TopologicalSpace Y\ns t : Set X\ninst\u271d\u00b2 : LindelofSpace X\nf : Filter X\ninst\u271d\u00b9 : f.NeBot\ninst\u271d : CountableInterFilter f\n\u22a2 f \u2264 \ud835\udcdf univ",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.5890609370544553,
    "entry_failed": false
  },
  "6844": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Matrix/Reflection.lean",
    "full_name": "Matrix.etaExpand_eq",
    "start": [
      232,
      1
    ],
    "end": [
      235,
      25
    ],
    "traced_tactics": [
      {
        "tactic": "simp_rw [etaExpand, FinVec.etaExpand_eq, Matrix.of]",
        "annotated_tactic": [
          "simp_rw [<a>etaExpand</a>, <a>FinVec.etaExpand_eq</a>, <a>Matrix.of</a>]",
          [
            {
              "full_name": "Matrix.etaExpand",
              "def_path": "Mathlib/Data/Matrix/Reflection.lean",
              "def_pos": [
                220,
                5
              ],
              "def_end_pos": [
                220,
                14
              ]
            },
            {
              "full_name": "FinVec.etaExpand_eq",
              "def_path": "Mathlib/Data/Fin/Tuple/Reflection.lean",
              "def_pos": [
                88,
                9
              ],
              "def_end_pos": [
                88,
                21
              ]
            },
            {
              "full_name": "Matrix.of",
              "def_path": "Mathlib/Data/Matrix/Basic.lean",
              "def_pos": [
                95,
                5
              ],
              "def_end_pos": [
                95,
                7
              ]
            }
          ]
        ],
        "state_before": "l m\u271d n\u271d : \u2115\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm n : \u2115\nA : Matrix (Fin m) (Fin n) \u03b1\n\u22a2 A.etaExpand = A",
        "state_after": "l m\u271d n\u271d : \u2115\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm n : \u2115\nA : Matrix (Fin m) (Fin n) \u03b1\n\u22a2 ((Equiv.refl (Fin m \u2192 Fin n \u2192 \u03b1)) fun i j => A i j) = A"
      },
      {
        "tactic": "erw [Equiv.refl_apply]",
        "annotated_tactic": [
          "erw [<a>Equiv.refl_apply</a>]",
          [
            {
              "full_name": "Equiv.refl_apply",
              "def_path": "Mathlib/Logic/Equiv/Defs.lean",
              "def_pos": [
                268,
                17
              ],
              "def_end_pos": [
                268,
                27
              ]
            }
          ]
        ],
        "state_before": "l m\u271d n\u271d : \u2115\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm n : \u2115\nA : Matrix (Fin m) (Fin n) \u03b1\n\u22a2 ((Equiv.refl (Fin m \u2192 Fin n \u2192 \u03b1)) fun i j => A i j) = A",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.2717889710329473,
    "entry_failed": false
  },
  "28553": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Zip.lean",
    "full_name": "List.zipWith_comm_of_comm",
    "start": [
      177,
      1
    ],
    "end": [
      180,
      19
    ],
    "traced_tactics": [
      {
        "tactic": "rw [zipWith_comm]",
        "annotated_tactic": [
          "rw [<a>zipWith_comm</a>]",
          [
            {
              "full_name": "List.zipWith_comm",
              "def_path": "Mathlib/Data/List/Zip.lean",
              "def_pos": [
                162,
                9
              ],
              "def_end_pos": [
                162,
                21
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b2\ncomm : \u2200 (x y : \u03b1), f x y = f y x\nl l' : List \u03b1\n\u22a2 zipWith f l l' = zipWith f l' l",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b2\ncomm : \u2200 (x y : \u03b1), f x y = f y x\nl l' : List \u03b1\n\u22a2 zipWith (fun b a => f a b) l' l = zipWith f l' l"
      },
      {
        "tactic": "simp only [comm]",
        "annotated_tactic": [
          "simp only [comm]",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\n\u03b3 : Type u_2\n\u03b4 : Type u_3\n\u03b5 : Type u_4\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b2\ncomm : \u2200 (x y : \u03b1), f x y = f y x\nl l' : List \u03b1\n\u22a2 zipWith (fun b a => f a b) l' l = zipWith f l' l",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.744877399993129,
    "entry_failed": false
  },
  "24334": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Sym/Card.lean",
    "full_name": "Sym.card_sym_eq_multichoose",
    "start": [
      110,
      1
    ],
    "end": [
      115,
      53
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 card_sym_fin_eq_multichoose]",
        "annotated_tactic": [
          "rw [\u2190 <a>card_sym_fin_eq_multichoose</a>]",
          [
            {
              "full_name": "Sym.card_sym_fin_eq_multichoose",
              "def_path": "Mathlib/Data/Sym/Card.lean",
              "def_pos": [
                97,
                9
              ],
              "def_end_pos": [
                97,
                36
              ]
            }
          ]
        ],
        "state_before": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\nn : \u2115\n\u03b1 : Type u_3\nk : \u2115\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype (Sym \u03b1 k)\n\u22a2 Fintype.card (Sym \u03b1 k) = (Fintype.card \u03b1).multichoose k",
        "state_after": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\nn : \u2115\n\u03b1 : Type u_3\nk : \u2115\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype (Sym \u03b1 k)\n\u22a2 Fintype.card (Sym \u03b1 k) = Fintype.card (Sym (Fin (Fintype.card \u03b1)) k)"
      },
      {
        "tactic": "exact Fintype.card_congr (equivCongr (equivFin \u03b1))",
        "annotated_tactic": [
          "exact <a>Fintype.card_congr</a> (<a>equivCongr</a> (<a>equivFin</a> \u03b1))",
          [
            {
              "full_name": "Fintype.card_congr",
              "def_path": "Mathlib/Data/Fintype/Card.lean",
              "def_pos": [
                151,
                9
              ],
              "def_end_pos": [
                151,
                19
              ]
            },
            {
              "full_name": "Sym.equivCongr",
              "def_path": "Mathlib/Data/Sym/Basic.lean",
              "def_pos": [
                432,
                5
              ],
              "def_end_pos": [
                432,
                15
              ]
            },
            {
              "full_name": "Fintype.equivFin",
              "def_path": "Mathlib/Data/Fintype/Card.lean",
              "def_pos": [
                96,
                19
              ],
              "def_end_pos": [
                96,
                27
              ]
            }
          ]
        ],
        "state_before": "\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\nn : \u2115\n\u03b1 : Type u_3\nk : \u2115\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype (Sym \u03b1 k)\n\u22a2 Fintype.card (Sym \u03b1 k) = Fintype.card (Sym (Fin (Fintype.card \u03b1)) k)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8929712260141969,
    "entry_failed": false
  },
  "14742": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/Integral/BoundedContinuousFunction.lean",
    "full_name": "BoundedContinuousFunction.apply_le_nndist_zero",
    "start": [
      24,
      1
    ],
    "end": [
      27,
      65
    ],
    "traced_tactics": [
      {
        "tactic": "convert nndist_coe_le_nndist x",
        "annotated_tactic": [
          "convert <a>nndist_coe_le_nndist</a> x",
          [
            {
              "full_name": "BoundedContinuousFunction.nndist_coe_le_nndist",
              "def_path": "Mathlib/Topology/ContinuousFunction/Bounded.lean",
              "def_pos": [
                238,
                9
              ],
              "def_end_pos": [
                238,
                29
              ]
            }
          ]
        ],
        "state_before": "X : Type u_1\ninst\u271d : TopologicalSpace X\nf : X \u2192\u1d47 \u211d\u22650\nx : X\n\u22a2 f x \u2264 nndist 0 f",
        "state_after": "case h.e'_3\nX : Type u_1\ninst\u271d : TopologicalSpace X\nf : X \u2192\u1d47 \u211d\u22650\nx : X\n\u22a2 f x = nndist (0 x) (f x)"
      },
      {
        "tactic": "simp only [coe_zero, Pi.zero_apply, NNReal.nndist_zero_eq_val]",
        "annotated_tactic": [
          "simp only [<a>coe_zero</a>, <a>Pi.zero_apply</a>, <a>NNReal.nndist_zero_eq_val</a>]",
          [
            {
              "full_name": "BoundedContinuousFunction.coe_zero",
              "def_path": "Mathlib/Topology/ContinuousFunction/Bounded.lean",
              "def_pos": [
                620,
                3
              ],
              "def_end_pos": [
                620,
                14
              ]
            },
            {
              "full_name": "Pi.zero_apply",
              "def_path": "Mathlib/Algebra/Group/Pi/Basic.lean",
              "def_pos": [
                62,
                3
              ],
              "def_end_pos": [
                62,
                14
              ]
            },
            {
              "full_name": "NNReal.nndist_zero_eq_val",
              "def_path": "Mathlib/Topology/MetricSpace/Pseudo/Constructions.lean",
              "def_pos": [
                106,
                7
              ],
              "def_end_pos": [
                106,
                32
              ]
            }
          ]
        ],
        "state_before": "case h.e'_3\nX : Type u_1\ninst\u271d : TopologicalSpace X\nf : X \u2192\u1d47 \u211d\u22650\nx : X\n\u22a2 f x = nndist (0 x) (f x)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.720934279030189,
    "entry_failed": false
  },
  "380": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/RingHom/Integral.lean",
    "full_name": "RingHom.isIntegral_stableUnderComposition",
    "start": [
      24,
      1
    ],
    "end": [
      25,
      40
    ],
    "traced_tactics": [
      {
        "tactic": "introv R hf hg",
        "annotated_tactic": [
          "introv R hf hg",
          []
        ],
        "state_before": "\u22a2 StableUnderComposition fun {R S} [CommRing R] [CommRing S] f => f.IsIntegral",
        "state_after": "R S T : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : CommRing T\nf : R \u2192+* S\ng : S \u2192+* T\nhf : f.IsIntegral\nhg : g.IsIntegral\n\u22a2 (g.comp f).IsIntegral"
      },
      {
        "tactic": "exact hf.trans _ _ hg",
        "annotated_tactic": [
          "exact hf.trans _ _ hg",
          []
        ],
        "state_before": "R S T : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : CommRing T\nf : R \u2192+* S\ng : S \u2192+* T\nhf : f.IsIntegral\nhg : g.IsIntegral\n\u22a2 (g.comp f).IsIntegral",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4539900299860165,
    "entry_failed": false
  },
  "23988": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Finsupp/Multiset.lean",
    "full_name": "Finsupp.toMultiset_strictMono",
    "start": [
      230,
      1
    ],
    "end": [
      231,
      53
    ],
    "traced_tactics": [
      {
        "tactic": "classical exact (@orderIsoMultiset \u03b9 _).strictMono",
        "annotated_tactic": [
          "classical exact (@<a>orderIsoMultiset</a> \u03b9 _).<a>strictMono</a>",
          [
            {
              "full_name": "Finsupp.orderIsoMultiset",
              "def_path": "Mathlib/Data/Finsupp/Multiset.lean",
              "def_pos": [
                214,
                5
              ],
              "def_end_pos": [
                214,
                21
              ]
            },
            {
              "full_name": "OrderIso.strictMono",
              "def_path": "Mathlib/Order/Hom/Basic.lean",
              "def_pos": [
                1074,
                19
              ],
              "def_end_pos": [
                1074,
                29
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u22a2 StrictMono \u21d1toMultiset",
        "state_after": "no goals"
      },
      {
        "tactic": "exact (@orderIsoMultiset \u03b9 _).strictMono",
        "annotated_tactic": [
          "exact (@<a>orderIsoMultiset</a> \u03b9 _).<a>strictMono</a>",
          [
            {
              "full_name": "Finsupp.orderIsoMultiset",
              "def_path": "Mathlib/Data/Finsupp/Multiset.lean",
              "def_pos": [
                214,
                5
              ],
              "def_end_pos": [
                214,
                21
              ]
            },
            {
              "full_name": "OrderIso.strictMono",
              "def_path": "Mathlib/Order/Hom/Basic.lean",
              "def_pos": [
                1074,
                19
              ],
              "def_end_pos": [
                1074,
                29
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\n\u22a2 StrictMono \u21d1toMultiset",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.3330443119630218,
    "entry_failed": false
  },
  "9420": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/Normed/Order/UpperLower.lean",
    "full_name": "IsUpperSet.thickening'",
    "start": [
      42,
      11
    ],
    "end": [
      45,
      20
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 ball_mul_one]",
        "annotated_tactic": [
          "rw [\u2190 <a>ball_mul_one</a>]",
          [
            {
              "full_name": "ball_mul_one",
              "def_path": "Mathlib/Analysis/Normed/Group/Pointwise.lean",
              "def_pos": [
                237,
                9
              ],
              "def_end_pos": [
                237,
                21
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d : NormedOrderedGroup \u03b1\ns : Set \u03b1\nhs : IsUpperSet s\n\u03b5 : \u211d\n\u22a2 IsUpperSet (thickening \u03b5 s)",
        "state_after": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d : NormedOrderedGroup \u03b1\ns : Set \u03b1\nhs : IsUpperSet s\n\u03b5 : \u211d\n\u22a2 IsUpperSet (ball 1 \u03b5 * s)"
      },
      {
        "tactic": "exact hs.mul_left",
        "annotated_tactic": [
          "exact hs.mul_left",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d : NormedOrderedGroup \u03b1\ns : Set \u03b1\nhs : IsUpperSet s\n\u03b5 : \u211d\n\u22a2 IsUpperSet (ball 1 \u03b5 * s)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5530105459038168,
    "entry_failed": false
  },
  "24790": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Ring/NegOnePow.lean",
    "full_name": "Int.negOnePow_neg",
    "start": [
      77,
      1
    ],
    "end": [
      80,
      53
    ],
    "traced_tactics": [
      {
        "tactic": "dsimp [negOnePow]",
        "annotated_tactic": [
          "dsimp [<a>negOnePow</a>]",
          [
            {
              "full_name": "Int.negOnePow",
              "def_path": "Mathlib/Algebra/Ring/NegOnePow.lean",
              "def_pos": [
                22,
                5
              ],
              "def_end_pos": [
                22,
                14
              ]
            }
          ]
        ],
        "state_before": "n : \u2124\n\u22a2 (-n).negOnePow = n.negOnePow",
        "state_after": "n : \u2124\n\u22a2 (-1) ^ (-n) = (-1) ^ n"
      },
      {
        "tactic": "simp only [zpow_neg, \u2190 inv_zpow, inv_neg, inv_one]",
        "annotated_tactic": [
          "simp only [<a>zpow_neg</a>, \u2190 <a>inv_zpow</a>, <a>inv_neg</a>, <a>inv_one</a>]",
          [
            {
              "full_name": "zpow_neg",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                593,
                7
              ],
              "def_end_pos": [
                593,
                15
              ]
            },
            {
              "full_name": "inv_zpow",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                611,
                7
              ],
              "def_end_pos": [
                611,
                15
              ]
            },
            {
              "full_name": "inv_neg",
              "def_path": "Mathlib/Algebra/Field/Basic.lean",
              "def_pos": [
                135,
                9
              ],
              "def_end_pos": [
                135,
                16
              ]
            },
            {
              "full_name": "inv_one",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                1118,
                9
              ],
              "def_end_pos": [
                1118,
                16
              ]
            }
          ]
        ],
        "state_before": "n : \u2124\n\u22a2 (-1) ^ (-n) = (-1) ^ n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4454969060607255,
    "entry_failed": false
  },
  "11126": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": ".lake/packages/batteries/Batteries/Data/Rat/Lemmas.lean",
    "full_name": "Rat.mkRat_mul_right",
    "start": [
      125,
      1
    ],
    "end": [
      126,
      90
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 mkRat_mul_left (d := d) a0]",
        "annotated_tactic": [
          "rw [\u2190 <a>mkRat_mul_left</a> (d := d) a0]",
          [
            {
              "full_name": "Rat.mkRat_mul_left",
              "def_path": ".lake/packages/batteries/Batteries/Data/Rat/Lemmas.lean",
              "def_pos": [
                121,
                9
              ],
              "def_end_pos": [
                121,
                23
              ]
            }
          ]
        ],
        "state_before": "n : Int\nd a : Nat\na0 : a \u2260 0\n\u22a2 mkRat (n * \u2191a) (d * a) = mkRat n d",
        "state_after": "n : Int\nd a : Nat\na0 : a \u2260 0\n\u22a2 mkRat (n * \u2191a) (d * a) = mkRat (\u2191a * n) (a * d)"
      },
      {
        "tactic": "congr 1 <;> [apply Int.mul_comm; apply Nat.mul_comm]",
        "annotated_tactic": [
          "congr 1 <;> [apply <a>Int.mul_comm</a>; apply <a>Nat.mul_comm</a>]",
          [
            {
              "full_name": "Int.mul_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Lemmas.lean",
              "def_pos": [
                357,
                19
              ],
              "def_end_pos": [
                357,
                27
              ]
            },
            {
              "full_name": "Nat.mul_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean",
              "def_pos": [
                217,
                19
              ],
              "def_end_pos": [
                217,
                27
              ]
            }
          ]
        ],
        "state_before": "n : Int\nd a : Nat\na0 : a \u2260 0\n\u22a2 mkRat (n * \u2191a) (d * a) = mkRat (\u2191a * n) (a * d)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.389049131073989,
    "entry_failed": false
  },
  "23651": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Ring/Parity.lean",
    "full_name": "Odd.sub_odd",
    "start": [
      247,
      1
    ],
    "end": [
      248,
      47
    ],
    "traced_tactics": [
      {
        "tactic": "rw [sub_eq_add_neg]",
        "annotated_tactic": [
          "rw [<a>sub_eq_add_neg</a>]",
          [
            {
              "full_name": "sub_eq_add_neg",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                1057,
                3
              ],
              "def_end_pos": [
                1057,
                14
              ]
            }
          ]
        ],
        "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d : Ring \u03b1\na b : \u03b1\nn : \u2115\nha : Odd a\nhb : Odd b\n\u22a2 Even (a - b)",
        "state_after": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d : Ring \u03b1\na b : \u03b1\nn : \u2115\nha : Odd a\nhb : Odd b\n\u22a2 Even (a + -b)"
      },
      {
        "tactic": "exact ha.add_odd hb.neg",
        "annotated_tactic": [
          "exact ha.add_odd hb.neg",
          []
        ],
        "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d : Ring \u03b1\na b : \u03b1\nn : \u2115\nha : Odd a\nhb : Odd b\n\u22a2 Even (a + -b)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.9535699740517884,
    "entry_failed": false
  },
  "28308": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Algebra/Order/UpperLower.lean",
    "full_name": "IsUpperSet.interior",
    "start": [
      100,
      11
    ],
    "end": [
      102,
      24
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 isLowerSet_compl, \u2190 closure_compl]",
        "annotated_tactic": [
          "rw [\u2190 <a>isLowerSet_compl</a>, \u2190 <a>closure_compl</a>]",
          [
            {
              "full_name": "isLowerSet_compl",
              "def_path": "Mathlib/Order/UpperLower/Basic.lean",
              "def_pos": [
                98,
                9
              ],
              "def_end_pos": [
                98,
                25
              ]
            },
            {
              "full_name": "closure_compl",
              "def_path": "Mathlib/Topology/Basic.lean",
              "def_pos": [
                551,
                9
              ],
              "def_end_pos": [
                551,
                22
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : HasUpperLowerClosure \u03b1\ns : Set \u03b1\nh : IsUpperSet s\n\u22a2 IsUpperSet (interior s)",
        "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : HasUpperLowerClosure \u03b1\ns : Set \u03b1\nh : IsUpperSet s\n\u22a2 IsLowerSet (closure s\u1d9c)"
      },
      {
        "tactic": "exact h.compl.closure",
        "annotated_tactic": [
          "exact h.compl.closure",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : HasUpperLowerClosure \u03b1\ns : Set \u03b1\nh : IsUpperSet s\n\u22a2 IsLowerSet (closure s\u1d9c)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6674073330359533,
    "entry_failed": false
  },
  "28092": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Real/ConjExponents.lean",
    "full_name": "NNReal.IsConjExponent.inv_add_inv_conj_ennreal",
    "start": [
      206,
      1
    ],
    "end": [
      206,
      98
    ],
    "traced_tactics": [
      {
        "tactic": "norm_cast",
        "annotated_tactic": [
          "norm_cast",
          []
        ],
        "state_before": "a b p q : \u211d\u22650\nh : p.IsConjExponent q\n\u22a2 \u2191p\u207b\u00b9 + \u2191q\u207b\u00b9 = 1",
        "state_after": "a b p q : \u211d\u22650\nh : p.IsConjExponent q\n\u22a2 p\u207b\u00b9 + q\u207b\u00b9 = 1"
      },
      {
        "tactic": "exact h.inv_add_inv_conj",
        "annotated_tactic": [
          "exact h.inv_add_inv_conj",
          []
        ],
        "state_before": "a b p q : \u211d\u22650\nh : p.IsConjExponent q\n\u22a2 p\u207b\u00b9 + q\u207b\u00b9 = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.9516754100332037,
    "entry_failed": false
  },
  "23710": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/SpecificGroups/Quaternion.lean",
    "full_name": "QuaternionGroup.orderOf_a",
    "start": [
      256,
      1
    ],
    "end": [
      259,
      47
    ],
    "traced_tactics": [
      {
        "tactic": "conv_lhs => rw [\u2190 ZMod.natCast_zmod_val i]",
        "annotated_tactic": [
          "conv_lhs => rw [\u2190 <a>ZMod.natCast_zmod_val</a> i]",
          [
            {
              "full_name": "ZMod.natCast_zmod_val",
              "def_path": "Mathlib/Data/ZMod/Basic.lean",
              "def_pos": [
                209,
                9
              ],
              "def_end_pos": [
                209,
                25
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\ninst\u271d : NeZero n\ni : ZMod (2 * n)\n\u22a2 orderOf (a i) = 2 * n / (2 * n).gcd i.val",
        "state_after": "n : \u2115\ninst\u271d : NeZero n\ni : ZMod (2 * n)\n\u22a2 orderOf (a \u2191i.val) = 2 * n / (2 * n).gcd i.val"
      },
      {
        "tactic": "rw [\u2190 a_one_pow, orderOf_pow, orderOf_a_one]",
        "annotated_tactic": [
          "rw [\u2190 <a>a_one_pow</a>, <a>orderOf_pow</a>, <a>orderOf_a_one</a>]",
          [
            {
              "full_name": "QuaternionGroup.a_one_pow",
              "def_path": "Mathlib/GroupTheory/SpecificGroups/Quaternion.lean",
              "def_pos": [
                180,
                9
              ],
              "def_end_pos": [
                180,
                18
              ]
            },
            {
              "full_name": "orderOf_pow",
              "def_path": "Mathlib/GroupTheory/OrderOfElement.lean",
              "def_pos": [
                873,
                9
              ],
              "def_end_pos": [
                873,
                20
              ]
            },
            {
              "full_name": "QuaternionGroup.orderOf_a_one",
              "def_path": "Mathlib/GroupTheory/SpecificGroups/Quaternion.lean",
              "def_pos": [
                235,
                9
              ],
              "def_end_pos": [
                235,
                22
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\ninst\u271d : NeZero n\ni : ZMod (2 * n)\n\u22a2 orderOf (a \u2191i.val) = 2 * n / (2 * n).gcd i.val",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.812980627990328,
    "entry_failed": false
  },
  "25662": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Int/Defs.lean",
    "full_name": "Int.pred_self_lt",
    "start": [
      242,
      1
    ],
    "end": [
      242,
      65
    ],
    "traced_tactics": [
      {
        "tactic": "unfold pred",
        "annotated_tactic": [
          "unfold <a>pred</a>",
          [
            {
              "full_name": "Int.pred",
              "def_path": "Mathlib/Data/Int/Defs.lean",
              "def_pos": [
                201,
                5
              ],
              "def_end_pos": [
                201,
                9
              ]
            }
          ]
        ],
        "state_before": "a\u271d b c d m n a : \u2124\n\u22a2 a.pred < a",
        "state_after": "a\u271d b c d m n a : \u2124\n\u22a2 a - 1 < a"
      },
      {
        "tactic": "omega",
        "annotated_tactic": [
          "omega",
          []
        ],
        "state_before": "a\u271d b c d m n a : \u2124\n\u22a2 a - 1 < a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.0253073889762163,
    "entry_failed": false
  },
  "14160": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Probability/Density.lean",
    "full_name": "MeasureTheory.pdf_of_not_aemeasurable",
    "start": [
      142,
      1
    ],
    "end": [
      145,
      23
    ],
    "traced_tactics": [
      {
        "tactic": "rw [pdf_def, map_of_not_aemeasurable hX]",
        "annotated_tactic": [
          "rw [<a>pdf_def</a>, <a>map_of_not_aemeasurable</a> hX]",
          [
            {
              "full_name": "MeasureTheory.pdf_def",
              "def_path": "Mathlib/Probability/Density.lean",
              "def_pos": [
                139,
                9
              ],
              "def_end_pos": [
                139,
                16
              ]
            },
            {
              "full_name": "MeasureTheory.Measure.map_of_not_aemeasurable",
              "def_path": "Mathlib/MeasureTheory/Measure/MeasureSpace.lean",
              "def_pos": [
                1237,
                9
              ],
              "def_end_pos": [
                1237,
                32
              ]
            }
          ]
        ],
        "state_before": "\u03a9 : Type u_1\nE : Type u_2\ninst\u271d : MeasurableSpace E\nx\u271d : MeasurableSpace \u03a9\n\u2119 : Measure \u03a9\n\u03bc : Measure E\nX : \u03a9 \u2192 E\nhX : \u00acAEMeasurable X \u2119\n\u22a2 pdf X \u2119 \u03bc =\u1da0[ae \u03bc] 0",
        "state_after": "\u03a9 : Type u_1\nE : Type u_2\ninst\u271d : MeasurableSpace E\nx\u271d : MeasurableSpace \u03a9\n\u2119 : Measure \u03a9\n\u03bc : Measure E\nX : \u03a9 \u2192 E\nhX : \u00acAEMeasurable X \u2119\n\u22a2 rnDeriv 0 \u03bc =\u1da0[ae \u03bc] 0"
      },
      {
        "tactic": "exact rnDeriv_zero \u03bc",
        "annotated_tactic": [
          "exact <a>rnDeriv_zero</a> \u03bc",
          [
            {
              "full_name": "MeasureTheory.Measure.rnDeriv_zero",
              "def_path": "Mathlib/MeasureTheory/Decomposition/Lebesgue.lean",
              "def_pos": [
                269,
                7
              ],
              "def_end_pos": [
                269,
                19
              ]
            }
          ]
        ],
        "state_before": "\u03a9 : Type u_1\nE : Type u_2\ninst\u271d : MeasurableSpace E\nx\u271d : MeasurableSpace \u03a9\n\u2119 : Measure \u03a9\n\u03bc : Measure E\nX : \u03a9 \u2192 E\nhX : \u00acAEMeasurable X \u2119\n\u22a2 rnDeriv 0 \u03bc =\u1da0[ae \u03bc] 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.2859830970410258,
    "entry_failed": false
  },
  "14185": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Int/Defs.lean",
    "full_name": "Int.lt_asymm",
    "start": [
      59,
      1
    ],
    "end": [
      59,
      85
    ],
    "traced_tactics": [
      {
        "tactic": "rw [Int.not_lt]",
        "annotated_tactic": [
          "rw [<a>Int.not_lt</a>]",
          [
            {
              "full_name": "Int.not_lt",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean",
              "def_pos": [
                139,
                19
              ],
              "def_end_pos": [
                139,
                25
              ]
            }
          ]
        ],
        "state_before": "a\u271d b\u271d c\u271d d m n a b c : \u2124\n\u22a2 a < b \u2192 \u00acb < a",
        "state_after": "a\u271d b\u271d c\u271d d m n a b c : \u2124\n\u22a2 a < b \u2192 a \u2264 b"
      },
      {
        "tactic": "exact Int.le_of_lt",
        "annotated_tactic": [
          "exact <a>Int.le_of_lt</a>",
          [
            {
              "full_name": "Int.le_of_lt",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean",
              "def_pos": [
                111,
                19
              ],
              "def_end_pos": [
                111,
                27
              ]
            }
          ]
        ],
        "state_before": "a\u271d b\u271d c\u271d d m n a b c : \u2124\n\u22a2 a < b \u2192 a \u2264 b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.552246505045332,
    "entry_failed": false
  },
  "9165": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": ".lake/packages/batteries/Batteries/Data/Array/Lemmas.lean",
    "full_name": "Array.size_shrink",
    "start": [
      126,
      1
    ],
    "end": [
      128,
      8
    ],
    "traced_tactics": [
      {
        "tactic": "simp [shrink, size_shrink_loop]",
        "annotated_tactic": [
          "simp [<a>shrink</a>, <a>size_shrink_loop</a>]",
          [
            {
              "full_name": "Array.shrink",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Basic.lean",
              "def_pos": [
                134,
                5
              ],
              "def_end_pos": [
                134,
                11
              ]
            },
            {
              "full_name": "Array.size_shrink_loop",
              "def_path": ".lake/packages/batteries/Batteries/Data/Array/Lemmas.lean",
              "def_pos": [
                120,
                9
              ],
              "def_end_pos": [
                120,
                25
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\na : Array \u03b1\nn : Nat\n\u22a2 (a.shrink n).size = min a.size n",
        "state_after": "\u03b1 : Type u_1\na : Array \u03b1\nn : Nat\n\u22a2 a.size - (a.size - n) = min a.size n"
      },
      {
        "tactic": "omega",
        "annotated_tactic": [
          "omega",
          []
        ],
        "state_before": "\u03b1 : Type u_1\na : Array \u03b1\nn : Nat\n\u22a2 a.size - (a.size - n) = min a.size n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.80246519704815,
    "entry_failed": false
  },
  "25516": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/CharZero/Lemmas.lean",
    "full_name": "one_eq_bit1",
    "start": [
      166,
      1
    ],
    "end": [
      168,
      20
    ],
    "traced_tactics": [
      {
        "tactic": "rw [eq_comm]",
        "annotated_tactic": [
          "rw [<a>eq_comm</a>]",
          [
            {
              "full_name": "eq_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                811,
                9
              ],
              "def_end_pos": [
                811,
                16
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d\u00b2 : NonAssocRing R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : CharZero R\na : R\n\u22a2 1 = bit1 a \u2194 a = 0",
        "state_after": "R : Type u_1\ninst\u271d\u00b2 : NonAssocRing R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : CharZero R\na : R\n\u22a2 bit1 a = 1 \u2194 a = 0"
      },
      {
        "tactic": "exact bit1_eq_one",
        "annotated_tactic": [
          "exact <a>bit1_eq_one</a>",
          [
            {
              "full_name": "bit1_eq_one",
              "def_path": "Mathlib/Algebra/CharZero/Lemmas.lean",
              "def_pos": [
                161,
                9
              ],
              "def_end_pos": [
                161,
                20
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d\u00b2 : NonAssocRing R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : CharZero R\na : R\n\u22a2 bit1 a = 1 \u2194 a = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.1098173540085554,
    "entry_failed": false
  },
  "24018": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/EuclideanDomain/Defs.lean",
    "full_name": "EuclideanDomain.gcd_zero_left",
    "start": [
      209,
      1
    ],
    "end": [
      211,
      19
    ],
    "traced_tactics": [
      {
        "tactic": "rw [gcd]",
        "annotated_tactic": [
          "rw [<a>gcd</a>]",
          [
            {
              "full_name": "EuclideanDomain.gcd",
              "def_path": "Mathlib/Algebra/EuclideanDomain/Defs.lean",
              "def_pos": [
                200,
                5
              ],
              "def_end_pos": [
                200,
                8
              ]
            }
          ]
        ],
        "state_before": "R : Type u\ninst\u271d\u00b9 : EuclideanDomain R\ninst\u271d : DecidableEq R\na : R\n\u22a2 gcd 0 a = a",
        "state_after": "R : Type u\ninst\u271d\u00b9 : EuclideanDomain R\ninst\u271d : DecidableEq R\na : R\n\u22a2 (if a0 : 0 = 0 then a\n    else\n      let_fun x := \u22ef;\n      gcd (a % 0) 0) =\n    a"
      },
      {
        "tactic": "exact if_pos rfl",
        "annotated_tactic": [
          "exact <a>if_pos</a> <a>rfl</a>",
          [
            {
              "full_name": "if_pos",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                932,
                9
              ],
              "def_end_pos": [
                932,
                15
              ]
            },
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "R : Type u\ninst\u271d\u00b9 : EuclideanDomain R\ninst\u271d : DecidableEq R\na : R\n\u22a2 (if a0 : 0 = 0 then a\n    else\n      let_fun x := \u22ef;\n      gcd (a % 0) 0) =\n    a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5521616789046675,
    "entry_failed": false
  },
  "7140": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Instances/Int.lean",
    "full_name": "Int.dist_eq'",
    "start": [
      35,
      1
    ],
    "end": [
      35,
      78
    ],
    "traced_tactics": [
      {
        "tactic": "rw [dist_eq]",
        "annotated_tactic": [
          "rw [<a>dist_eq</a>]",
          [
            {
              "full_name": "Int.dist_eq",
              "def_path": "Mathlib/Topology/Instances/Int.lean",
              "def_pos": [
                32,
                9
              ],
              "def_end_pos": [
                32,
                16
              ]
            }
          ]
        ],
        "state_before": "m n : \u2124\n\u22a2 dist m n = \u2191|m - n|",
        "state_after": "m n : \u2124\n\u22a2 |\u2191m - \u2191n| = \u2191|m - n|"
      },
      {
        "tactic": "norm_cast",
        "annotated_tactic": [
          "norm_cast",
          []
        ],
        "state_before": "m n : \u2124\n\u22a2 |\u2191m - \u2191n| = \u2191|m - n|",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2811388949630782,
    "entry_failed": false
  },
  "11269": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Coprime/Lemmas.lean",
    "full_name": "IsCoprime.pow_right",
    "start": [
      204,
      1
    ],
    "end": [
      206,
      41
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 Finset.card_range n, \u2190 Finset.prod_const]",
        "annotated_tactic": [
          "rw [\u2190 <a>Finset.card_range</a> n, \u2190 <a>Finset.prod_const</a>]",
          [
            {
              "full_name": "Finset.card_range",
              "def_path": "Mathlib/Data/Finset/Card.lean",
              "def_pos": [
                206,
                9
              ],
              "def_end_pos": [
                206,
                19
              ]
            },
            {
              "full_name": "Finset.prod_const",
              "def_path": "Mathlib/Algebra/BigOperators/Group/Finset.lean",
              "def_pos": [
                1737,
                9
              ],
              "def_end_pos": [
                1737,
                19
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nI : Type v\ninst\u271d : CommSemiring R\nx y z : R\ns : I \u2192 R\nt : Finset I\nm n : \u2115\nH : IsCoprime x y\n\u22a2 IsCoprime x (y ^ n)",
        "state_after": "R : Type u\nI : Type v\ninst\u271d : CommSemiring R\nx y z : R\ns : I \u2192 R\nt : Finset I\nm n : \u2115\nH : IsCoprime x y\n\u22a2 IsCoprime x (\u220f _x \u2208 range n, y)"
      },
      {
        "tactic": "exact IsCoprime.prod_right fun _ _ \u21a6 H",
        "annotated_tactic": [
          "exact <a>IsCoprime.prod_right</a> fun _ _ \u21a6 H",
          [
            {
              "full_name": "IsCoprime.prod_right",
              "def_path": "Mathlib/RingTheory/Coprime/Lemmas.lean",
              "def_pos": [
                69,
                9
              ],
              "def_end_pos": [
                69,
                29
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nI : Type v\ninst\u271d : CommSemiring R\nx y z : R\ns : I \u2192 R\nt : Finset I\nm n : \u2115\nH : IsCoprime x y\n\u22a2 IsCoprime x (\u220f _x \u2208 range n, y)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.4290798020083457,
    "entry_failed": false
  },
  "15483": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/UpperLower.lean",
    "full_name": "IsUpperSet.mul_right",
    "start": [
      70,
      1
    ],
    "end": [
      72,
      20
    ],
    "traced_tactics": [
      {
        "tactic": "rw [mul_comm]",
        "annotated_tactic": [
          "rw [<a>mul_comm</a>]",
          [
            {
              "full_name": "mul_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                332,
                9
              ],
              "def_end_pos": [
                332,
                17
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : OrderedCommGroup \u03b1\ns t : Set \u03b1\na : \u03b1\nhs : IsUpperSet s\n\u22a2 IsUpperSet (s * t)",
        "state_after": "\u03b1 : Type u_1\ninst\u271d : OrderedCommGroup \u03b1\ns t : Set \u03b1\na : \u03b1\nhs : IsUpperSet s\n\u22a2 IsUpperSet (t * s)"
      },
      {
        "tactic": "exact hs.mul_left",
        "annotated_tactic": [
          "exact hs.mul_left",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : OrderedCommGroup \u03b1\ns t : Set \u03b1\na : \u03b1\nhs : IsUpperSet s\n\u22a2 IsUpperSet (t * s)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7907178149325773,
    "entry_failed": false
  },
  "4896": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Associated.lean",
    "full_name": "Prime.pow_dvd_of_dvd_mul_right",
    "start": [
      148,
      1
    ],
    "end": [
      151,
      42
    ],
    "traced_tactics": [
      {
        "tactic": "rw [mul_comm] at h'",
        "annotated_tactic": [
          "rw [<a>mul_comm</a>] at h'",
          [
            {
              "full_name": "mul_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                332,
                9
              ],
              "def_end_pos": [
                332,
                17
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np a b : \u03b1\nhp : Prime p\nn : \u2115\nh : \u00acp \u2223 b\nh' : p ^ n \u2223 a * b\n\u22a2 p ^ n \u2223 a",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np a b : \u03b1\nhp : Prime p\nn : \u2115\nh : \u00acp \u2223 b\nh' : p ^ n \u2223 b * a\n\u22a2 p ^ n \u2223 a"
      },
      {
        "tactic": "exact hp.pow_dvd_of_dvd_mul_left n h h'",
        "annotated_tactic": [
          "exact hp.pow_dvd_of_dvd_mul_left n h h'",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d : CancelCommMonoidWithZero \u03b1\np a b : \u03b1\nhp : Prime p\nn : \u2115\nh : \u00acp \u2223 b\nh' : p ^ n \u2223 b * a\n\u22a2 p ^ n \u2223 a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.350718323024921,
    "entry_failed": false
  },
  "9153": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Tactic/Congr!.lean",
    "full_name": "FastSubsingleton.helim",
    "start": [
      428,
      11
    ],
    "end": [
      431,
      34
    ],
    "traced_tactics": [
      {
        "tactic": "have : Subsingleton \u03b1 := FastSubsingleton.inst",
        "annotated_tactic": [
          "have : <a>Subsingleton</a> \u03b1 := <a>FastSubsingleton.inst</a>",
          [
            {
              "full_name": "Subsingleton",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1009,
                7
              ],
              "def_end_pos": [
                1009,
                19
              ]
            },
            {
              "full_name": "Lean.Meta.FastSubsingleton.inst",
              "def_path": "Mathlib/Lean/Meta/CongrTheorems.lean",
              "def_pos": [
                100,
                4
              ],
              "def_end_pos": [
                100,
                8
              ]
            }
          ]
        ],
        "state_before": "\u03b1 \u03b2 : Sort u\ninst\u271d : FastSubsingleton \u03b1\nh\u2082 : \u03b1 = \u03b2\na : \u03b1\nb : \u03b2\n\u22a2 HEq a b",
        "state_after": "\u03b1 \u03b2 : Sort u\ninst\u271d : FastSubsingleton \u03b1\nh\u2082 : \u03b1 = \u03b2\na : \u03b1\nb : \u03b2\nthis : Subsingleton \u03b1\n\u22a2 HEq a b"
      },
      {
        "tactic": "exact Subsingleton.helim h\u2082 a b",
        "annotated_tactic": [
          "exact <a>Subsingleton.helim</a> h\u2082 a b",
          [
            {
              "full_name": "Subsingleton.helim",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1018,
                19
              ],
              "def_end_pos": [
                1018,
                37
              ]
            }
          ]
        ],
        "state_before": "\u03b1 \u03b2 : Sort u\ninst\u271d : FastSubsingleton \u03b1\nh\u2082 : \u03b1 = \u03b2\na : \u03b1\nb : \u03b2\nthis : Subsingleton \u03b1\n\u22a2 HEq a b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.7279569830279797,
    "entry_failed": false
  },
  "15671": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Divisibility/Units.lean",
    "full_name": "IsRelPrime.of_mul_right_left",
    "start": [
      180,
      1
    ],
    "end": [
      182,
      27
    ],
    "traced_tactics": [
      {
        "tactic": "rw [isRelPrime_comm] at H \u22a2",
        "annotated_tactic": [
          "rw [<a>isRelPrime_comm</a>] at H \u22a2",
          [
            {
              "full_name": "isRelPrime_comm",
              "def_path": "Mathlib/Algebra/Divisibility/Units.lean",
              "def_pos": [
                162,
                9
              ],
              "def_end_pos": [
                162,
                24
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : CommMonoid \u03b1\nx y z : \u03b1\nH : IsRelPrime x (y * z)\n\u22a2 IsRelPrime x y",
        "state_after": "\u03b1 : Type u_1\ninst\u271d : CommMonoid \u03b1\nx y z : \u03b1\nH : IsRelPrime (y * z) x\n\u22a2 IsRelPrime y x"
      },
      {
        "tactic": "exact H.of_mul_left_left",
        "annotated_tactic": [
          "exact H.of_mul_left_left",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : CommMonoid \u03b1\nx y z : \u03b1\nH : IsRelPrime (y * z) x\n\u22a2 IsRelPrime y x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5757022469770163,
    "entry_failed": false
  },
  "22648": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Set/Card.lean",
    "full_name": "Set.encard_eq_coe_toFinset_card",
    "start": [
      78,
      1
    ],
    "end": [
      80,
      56
    ],
    "traced_tactics": [
      {
        "tactic": "have h := toFinite s",
        "annotated_tactic": [
          "have h := <a>toFinite</a> s",
          [
            {
              "full_name": "Set.toFinite",
              "def_path": "Mathlib/Data/Set/Finite.lean",
              "def_pos": [
                77,
                9
              ],
              "def_end_pos": [
                77,
                17
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns\u271d t s : Set \u03b1\ninst\u271d : Fintype \u2191s\n\u22a2 s.encard = \u2191s.toFinset.card",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns\u271d t s : Set \u03b1\ninst\u271d : Fintype \u2191s\nh : s.Finite\n\u22a2 s.encard = \u2191s.toFinset.card"
      },
      {
        "tactic": "rw [h.encard_eq_coe_toFinset_card, toFinite_toFinset]",
        "annotated_tactic": [
          "rw [h.encard_eq_coe_toFinset_card, <a>toFinite_toFinset</a>]",
          [
            {
              "full_name": "Set.toFinite_toFinset",
              "def_path": "Mathlib/Data/Set/Finite.lean",
              "def_pos": [
                114,
                9
              ],
              "def_end_pos": [
                114,
                26
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns\u271d t s : Set \u03b1\ninst\u271d : Fintype \u2191s\nh : s.Finite\n\u22a2 s.encard = \u2191s.toFinset.card",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.5712544380221516,
    "entry_failed": false
  },
  "12895": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Probability/Distributions/Uniform.lean",
    "full_name": "MeasureTheory.pdf.IsUniform.absolutelyContinuous",
    "start": [
      77,
      1
    ],
    "end": [
      78,
      61
    ],
    "traced_tactics": [
      {
        "tactic": "rw [hu]",
        "annotated_tactic": [
          "rw [hu]",
          []
        ],
        "state_before": "E : Type u_1\ninst\u271d : MeasurableSpace E\nm \u03bc : Measure E\n\u03a9 : Type u_2\nx\u271d : MeasurableSpace \u03a9\n\u2119 : Measure \u03a9\nX : \u03a9 \u2192 E\ns : Set E\nhu : IsUniform X s \u2119 \u03bc\n\u22a2 Measure.map X \u2119 \u226a \u03bc",
        "state_after": "E : Type u_1\ninst\u271d : MeasurableSpace E\nm \u03bc : Measure E\n\u03a9 : Type u_2\nx\u271d : MeasurableSpace \u03a9\n\u2119 : Measure \u03a9\nX : \u03a9 \u2192 E\ns : Set E\nhu : IsUniform X s \u2119 \u03bc\n\u22a2 ProbabilityTheory.cond \u03bc s \u226a \u03bc"
      },
      {
        "tactic": "exact ProbabilityTheory.cond_absolutelyContinuous",
        "annotated_tactic": [
          "exact <a>ProbabilityTheory.cond_absolutelyContinuous</a>",
          [
            {
              "full_name": "ProbabilityTheory.cond_absolutelyContinuous",
              "def_path": "Mathlib/Probability/ConditionalProbability.lean",
              "def_pos": [
                118,
                7
              ],
              "def_end_pos": [
                118,
                32
              ]
            }
          ]
        ],
        "state_before": "E : Type u_1\ninst\u271d : MeasurableSpace E\nm \u03bc : Measure E\n\u03a9 : Type u_2\nx\u271d : MeasurableSpace \u03a9\n\u2119 : Measure \u03a9\nX : \u03a9 \u2192 E\ns : Set E\nhu : IsUniform X s \u2119 \u03bc\n\u22a2 ProbabilityTheory.cond \u03bc s \u226a \u03bc",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.260618450003676,
    "entry_failed": false
  },
  "21288": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/FieldTheory/KrullTopology.lean",
    "full_name": "IntermediateField.fixingSubgroup_top",
    "start": [
      281,
      1
    ],
    "end": [
      284,
      50
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "K : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\n\u22a2 \u22a4.fixingSubgroup = \u22a5",
        "state_after": "case h\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nx\u271d : L \u2243\u2090[K] L\n\u22a2 x\u271d \u2208 \u22a4.fixingSubgroup \u2194 x\u271d \u2208 \u22a5"
      },
      {
        "tactic": "simp [mem_fixingSubgroup_iff, DFunLike.ext_iff]",
        "annotated_tactic": [
          "simp [<a>mem_fixingSubgroup_iff</a>, <a>DFunLike.ext_iff</a>]",
          [
            {
              "full_name": "IntermediateField.mem_fixingSubgroup_iff",
              "def_path": "Mathlib/FieldTheory/KrullTopology.lean",
              "def_pos": [
                118,
                9
              ],
              "def_end_pos": [
                118,
                49
              ]
            },
            {
              "full_name": "DFunLike.ext_iff",
              "def_path": "Mathlib/Data/FunLike/Basic.lean",
              "def_pos": [
                205,
                9
              ],
              "def_end_pos": [
                205,
                16
              ]
            }
          ]
        ],
        "state_before": "case h\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nx\u271d : L \u2243\u2090[K] L\n\u22a2 x\u271d \u2208 \u22a4.fixingSubgroup \u2194 x\u271d \u2208 \u22a5",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.597745993058197,
    "entry_failed": false
  },
  "23173": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Rotate.lean",
    "full_name": "List.IsRotated.reverse",
    "start": [
      511,
      1
    ],
    "end": [
      513,
      39
    ],
    "traced_tactics": [
      {
        "tactic": "obtain \u27e8n, rfl\u27e9 := h",
        "annotated_tactic": [
          "obtain \u27e8n, rfl\u27e9 := h",
          []
        ],
        "state_before": "\u03b1 : Type u\nl l' : List \u03b1\nh : l ~r l'\n\u22a2 l.reverse ~r l'.reverse",
        "state_after": "case intro\n\u03b1 : Type u\nl : List \u03b1\nn : \u2115\n\u22a2 l.reverse ~r (l.rotate n).reverse"
      },
      {
        "tactic": "exact \u27e8_, (reverse_rotate _ _).symm\u27e9",
        "annotated_tactic": [
          "exact \u27e8_, (<a>reverse_rotate</a> _ _).<a>symm</a>\u27e9",
          [
            {
              "full_name": "List.reverse_rotate",
              "def_path": "Mathlib/Data/List/Rotate.lean",
              "def_pos": [
                361,
                9
              ],
              "def_end_pos": [
                361,
                23
              ]
            },
            {
              "full_name": "Eq.symm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                323,
                9
              ],
              "def_end_pos": [
                323,
                16
              ]
            }
          ]
        ],
        "state_before": "case intro\n\u03b1 : Type u\nl : List \u03b1\nn : \u2115\n\u22a2 l.reverse ~r (l.rotate n).reverse",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.028296643984504,
    "entry_failed": false
  },
  "17745": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/MetricSpace/Infsep.lean",
    "full_name": "Set.infsep_pair",
    "start": [
      423,
      1
    ],
    "end": [
      425,
      42
    ],
    "traced_tactics": [
      {
        "tactic": "rw [infsep_pair_eq_toReal, edist_dist]",
        "annotated_tactic": [
          "rw [<a>infsep_pair_eq_toReal</a>, <a>edist_dist</a>]",
          [
            {
              "full_name": "Set.infsep_pair_eq_toReal",
              "def_path": "Mathlib/Topology/MetricSpace/Infsep.lean",
              "def_pos": [
                374,
                9
              ],
              "def_end_pos": [
                374,
                30
              ]
            },
            {
              "full_name": "edist_dist",
              "def_path": "Mathlib/Topology/MetricSpace/Pseudo/Defs.lean",
              "def_pos": [
                181,
                9
              ],
              "def_end_pos": [
                181,
                19
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\n\u22a2 {x, y}.infsep = dist x y",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\n\u22a2 (ENNReal.ofReal (dist x y)).toReal = dist x y"
      },
      {
        "tactic": "exact ENNReal.toReal_ofReal dist_nonneg",
        "annotated_tactic": [
          "exact <a>ENNReal.toReal_ofReal</a> <a>dist_nonneg</a>",
          [
            {
              "full_name": "ENNReal.toReal_ofReal",
              "def_path": "Mathlib/Data/ENNReal/Basic.lean",
              "def_pos": [
                217,
                9
              ],
              "def_end_pos": [
                217,
                22
              ]
            },
            {
              "full_name": "dist_nonneg",
              "def_path": "Mathlib/Topology/MetricSpace/Pseudo/Defs.lean",
              "def_pos": [
                259,
                9
              ],
              "def_end_pos": [
                259,
                20
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\nx y z : \u03b1\ns t : Set \u03b1\n\u22a2 (ENNReal.ofReal (dist x y)).toReal = dist x y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.056719745043665,
    "entry_failed": false
  },
  "26097": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/AlgebraicGeometry/EllipticCurve/DivisionPolynomial/Basic.lean",
    "full_name": "WeierstrassCurve.\u03a8Sq_four",
    "start": [
      271,
      1
    ],
    "end": [
      273,
      51
    ],
    "traced_tactics": [
      {
        "tactic": "erw [\u03a8Sq_ofNat, pre\u03a8'_four, if_pos <| by decide]",
        "annotated_tactic": [
          "erw [<a>\u03a8Sq_ofNat</a>, <a>pre\u03a8'_four</a>, <a>if_pos</a> <| by decide]",
          [
            {
              "full_name": "WeierstrassCurve.\u03a8Sq_ofNat",
              "def_path": "Mathlib/AlgebraicGeometry/EllipticCurve/DivisionPolynomial/Basic.lean",
              "def_pos": [
                252,
                7
              ],
              "def_end_pos": [
                252,
                16
              ]
            },
            {
              "full_name": "WeierstrassCurve.pre\u03a8'_four",
              "def_path": "Mathlib/AlgebraicGeometry/EllipticCurve/DivisionPolynomial/Basic.lean",
              "def_pos": [
                179,
                7
              ],
              "def_end_pos": [
                179,
                17
              ]
            },
            {
              "full_name": "if_pos",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                932,
                9
              ],
              "def_end_pos": [
                932,
                15
              ]
            }
          ]
        ],
        "state_before": "R : Type r\nS : Type s\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nW : WeierstrassCurve R\n\u22a2 W.\u03a8Sq 4 = W.pre\u03a8\u2084 ^ 2 * W.\u03a8\u2082Sq",
        "state_after": "no goals"
      },
      {
        "tactic": "decide",
        "annotated_tactic": [
          "decide",
          []
        ],
        "state_before": "R : Type r\nS : Type s\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nW : WeierstrassCurve R\n\u22a2 Even 4",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.7614932500291616,
    "entry_failed": false
  },
  "22493": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/ContinuedFractions/Computation/TerminatesIffRat.lean",
    "full_name": "GeneralizedContinuedFraction.exists_gcf_pair_rat_eq_nth_conts",
    "start": [
      101,
      1
    ],
    "end": [
      103,
      95
    ],
    "traced_tactics": [
      {
        "tactic": "rw [nth_cont_eq_succ_nth_cont_aux]",
        "annotated_tactic": [
          "rw [<a>nth_cont_eq_succ_nth_cont_aux</a>]",
          [
            {
              "full_name": "GeneralizedContinuedFraction.nth_cont_eq_succ_nth_cont_aux",
              "def_path": "Mathlib/Algebra/ContinuedFractions/Translations.lean",
              "def_pos": [
                91,
                9
              ],
              "def_end_pos": [
                91,
                38
              ]
            }
          ]
        ],
        "state_before": "K : Type u_1\ninst\u271d\u00b9 : LinearOrderedField K\ninst\u271d : FloorRing K\nv : K\nn : \u2115\n\u22a2 \u2203 conts, (of v).continuants n = Pair.map Rat.cast conts",
        "state_after": "K : Type u_1\ninst\u271d\u00b9 : LinearOrderedField K\ninst\u271d : FloorRing K\nv : K\nn : \u2115\n\u22a2 \u2203 conts, (of v).continuantsAux (n + 1) = Pair.map Rat.cast conts"
      },
      {
        "tactic": "exact exists_gcf_pair_rat_eq_of_nth_conts_aux v <| n + 1",
        "annotated_tactic": [
          "exact <a>exists_gcf_pair_rat_eq_of_nth_conts_aux</a> v <| n + 1",
          [
            {
              "full_name": "GeneralizedContinuedFraction.exists_gcf_pair_rat_eq_of_nth_conts_aux",
              "def_path": "Mathlib/Algebra/ContinuedFractions/Computation/TerminatesIffRat.lean",
              "def_pos": [
                62,
                16
              ],
              "def_end_pos": [
                62,
                55
              ]
            }
          ]
        ],
        "state_before": "K : Type u_1\ninst\u271d\u00b9 : LinearOrderedField K\ninst\u271d : FloorRing K\nv : K\nn : \u2115\n\u22a2 \u2203 conts, (of v).continuantsAux (n + 1) = Pair.map Rat.cast conts",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.916616837028414,
    "entry_failed": false
  },
  "20768": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Category/MonCat/Colimits.lean",
    "full_name": "MonCat.Colimits.cocone_naturality_components",
    "start": [
      188,
      1
    ],
    "end": [
      191,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 cocone_naturality F f]",
        "annotated_tactic": [
          "rw [\u2190 <a>cocone_naturality</a> F f]",
          [
            {
              "full_name": "MonCat.Colimits.cocone_naturality",
              "def_path": "Mathlib/Algebra/Category/MonCat/Colimits.lean",
              "def_pos": [
                179,
                9
              ],
              "def_end_pos": [
                179,
                26
              ]
            }
          ]
        ],
        "state_before": "J : Type v\ninst\u271d : SmallCategory J\nF : J \u2964 MonCat\nj j' : J\nf : j \u27f6 j'\nx : \u2191(F.obj j)\n\u22a2 (coconeMorphism F j') ((F.map f) x) = (coconeMorphism F j) x",
        "state_after": "J : Type v\ninst\u271d : SmallCategory J\nF : J \u2964 MonCat\nj j' : J\nf : j \u27f6 j'\nx : \u2191(F.obj j)\n\u22a2 (coconeMorphism F j') ((F.map f) x) = (F.map f \u226b coconeMorphism F j') x"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "J : Type v\ninst\u271d : SmallCategory J\nF : J \u2964 MonCat\nj j' : J\nf : j \u27f6 j'\nx : \u2191(F.obj j)\n\u22a2 (coconeMorphism F j') ((F.map f) x) = (F.map f \u226b coconeMorphism F j') x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7126530150417238,
    "entry_failed": false
  },
  "13526": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean",
    "full_name": "SimpleGraph.transpose_adjMatrix",
    "start": [
      169,
      1
    ],
    "end": [
      171,
      18
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "V : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableRel G.Adj\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\n\u22a2 (adjMatrix \u03b1 G)\u1d40 = adjMatrix \u03b1 G",
        "state_after": "case a\nV : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableRel G.Adj\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\ni\u271d j\u271d : V\n\u22a2 (adjMatrix \u03b1 G)\u1d40 i\u271d j\u271d = adjMatrix \u03b1 G i\u271d j\u271d"
      },
      {
        "tactic": "simp [adj_comm]",
        "annotated_tactic": [
          "simp [<a>adj_comm</a>]",
          [
            {
              "full_name": "SimpleGraph.adj_comm",
              "def_path": "Mathlib/Combinatorics/SimpleGraph/Basic.lean",
              "def_pos": [
                175,
                9
              ],
              "def_end_pos": [
                175,
                17
              ]
            }
          ]
        ],
        "state_before": "case a\nV : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nG : SimpleGraph V\ninst\u271d\u00b2 : DecidableRel G.Adj\ninst\u271d\u00b9 : Zero \u03b1\ninst\u271d : One \u03b1\ni\u271d j\u271d : V\n\u22a2 (adjMatrix \u03b1 G)\u1d40 i\u271d j\u271d = adjMatrix \u03b1 G i\u271d j\u271d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.055673346039839,
    "entry_failed": false
  },
  "21723": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Matroid/Map.lean",
    "full_name": "Matroid.restrictSubtype_indep_iff_of_subset",
    "start": [
      621,
      1
    ],
    "end": [
      623,
      65
    ],
    "traced_tactics": [
      {
        "tactic": "rw [restrictSubtype_indep_iff, image_preimage_eq_iff.2]",
        "annotated_tactic": [
          "rw [<a>restrictSubtype_indep_iff</a>, <a>image_preimage_eq_iff</a>.2]",
          [
            {
              "full_name": "Matroid.restrictSubtype_indep_iff",
              "def_path": "Mathlib/Data/Matroid/Map.lean",
              "def_pos": [
                617,
                15
              ],
              "def_end_pos": [
                617,
                40
              ]
            },
            {
              "full_name": "Set.image_preimage_eq_iff",
              "def_path": "Mathlib/Data/Set/Image.lean",
              "def_pos": [
                794,
                9
              ],
              "def_end_pos": [
                794,
                30
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nE\u271d I\u271d s : Set \u03b1\nM\u271d : Matroid \u03b1\nN : Matroid \u03b2\nE X I : Set \u03b1\nM : Matroid \u03b1\nhIX : I \u2286 X\n\u22a2 (M.restrictSubtype X).Indep (X \u2193\u2229 I) \u2194 M.Indep I",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nE\u271d I\u271d s : Set \u03b1\nM\u271d : Matroid \u03b1\nN : Matroid \u03b2\nE X I : Set \u03b1\nM : Matroid \u03b1\nhIX : I \u2286 X\n\u22a2 I \u2286 range Subtype.val"
      },
      {
        "tactic": "simpa",
        "annotated_tactic": [
          "simpa",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nE\u271d I\u271d s : Set \u03b1\nM\u271d : Matroid \u03b1\nN : Matroid \u03b2\nE X I : Set \u03b1\nM : Matroid \u03b1\nhIX : I \u2286 X\n\u22a2 I \u2286 range Subtype.val",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.582275792956352,
    "entry_failed": false
  },
  "18320": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean",
    "full_name": "Real.toNNReal_rpow_of_nonneg",
    "start": [
      353,
      1
    ],
    "end": [
      356,
      44
    ],
    "traced_tactics": [
      {
        "tactic": "nth_rw 1 [\u2190 Real.coe_toNNReal x hx]",
        "annotated_tactic": [
          "nth_rw 1 [\u2190 <a>Real.coe_toNNReal</a> x hx]",
          [
            {
              "full_name": "Real.coe_toNNReal",
              "def_path": "Mathlib/Data/NNReal/Basic.lean",
              "def_pos": [
                124,
                9
              ],
              "def_end_pos": [
                124,
                33
              ]
            }
          ]
        ],
        "state_before": "w x\u271d y\u271d z x y : \u211d\nhx : 0 \u2264 x\n\u22a2 (x ^ y).toNNReal = x.toNNReal ^ y",
        "state_after": "w x\u271d y\u271d z x y : \u211d\nhx : 0 \u2264 x\n\u22a2 (\u2191x.toNNReal ^ y).toNNReal = x.toNNReal ^ y"
      },
      {
        "tactic": "rw [\u2190 NNReal.coe_rpow, Real.toNNReal_coe]",
        "annotated_tactic": [
          "rw [\u2190 <a>NNReal.coe_rpow</a>, <a>Real.toNNReal_coe</a>]",
          [
            {
              "full_name": "NNReal.coe_rpow",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean",
              "def_pos": [
                47,
                9
              ],
              "def_end_pos": [
                47,
                17
              ]
            },
            {
              "full_name": "Real.toNNReal_coe",
              "def_path": "Mathlib/Data/NNReal/Basic.lean",
              "def_pos": [
                397,
                9
              ],
              "def_end_pos": [
                397,
                33
              ]
            }
          ]
        ],
        "state_before": "w x\u271d y\u271d z x y : \u211d\nhx : 0 \u2264 x\n\u22a2 (\u2191x.toNNReal ^ y).toNNReal = x.toNNReal ^ y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.523152359994128,
    "entry_failed": false
  },
  "13655": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Deriv.lean",
    "full_name": "HasDerivAt.log",
    "start": [
      105,
      1
    ],
    "end": [
      108,
      18
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 hasDerivWithinAt_univ] at *",
        "annotated_tactic": [
          "rw [\u2190 <a>hasDerivWithinAt_univ</a>] at *",
          [
            {
              "full_name": "hasDerivWithinAt_univ",
              "def_path": "Mathlib/Analysis/Calculus/Deriv/Basic.lean",
              "def_pos": [
                400,
                9
              ],
              "def_end_pos": [
                400,
                30
              ]
            }
          ]
        ],
        "state_before": "f : \u211d \u2192 \u211d\nx f' : \u211d\ns : Set \u211d\nhf : HasDerivAt f f' x\nhx : f x \u2260 0\n\u22a2 HasDerivAt (fun y => Real.log (f y)) (f' / f x) x",
        "state_after": "f : \u211d \u2192 \u211d\nx f' : \u211d\ns : Set \u211d\nhf : HasDerivWithinAt f f' Set.univ x\nhx : f x \u2260 0\n\u22a2 HasDerivWithinAt (fun y => Real.log (f y)) (f' / f x) Set.univ x"
      },
      {
        "tactic": "exact hf.log hx",
        "annotated_tactic": [
          "exact hf.log hx",
          []
        ],
        "state_before": "f : \u211d \u2192 \u211d\nx f' : \u211d\ns : Set \u211d\nhf : HasDerivWithinAt f f' Set.univ x\nhx : f x \u2260 0\n\u22a2 HasDerivWithinAt (fun y => Real.log (f y)) (f' / f x) Set.univ x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.732362969079986,
    "entry_failed": false
  },
  "20659": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": ".lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "full_name": "Batteries.PairingHeapImp.Heap.noSibling_deleteMin",
    "start": [
      103,
      1
    ],
    "end": [
      105,
      66
    ],
    "traced_tactics": [
      {
        "tactic": "cases s with cases eq | node a c => exact noSibling_combine _ _",
        "annotated_tactic": [
          "cases s with cases eq | <a>node</a> a c => exact <a>noSibling_combine</a> _ _",
          [
            {
              "full_name": "Batteries.PairingHeapImp.Heap.node",
              "def_path": ".lake/packages/batteries/Batteries/Data/PairingHeap.lean",
              "def_pos": [
                25,
                5
              ],
              "def_end_pos": [
                25,
                9
              ]
            },
            {
              "full_name": "Batteries.PairingHeapImp.Heap.noSibling_combine",
              "def_path": ".lake/packages/batteries/Batteries/Data/PairingHeap.lean",
              "def_pos": [
                95,
                9
              ],
              "def_end_pos": [
                95,
                31
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\na : \u03b1\ns' s : Heap \u03b1\neq : deleteMin le s = some (a, s')\n\u22a2 s'.NoSibling",
        "state_after": "no goals"
      },
      {
        "tactic": "exact noSibling_combine _ _",
        "annotated_tactic": [
          "exact <a>noSibling_combine</a> _ _",
          [
            {
              "full_name": "Batteries.PairingHeapImp.Heap.noSibling_combine",
              "def_path": ".lake/packages/batteries/Batteries/Data/PairingHeap.lean",
              "def_pos": [
                95,
                9
              ],
              "def_end_pos": [
                95,
                31
              ]
            }
          ]
        ],
        "state_before": "case node.refl\n\u03b1 : Type u_1\nle : \u03b1 \u2192 \u03b1 \u2192 Bool\na : \u03b1\nc sibling\u271d : Heap \u03b1\n\u22a2 (combine le c).NoSibling",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2133660990511999,
    "entry_failed": false
  },
  "2641": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/DList/Defs.lean",
    "full_name": "Batteries.DList.toList_cons",
    "start": [
      80,
      1
    ],
    "end": [
      81,
      16
    ],
    "traced_tactics": [
      {
        "tactic": "cases l",
        "annotated_tactic": [
          "cases l",
          []
        ],
        "state_before": "\u03b1 : Type u\nx : \u03b1\nl : DList \u03b1\n\u22a2 (cons x l).toList = x :: l.toList",
        "state_after": "case mk\n\u03b1 : Type u\nx : \u03b1\napply\u271d : List \u03b1 \u2192 List \u03b1\ninvariant\u271d : \u2200 (l : List \u03b1), apply\u271d l = apply\u271d [] ++ l\n\u22a2 (cons x { apply := apply\u271d, invariant := invariant\u271d }).toList =\n    x :: { apply := apply\u271d, invariant := invariant\u271d }.toList"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case mk\n\u03b1 : Type u\nx : \u03b1\napply\u271d : List \u03b1 \u2192 List \u03b1\ninvariant\u271d : \u2200 (l : List \u03b1), apply\u271d l = apply\u271d [] ++ l\n\u22a2 (cons x { apply := apply\u271d, invariant := invariant\u271d }).toList =\n    x :: { apply := apply\u271d, invariant := invariant\u271d }.toList",
        "state_after": "no goals"
      }
    ],
    "entry_time": 0.7573123381007463,
    "entry_failed": false
  },
  "4743": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Filter/Cofinite.lean",
    "full_name": "Filter.Tendsto.countable_compl_preimage_ker",
    "start": [
      150,
      1
    ],
    "end": [
      152,
      94
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 ker_comap]",
        "annotated_tactic": [
          "rw [\u2190 <a>ker_comap</a>]",
          [
            {
              "full_name": "Filter.ker_comap",
              "def_path": "Mathlib/Order/Filter/Ker.lean",
              "def_pos": [
                52,
                15
              ],
              "def_end_pos": [
                52,
                24
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl\u271d : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\nl : Filter \u03b2\ninst\u271d : l.IsCountablyGenerated\nh : Tendsto f cofinite l\n\u22a2 (f \u207b\u00b9' l.ker)\u1d9c.Countable",
        "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl\u271d : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\nl : Filter \u03b2\ninst\u271d : l.IsCountablyGenerated\nh : Tendsto f cofinite l\n\u22a2 (comap f l).ker\u1d9c.Countable"
      },
      {
        "tactic": "exact countable_compl_ker h.le_comap",
        "annotated_tactic": [
          "exact <a>countable_compl_ker</a> h.le_comap",
          [
            {
              "full_name": "Filter.countable_compl_ker",
              "def_path": "Mathlib/Order/Filter/Cofinite.lean",
              "def_pos": [
                143,
                9
              ],
              "def_end_pos": [
                143,
                28
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nl\u271d : Filter \u03b1\nf : \u03b1 \u2192 \u03b2\nl : Filter \u03b2\ninst\u271d : l.IsCountablyGenerated\nh : Tendsto f cofinite l\n\u22a2 (comap f l).ker\u1d9c.Countable",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.683825112064369,
    "entry_failed": false
  },
  "945": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Coprime/Basic.lean",
    "full_name": "IsCoprime.of_add_mul_right_right",
    "start": [
      212,
      1
    ],
    "end": [
      214,
      32
    ],
    "traced_tactics": [
      {
        "tactic": "rw [mul_comm] at h",
        "annotated_tactic": [
          "rw [<a>mul_comm</a>] at h",
          [
            {
              "full_name": "mul_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                332,
                9
              ],
              "def_end_pos": [
                332,
                17
              ]
            }
          ]
        ],
        "state_before": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nh : IsCoprime x (y + z * x)\n\u22a2 IsCoprime x y",
        "state_after": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nh : IsCoprime x (y + x * z)\n\u22a2 IsCoprime x y"
      },
      {
        "tactic": "exact h.of_add_mul_left_right",
        "annotated_tactic": [
          "exact h.of_add_mul_left_right",
          []
        ],
        "state_before": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nh : IsCoprime x (y + x * z)\n\u22a2 IsCoprime x y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.216375346062705,
    "entry_failed": false
  },
  "20607": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Interval/Set/OrderIso.lean",
    "full_name": "OrderIso.preimage_Iic",
    "start": [
      24,
      1
    ],
    "end": [
      26,
      23
    ],
    "traced_tactics": [
      {
        "tactic": "ext x",
        "annotated_tactic": [
          "ext x",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ne : \u03b1 \u2243o \u03b2\nb : \u03b2\n\u22a2 \u21d1e \u207b\u00b9' Iic b = Iic (e.symm b)",
        "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ne : \u03b1 \u2243o \u03b2\nb : \u03b2\nx : \u03b1\n\u22a2 x \u2208 \u21d1e \u207b\u00b9' Iic b \u2194 x \u2208 Iic (e.symm b)"
      },
      {
        "tactic": "simp [\u2190 e.le_iff_le]",
        "annotated_tactic": [
          "simp [\u2190 e.le_iff_le]",
          []
        ],
        "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ne : \u03b1 \u2243o \u03b2\nb : \u03b2\nx : \u03b1\n\u22a2 x \u2208 \u21d1e \u207b\u00b9' Iic b \u2194 x \u2208 Iic (e.symm b)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.0169901829212904,
    "entry_failed": false
  },
  "15937": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Coprime/Lemmas.lean",
    "full_name": "IsRelPrime.pow_left",
    "start": [
      295,
      1
    ],
    "end": [
      297,
      41
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 Finset.card_range m, \u2190 Finset.prod_const]",
        "annotated_tactic": [
          "rw [\u2190 <a>Finset.card_range</a> m, \u2190 <a>Finset.prod_const</a>]",
          [
            {
              "full_name": "Finset.card_range",
              "def_path": "Mathlib/Data/Finset/Card.lean",
              "def_pos": [
                206,
                9
              ],
              "def_end_pos": [
                206,
                19
              ]
            },
            {
              "full_name": "Finset.prod_const",
              "def_path": "Mathlib/Algebra/BigOperators/Group/Finset.lean",
              "def_pos": [
                1737,
                9
              ],
              "def_end_pos": [
                1737,
                19
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nI : Type ?u.58098\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : DecompositionMonoid \u03b1\nx y z : \u03b1\ns : I \u2192 \u03b1\nt : Finset I\nm n : \u2115\nH : IsRelPrime x y\n\u22a2 IsRelPrime (x ^ m) y",
        "state_after": "\u03b1 : Type u_1\nI : Type ?u.58098\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : DecompositionMonoid \u03b1\nx y z : \u03b1\ns : I \u2192 \u03b1\nt : Finset I\nm n : \u2115\nH : IsRelPrime x y\n\u22a2 IsRelPrime (\u220f _x \u2208 Finset.range m, x) y"
      },
      {
        "tactic": "exact IsRelPrime.prod_left fun _ _ \u21a6 H",
        "annotated_tactic": [
          "exact <a>IsRelPrime.prod_left</a> fun _ _ \u21a6 H",
          [
            {
              "full_name": "IsRelPrime.prod_left",
              "def_path": "Mathlib/RingTheory/Coprime/Lemmas.lean",
              "def_pos": [
                235,
                9
              ],
              "def_end_pos": [
                235,
                29
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nI : Type ?u.58098\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : DecompositionMonoid \u03b1\nx y z : \u03b1\ns : I \u2192 \u03b1\nt : Finset I\nm n : \u2115\nH : IsRelPrime x y\n\u22a2 IsRelPrime (\u220f _x \u2208 Finset.range m, x) y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.0850861240178347,
    "entry_failed": false
  },
  "9635": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Finset/Card.lean",
    "full_name": "Finset.exists_subset_card_eq",
    "start": [
      636,
      1
    ],
    "end": [
      638,
      70
    ],
    "traced_tactics": [
      {
        "tactic": "simpa using exists_subsuperset_card_eq s.empty_subset (by simp) hns",
        "annotated_tactic": [
          "simpa using <a>exists_subsuperset_card_eq</a> s.empty_subset (by simp) hns",
          [
            {
              "full_name": "Finset.exists_subsuperset_card_eq",
              "def_path": "Mathlib/Data/Finset/Card.lean",
              "def_pos": [
                623,
                7
              ],
              "def_end_pos": [
                623,
                33
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t u : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nn : \u2115\nhns : n \u2264 s.card\n\u22a2 \u2203 t \u2286 s, t.card = n",
        "state_after": "no goals"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nR : Type u_3\ns t u : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nn : \u2115\nhns : n \u2264 s.card\n\u22a2 \u2205.card \u2264 n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.60826688806992,
    "entry_failed": false
  },
  "17315": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/ZMod/Parity.lean",
    "full_name": "ZMod.ne_zero_iff_odd",
    "start": [
      32,
      1
    ],
    "end": [
      35,
      30
    ],
    "traced_tactics": [
      {
        "tactic": "contrapose",
        "annotated_tactic": [
          "contrapose",
          []
        ],
        "state_before": "case mpr\nn : \u2115\n\u22a2 Odd n \u2192 \u2191n \u2260 0",
        "state_after": "case mpr\nn : \u2115\n\u22a2 \u00ac\u2191n \u2260 0 \u2192 \u00acOdd n"
      },
      {
        "tactic": "simp [eq_zero_iff_even]",
        "annotated_tactic": [
          "simp [<a>eq_zero_iff_even</a>]",
          [
            {
              "full_name": "ZMod.eq_zero_iff_even",
              "def_path": "Mathlib/Data/ZMod/Parity.lean",
              "def_pos": [
                24,
                9
              ],
              "def_end_pos": [
                24,
                25
              ]
            }
          ]
        ],
        "state_before": "case mpr\nn : \u2115\n\u22a2 \u00ac\u2191n \u2260 0 \u2192 \u00acOdd n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.3461304689990357,
    "entry_failed": false
  },
  "18978": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Int/GCD.lean",
    "full_name": "Int.lcm_zero_left",
    "start": [
      412,
      1
    ],
    "end": [
      414,
      26
    ],
    "traced_tactics": [
      {
        "tactic": "rw [Int.lcm]",
        "annotated_tactic": [
          "rw [<a>Int.lcm</a>]",
          [
            {
              "full_name": "Int.lcm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Gcd.lean",
              "def_pos": [
                41,
                5
              ],
              "def_end_pos": [
                41,
                8
              ]
            }
          ]
        ],
        "state_before": "i : \u2124\n\u22a2 lcm 0 i = 0",
        "state_after": "i : \u2124\n\u22a2 (natAbs 0).lcm i.natAbs = 0"
      },
      {
        "tactic": "apply Nat.lcm_zero_left",
        "annotated_tactic": [
          "apply <a>Nat.lcm_zero_left</a>",
          [
            {
              "full_name": "Nat.lcm_zero_left",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lcm.lean",
              "def_pos": [
                19,
                17
              ],
              "def_end_pos": [
                19,
                30
              ]
            }
          ]
        ],
        "state_before": "i : \u2124\n\u22a2 (natAbs 0).lcm i.natAbs = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.5977293129544705,
    "entry_failed": false
  },
  "1359": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/PNat/Prime.lean",
    "full_name": "PNat.Coprime.factor_eq_gcd_right_right",
    "start": [
      296,
      1
    ],
    "end": [
      299,
      46
    ],
    "traced_tactics": [
      {
        "tactic": "rw [gcd_comm]",
        "annotated_tactic": [
          "rw [<a>gcd_comm</a>]",
          [
            {
              "full_name": "PNat.gcd_comm",
              "def_path": "Mathlib/Data/PNat/Prime.lean",
              "def_pos": [
                204,
                9
              ],
              "def_end_pos": [
                204,
                17
              ]
            }
          ]
        ],
        "state_before": "a b m n : \u2115+\ncop : m.Coprime n\nam : a \u2223 m\nbn : b \u2223 n\n\u22a2 a = m.gcd (b * a)",
        "state_after": "a b m n : \u2115+\ncop : m.Coprime n\nam : a \u2223 m\nbn : b \u2223 n\n\u22a2 a = (b * a).gcd m"
      },
      {
        "tactic": "apply Coprime.factor_eq_gcd_right cop am bn",
        "annotated_tactic": [
          "apply <a>Coprime.factor_eq_gcd_right</a> cop am bn",
          [
            {
              "full_name": "PNat.Coprime.factor_eq_gcd_right",
              "def_path": "Mathlib/Data/PNat/Prime.lean",
              "def_pos": [
                288,
                9
              ],
              "def_end_pos": [
                288,
                36
              ]
            }
          ]
        ],
        "state_before": "a b m n : \u2115+\ncop : m.Coprime n\nam : a \u2223 m\nbn : b \u2223 n\n\u22a2 a = (b * a).gcd m",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9659123399760574,
    "entry_failed": false
  },
  "17625": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Vector/Basic.lean",
    "full_name": "Vector.append_nil",
    "start": [
      796,
      1
    ],
    "end": [
      797,
      26
    ],
    "traced_tactics": [
      {
        "tactic": "cases xs",
        "annotated_tactic": [
          "cases xs",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nm n : \u2115\nxs : Vector \u03b1 n\nys : Vector \u03b1 m\n\u22a2 xs.append nil = xs",
        "state_after": "case mk\n\u03b1 : Type u_1\nm n : \u2115\nys : Vector \u03b1 m\nval\u271d : List \u03b1\nproperty\u271d : val\u271d.length = n\n\u22a2 append \u27e8val\u271d, property\u271d\u27e9 nil = \u27e8val\u271d, property\u271d\u27e9"
      },
      {
        "tactic": "simp [append]",
        "annotated_tactic": [
          "simp [<a>append</a>]",
          [
            {
              "full_name": "Vector.append",
              "def_path": "Mathlib/Data/Vector/Defs.lean",
              "def_pos": [
                92,
                5
              ],
              "def_end_pos": [
                92,
                11
              ]
            }
          ]
        ],
        "state_before": "case mk\n\u03b1 : Type u_1\nm n : \u2115\nys : Vector \u03b1 m\nval\u271d : List \u03b1\nproperty\u271d : val\u271d.length = n\n\u22a2 append \u27e8val\u271d, property\u271d\u27e9 nil = \u27e8val\u271d, property\u271d\u27e9",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.279352511977777,
    "entry_failed": false
  },
  "24201": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/ConcreteCategory/EpiMono.lean",
    "full_name": "CategoryTheory.ConcreteCategory.surjective_eq_epimorphisms",
    "start": [
      112,
      1
    ],
    "end": [
      115,
      17
    ],
    "traced_tactics": [
      {
        "tactic": "rw [surjective_eq_epimorphisms_iff]",
        "annotated_tactic": [
          "rw [<a>surjective_eq_epimorphisms_iff</a>]",
          [
            {
              "full_name": "CategoryTheory.ConcreteCategory.surjective_eq_epimorphisms_iff",
              "def_path": "Mathlib/CategoryTheory/ConcreteCategory/EpiMono.lean",
              "def_pos": [
                73,
                7
              ],
              "def_end_pos": [
                73,
                37
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : ConcreteCategory C\ninst\u271d : (forget C).PreservesEpimorphisms\n\u22a2 MorphismProperty.surjective C = epimorphisms C",
        "state_after": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : ConcreteCategory C\ninst\u271d : (forget C).PreservesEpimorphisms\n\u22a2 (forget C).PreservesEpimorphisms"
      },
      {
        "tactic": "infer_instance",
        "annotated_tactic": [
          "infer_instance",
          []
        ],
        "state_before": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : ConcreteCategory C\ninst\u271d : (forget C).PreservesEpimorphisms\n\u22a2 (forget C).PreservesEpimorphisms",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.3568789380369708,
    "entry_failed": false
  },
  "11658": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Tactic/NormNum/Basic.lean",
    "full_name": "Mathlib.Meta.NormNum.isintCast",
    "start": [
      125,
      1
    ],
    "end": [
      126,
      63
    ],
    "traced_tactics": [
      {
        "tactic": "rintro \u27e8\u27e8\u27e9\u27e9",
        "annotated_tactic": [
          "rintro \u27e8\u27e8\u27e9\u27e9",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d : Ring R\nn m : \u2124\n\u22a2 IsInt n m \u2192 IsInt (\u2191n) m",
        "state_after": "case mk.refl\nR : Type u_1\ninst\u271d : Ring R\nm : \u2124\n\u22a2 IsInt (\u2191\u2191m) m"
      },
      {
        "tactic": "exact \u27e8rfl\u27e9",
        "annotated_tactic": [
          "exact \u27e8<a>rfl</a>\u27e9",
          [
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "case mk.refl\nR : Type u_1\ninst\u271d : Ring R\nm : \u2124\n\u22a2 IsInt (\u2191\u2191m) m",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.642273116041906,
    "entry_failed": false
  },
  "7949": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/LegendreSymbol/ZModChar.lean",
    "full_name": "ZMod.isQuadratic_\u03c7\u2088",
    "start": [
      142,
      1
    ],
    "end": [
      144,
      9
    ],
    "traced_tactics": [
      {
        "tactic": "unfold MulChar.IsQuadratic",
        "annotated_tactic": [
          "unfold <a>MulChar.IsQuadratic</a>",
          [
            {
              "full_name": "MulChar.IsQuadratic",
              "def_path": "Mathlib/NumberTheory/MulChar/Basic.lean",
              "def_pos": [
                459,
                5
              ],
              "def_end_pos": [
                459,
                16
              ]
            }
          ]
        ],
        "state_before": "\u22a2 \u03c7\u2088.IsQuadratic",
        "state_after": "\u22a2 \u2200 (a : ZMod 8), \u03c7\u2088 a = 0 \u2228 \u03c7\u2088 a = 1 \u2228 \u03c7\u2088 a = -1"
      },
      {
        "tactic": "decide",
        "annotated_tactic": [
          "decide",
          []
        ],
        "state_before": "\u22a2 \u2200 (a : ZMod 8), \u03c7\u2088 a = 0 \u2228 \u03c7\u2088 a = 1 \u2228 \u03c7\u2088 a = -1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.4052125059533864,
    "entry_failed": false
  },
  "25921": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Maps.lean",
    "full_name": "IsOpenMap.isOpen_range",
    "start": [
      337,
      1
    ],
    "end": [
      339,
      25
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 image_univ]",
        "annotated_tactic": [
          "rw [\u2190 <a>image_univ</a>]",
          [
            {
              "full_name": "Set.image_univ",
              "def_path": "Mathlib/Data/Set/Image.lean",
              "def_pos": [
                701,
                9
              ],
              "def_end_pos": [
                701,
                19
              ]
            }
          ]
        ],
        "state_before": "X : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b9 : Type u_4\nf : X \u2192 Y\ng : Y \u2192 Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nhf : IsOpenMap f\n\u22a2 IsOpen (range f)",
        "state_after": "X : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b9 : Type u_4\nf : X \u2192 Y\ng : Y \u2192 Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nhf : IsOpenMap f\n\u22a2 IsOpen (f '' univ)"
      },
      {
        "tactic": "exact hf _ isOpen_univ",
        "annotated_tactic": [
          "exact hf _ <a>isOpen_univ</a>",
          [
            {
              "full_name": "isOpen_univ",
              "def_path": "Mathlib/Topology/Defs/Basic.lean",
              "def_pos": [
                88,
                17
              ],
              "def_end_pos": [
                88,
                28
              ]
            }
          ]
        ],
        "state_before": "X : Type u_1\nY : Type u_2\nZ : Type u_3\n\u03b9 : Type u_4\nf : X \u2192 Y\ng : Y \u2192 Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nhf : IsOpenMap f\n\u22a2 IsOpen (f '' univ)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.7223526429152116,
    "entry_failed": false
  },
  "26916": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Interval/Set/OrderIso.lean",
    "full_name": "OrderIso.preimage_Iio",
    "start": [
      36,
      1
    ],
    "end": [
      38,
      23
    ],
    "traced_tactics": [
      {
        "tactic": "ext x",
        "annotated_tactic": [
          "ext x",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ne : \u03b1 \u2243o \u03b2\nb : \u03b2\n\u22a2 \u21d1e \u207b\u00b9' Iio b = Iio (e.symm b)",
        "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ne : \u03b1 \u2243o \u03b2\nb : \u03b2\nx : \u03b1\n\u22a2 x \u2208 \u21d1e \u207b\u00b9' Iio b \u2194 x \u2208 Iio (e.symm b)"
      },
      {
        "tactic": "simp [\u2190 e.lt_iff_lt]",
        "annotated_tactic": [
          "simp [\u2190 e.lt_iff_lt]",
          []
        ],
        "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ne : \u03b1 \u2243o \u03b2\nb : \u03b2\nx : \u03b1\n\u22a2 x \u2208 \u21d1e \u207b\u00b9' Iio b \u2194 x \u2208 Iio (e.symm b)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.1054545670049265,
    "entry_failed": false
  },
  "17959": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/GroupWithZero/Center.lean",
    "full_name": "Set.div_mem_centralizer\u2080",
    "start": [
      65,
      9
    ],
    "end": [
      68,
      57
    ],
    "traced_tactics": [
      {
        "tactic": "rw [div_eq_mul_inv]",
        "annotated_tactic": [
          "rw [<a>div_eq_mul_inv</a>]",
          [
            {
              "full_name": "div_eq_mul_inv",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                1059,
                9
              ],
              "def_end_pos": [
                1059,
                23
              ]
            }
          ]
        ],
        "state_before": "M\u2080 : Type u_1\nG\u2080 : Type u_2\ninst\u271d : GroupWithZero G\u2080\ns : Set G\u2080\na b : G\u2080\nha : a \u2208 s.centralizer\nhb : b \u2208 s.centralizer\n\u22a2 a / b \u2208 s.centralizer",
        "state_after": "M\u2080 : Type u_1\nG\u2080 : Type u_2\ninst\u271d : GroupWithZero G\u2080\ns : Set G\u2080\na b : G\u2080\nha : a \u2208 s.centralizer\nhb : b \u2208 s.centralizer\n\u22a2 a * b\u207b\u00b9 \u2208 s.centralizer"
      },
      {
        "tactic": "exact mul_mem_centralizer ha (inv_mem_centralizer\u2080 hb)",
        "annotated_tactic": [
          "exact <a>mul_mem_centralizer</a> ha (<a>inv_mem_centralizer\u2080</a> hb)",
          [
            {
              "full_name": "Set.mul_mem_centralizer",
              "def_path": "Mathlib/Algebra/Group/Centralizer.lean",
              "def_pos": [
                66,
                9
              ],
              "def_end_pos": [
                66,
                28
              ]
            },
            {
              "full_name": "Set.inv_mem_centralizer\u2080",
              "def_path": "Mathlib/Algebra/GroupWithZero/Center.lean",
              "def_pos": [
                56,
                17
              ],
              "def_end_pos": [
                56,
                37
              ]
            }
          ]
        ],
        "state_before": "M\u2080 : Type u_1\nG\u2080 : Type u_2\ninst\u271d : GroupWithZero G\u2080\ns : Set G\u2080\na b : G\u2080\nha : a \u2208 s.centralizer\nhb : b \u2208 s.centralizer\n\u22a2 a * b\u207b\u00b9 \u2208 s.centralizer",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.063180101918988,
    "entry_failed": false
  },
  "9028": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Interval/Set/Instances.lean",
    "full_name": "Set.Icc.coe_eq_one",
    "start": [
      89,
      1
    ],
    "end": [
      91,
      24
    ],
    "traced_tactics": [
      {
        "tactic": "symm",
        "annotated_tactic": [
          "symm",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : OrderedSemiring \u03b1\nx : \u2191(Icc 0 1)\n\u22a2 \u2191x = 1 \u2194 x = 1",
        "state_after": "\u03b1 : Type u_1\ninst\u271d : OrderedSemiring \u03b1\nx : \u2191(Icc 0 1)\n\u22a2 x = 1 \u2194 \u2191x = 1"
      },
      {
        "tactic": "exact Subtype.ext_iff",
        "annotated_tactic": [
          "exact <a>Subtype.ext_iff</a>",
          [
            {
              "full_name": "Subtype.ext_iff",
              "def_path": "Mathlib/Data/Subtype.lean",
              "def_pos": [
                78,
                9
              ],
              "def_end_pos": [
                78,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : OrderedSemiring \u03b1\nx : \u2191(Icc 0 1)\n\u22a2 x = 1 \u2194 \u2191x = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4159624309977517,
    "entry_failed": false
  },
  "748": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/Fourier/AddCircle.lean",
    "full_name": "fourier_neg'",
    "start": [
      163,
      1
    ],
    "end": [
      164,
      54
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 neg_smul, \u2190 fourier_apply]",
        "annotated_tactic": [
          "rw [\u2190 <a>neg_smul</a>, \u2190 <a>fourier_apply</a>]",
          [
            {
              "full_name": "neg_smul",
              "def_path": "Mathlib/Algebra/Module/Defs.lean",
              "def_pos": [
                253,
                9
              ],
              "def_end_pos": [
                253,
                17
              ]
            },
            {
              "full_name": "fourier_apply",
              "def_path": "Mathlib/Analysis/Fourier/AddCircle.lean",
              "def_pos": [
                112,
                9
              ],
              "def_end_pos": [
                112,
                22
              ]
            }
          ]
        ],
        "state_before": "T : \u211d\nn : \u2124\nx : AddCircle T\n\u22a2 \u2191(-(n \u2022 x)).toCircle = (starRingEnd \u2102) ((fourier n) x)",
        "state_after": "T : \u211d\nn : \u2124\nx : AddCircle T\n\u22a2 (fourier (-n)) x = (starRingEnd \u2102) ((fourier n) x)"
      },
      {
        "tactic": "exact fourier_neg",
        "annotated_tactic": [
          "exact <a>fourier_neg</a>",
          [
            {
              "full_name": "fourier_neg",
              "def_path": "Mathlib/Analysis/Fourier/AddCircle.lean",
              "def_pos": [
                154,
                9
              ],
              "def_end_pos": [
                154,
                20
              ]
            }
          ]
        ],
        "state_before": "T : \u211d\nn : \u2124\nx : AddCircle T\n\u22a2 (fourier (-n)) x = (starRingEnd \u2102) ((fourier n) x)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.7696078810840845,
    "entry_failed": false
  },
  "8258": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Index.lean",
    "full_name": "Subgroup.relindex_ker",
    "start": [
      282,
      1
    ],
    "end": [
      285,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 MonoidHom.comap_bot, relindex_comap, relindex_bot_left]",
        "annotated_tactic": [
          "rw [\u2190 <a>MonoidHom.comap_bot</a>, <a>relindex_comap</a>, <a>relindex_bot_left</a>]",
          [
            {
              "full_name": "MonoidHom.comap_bot",
              "def_path": "Mathlib/Algebra/Group/Subgroup/Basic.lean",
              "def_pos": [
                2729,
                9
              ],
              "def_end_pos": [
                2729,
                18
              ]
            },
            {
              "full_name": "Subgroup.relindex_comap",
              "def_path": "Mathlib/GroupTheory/Index.lean",
              "def_pos": [
                89,
                9
              ],
              "def_end_pos": [
                89,
                23
              ]
            },
            {
              "full_name": "Subgroup.relindex_bot_left",
              "def_path": "Mathlib/GroupTheory/Index.lean",
              "def_pos": [
                253,
                9
              ],
              "def_end_pos": [
                253,
                26
              ]
            }
          ]
        ],
        "state_before": "G : Type u_1\ninst\u271d\u00b9 : Group G\nH\u271d K\u271d L : Subgroup G\nH : Type u_2\ninst\u271d : Group H\nf : G \u2192* H\nK : Subgroup G\n\u22a2 f.ker.relindex K = Nat.card \u2191(\u21d1f '' \u2191K)",
        "state_after": "G : Type u_1\ninst\u271d\u00b9 : Group G\nH\u271d K\u271d L : Subgroup G\nH : Type u_2\ninst\u271d : Group H\nf : G \u2192* H\nK : Subgroup G\n\u22a2 Nat.card \u21a5(map f K) = Nat.card \u2191(\u21d1f '' \u2191K)"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "G : Type u_1\ninst\u271d\u00b9 : Group G\nH\u271d K\u271d L : Subgroup G\nH : Type u_2\ninst\u271d : Group H\nf : G \u2192* H\nK : Subgroup G\n\u22a2 Nat.card \u21a5(map f K) = Nat.card \u2191(\u21d1f '' \u2191K)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.2633638370316476,
    "entry_failed": false
  },
  "17864": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Perm/Cycle/Concrete.lean",
    "full_name": "Cycle.formPerm_eq_self_of_not_mem",
    "start": [
      173,
      1
    ],
    "end": [
      176,
      54
    ],
    "traced_tactics": [
      {
        "tactic": "induction s using Quot.inductionOn",
        "annotated_tactic": [
          "induction s using <a>Quot.inductionOn</a>",
          [
            {
              "full_name": "Quot.inductionOn",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1495,
                19
              ],
              "def_end_pos": [
                1495,
                30
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns\u271d s' s : Cycle \u03b1\nh : s.Nodup\nx : \u03b1\nhx : x \u2209 s\n\u22a2 (s.formPerm h) x = x",
        "state_after": "case h\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns s' : Cycle \u03b1\nx : \u03b1\na\u271d : List \u03b1\nh : Nodup (Quot.mk Setoid.r a\u271d)\nhx : x \u2209 Quot.mk Setoid.r a\u271d\n\u22a2 (formPerm (Quot.mk Setoid.r a\u271d) h) x = x"
      },
      {
        "tactic": "simpa using List.formPerm_eq_self_of_not_mem _ _ hx",
        "annotated_tactic": [
          "simpa using <a>List.formPerm_eq_self_of_not_mem</a> _ _ hx",
          [
            {
              "full_name": "List.formPerm_eq_self_of_not_mem",
              "def_path": "Mathlib/GroupTheory/Perm/List.lean",
              "def_pos": [
                414,
                9
              ],
              "def_end_pos": [
                414,
                36
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns s' : Cycle \u03b1\nx : \u03b1\na\u271d : List \u03b1\nh : Nodup (Quot.mk Setoid.r a\u271d)\nhx : x \u2209 Quot.mk Setoid.r a\u271d\n\u22a2 (formPerm (Quot.mk Setoid.r a\u271d) h) x = x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.332567366072908,
    "entry_failed": false
  },
  "20546": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/Monoidal/Category.lean",
    "full_name": "CategoryTheory.MonoidalCategory.id_whiskerLeft",
    "start": [
      240,
      1
    ],
    "end": [
      242,
      61
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 assoc, \u2190 leftUnitor_naturality]",
        "annotated_tactic": [
          "rw [\u2190 <a>assoc</a>, \u2190 <a>leftUnitor_naturality</a>]",
          [
            {
              "full_name": "CategoryTheory.Category.assoc",
              "def_path": "Mathlib/CategoryTheory/Category/Basic.lean",
              "def_pos": [
                181,
                3
              ],
              "def_end_pos": [
                181,
                8
              ]
            },
            {
              "full_name": "CategoryTheory.MonoidalCategory.leftUnitor_naturality",
              "def_path": "Mathlib/CategoryTheory/Monoidal/Category.lean",
              "def_pos": [
                184,
                3
              ],
              "def_end_pos": [
                184,
                24
              ]
            }
          ]
        ],
        "state_before": "C : Type u\n\ud835\udc9e : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nX Y : C\nf : X \u27f6 Y\n\u22a2 \ud835\udfd9_ C \u25c1 f = (\u03bb_ X).hom \u226b f \u226b (\u03bb_ Y).inv",
        "state_after": "C : Type u\n\ud835\udc9e : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nX Y : C\nf : X \u27f6 Y\n\u22a2 \ud835\udfd9_ C \u25c1 f = (\ud835\udfd9_ C \u25c1 f \u226b (\u03bb_ Y).hom) \u226b (\u03bb_ Y).inv"
      },
      {
        "tactic": "simp [id_tensorHom]",
        "annotated_tactic": [
          "simp [<a>id_tensorHom</a>]",
          [
            {
              "full_name": "CategoryTheory.MonoidalCategory.id_tensorHom",
              "def_path": "Mathlib/CategoryTheory/Monoidal/Category.lean",
              "def_pos": [
                225,
                9
              ],
              "def_end_pos": [
                225,
                21
              ]
            }
          ]
        ],
        "state_before": "C : Type u\n\ud835\udc9e : Category.{v, u} C\ninst\u271d : MonoidalCategory C\nX Y : C\nf : X \u27f6 Y\n\u22a2 \ud835\udfd9_ C \u25c1 f = (\ud835\udfd9_ C \u25c1 f \u226b (\u03bb_ Y).hom) \u226b (\u03bb_ Y).inv",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.6374793449649587,
    "entry_failed": false
  },
  "18936": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Finset/Powerset.lean",
    "full_name": "Finset.powersetCard_eq_filter",
    "start": [
      254,
      1
    ],
    "end": [
      257,
      26
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d : Finset \u03b1\nn\u271d : ?m.20896\ns\u271d t : Finset \u03b1\nn : \u2115\ns : Finset \u03b1\n\u22a2 powersetCard n s = filter (fun x => x.card = n) s.powerset",
        "state_after": "case a\n\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d : Finset \u03b1\nn\u271d : ?m.20896\ns\u271d t : Finset \u03b1\nn : \u2115\ns a\u271d : Finset \u03b1\n\u22a2 a\u271d \u2208 powersetCard n s \u2194 a\u271d \u2208 filter (fun x => x.card = n) s.powerset"
      },
      {
        "tactic": "simp [mem_powersetCard]",
        "annotated_tactic": [
          "simp [<a>mem_powersetCard</a>]",
          [
            {
              "full_name": "Finset.mem_powersetCard",
              "def_path": "Mathlib/Data/Finset/Powerset.lean",
              "def_pos": [
                203,
                15
              ],
              "def_end_pos": [
                203,
                31
              ]
            }
          ]
        ],
        "state_before": "case a\n\u03b1 : Type u_1\ns\u271d\u00b9 t\u271d : Finset \u03b1\nn\u271d : ?m.20896\ns\u271d t : Finset \u03b1\nn : \u2115\ns a\u271d : Finset \u03b1\n\u22a2 a\u271d \u2208 powersetCard n s \u2194 a\u271d \u2208 filter (fun x => x.card = n) s.powerset",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.3805717199575156,
    "entry_failed": false
  },
  "684": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Directed.lean",
    "full_name": "directedOn_pair'",
    "start": [
      254,
      1
    ],
    "end": [
      257,
      30
    ],
    "traced_tactics": [
      {
        "tactic": "rw [Set.pair_comm]",
        "annotated_tactic": [
          "rw [<a>Set.pair_comm</a>]",
          [
            {
              "full_name": "Set.pair_comm",
              "def_path": "Mathlib/Data/Set/Basic.lean",
              "def_pos": [
                2069,
                9
              ],
              "def_end_pos": [
                2069,
                18
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\nr r' s : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : Reflexive r\na b : \u03b1\nhab : r a b\n\u22a2 DirectedOn r {b, a}",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\nr r' s : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : Reflexive r\na b : \u03b1\nhab : r a b\n\u22a2 DirectedOn r {a, b}"
      },
      {
        "tactic": "apply directedOn_pair h hab",
        "annotated_tactic": [
          "apply <a>directedOn_pair</a> h hab",
          [
            {
              "full_name": "directedOn_pair",
              "def_path": "Mathlib/Order/Directed.lean",
              "def_pos": [
                250,
                9
              ],
              "def_end_pos": [
                250,
                24
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\nr r' s : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : Reflexive r\na b : \u03b1\nhab : r a b\n\u22a2 DirectedOn r {a, b}",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8127132210647687,
    "entry_failed": false
  },
  "189": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/EqToHom.lean",
    "full_name": "CategoryTheory.eqToIso_trans",
    "start": [
      169,
      1
    ],
    "end": [
      170,
      65
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "C : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\n\u03b2 : Sort u_1\nX Y Z : C\np : X = Y\nq : Y = Z\n\u22a2 eqToIso p \u226a\u226b eqToIso q = eqToIso \u22ef",
        "state_after": "case w\nC : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\n\u03b2 : Sort u_1\nX Y Z : C\np : X = Y\nq : Y = Z\n\u22a2 (eqToIso p \u226a\u226b eqToIso q).hom = (eqToIso \u22ef).hom"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case w\nC : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\n\u03b2 : Sort u_1\nX Y Z : C\np : X = Y\nq : Y = Z\n\u22a2 (eqToIso p \u226a\u226b eqToIso q).hom = (eqToIso \u22ef).hom",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4942797250114381,
    "entry_failed": false
  },
  "13591": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Ring/NegOnePow.lean",
    "full_name": "Int.negOnePow_even",
    "start": [
      39,
      1
    ],
    "end": [
      41,
      37
    ],
    "traced_tactics": [
      {
        "tactic": "obtain \u27e8k, rfl\u27e9 := hn",
        "annotated_tactic": [
          "obtain \u27e8k, rfl\u27e9 := hn",
          []
        ],
        "state_before": "n : \u2124\nhn : Even n\n\u22a2 n.negOnePow = 1",
        "state_after": "case intro\nk : \u2124\n\u22a2 (k + k).negOnePow = 1"
      },
      {
        "tactic": "rw [negOnePow_add, units_mul_self]",
        "annotated_tactic": [
          "rw [<a>negOnePow_add</a>, <a>units_mul_self</a>]",
          [
            {
              "full_name": "Int.negOnePow_add",
              "def_path": "Mathlib/Algebra/Ring/NegOnePow.lean",
              "def_pos": [
                26,
                7
              ],
              "def_end_pos": [
                26,
                20
              ]
            },
            {
              "full_name": "Int.units_mul_self",
              "def_path": "Mathlib/Data/Int/Order/Units.lean",
              "def_pos": [
                33,
                9
              ],
              "def_end_pos": [
                33,
                23
              ]
            }
          ]
        ],
        "state_before": "case intro\nk : \u2124\n\u22a2 (k + k).negOnePow = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2778809960000217,
    "entry_failed": false
  },
  "13583": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Matroid/Basic.lean",
    "full_name": "Matroid.setOf_indep_eq",
    "start": [
      476,
      1
    ],
    "end": [
      478,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "simp_rw [indep_iff]",
        "annotated_tactic": [
          "simp_rw [<a>indep_iff</a>]",
          [
            {
              "full_name": "Matroid.indep_iff",
              "def_path": "Mathlib/Data/Matroid/Basic.lean",
              "def_pos": [
                473,
                9
              ],
              "def_end_pos": [
                473,
                18
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nM\u271d M : Matroid \u03b1\n\u22a2 {I | M.Indep I} = \u2191(lowerClosure {B | M.Base B})",
        "state_after": "\u03b1 : Type u_1\nM\u271d M : Matroid \u03b1\n\u22a2 {I | \u2203 B, M.Base B \u2227 I \u2286 B} = \u2191(lowerClosure {B | M.Base B})"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nM\u271d M : Matroid \u03b1\n\u22a2 {I | \u2203 B, M.Base B \u2227 I \u2286 B} = \u2191(lowerClosure {B | M.Base B})",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.382623177021742,
    "entry_failed": false
  },
  "11952": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/WittVector/Identities.lean",
    "full_name": "WittVector.p_nonzero",
    "start": [
      90,
      1
    ],
    "end": [
      92,
      64
    ],
    "traced_tactics": [
      {
        "tactic": "intro h",
        "annotated_tactic": [
          "intro h",
          []
        ],
        "state_before": "p : \u2115\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : CharP R p\n\u22a2 \u2191p \u2260 0",
        "state_after": "p : \u2115\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : CharP R p\nh : \u2191p = 0\n\u22a2 False"
      },
      {
        "tactic": "simpa only [h, zero_coeff, zero_ne_one] using coeff_p_one p R",
        "annotated_tactic": [
          "simpa only [h, <a>zero_coeff</a>, <a>zero_ne_one</a>] using <a>coeff_p_one</a> p R",
          [
            {
              "full_name": "WittVector.zero_coeff",
              "def_path": "Mathlib/RingTheory/WittVector/Defs.lean",
              "def_pos": [
                328,
                9
              ],
              "def_end_pos": [
                328,
                19
              ]
            },
            {
              "full_name": "zero_ne_one",
              "def_path": "Mathlib/Algebra/NeZero.lean",
              "def_pos": [
                55,
                15
              ],
              "def_end_pos": [
                55,
                26
              ]
            },
            {
              "full_name": "WittVector.coeff_p_one",
              "def_path": "Mathlib/RingTheory/WittVector/Identities.lean",
              "def_pos": [
                87,
                9
              ],
              "def_end_pos": [
                87,
                20
              ]
            }
          ]
        ],
        "state_before": "p : \u2115\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : CharP R p\nh : \u2191p = 0\n\u22a2 False",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.183963725925423,
    "entry_failed": false
  },
  "2986": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Group/Centralizer.lean",
    "full_name": "Set.div_mem_centralizer",
    "start": [
      79,
      1
    ],
    "end": [
      82,
      56
    ],
    "traced_tactics": [
      {
        "tactic": "rw [div_eq_mul_inv]",
        "annotated_tactic": [
          "rw [<a>div_eq_mul_inv</a>]",
          [
            {
              "full_name": "div_eq_mul_inv",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                1059,
                9
              ],
              "def_end_pos": [
                1059,
                23
              ]
            }
          ]
        ],
        "state_before": "M : Type u_1\nS T : Set M\na b : M\ninst\u271d : Group M\nha : a \u2208 S.centralizer\nhb : b \u2208 S.centralizer\n\u22a2 a / b \u2208 S.centralizer",
        "state_after": "M : Type u_1\nS T : Set M\na b : M\ninst\u271d : Group M\nha : a \u2208 S.centralizer\nhb : b \u2208 S.centralizer\n\u22a2 a * b\u207b\u00b9 \u2208 S.centralizer"
      },
      {
        "tactic": "exact mul_mem_centralizer ha (inv_mem_centralizer hb)",
        "annotated_tactic": [
          "exact <a>mul_mem_centralizer</a> ha (<a>inv_mem_centralizer</a> hb)",
          [
            {
              "full_name": "Set.mul_mem_centralizer",
              "def_path": "Mathlib/Algebra/Group/Centralizer.lean",
              "def_pos": [
                66,
                9
              ],
              "def_end_pos": [
                66,
                28
              ]
            },
            {
              "full_name": "Set.inv_mem_centralizer",
              "def_path": "Mathlib/Algebra/Group/Centralizer.lean",
              "def_pos": [
                73,
                9
              ],
              "def_end_pos": [
                73,
                28
              ]
            }
          ]
        ],
        "state_before": "M : Type u_1\nS T : Set M\na b : M\ninst\u271d : Group M\nha : a \u2208 S.centralizer\nhb : b \u2208 S.centralizer\n\u22a2 a * b\u207b\u00b9 \u2208 S.centralizer",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.161286975024268,
    "entry_failed": false
  },
  "1047": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Set/Finite.lean",
    "full_name": "Set.Finite.toFinset_eq_toFinset",
    "start": [
      105,
      1
    ],
    "end": [
      110,
      29
    ],
    "traced_tactics": [
      {
        "tactic": "have : h.fintype = \u2039_\u203a := Subsingleton.elim _ _",
        "annotated_tactic": [
          "have : h.fintype = \u2039_\u203a := <a>Subsingleton.elim</a> _ _",
          [
            {
              "full_name": "Subsingleton.elim",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1015,
                19
              ],
              "def_end_pos": [
                1015,
                36
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns : Set \u03b1\ninst\u271d : Fintype \u2191s\nh : s.Finite\n\u22a2 h.toFinset = s.toFinset",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns : Set \u03b1\ninst\u271d : Fintype \u2191s\nh : s.Finite\nthis : h.fintype = inst\u271d\n\u22a2 h.toFinset = s.toFinset"
      },
      {
        "tactic": "rw [Finite.toFinset, this]",
        "annotated_tactic": [
          "rw [<a>Finite.toFinset</a>, this]",
          [
            {
              "full_name": "Set.Finite.toFinset",
              "def_path": "Mathlib/Data/Set/Finite.lean",
              "def_pos": [
                101,
                29
              ],
              "def_end_pos": [
                101,
                44
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Sort w\n\u03b3 : Type x\ns : Set \u03b1\ninst\u271d : Fintype \u2191s\nh : s.Finite\nthis : h.fintype = inst\u271d\n\u22a2 h.toFinset = s.toFinset",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.253444868023507,
    "entry_failed": false
  },
  "4132": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/OuterMeasure/AE.lean",
    "full_name": "MeasureTheory.inter_ae_eq_left_of_ae_eq_univ",
    "start": [
      231,
      1
    ],
    "end": [
      233,
      18
    ],
    "traced_tactics": [
      {
        "tactic": "convert ae_eq_set_inter (ae_eq_refl s) h",
        "annotated_tactic": [
          "convert <a>ae_eq_set_inter</a> (<a>ae_eq_refl</a> s) h",
          [
            {
              "full_name": "MeasureTheory.ae_eq_set_inter",
              "def_path": "Mathlib/MeasureTheory/OuterMeasure/AE.lean",
              "def_pos": [
                197,
                9
              ],
              "def_end_pos": [
                197,
                24
              ]
            },
            {
              "full_name": "MeasureTheory.ae_eq_refl",
              "def_path": "Mathlib/MeasureTheory/OuterMeasure/AE.lean",
              "def_pos": [
                120,
                9
              ],
              "def_end_pos": [
                120,
                19
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nF : Type u_3\ninst\u271d\u00b9 : FunLike F (Set \u03b1) \u211d\u22650\u221e\ninst\u271d : OuterMeasureClass F \u03b1\n\u03bc : F\ns t : Set \u03b1\nh : t =\u1da0[ae \u03bc] univ\n\u22a2 s \u2229 t =\u1da0[ae \u03bc] s",
        "state_after": "case h.e'_5\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nF : Type u_3\ninst\u271d\u00b9 : FunLike F (Set \u03b1) \u211d\u22650\u221e\ninst\u271d : OuterMeasureClass F \u03b1\n\u03bc : F\ns t : Set \u03b1\nh : t =\u1da0[ae \u03bc] univ\n\u22a2 s = s \u2229 univ"
      },
      {
        "tactic": "rw [inter_univ]",
        "annotated_tactic": [
          "rw [<a>inter_univ</a>]",
          [
            {
              "full_name": "Set.inter_univ",
              "def_path": "Mathlib/Data/Set/Basic.lean",
              "def_pos": [
                981,
                9
              ],
              "def_end_pos": [
                981,
                19
              ]
            }
          ]
        ],
        "state_before": "case h.e'_5\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nF : Type u_3\ninst\u271d\u00b9 : FunLike F (Set \u03b1) \u211d\u22650\u221e\ninst\u271d : OuterMeasureClass F \u03b1\n\u03bc : F\ns t : Set \u03b1\nh : t =\u1da0[ae \u03bc] univ\n\u22a2 s = s \u2229 univ",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.287253088899888,
    "entry_failed": false
  },
  "14569": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Cardinal/ENat.lean",
    "full_name": "Cardinal.zero_eq_ofENat",
    "start": [
      109,
      1
    ],
    "end": [
      109,
      98
    ],
    "traced_tactics": [
      {
        "tactic": "norm_cast",
        "annotated_tactic": [
          "norm_cast",
          []
        ],
        "state_before": "m : \u2115\u221e\n\u22a2 0 = \u2191m \u2194 m = 0",
        "state_after": "m : \u2115\u221e\n\u22a2 0 = m \u2194 m = 0"
      },
      {
        "tactic": "apply eq_comm",
        "annotated_tactic": [
          "apply <a>eq_comm</a>",
          [
            {
              "full_name": "eq_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                811,
                9
              ],
              "def_end_pos": [
                811,
                16
              ]
            }
          ]
        ],
        "state_before": "m : \u2115\u221e\n\u22a2 0 = m \u2194 m = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.0653447710210457,
    "entry_failed": false
  },
  "7335": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Irreducible.lean",
    "full_name": "InfPrime.ne_top",
    "start": [
      204,
      1
    ],
    "end": [
      204,
      94
    ],
    "traced_tactics": [
      {
        "tactic": "rintro rfl",
        "annotated_tactic": [
          "rintro rfl",
          []
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : SemilatticeInf \u03b1\na b c : \u03b1\ninst\u271d : OrderTop \u03b1\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nha : InfPrime a\n\u22a2 a \u2260 \u22a4",
        "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : SemilatticeInf \u03b1\nb c : \u03b1\ninst\u271d : OrderTop \u03b1\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nha : InfPrime \u22a4\n\u22a2 False"
      },
      {
        "tactic": "exact not_infPrime_top ha",
        "annotated_tactic": [
          "exact <a>not_infPrime_top</a> ha",
          [
            {
              "full_name": "not_infPrime_top",
              "def_path": "Mathlib/Order/Irreducible.lean",
              "def_pos": [
                197,
                9
              ],
              "def_end_pos": [
                197,
                25
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : SemilatticeInf \u03b1\nb c : \u03b1\ninst\u271d : OrderTop \u03b1\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\nha : InfPrime \u22a4\n\u22a2 False",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.2417742561083287,
    "entry_failed": false
  },
  "21113": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Index.lean",
    "full_name": "Subgroup.dvd_index_map",
    "start": [
      341,
      1
    ],
    "end": [
      344,
      22
    ],
    "traced_tactics": [
      {
        "tactic": "rw [index_map, sup_of_le_left hf]",
        "annotated_tactic": [
          "rw [<a>index_map</a>, <a>sup_of_le_left</a> hf]",
          [
            {
              "full_name": "Subgroup.index_map",
              "def_path": "Mathlib/GroupTheory/Index.lean",
              "def_pos": [
                326,
                9
              ],
              "def_end_pos": [
                326,
                18
              ]
            },
            {
              "full_name": "sup_of_le_left",
              "def_path": "Mathlib/Order/Lattice.lean",
              "def_pos": [
                173,
                11
              ],
              "def_end_pos": [
                173,
                25
              ]
            }
          ]
        ],
        "state_before": "G : Type u_1\ninst\u271d\u00b9 : Group G\nH K L : Subgroup G\nG' : Type u_2\ninst\u271d : Group G'\nf : G \u2192* G'\nhf : f.ker \u2264 H\n\u22a2 H.index \u2223 (map f H).index",
        "state_after": "G : Type u_1\ninst\u271d\u00b9 : Group G\nH K L : Subgroup G\nG' : Type u_2\ninst\u271d : Group G'\nf : G \u2192* G'\nhf : f.ker \u2264 H\n\u22a2 H.index \u2223 H.index * f.range.index"
      },
      {
        "tactic": "apply dvd_mul_right",
        "annotated_tactic": [
          "apply <a>dvd_mul_right</a>",
          [
            {
              "full_name": "dvd_mul_right",
              "def_path": "Mathlib/Algebra/Divisibility/Basic.lean",
              "def_pos": [
                83,
                9
              ],
              "def_end_pos": [
                83,
                22
              ]
            }
          ]
        ],
        "state_before": "G : Type u_1\ninst\u271d\u00b9 : Group G\nH K L : Subgroup G\nG' : Type u_2\ninst\u271d : Group G'\nf : G \u2192* G'\nhf : f.ker \u2264 H\n\u22a2 H.index \u2223 H.index * f.range.index",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.7498277300037444,
    "entry_failed": false
  },
  "28717": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/Measure/Trim.lean",
    "full_name": "MeasureTheory.le_trim",
    "start": [
      57,
      1
    ],
    "end": [
      59,
      38
    ],
    "traced_tactics": [
      {
        "tactic": "simp_rw [Measure.trim]",
        "annotated_tactic": [
          "simp_rw [<a>Measure.trim</a>]",
          [
            {
              "full_name": "MeasureTheory.Measure.trim",
              "def_path": "Mathlib/MeasureTheory/Measure/Trim.lean",
              "def_pos": [
                32,
                5
              ],
              "def_end_pos": [
                32,
                17
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nm m0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns : Set \u03b1\nhm : m \u2264 m0\n\u22a2 \u03bc s \u2264 (\u03bc.trim hm) s",
        "state_after": "\u03b1 : Type u_1\nm m0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns : Set \u03b1\nhm : m \u2264 m0\n\u22a2 \u03bc s \u2264 (\u03bc.toMeasure \u22ef) s"
      },
      {
        "tactic": "exact @le_toMeasure_apply _ m _ _ _",
        "annotated_tactic": [
          "exact @<a>le_toMeasure_apply</a> _ m _ _ _",
          [
            {
              "full_name": "MeasureTheory.le_toMeasure_apply",
              "def_path": "Mathlib/MeasureTheory/Measure/MeasureSpace.lean",
              "def_pos": [
                743,
                9
              ],
              "def_end_pos": [
                743,
                27
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nm m0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns : Set \u03b1\nhm : m \u2264 m0\n\u22a2 \u03bc s \u2264 (\u03bc.toMeasure \u22ef) s",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6622472029412165,
    "entry_failed": false
  },
  "5537": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Dist.lean",
    "full_name": "Nat.dist_add_add_left",
    "start": [
      81,
      1
    ],
    "end": [
      82,
      60
    ],
    "traced_tactics": [
      {
        "tactic": "rw [add_comm k n, add_comm k m]",
        "annotated_tactic": [
          "rw [<a>add_comm</a> k n, <a>add_comm</a> k m]",
          [
            {
              "full_name": "add_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                331,
                3
              ],
              "def_end_pos": [
                331,
                14
              ]
            },
            {
              "full_name": "add_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                331,
                3
              ],
              "def_end_pos": [
                331,
                14
              ]
            }
          ]
        ],
        "state_before": "k n m : \u2115\n\u22a2 (k + n).dist (k + m) = n.dist m",
        "state_after": "k n m : \u2115\n\u22a2 (n + k).dist (m + k) = n.dist m"
      },
      {
        "tactic": "apply dist_add_add_right",
        "annotated_tactic": [
          "apply <a>dist_add_add_right</a>",
          [
            {
              "full_name": "Nat.dist_add_add_right",
              "def_path": "Mathlib/Data/Nat/Dist.lean",
              "def_pos": [
                74,
                9
              ],
              "def_end_pos": [
                74,
                27
              ]
            }
          ]
        ],
        "state_before": "k n m : \u2115\n\u22a2 (n + k).dist (m + k) = n.dist m",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.420946942991577,
    "entry_failed": false
  },
  "27863": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/BooleanAlgebra.lean",
    "full_name": "sdiff_eq_right",
    "start": [
      330,
      1
    ],
    "end": [
      331,
      46
    ],
    "traced_tactics": [
      {
        "tactic": "rw [disjoint_sdiff_self_left.eq_iff]",
        "annotated_tactic": [
          "rw [disjoint_sdiff_self_left.eq_iff]",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\nw x y z : \u03b1\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\n\u22a2 x \\ y = y \u2194 x = \u22a5 \u2227 y = \u22a5",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type u_1\nw x y z : \u03b1\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\n\u22a2 x \\ y = \u22a5 \u2227 y = \u22a5 \u2194 x = \u22a5 \u2227 y = \u22a5"
      },
      {
        "tactic": "aesop",
        "annotated_tactic": [
          "aesop",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\nw x y z : \u03b1\ninst\u271d : GeneralizedBooleanAlgebra \u03b1\n\u22a2 x \\ y = \u22a5 \u2227 y = \u22a5 \u2194 x = \u22a5 \u2227 y = \u22a5",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.902167635038495,
    "entry_failed": false
  },
  "19625": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Bits.lean",
    "full_name": "Nat.bit1_mod_two",
    "start": [
      398,
      1
    ],
    "end": [
      400,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "rw [Nat.mod_two_of_bodd]",
        "annotated_tactic": [
          "rw [<a>Nat.mod_two_of_bodd</a>]",
          [
            {
              "full_name": "Nat.mod_two_of_bodd",
              "def_path": "Mathlib/Data/Nat/Bits.lean",
              "def_pos": [
                89,
                7
              ],
              "def_end_pos": [
                89,
                22
              ]
            }
          ]
        ],
        "state_before": "m n : \u2115\n\u22a2 bit1 n % 2 = 1",
        "state_after": "m n : \u2115\n\u22a2 (bif (bit1 n).bodd then 1 else 0) = 1"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "m n : \u2115\n\u22a2 (bif (bit1 n).bodd then 1 else 0) = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.1130666059907526,
    "entry_failed": false
  },
  "12146": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Field/Basic.lean",
    "full_name": "inv_mul_lt_iff",
    "start": [
      117,
      1
    ],
    "end": [
      119,
      22
    ],
    "traced_tactics": [
      {
        "tactic": "rw [inv_eq_one_div, mul_comm, \u2190 div_eq_mul_one_div]",
        "annotated_tactic": [
          "rw [<a>inv_eq_one_div</a>, <a>mul_comm</a>, \u2190 <a>div_eq_mul_one_div</a>]",
          [
            {
              "full_name": "inv_eq_one_div",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                445,
                9
              ],
              "def_end_pos": [
                445,
                23
              ]
            },
            {
              "full_name": "mul_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                332,
                9
              ],
              "def_end_pos": [
                332,
                17
              ]
            },
            {
              "full_name": "div_eq_mul_one_div",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                479,
                9
              ],
              "def_end_pos": [
                479,
                27
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nh : 0 < b\n\u22a2 b\u207b\u00b9 * a < c \u2194 a < b * c",
        "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nh : 0 < b\n\u22a2 a / b < c \u2194 a < b * c"
      },
      {
        "tactic": "exact div_lt_iff' h",
        "annotated_tactic": [
          "exact <a>div_lt_iff'</a> h",
          [
            {
              "full_name": "div_lt_iff'",
              "def_path": "Mathlib/Algebra/Order/Field/Basic.lean",
              "def_pos": [
                93,
                9
              ],
              "def_end_pos": [
                93,
                20
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nh : 0 < b\n\u22a2 a / b < c \u2194 a < b * c",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.2342259999131784,
    "entry_failed": false
  },
  "11082": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/ModularLattice.lean",
    "full_name": "covBy_sup_of_inf_covBy_of_inf_covBy_right",
    "start": [
      103,
      1
    ],
    "end": [
      105,
      68
    ],
    "traced_tactics": [
      {
        "tactic": "rw [inf_comm, sup_comm]",
        "annotated_tactic": [
          "rw [<a>inf_comm</a>, <a>sup_comm</a>]",
          [
            {
              "full_name": "inf_comm",
              "def_path": "Mathlib/Order/Lattice.lean",
              "def_pos": [
                461,
                9
              ],
              "def_end_pos": [
                461,
                17
              ]
            },
            {
              "full_name": "sup_comm",
              "def_path": "Mathlib/Order/Lattice.lean",
              "def_pos": [
                224,
                9
              ],
              "def_end_pos": [
                224,
                17
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : IsWeakUpperModularLattice \u03b1\na b : \u03b1\n\u22a2 a \u2293 b \u22d6 a \u2192 a \u2293 b \u22d6 b \u2192 b \u22d6 a \u2294 b",
        "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : IsWeakUpperModularLattice \u03b1\na b : \u03b1\n\u22a2 b \u2293 a \u22d6 a \u2192 b \u2293 a \u22d6 b \u2192 b \u22d6 b \u2294 a"
      },
      {
        "tactic": "exact fun ha hb => covBy_sup_of_inf_covBy_of_inf_covBy_left hb ha",
        "annotated_tactic": [
          "exact fun ha hb => <a>covBy_sup_of_inf_covBy_of_inf_covBy_left</a> hb ha",
          [
            {
              "full_name": "covBy_sup_of_inf_covBy_of_inf_covBy_left",
              "def_path": "Mathlib/Order/ModularLattice.lean",
              "def_pos": [
                99,
                9
              ],
              "def_end_pos": [
                99,
                49
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : IsWeakUpperModularLattice \u03b1\na b : \u03b1\n\u22a2 b \u2293 a \u22d6 a \u2192 b \u2293 a \u22d6 b \u2192 b \u22d6 b \u2294 a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.291909217950888,
    "entry_failed": false
  },
  "27988": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Ring/Ext.lean",
    "full_name": "Ring.toNonUnitalRing_injective",
    "start": [
      375,
      1
    ],
    "end": [
      380,
      39
    ],
    "traced_tactics": [
      {
        "tactic": "intro _ _ h",
        "annotated_tactic": [
          "intro _ _ h",
          []
        ],
        "state_before": "R : Type u\n\u22a2 Function.Injective (@toNonUnitalRing R)",
        "state_after": "R : Type u\na\u2081\u271d a\u2082\u271d : Ring R\nh : toNonUnitalRing = toNonUnitalRing\n\u22a2 a\u2081\u271d = a\u2082\u271d"
      },
      {
        "tactic": "ext x y",
        "annotated_tactic": [
          "ext x y",
          []
        ],
        "state_before": "R : Type u\na\u2081\u271d a\u2082\u271d : Ring R\nh : toNonUnitalRing = toNonUnitalRing\n\u22a2 a\u2081\u271d = a\u2082\u271d",
        "state_after": "case h_add.h.h\nR : Type u\na\u2081\u271d a\u2082\u271d : Ring R\nh : toNonUnitalRing = toNonUnitalRing\nx y : R\n\u22a2 x + y = x + y\n\ncase h_mul.h.h\nR : Type u\na\u2081\u271d a\u2082\u271d : Ring R\nh : toNonUnitalRing = toNonUnitalRing\nx y : R\n\u22a2 x * y = x * y"
      }
    ],
    "entry_time": 2.3110044490313157,
    "entry_failed": false
  },
  "20120": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/LinearAlgebra/Dimension/Finrank.lean",
    "full_name": "finrank_top",
    "start": [
      140,
      1
    ],
    "end": [
      142,
      18
    ],
    "traced_tactics": [
      {
        "tactic": "unfold finrank",
        "annotated_tactic": [
          "unfold <a>finrank</a>",
          [
            {
              "full_name": "FiniteDimensional.finrank",
              "def_path": "Mathlib/LinearAlgebra/Dimension/Finrank.lean",
              "def_pos": [
                54,
                19
              ],
              "def_end_pos": [
                54,
                26
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nM : Type v\nN : Type w\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module R N\n\u22a2 finrank R \u21a5\u22a4 = finrank R M",
        "state_after": "R : Type u\nM : Type v\nN : Type w\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module R N\n\u22a2 toNat (Module.rank R \u21a5\u22a4) = toNat (Module.rank R M)"
      },
      {
        "tactic": "simp [rank_top]",
        "annotated_tactic": [
          "simp [<a>rank_top</a>]",
          [
            {
              "full_name": "rank_top",
              "def_path": "Mathlib/LinearAlgebra/Dimension/Basic.lean",
              "def_pos": [
                330,
                9
              ],
              "def_end_pos": [
                330,
                17
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nM : Type v\nN : Type w\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module R N\n\u22a2 toNat (Module.rank R \u21a5\u22a4) = toNat (Module.rank R M)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.077714824001305,
    "entry_failed": false
  },
  "20079": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Finsupp/Multiset.lean",
    "full_name": "Multiset.toFinsupp_union",
    "start": [
      186,
      1
    ],
    "end": [
      188,
      20
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t : Multiset \u03b1\n\u22a2 toFinsupp (s \u222a t) = toFinsupp s \u2294 toFinsupp t",
        "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t : Multiset \u03b1\na\u271d : \u03b1\n\u22a2 (toFinsupp (s \u222a t)) a\u271d = (toFinsupp s \u2294 toFinsupp t) a\u271d"
      },
      {
        "tactic": "simp [sup_eq_max]",
        "annotated_tactic": [
          "simp [<a>sup_eq_max</a>]",
          [
            {
              "full_name": "sup_eq_max",
              "def_path": "Mathlib/Order/Lattice.lean",
              "def_pos": [
                785,
                9
              ],
              "def_end_pos": [
                785,
                19
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t : Multiset \u03b1\na\u271d : \u03b1\n\u22a2 (toFinsupp (s \u222a t)) a\u271d = (toFinsupp s \u2294 toFinsupp t) a\u271d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.6424361299723387,
    "entry_failed": false
  },
  "2768": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/Subobject/Basic.lean",
    "full_name": "CategoryTheory.Subobject.arrow_congr",
    "start": [
      210,
      1
    ],
    "end": [
      213,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "induction h",
        "annotated_tactic": [
          "induction h",
          []
        ],
        "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nX\u271d Y\u271d Z : C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nA : C\nX Y : Subobject A\nh : X = Y\n\u22a2 eqToHom \u22ef \u226b Y.arrow = X.arrow",
        "state_after": "case refl\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nX\u271d Y\u271d Z : C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nA : C\nX Y : Subobject A\n\u22a2 eqToHom \u22ef \u226b X.arrow = X.arrow"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case refl\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nX\u271d Y\u271d Z : C\nD : Type u\u2082\ninst\u271d : Category.{v\u2082, u\u2082} D\nA : C\nX Y : Subobject A\n\u22a2 eqToHom \u22ef \u226b X.arrow = X.arrow",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8919231380568817,
    "entry_failed": false
  },
  "21262": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Polynomial/UnitTrinomial.lean",
    "full_name": "Polynomial.trinomial_monic",
    "start": [
      105,
      1
    ],
    "end": [
      107,
      51
    ],
    "traced_tactics": [
      {
        "tactic": "nontriviality R",
        "annotated_tactic": [
          "nontriviality R",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d : Semiring R\nk m n : \u2115\nu v w : R\nhkm : k < m\nhmn : m < n\n\u22a2 (trinomial k m n u v 1).Monic",
        "state_after": "R : Type u_1\ninst\u271d : Semiring R\nk m n : \u2115\nu v w : R\nhkm : k < m\nhmn : m < n\na\u271d : Nontrivial R\n\u22a2 (trinomial k m n u v 1).Monic"
      },
      {
        "tactic": "exact trinomial_leadingCoeff hkm hmn one_ne_zero",
        "annotated_tactic": [
          "exact <a>trinomial_leadingCoeff</a> hkm hmn <a>one_ne_zero</a>",
          [
            {
              "full_name": "Polynomial.trinomial_leadingCoeff",
              "def_path": "Mathlib/Algebra/Polynomial/UnitTrinomial.lean",
              "def_pos": [
                95,
                9
              ],
              "def_end_pos": [
                95,
                31
              ]
            },
            {
              "full_name": "one_ne_zero",
              "def_path": "Mathlib/Algebra/NeZero.lean",
              "def_pos": [
                58,
                15
              ],
              "def_end_pos": [
                58,
                26
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d : Semiring R\nk m n : \u2115\nu v w : R\nhkm : k < m\nhmn : m < n\na\u271d : Nontrivial R\n\u22a2 (trinomial k m n u v 1).Monic",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.7643347160192207,
    "entry_failed": false
  },
  "24915": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Monoid/NatCast.lean",
    "full_name": "zero_lt_three",
    "start": [
      74,
      1
    ],
    "end": [
      77,
      55
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 two_add_one_eq_three]",
        "annotated_tactic": [
          "rw [\u2190 <a>two_add_one_eq_three</a>]",
          [
            {
              "full_name": "two_add_one_eq_three",
              "def_path": "Mathlib/Data/Nat/Cast/Defs.lean",
              "def_pos": [
                237,
                9
              ],
              "def_end_pos": [
                237,
                29
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u2074 : AddMonoidWithOne \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : ZeroLEOneClass \u03b1\ninst\u271d\u00b9 : NeZero 1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\n\u22a2 0 < 3",
        "state_after": "\u03b1 : Type u_1\ninst\u271d\u2074 : AddMonoidWithOne \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : ZeroLEOneClass \u03b1\ninst\u271d\u00b9 : NeZero 1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\n\u22a2 0 < 2 + 1"
      },
      {
        "tactic": "exact lt_add_of_lt_of_nonneg zero_lt_two zero_le_one",
        "annotated_tactic": [
          "exact <a>lt_add_of_lt_of_nonneg</a> <a>zero_lt_two</a> <a>zero_le_one</a>",
          [
            {
              "full_name": "lt_add_of_lt_of_nonneg",
              "def_path": "Mathlib/Algebra/Order/Monoid/Unbundled/Basic.lean",
              "def_pos": [
                735,
                3
              ],
              "def_end_pos": [
                735,
                14
              ]
            },
            {
              "full_name": "zero_lt_two",
              "def_path": "Mathlib/Algebra/Order/Monoid/NatCast.lean",
              "def_pos": [
                71,
                15
              ],
              "def_end_pos": [
                71,
                26
              ]
            },
            {
              "full_name": "zero_le_one",
              "def_path": "Mathlib/Algebra/Order/ZeroLEOne.lean",
              "def_pos": [
                26,
                15
              ],
              "def_end_pos": [
                26,
                26
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u2074 : AddMonoidWithOne \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : ZeroLEOneClass \u03b1\ninst\u271d\u00b9 : NeZero 1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\n\u22a2 0 < 2 + 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.3675837670452893,
    "entry_failed": false
  },
  "27354": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Quot.lean",
    "full_name": "Quotient.eq_mk_iff_out",
    "start": [
      398,
      1
    ],
    "end": [
      401,
      25
    ],
    "traced_tactics": [
      {
        "tactic": "refine Iff.trans ?_ Quotient.eq",
        "annotated_tactic": [
          "refine <a>Iff.trans</a> ?_ <a>Quotient.eq</a>",
          [
            {
              "full_name": "Iff.trans",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                803,
                9
              ],
              "def_end_pos": [
                803,
                18
              ]
            },
            {
              "full_name": "Quotient.eq",
              "def_path": "Mathlib/Data/Quot.lean",
              "def_pos": [
                300,
                9
              ],
              "def_end_pos": [
                300,
                20
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\ns : Setoid \u03b1\nx : Quotient s\ny : \u03b1\n\u22a2 x = \u27e6y\u27e7 \u2194 x.out \u2248 y",
        "state_after": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\ns : Setoid \u03b1\nx : Quotient s\ny : \u03b1\n\u22a2 x = \u27e6y\u27e7 \u2194 \u27e6x.out\u27e7 = \u27e6y\u27e7"
      },
      {
        "tactic": "rw [Quotient.out_eq x]",
        "annotated_tactic": [
          "rw [<a>Quotient.out_eq</a> x]",
          [
            {
              "full_name": "Quotient.out_eq",
              "def_path": "Mathlib/Data/Quot.lean",
              "def_pos": [
                384,
                9
              ],
              "def_end_pos": [
                384,
                24
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\ns : Setoid \u03b1\nx : Quotient s\ny : \u03b1\n\u22a2 x = \u27e6y\u27e7 \u2194 \u27e6x.out\u27e7 = \u27e6y\u27e7",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.2500124849611893,
    "entry_failed": false
  },
  "21988": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/Basic.lean",
    "full_name": "InnerProductGeometry.angle_zero_right",
    "start": [
      127,
      1
    ],
    "end": [
      129,
      52
    ],
    "traced_tactics": [
      {
        "tactic": "unfold angle",
        "annotated_tactic": [
          "unfold <a>angle</a>",
          [
            {
              "full_name": "InnerProductGeometry.angle",
              "def_path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/Basic.lean",
              "def_pos": [
                45,
                5
              ],
              "def_end_pos": [
                45,
                10
              ]
            }
          ]
        ],
        "state_before": "V : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : InnerProductSpace \u211d V\nx\u271d y x : V\n\u22a2 angle x 0 = \u03c0 / 2",
        "state_after": "V : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : InnerProductSpace \u211d V\nx\u271d y x : V\n\u22a2 arccos (\u27eax, 0\u27eb_\u211d / (\u2016x\u2016 * \u20160\u2016)) = \u03c0 / 2"
      },
      {
        "tactic": "rw [inner_zero_right, zero_div, Real.arccos_zero]",
        "annotated_tactic": [
          "rw [<a>inner_zero_right</a>, <a>zero_div</a>, <a>Real.arccos_zero</a>]",
          [
            {
              "full_name": "inner_zero_right",
              "def_path": "Mathlib/Analysis/InnerProductSpace/Basic.lean",
              "def_pos": [
                555,
                9
              ],
              "def_end_pos": [
                555,
                25
              ]
            },
            {
              "full_name": "zero_div",
              "def_path": "Mathlib/Algebra/GroupWithZero/Basic.lean",
              "def_pos": [
                347,
                9
              ],
              "def_end_pos": [
                347,
                17
              ]
            },
            {
              "full_name": "Real.arccos_zero",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Inverse.lean",
              "def_pos": [
                386,
                9
              ],
              "def_end_pos": [
                386,
                20
              ]
            }
          ]
        ],
        "state_before": "V : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : InnerProductSpace \u211d V\nx\u271d y x : V\n\u22a2 arccos (\u27eax, 0\u27eb_\u211d / (\u2016x\u2016 * \u20160\u2016)) = \u03c0 / 2",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.8704171220306307,
    "entry_failed": false
  },
  "10565": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/MvPolynomial/Variables.lean",
    "full_name": "MvPolynomial.vars_0",
    "start": [
      77,
      1
    ],
    "end": [
      78,
      64
    ],
    "traced_tactics": [
      {
        "tactic": "classical rw [vars_def, degrees_zero, Multiset.toFinset_zero]",
        "annotated_tactic": [
          "classical rw [<a>vars_def</a>, <a>degrees_zero</a>, <a>Multiset.toFinset_zero</a>]",
          [
            {
              "full_name": "MvPolynomial.vars_def",
              "def_path": "Mathlib/Algebra/MvPolynomial/Variables.lean",
              "def_pos": [
                71,
                9
              ],
              "def_end_pos": [
                71,
                17
              ]
            },
            {
              "full_name": "MvPolynomial.degrees_zero",
              "def_path": "Mathlib/Algebra/MvPolynomial/Degrees.lean",
              "def_pos": [
                118,
                9
              ],
              "def_end_pos": [
                118,
                21
              ]
            },
            {
              "full_name": "Multiset.toFinset_zero",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                3105,
                9
              ],
              "def_end_pos": [
                3105,
                22
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\n\u22a2 vars 0 = \u2205",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [vars_def, degrees_zero, Multiset.toFinset_zero]",
        "annotated_tactic": [
          "rw [<a>vars_def</a>, <a>degrees_zero</a>, <a>Multiset.toFinset_zero</a>]",
          [
            {
              "full_name": "MvPolynomial.vars_def",
              "def_path": "Mathlib/Algebra/MvPolynomial/Variables.lean",
              "def_pos": [
                71,
                9
              ],
              "def_end_pos": [
                71,
                17
              ]
            },
            {
              "full_name": "MvPolynomial.degrees_zero",
              "def_path": "Mathlib/Algebra/MvPolynomial/Degrees.lean",
              "def_pos": [
                118,
                9
              ],
              "def_end_pos": [
                118,
                21
              ]
            },
            {
              "full_name": "Multiset.toFinset_zero",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                3105,
                9
              ],
              "def_end_pos": [
                3105,
                22
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\n\u22a2 vars 0 = \u2205",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5444554860005155,
    "entry_failed": false
  },
  "22338": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Tactic/NormNum/Basic.lean",
    "full_name": "Mathlib.Meta.NormNum.isNat_natCast",
    "start": [
      104,
      1
    ],
    "end": [
      105,
      63
    ],
    "traced_tactics": [
      {
        "tactic": "rintro \u27e8\u27e8\u27e9\u27e9",
        "annotated_tactic": [
          "rintro \u27e8\u27e8\u27e9\u27e9",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d : AddMonoidWithOne R\nn m : \u2115\n\u22a2 IsNat n m \u2192 IsNat (\u2191n) m",
        "state_after": "case mk.refl\nR : Type u_1\ninst\u271d : AddMonoidWithOne R\nm : \u2115\n\u22a2 IsNat (\u2191\u2191m) m"
      },
      {
        "tactic": "exact \u27e8rfl\u27e9",
        "annotated_tactic": [
          "exact \u27e8<a>rfl</a>\u27e9",
          [
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "case mk.refl\nR : Type u_1\ninst\u271d : AddMonoidWithOne R\nm : \u2115\n\u22a2 IsNat (\u2191\u2191m) m",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.441499024978839,
    "entry_failed": false
  },
  "13145": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Filter/CardinalInter.lean",
    "full_name": "Filter.cardinalInter_ofCardinalGenerate",
    "start": [
      290,
      1
    ],
    "end": [
      293,
      44
    ],
    "traced_tactics": [
      {
        "tactic": "delta cardinalGenerate",
        "annotated_tactic": [
          "delta <a>cardinalGenerate</a>",
          [
            {
              "full_name": "Filter.cardinalGenerate",
              "def_path": "Mathlib/Order/Filter/CardinalInter.lean",
              "def_pos": [
                286,
                5
              ],
              "def_end_pos": [
                286,
                21
              ]
            }
          ]
        ],
        "state_before": "\u03b9 \u03b1 \u03b2 : Type u\nc : Cardinal.{u}\nl : Filter \u03b1\ninst\u271d : CardinalInterFilter l c\ng : Set (Set \u03b1)\nhc : 2 < c\n\u22a2 CardinalInterFilter (cardinalGenerate g hc) c",
        "state_after": "\u03b9 \u03b1 \u03b2 : Type u\nc : Cardinal.{u}\nl : Filter \u03b1\ninst\u271d : CardinalInterFilter l c\ng : Set (Set \u03b1)\nhc : 2 < c\n\u22a2 CardinalInterFilter (ofCardinalInter (CardinalGenerateSets g) hc \u22ef \u22ef) c"
      },
      {
        "tactic": "apply cardinalInter_ofCardinalInter _ _ _",
        "annotated_tactic": [
          "apply <a>cardinalInter_ofCardinalInter</a> _ _ _",
          [
            {
              "full_name": "Filter.cardinalInter_ofCardinalInter",
              "def_path": "Mathlib/Order/Filter/CardinalInter.lean",
              "def_pos": [
                174,
                10
              ],
              "def_end_pos": [
                174,
                39
              ]
            }
          ]
        ],
        "state_before": "\u03b9 \u03b1 \u03b2 : Type u\nc : Cardinal.{u}\nl : Filter \u03b1\ninst\u271d : CardinalInterFilter l c\ng : Set (Set \u03b1)\nhc : 2 < c\n\u22a2 CardinalInterFilter (ofCardinalInter (CardinalGenerateSets g) hc \u22ef \u22ef) c",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.4754463710123673,
    "entry_failed": false
  },
  "18958": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Polynomial/Monomial.lean",
    "full_name": "Polynomial.monomial_one_eq_iff",
    "start": [
      28,
      1
    ],
    "end": [
      32,
      45
    ],
    "traced_tactics": [
      {
        "tactic": "simp_rw [\u2190 ofFinsupp_single, ofFinsupp.injEq]",
        "annotated_tactic": [
          "simp_rw [\u2190 <a>ofFinsupp_single</a>, ofFinsupp.injEq]",
          [
            {
              "full_name": "Polynomial.ofFinsupp_single",
              "def_path": "Mathlib/Algebra/Polynomial/Basic.lean",
              "def_pos": [
                448,
                9
              ],
              "def_end_pos": [
                448,
                25
              ]
            }
          ]
        ],
        "state_before": "R : Type u\na b : R\nm n : \u2115\ninst\u271d\u00b9 : Semiring R\np q r : R[X]\ninst\u271d : Nontrivial R\ni j : \u2115\n\u22a2 (monomial i) 1 = (monomial j) 1 \u2194 i = j",
        "state_after": "R : Type u\na b : R\nm n : \u2115\ninst\u271d\u00b9 : Semiring R\np q r : R[X]\ninst\u271d : Nontrivial R\ni j : \u2115\n\u22a2 Finsupp.single i 1 = Finsupp.single j 1 \u2194 i = j"
      },
      {
        "tactic": "exact AddMonoidAlgebra.of_injective.eq_iff",
        "annotated_tactic": [
          "exact AddMonoidAlgebra.of_injective.eq_iff",
          []
        ],
        "state_before": "R : Type u\na b : R\nm n : \u2115\ninst\u271d\u00b9 : Semiring R\np q r : R[X]\ninst\u271d : Nontrivial R\ni j : \u2115\n\u22a2 Finsupp.single i 1 = Finsupp.single j 1 \u2194 i = j",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.278289360110648,
    "entry_failed": false
  },
  "24883": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Tactic/Peel.lean",
    "full_name": "Mathlib.Tactic.Peel.frequently_congr",
    "start": [
      101,
      9
    ],
    "end": [
      103,
      23
    ],
    "traced_tactics": [
      {
        "tactic": "congr! 2",
        "annotated_tactic": [
          "congr! 2",
          []
        ],
        "state_before": "\u03b1 : Type u_1\np q : \u03b1 \u2192 Prop\nf : Filter \u03b1\nhq : \u2200 (x : \u03b1), p x \u2194 q x\n\u22a2 (\u2203\u1da0 (x : \u03b1) in f, p x) \u2194 \u2203\u1da0 (x : \u03b1) in f, q x",
        "state_after": "case a.h.e'_2.h.a\n\u03b1 : Type u_1\np q : \u03b1 \u2192 Prop\nf : Filter \u03b1\nhq : \u2200 (x : \u03b1), p x \u2194 q x\nx\u271d : \u03b1\n\u22a2 p x\u271d \u2194 q x\u271d"
      },
      {
        "tactic": "exact hq _",
        "annotated_tactic": [
          "exact hq _",
          []
        ],
        "state_before": "case a.h.e'_2.h.a\n\u03b1 : Type u_1\np q : \u03b1 \u2192 Prop\nf : Filter \u03b1\nhq : \u2200 (x : \u03b1), p x \u2194 q x\nx\u271d : \u03b1\n\u22a2 p x\u271d \u2194 q x\u271d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.11792439292185,
    "entry_failed": false
  },
  "26207": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/Measure/WithDensity.lean",
    "full_name": "MeasureTheory.withDensity_const",
    "start": [
      170,
      1
    ],
    "end": [
      172,
      32
    ],
    "traced_tactics": [
      {
        "tactic": "ext1 s hs",
        "annotated_tactic": [
          "ext1 s hs",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nc : \u211d\u22650\u221e\n\u22a2 (\u03bc.withDensity fun x => c) = c \u2022 \u03bc",
        "state_after": "case h\n\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nc : \u211d\u22650\u221e\ns : Set \u03b1\nhs : MeasurableSet s\n\u22a2 (\u03bc.withDensity fun x => c) s = (c \u2022 \u03bc) s"
      },
      {
        "tactic": "simp [withDensity_apply _ hs]",
        "annotated_tactic": [
          "simp [<a>withDensity_apply</a> _ hs]",
          [
            {
              "full_name": "MeasureTheory.withDensity_apply",
              "def_path": "Mathlib/MeasureTheory/Measure/WithDensity.lean",
              "def_pos": [
                39,
                9
              ],
              "def_end_pos": [
                39,
                26
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nc : \u211d\u22650\u221e\ns : Set \u03b1\nhs : MeasurableSet s\n\u22a2 (\u03bc.withDensity fun x => c) s = (c \u2022 \u03bc) s",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.102191674988717,
    "entry_failed": false
  },
  "22837": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Bounded.lean",
    "full_name": "Set.unbounded_le_inter_le",
    "start": [
      346,
      1
    ],
    "end": [
      349,
      30
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 not_bounded_iff, \u2190 not_bounded_iff, not_iff_not]",
        "annotated_tactic": [
          "rw [\u2190 <a>not_bounded_iff</a>, \u2190 <a>not_bounded_iff</a>, <a>not_iff_not</a>]",
          [
            {
              "full_name": "Set.not_bounded_iff",
              "def_path": "Mathlib/Order/RelClasses.lean",
              "def_pos": [
                552,
                9
              ],
              "def_end_pos": [
                552,
                24
              ]
            },
            {
              "full_name": "Set.not_bounded_iff",
              "def_path": "Mathlib/Order/RelClasses.lean",
              "def_pos": [
                552,
                9
              ],
              "def_end_pos": [
                552,
                24
              ]
            },
            {
              "full_name": "not_iff_not",
              "def_path": "Mathlib/Logic/Basic.lean",
              "def_pos": [
                447,
                9
              ],
              "def_end_pos": [
                447,
                20
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns t : Set \u03b1\ninst\u271d : LinearOrder \u03b1\na : \u03b1\n\u22a2 Unbounded (fun x x_1 => x \u2264 x_1) (s \u2229 {b | a \u2264 b}) \u2194 Unbounded (fun x x_1 => x \u2264 x_1) s",
        "state_after": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns t : Set \u03b1\ninst\u271d : LinearOrder \u03b1\na : \u03b1\n\u22a2 Bounded (fun x x_1 => x \u2264 x_1) (s \u2229 {b | a \u2264 b}) \u2194 Bounded (fun x x_1 => x \u2264 x_1) s"
      },
      {
        "tactic": "exact bounded_le_inter_le a",
        "annotated_tactic": [
          "exact <a>bounded_le_inter_le</a> a",
          [
            {
              "full_name": "Set.bounded_le_inter_le",
              "def_path": "Mathlib/Order/Bounded.lean",
              "def_pos": [
                339,
                9
              ],
              "def_end_pos": [
                339,
                28
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns t : Set \u03b1\ninst\u271d : LinearOrder \u03b1\na : \u03b1\n\u22a2 Bounded (fun x x_1 => x \u2264 x_1) (s \u2229 {b | a \u2264 b}) \u2194 Bounded (fun x x_1 => x \u2264 x_1) s",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9557161380071193,
    "entry_failed": false
  },
  "25650": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Vector/Basic.lean",
    "full_name": "Vector.tail_map",
    "start": [
      112,
      1
    ],
    "end": [
      115,
      41
    ],
    "traced_tactics": [
      {
        "tactic": "obtain \u27e8a, v', h\u27e9 := Vector.exists_eq_cons v",
        "annotated_tactic": [
          "obtain \u27e8a, v', h\u27e9 := <a>Vector.exists_eq_cons</a> v",
          [
            {
              "full_name": "Vector.exists_eq_cons",
              "def_path": "Mathlib/Data/Vector/Basic.lean",
              "def_pos": [
                75,
                9
              ],
              "def_end_pos": [
                75,
                23
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nv : Vector \u03b1 (n + 1)\nf : \u03b1 \u2192 \u03b2\n\u22a2 (map f v).tail = map f v.tail",
        "state_after": "case intro.intro\nn : \u2115\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nv : Vector \u03b1 (n + 1)\nf : \u03b1 \u2192 \u03b2\na : \u03b1\nv' : Vector \u03b1 n\nh : v = a ::\u1d65 v'\n\u22a2 (map f v).tail = map f v.tail"
      },
      {
        "tactic": "rw [h, map_cons, tail_cons, tail_cons]",
        "annotated_tactic": [
          "rw [h, <a>map_cons</a>, <a>tail_cons</a>, <a>tail_cons</a>]",
          [
            {
              "full_name": "Vector.map_cons",
              "def_path": "Mathlib/Data/Vector/Defs.lean",
              "def_pos": [
                134,
                9
              ],
              "def_end_pos": [
                134,
                17
              ]
            },
            {
              "full_name": "Vector.tail_cons",
              "def_path": "Mathlib/Data/Vector/Defs.lean",
              "def_pos": [
                70,
                9
              ],
              "def_end_pos": [
                70,
                18
              ]
            },
            {
              "full_name": "Vector.tail_cons",
              "def_path": "Mathlib/Data/Vector/Defs.lean",
              "def_pos": [
                70,
                9
              ],
              "def_end_pos": [
                70,
                18
              ]
            }
          ]
        ],
        "state_before": "case intro.intro\nn : \u2115\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nv : Vector \u03b1 (n + 1)\nf : \u03b1 \u2192 \u03b2\na : \u03b1\nv' : Vector \u03b1 n\nh : v = a ::\u1d65 v'\n\u22a2 (map f v).tail = map f v.tail",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9870476659853011,
    "entry_failed": false
  },
  "19183": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean",
    "full_name": "Polynomial.cyclotomic.monic",
    "start": [
      320,
      1
    ],
    "end": [
      322,
      42
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 map_cyclotomic_int]",
        "annotated_tactic": [
          "rw [\u2190 <a>map_cyclotomic_int</a>]",
          [
            {
              "full_name": "Polynomial.map_cyclotomic_int",
              "def_path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean",
              "def_pos": [
                266,
                9
              ],
              "def_end_pos": [
                266,
                27
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\nR : Type u_1\ninst\u271d : Ring R\n\u22a2 (cyclotomic n R).Monic",
        "state_after": "n : \u2115\nR : Type u_1\ninst\u271d : Ring R\n\u22a2 (map (Int.castRingHom R) (cyclotomic n \u2124)).Monic"
      },
      {
        "tactic": "exact (int_cyclotomic_spec n).2.2.map _",
        "annotated_tactic": [
          "exact (<a>int_cyclotomic_spec</a> n).2.2.<a>map</a> _",
          [
            {
              "full_name": "Polynomial.int_cyclotomic_spec",
              "def_path": "Mathlib/RingTheory/Polynomial/Cyclotomic/Basic.lean",
              "def_pos": [
                273,
                9
              ],
              "def_end_pos": [
                273,
                28
              ]
            },
            {
              "full_name": "Polynomial.Monic.map",
              "def_path": "Mathlib/Algebra/Polynomial/Monic.lean",
              "def_pos": [
                65,
                9
              ],
              "def_end_pos": [
                65,
                18
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\nR : Type u_1\ninst\u271d : Ring R\n\u22a2 (map (Int.castRingHom R) (cyclotomic n \u2124)).Monic",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.370284382021055,
    "entry_failed": false
  },
  "17884": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/ModelTheory/FinitelyGenerated.lean",
    "full_name": "FirstOrder.Language.Substructure.FG.cg",
    "start": [
      111,
      1
    ],
    "end": [
      113,
      31
    ],
    "traced_tactics": [
      {
        "tactic": "obtain \u27e8s, hf, rfl\u27e9 := fg_def.1 h",
        "annotated_tactic": [
          "obtain \u27e8s, hf, rfl\u27e9 := <a>fg_def</a>.1 h",
          [
            {
              "full_name": "FirstOrder.Language.Substructure.fg_def",
              "def_path": "Mathlib/ModelTheory/FinitelyGenerated.lean",
              "def_pos": [
                45,
                9
              ],
              "def_end_pos": [
                45,
                15
              ]
            }
          ]
        ],
        "state_before": "L : Language\nM : Type u_1\ninst\u271d : L.Structure M\nN : L.Substructure M\nh : N.FG\n\u22a2 N.CG",
        "state_after": "case intro.intro\nL : Language\nM : Type u_1\ninst\u271d : L.Structure M\ns : Set M\nhf : s.Finite\nh : ((closure L).toFun s).FG\n\u22a2 ((closure L).toFun s).CG"
      },
      {
        "tactic": "exact \u27e8s, hf.countable, rfl\u27e9",
        "annotated_tactic": [
          "exact \u27e8s, hf.countable, <a>rfl</a>\u27e9",
          [
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "case intro.intro\nL : Language\nM : Type u_1\ninst\u271d : L.Structure M\ns : Set M\nhf : s.Finite\nh : ((closure L).toFun s).FG\n\u22a2 ((closure L).toFun s).CG",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6432052559684962,
    "entry_failed": false
  },
  "5168": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/SmoothNumbers.lean",
    "full_name": "Nat.mul_mem_smoothNumbers",
    "start": [
      334,
      1
    ],
    "end": [
      337,
      40
    ],
    "traced_tactics": [
      {
        "tactic": "rw [smoothNumbers_eq_factoredNumbers] at hm1 hm2 \u22a2",
        "annotated_tactic": [
          "rw [<a>smoothNumbers_eq_factoredNumbers</a>] at hm1 hm2 \u22a2",
          [
            {
              "full_name": "Nat.smoothNumbers_eq_factoredNumbers",
              "def_path": "Mathlib/NumberTheory/SmoothNumbers.lean",
              "def_pos": [
                275,
                7
              ],
              "def_end_pos": [
                275,
                39
              ]
            }
          ]
        ],
        "state_before": "m\u2081 m\u2082 n : \u2115\nhm1 : m\u2081 \u2208 n.smoothNumbers\nhm2 : m\u2082 \u2208 n.smoothNumbers\n\u22a2 m\u2081 * m\u2082 \u2208 n.smoothNumbers",
        "state_after": "m\u2081 m\u2082 n : \u2115\nhm1 : m\u2081 \u2208 factoredNumbers (Finset.range n)\nhm2 : m\u2082 \u2208 factoredNumbers (Finset.range n)\n\u22a2 m\u2081 * m\u2082 \u2208 factoredNumbers (Finset.range n)"
      },
      {
        "tactic": "exact mul_mem_factoredNumbers hm1 hm2",
        "annotated_tactic": [
          "exact <a>mul_mem_factoredNumbers</a> hm1 hm2",
          [
            {
              "full_name": "Nat.mul_mem_factoredNumbers",
              "def_path": "Mathlib/NumberTheory/SmoothNumbers.lean",
              "def_pos": [
                139,
                7
              ],
              "def_end_pos": [
                139,
                30
              ]
            }
          ]
        ],
        "state_before": "m\u2081 m\u2082 n : \u2115\nhm1 : m\u2081 \u2208 factoredNumbers (Finset.range n)\nhm2 : m\u2082 \u2208 factoredNumbers (Finset.range n)\n\u22a2 m\u2081 * m\u2082 \u2208 factoredNumbers (Finset.range n)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.7042787759564817,
    "entry_failed": false
  },
  "21617": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Rotate.lean",
    "full_name": "List.rotate'_length",
    "start": [
      88,
      1
    ],
    "end": [
      89,
      48
    ],
    "traced_tactics": [
      {
        "tactic": "rw [rotate'_eq_drop_append_take le_rfl]",
        "annotated_tactic": [
          "rw [<a>rotate'_eq_drop_append_take</a> <a>le_rfl</a>]",
          [
            {
              "full_name": "List.rotate'_eq_drop_append_take",
              "def_path": "Mathlib/Data/List/Rotate.lean",
              "def_pos": [
                67,
                9
              ],
              "def_end_pos": [
                67,
                36
              ]
            },
            {
              "full_name": "le_rfl",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                50,
                9
              ],
              "def_end_pos": [
                50,
                15
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\nl : List \u03b1\n\u22a2 l.rotate' l.length = l",
        "state_after": "\u03b1 : Type u\nl : List \u03b1\n\u22a2 drop l.length l ++ take l.length l = l"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "\u03b1 : Type u\nl : List \u03b1\n\u22a2 drop l.length l ++ take l.length l = l",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8093699170276523,
    "entry_failed": false
  },
  "2195": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Sym.lean",
    "full_name": "List.right_mem_of_mk_mem_sym2",
    "start": [
      63,
      1
    ],
    "end": [
      66,
      34
    ],
    "traced_tactics": [
      {
        "tactic": "rw [Sym2.eq_swap] at h",
        "annotated_tactic": [
          "rw [<a>Sym2.eq_swap</a>] at h",
          [
            {
              "full_name": "Sym2.eq_swap",
              "def_path": "Mathlib/Data/Sym/Sym2.lean",
              "def_pos": [
                171,
                9
              ],
              "def_end_pos": [
                171,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nxs : List \u03b1\na b : \u03b1\nh : s(a, b) \u2208 xs.sym2\n\u22a2 b \u2208 xs",
        "state_after": "\u03b1 : Type u_1\nxs : List \u03b1\na b : \u03b1\nh : s(b, a) \u2208 xs.sym2\n\u22a2 b \u2208 xs"
      },
      {
        "tactic": "exact left_mem_of_mk_mem_sym2 h",
        "annotated_tactic": [
          "exact <a>left_mem_of_mk_mem_sym2</a> h",
          [
            {
              "full_name": "List.left_mem_of_mk_mem_sym2",
              "def_path": "Mathlib/Data/List/Sym.lean",
              "def_pos": [
                49,
                9
              ],
              "def_end_pos": [
                49,
                32
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nxs : List \u03b1\na b : \u03b1\nh : s(b, a) \u2208 xs.sym2\n\u22a2 b \u2208 xs",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.3009286420419812,
    "entry_failed": false
  },
  "24633": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/EqToHom.lean",
    "full_name": "CategoryTheory.congrArg_cast_hom_left",
    "start": [
      104,
      1
    ],
    "end": [
      107,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "cases p",
        "annotated_tactic": [
          "cases p",
          []
        ],
        "state_before": "C : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\n\u03b2 : Sort u_1\nX Y Z : C\np : X = Y\nq : Y \u27f6 Z\n\u22a2 cast \u22ef q = eqToHom p \u226b q",
        "state_after": "case refl\nC : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\n\u03b2 : Sort u_1\nX Z : C\nq : X \u27f6 Z\n\u22a2 cast \u22ef q = eqToHom \u22ef \u226b q"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case refl\nC : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\n\u03b2 : Sort u_1\nX Z : C\nq : X \u27f6 Z\n\u22a2 cast \u22ef q = eqToHom \u22ef \u226b q",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4126378369983286,
    "entry_failed": false
  },
  "6889": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Fintype/Card.lean",
    "full_name": "Fintype.card_subtype",
    "start": [
      883,
      1
    ],
    "end": [
      886,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "refine Fintype.card_of_subtype _ ?_",
        "annotated_tactic": [
          "refine <a>Fintype.card_of_subtype</a> _ ?_",
          [
            {
              "full_name": "Fintype.card_of_subtype",
              "def_path": "Mathlib/Data/Fintype/Card.lean",
              "def_pos": [
                126,
                9
              ],
              "def_end_pos": [
                126,
                24
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Fintype \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\n\u22a2 card { x // p x } = (filter p univ).card",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Fintype \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\n\u22a2 \u2200 (x : \u03b1), x \u2208 filter p univ \u2194 p x"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : Fintype \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\n\u22a2 \u2200 (x : \u03b1), x \u2208 filter p univ \u2194 p x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.375931352027692,
    "entry_failed": false
  },
  "19953": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/RingHom/Finite.lean",
    "full_name": "RingHom.finite_stableUnderComposition",
    "start": [
      23,
      1
    ],
    "end": [
      25,
      19
    ],
    "traced_tactics": [
      {
        "tactic": "introv R hf hg",
        "annotated_tactic": [
          "introv R hf hg",
          []
        ],
        "state_before": "\u22a2 StableUnderComposition @Finite",
        "state_after": "R S T : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : CommRing T\nf : R \u2192+* S\ng : S \u2192+* T\nhf : f.Finite\nhg : g.Finite\n\u22a2 (g.comp f).Finite"
      },
      {
        "tactic": "exact hg.comp hf",
        "annotated_tactic": [
          "exact hg.comp hf",
          []
        ],
        "state_before": "R S T : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : CommRing T\nf : R \u2192+* S\ng : S \u2192+* T\nhf : f.Finite\nhg : g.Finite\n\u22a2 (g.comp f).Finite",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.3636679169721901,
    "entry_failed": false
  },
  "14912": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/GCDMonoid/Multiset.lean",
    "full_name": "Multiset.lcm_ndunion",
    "start": [
      104,
      1
    ],
    "end": [
      106,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 lcm_dedup, dedup_ext.2, lcm_dedup, lcm_add]",
        "annotated_tactic": [
          "rw [\u2190 <a>lcm_dedup</a>, <a>dedup_ext</a>.2, <a>lcm_dedup</a>, <a>lcm_add</a>]",
          [
            {
              "full_name": "Multiset.lcm_dedup",
              "def_path": "Mathlib/Algebra/GCDMonoid/Multiset.lean",
              "def_pos": [
                95,
                9
              ],
              "def_end_pos": [
                95,
                18
              ]
            },
            {
              "full_name": "Multiset.dedup_ext",
              "def_path": "Mathlib/Data/Multiset/Dedup.lean",
              "def_pos": [
                116,
                9
              ],
              "def_end_pos": [
                116,
                18
              ]
            },
            {
              "full_name": "Multiset.lcm_dedup",
              "def_path": "Mathlib/Algebra/GCDMonoid/Multiset.lean",
              "def_pos": [
                95,
                9
              ],
              "def_end_pos": [
                95,
                18
              ]
            },
            {
              "full_name": "Multiset.lcm_add",
              "def_path": "Mathlib/Algebra/GCDMonoid/Multiset.lean",
              "def_pos": [
                59,
                9
              ],
              "def_end_pos": [
                59,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b9 : NormalizedGCDMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\ns\u2081 s\u2082 : Multiset \u03b1\n\u22a2 (s\u2081.ndunion s\u2082).lcm = GCDMonoid.lcm s\u2081.lcm s\u2082.lcm",
        "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b9 : NormalizedGCDMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\ns\u2081 s\u2082 : Multiset \u03b1\n\u22a2 \u2200 (a : \u03b1), a \u2208 s\u2081.ndunion s\u2082 \u2194 a \u2208 s\u2081 + s\u2082"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b9 : NormalizedGCDMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\ns\u2081 s\u2082 : Multiset \u03b1\n\u22a2 \u2200 (a : \u03b1), a \u2208 s\u2081.ndunion s\u2082 \u2194 a \u2208 s\u2081 + s\u2082",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.532868759939447,
    "entry_failed": false
  },
  "4030": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Category/TopCat/Limits/Products.lean",
    "full_name": "TopCat.prodIsoProd_hom_fst",
    "start": [
      204,
      1
    ],
    "end": [
      207,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "simp [\u2190 Iso.eq_inv_comp, prodIsoProd]",
        "annotated_tactic": [
          "simp [\u2190 <a>Iso.eq_inv_comp</a>, <a>prodIsoProd</a>]",
          [
            {
              "full_name": "CategoryTheory.Iso.eq_inv_comp",
              "def_path": "Mathlib/CategoryTheory/Iso.lean",
              "def_pos": [
                215,
                9
              ],
              "def_end_pos": [
                215,
                20
              ]
            },
            {
              "full_name": "TopCat.prodIsoProd",
              "def_path": "Mathlib/Topology/Category/TopCat/Limits/Products.lean",
              "def_pos": [
                199,
                5
              ],
              "def_end_pos": [
                199,
                16
              ]
            }
          ]
        ],
        "state_before": "J : Type v\ninst\u271d : SmallCategory J\nX Y : TopCat\n\u22a2 (X.prodIsoProd Y).hom \u226b prodFst = prod.fst",
        "state_after": "J : Type v\ninst\u271d : SmallCategory J\nX Y : TopCat\n\u22a2 prodFst = (X.prodBinaryFan Y).fst"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "J : Type v\ninst\u271d : SmallCategory J\nX Y : TopCat\n\u22a2 prodFst = (X.prodBinaryFan Y).fst",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.4520154970232397,
    "entry_failed": false
  },
  "23196": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/MetricSpace/Bounded.lean",
    "full_name": "Metric.diam_union'",
    "start": [
      526,
      1
    ],
    "end": [
      528,
      31
    ],
    "traced_tactics": [
      {
        "tactic": "rcases h with \u27e8x, \u27e8xs, xt\u27e9\u27e9",
        "annotated_tactic": [
          "rcases h with \u27e8x, \u27e8xs, xt\u27e9\u27e9",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nx y z : \u03b1\nt : Set \u03b1\nh : (s \u2229 t).Nonempty\n\u22a2 diam (s \u222a t) \u2264 diam s + diam t",
        "state_after": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nx\u271d y z : \u03b1\nt : Set \u03b1\nx : \u03b1\nxs : x \u2208 s\nxt : x \u2208 t\n\u22a2 diam (s \u222a t) \u2264 diam s + diam t"
      },
      {
        "tactic": "simpa using diam_union xs xt",
        "annotated_tactic": [
          "simpa using <a>diam_union</a> xs xt",
          [
            {
              "full_name": "Metric.diam_union",
              "def_path": "Mathlib/Topology/MetricSpace/Bounded.lean",
              "def_pos": [
                515,
                9
              ],
              "def_end_pos": [
                515,
                19
              ]
            }
          ]
        ],
        "state_before": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\nX : Type u_1\n\u03b9 : Type u_2\ninst\u271d : PseudoMetricSpace \u03b1\ns : Set \u03b1\nx\u271d y z : \u03b1\nt : Set \u03b1\nx : \u03b1\nxs : x \u2208 s\nxt : x \u2208 t\n\u22a2 diam (s \u222a t) \u2264 diam s + diam t",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.227110526058823,
    "entry_failed": false
  },
  "15336": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Sum/Basic.lean",
    "full_name": "Sum.isSome_getLeft?_iff_isLeft",
    "start": [
      78,
      9
    ],
    "end": [
      79,
      50
    ],
    "traced_tactics": [
      {
        "tactic": "rw [isLeft_iff, Option.isSome_iff_exists]",
        "annotated_tactic": [
          "rw [<a>isLeft_iff</a>, <a>Option.isSome_iff_exists</a>]",
          [
            {
              "full_name": "Sum.isLeft_iff",
              "def_path": ".lake/packages/batteries/Batteries/Data/Sum/Lemmas.lean",
              "def_pos": [
                83,
                9
              ],
              "def_end_pos": [
                83,
                19
              ]
            },
            {
              "full_name": "Option.isSome_iff_exists",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Option/Lemmas.lean",
              "def_pos": [
                59,
                9
              ],
              "def_end_pos": [
                59,
                26
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b1' : Type w\n\u03b2 : Type v\n\u03b2' : Type x\n\u03b3 : Type u_1\n\u03b4 : Type u_2\nx y : \u03b1 \u2295 \u03b2\n\u22a2 x.getLeft?.isSome = true \u2194 x.isLeft = true",
        "state_after": "\u03b1 : Type u\n\u03b1' : Type w\n\u03b2 : Type v\n\u03b2' : Type x\n\u03b3 : Type u_1\n\u03b4 : Type u_2\nx y : \u03b1 \u2295 \u03b2\n\u22a2 (\u2203 a, x.getLeft? = some a) \u2194 \u2203 y, x = inl y"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b1' : Type w\n\u03b2 : Type v\n\u03b2' : Type x\n\u03b3 : Type u_1\n\u03b4 : Type u_2\nx y : \u03b1 \u2295 \u03b2\n\u22a2 (\u2203 a, x.getLeft? = some a) \u2194 \u2203 y, x = inl y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.085536637925543,
    "entry_failed": false
  },
  "7568": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/FintypeCat.lean",
    "full_name": "FintypeCat.Skeleton.incl_mk_nat_card",
    "start": [
      211,
      1
    ],
    "end": [
      213,
      29
    ],
    "traced_tactics": [
      {
        "tactic": "convert Finset.card_fin n",
        "annotated_tactic": [
          "convert <a>Finset.card_fin</a> n",
          [
            {
              "full_name": "Finset.card_fin",
              "def_path": "Mathlib/Data/Fintype/Card.lean",
              "def_pos": [
                324,
                9
              ],
              "def_end_pos": [
                324,
                24
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\n\u22a2 Fintype.card \u2191(incl.obj (mk n)) = n",
        "state_after": "case h.e'_2\nn : \u2115\n\u22a2 Fintype.card \u2191(incl.obj (mk n)) = Finset.univ.card"
      },
      {
        "tactic": "apply Fintype.ofEquiv_card",
        "annotated_tactic": [
          "apply <a>Fintype.ofEquiv_card</a>",
          [
            {
              "full_name": "Fintype.ofEquiv_card",
              "def_path": "Mathlib/Data/Fintype/Card.lean",
              "def_pos": [
                147,
                9
              ],
              "def_end_pos": [
                147,
                21
              ]
            }
          ]
        ],
        "state_before": "case h.e'_2\nn : \u2115\n\u22a2 Fintype.card \u2191(incl.obj (mk n)) = Finset.univ.card",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.221734463935718,
    "entry_failed": false
  },
  "24619": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Setoid/Partition.lean",
    "full_name": "Setoid.eqv_class_mem'",
    "start": [
      140,
      1
    ],
    "end": [
      143,
      20
    ],
    "traced_tactics": [
      {
        "tactic": "convert @Setoid.eqv_class_mem _ _ H x using 3",
        "annotated_tactic": [
          "convert @<a>Setoid.eqv_class_mem</a> _ _ H x using 3",
          [
            {
              "full_name": "Setoid.eqv_class_mem",
              "def_path": "Mathlib/Data/Setoid/Partition.lean",
              "def_pos": [
                135,
                9
              ],
              "def_end_pos": [
                135,
                22
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nc : Set (Set \u03b1)\nH : \u2200 (a : \u03b1), \u2203! b, b \u2208 c \u2227 a \u2208 b\nx : \u03b1\n\u22a2 {y | (mkClasses c H).Rel x y} \u2208 c",
        "state_after": "case h.e'_4.h.e'_2.h.a\n\u03b1 : Type u_1\nc : Set (Set \u03b1)\nH : \u2200 (a : \u03b1), \u2203! b, b \u2208 c \u2227 a \u2208 b\nx x\u271d : \u03b1\n\u22a2 (mkClasses c H).Rel x x\u271d \u2194 (mkClasses c H).Rel x\u271d x"
      },
      {
        "tactic": "rw [Setoid.comm']",
        "annotated_tactic": [
          "rw [<a>Setoid.comm'</a>]",
          [
            {
              "full_name": "Setoid.comm'",
              "def_path": "Mathlib/Data/Setoid/Basic.lean",
              "def_pos": [
                90,
                9
              ],
              "def_end_pos": [
                90,
                14
              ]
            }
          ]
        ],
        "state_before": "case h.e'_4.h.e'_2.h.a\n\u03b1 : Type u_1\nc : Set (Set \u03b1)\nH : \u2200 (a : \u03b1), \u2203! b, b \u2208 c \u2227 a \u2208 b\nx x\u271d : \u03b1\n\u22a2 (mkClasses c H).Rel x x\u271d \u2194 (mkClasses c H).Rel x\u271d x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.614059439045377,
    "entry_failed": false
  },
  "5541": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Fin/Basic.lean",
    "full_name": "Fin.heq_ext_iff",
    "start": [
      212,
      11
    ],
    "end": [
      215,
      20
    ],
    "traced_tactics": [
      {
        "tactic": "subst h",
        "annotated_tactic": [
          "subst h",
          []
        ],
        "state_before": "n m k l : \u2115\nh : k = l\ni : Fin k\nj : Fin l\n\u22a2 HEq i j \u2194 \u2191i = \u2191j",
        "state_after": "n m k : \u2115\ni j : Fin k\n\u22a2 HEq i j \u2194 \u2191i = \u2191j"
      },
      {
        "tactic": "simp [val_eq_val]",
        "annotated_tactic": [
          "simp [<a>val_eq_val</a>]",
          [
            {
              "full_name": "Fin.val_eq_val",
              "def_path": "Mathlib/Data/Fin/Basic.lean",
              "def_pos": [
                164,
                9
              ],
              "def_end_pos": [
                164,
                19
              ]
            }
          ]
        ],
        "state_before": "n m k : \u2115\ni j : Fin k\n\u22a2 HEq i j \u2194 \u2191i = \u2191j",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.239558502100408,
    "entry_failed": false
  },
  "26046": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/AlgebraicTopology/DoldKan/Projections.lean",
    "full_name": "AlgebraicTopology.DoldKan.Q_succ",
    "start": [
      92,
      1
    ],
    "end": [
      94,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "simp only [Q, P_succ, comp_add, comp_id]",
        "annotated_tactic": [
          "simp only [<a>Q</a>, <a>P_succ</a>, <a>comp_add</a>, <a>comp_id</a>]",
          [
            {
              "full_name": "AlgebraicTopology.DoldKan.Q",
              "def_path": "Mathlib/AlgebraicTopology/DoldKan/Projections.lean",
              "def_pos": [
                70,
                5
              ],
              "def_end_pos": [
                70,
                6
              ]
            },
            {
              "full_name": "AlgebraicTopology.DoldKan.P_succ",
              "def_path": "Mathlib/AlgebraicTopology/DoldKan/Projections.lean",
              "def_pos": [
                57,
                7
              ],
              "def_end_pos": [
                57,
                13
              ]
            },
            {
              "full_name": "CategoryTheory.Preadditive.comp_add",
              "def_path": "Mathlib/CategoryTheory/Preadditive/Basic.lean",
              "def_pos": [
                62,
                3
              ],
              "def_end_pos": [
                62,
                11
              ]
            },
            {
              "full_name": "CategoryTheory.Category.comp_id",
              "def_path": "Mathlib/CategoryTheory/Category/Basic.lean",
              "def_pos": [
                179,
                3
              ],
              "def_end_pos": [
                179,
                10
              ]
            }
          ]
        ],
        "state_before": "C : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nq : \u2115\n\u22a2 Q (q + 1) = Q q - P q \u226b H\u03c3 q",
        "state_after": "C : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nq : \u2115\n\u22a2 \ud835\udfd9 K[X] - (P q + P q \u226b H\u03c3 q) = \ud835\udfd9 K[X] - P q - P q \u226b H\u03c3 q"
      },
      {
        "tactic": "abel",
        "annotated_tactic": [
          "abel",
          []
        ],
        "state_before": "C : Type u_1\ninst\u271d\u00b9 : Category.{u_2, u_1} C\ninst\u271d : Preadditive C\nX : SimplicialObject C\nq : \u2115\n\u22a2 \ud835\udfd9 K[X] - (P q + P q \u226b H\u03c3 q) = \ud835\udfd9 K[X] - P q - P q \u226b H\u03c3 q",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.936091586947441,
    "entry_failed": false
  },
  "26784": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Multiset/Lattice.lean",
    "full_name": "Multiset.inf_ndinsert",
    "start": [
      173,
      1
    ],
    "end": [
      174,
      59
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 inf_dedup, dedup_ext.2, inf_dedup, inf_cons]",
        "annotated_tactic": [
          "rw [\u2190 <a>inf_dedup</a>, <a>dedup_ext</a>.2, <a>inf_dedup</a>, <a>inf_cons</a>]",
          [
            {
              "full_name": "Multiset.inf_dedup",
              "def_path": "Mathlib/Data/Multiset/Lattice.lean",
              "def_pos": [
                158,
                9
              ],
              "def_end_pos": [
                158,
                18
              ]
            },
            {
              "full_name": "Multiset.dedup_ext",
              "def_path": "Mathlib/Data/Multiset/Dedup.lean",
              "def_pos": [
                116,
                9
              ],
              "def_end_pos": [
                116,
                18
              ]
            },
            {
              "full_name": "Multiset.inf_dedup",
              "def_path": "Mathlib/Data/Multiset/Lattice.lean",
              "def_pos": [
                158,
                9
              ],
              "def_end_pos": [
                158,
                18
              ]
            },
            {
              "full_name": "Multiset.inf_cons",
              "def_path": "Mathlib/Data/Multiset/Lattice.lean",
              "def_pos": [
                128,
                9
              ],
              "def_end_pos": [
                128,
                17
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : OrderTop \u03b1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\ns : Multiset \u03b1\n\u22a2 (ndinsert a s).inf = a \u2293 s.inf",
        "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : OrderTop \u03b1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\ns : Multiset \u03b1\n\u22a2 \u2200 (a_1 : \u03b1), a_1 \u2208 ndinsert a s \u2194 a_1 \u2208 a ::\u2098 s"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : OrderTop \u03b1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\ns : Multiset \u03b1\n\u22a2 \u2200 (a_1 : \u03b1), a_1 \u2208 ndinsert a s \u2194 a_1 \u2208 a ::\u2098 s",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.1092797711025923,
    "entry_failed": false
  },
  "3963": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Order.lean",
    "full_name": "continuous_generateFrom_iff",
    "start": [
      688,
      1
    ],
    "end": [
      691,
      68
    ],
    "traced_tactics": [
      {
        "tactic": "rw [continuous_iff_coinduced_le, le_generateFrom_iff_subset_isOpen]",
        "annotated_tactic": [
          "rw [<a>continuous_iff_coinduced_le</a>, <a>le_generateFrom_iff_subset_isOpen</a>]",
          [
            {
              "full_name": "continuous_iff_coinduced_le",
              "def_path": "Mathlib/Topology/Order.lean",
              "def_pos": [
                678,
                9
              ],
              "def_end_pos": [
                678,
                36
              ]
            },
            {
              "full_name": "TopologicalSpace.le_generateFrom_iff_subset_isOpen",
              "def_path": "Mathlib/Topology/Order.lean",
              "def_pos": [
                162,
                9
              ],
              "def_end_pos": [
                162,
                42
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type u_1\nf : \u03b1 \u2192 \u03b2\n\u03b9 : Sort u_2\nt : TopologicalSpace \u03b1\nb : Set (Set \u03b2)\n\u22a2 Continuous f \u2194 \u2200 s \u2208 b, IsOpen (f \u207b\u00b9' s)",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type u_1\nf : \u03b1 \u2192 \u03b2\n\u03b9 : Sort u_2\nt : TopologicalSpace \u03b1\nb : Set (Set \u03b2)\n\u22a2 b \u2286 {s | IsOpen s} \u2194 \u2200 s \u2208 b, IsOpen (f \u207b\u00b9' s)"
      },
      {
        "tactic": "simp only [isOpen_coinduced, preimage_id', subset_def, mem_setOf]",
        "annotated_tactic": [
          "simp only [<a>isOpen_coinduced</a>, <a>preimage_id'</a>, <a>subset_def</a>, <a>mem_setOf</a>]",
          [
            {
              "full_name": "isOpen_coinduced",
              "def_path": "Mathlib/Topology/Order.lean",
              "def_pos": [
                392,
                9
              ],
              "def_end_pos": [
                392,
                25
              ]
            },
            {
              "full_name": "Set.preimage_id'",
              "def_path": "Mathlib/Data/Set/Image.lean",
              "def_pos": [
                119,
                9
              ],
              "def_end_pos": [
                119,
                21
              ]
            },
            {
              "full_name": "Set.subset_def",
              "def_path": "Mathlib/Data/Set/Basic.lean",
              "def_pos": [
                322,
                9
              ],
              "def_end_pos": [
                322,
                19
              ]
            },
            {
              "full_name": "Set.mem_setOf",
              "def_path": "Mathlib/Data/Set/Basic.lean",
              "def_pos": [
                230,
                9
              ],
              "def_end_pos": [
                230,
                18
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type u_1\nf : \u03b1 \u2192 \u03b2\n\u03b9 : Sort u_2\nt : TopologicalSpace \u03b1\nb : Set (Set \u03b2)\n\u22a2 b \u2286 {s | IsOpen s} \u2194 \u2200 s \u2208 b, IsOpen (f \u207b\u00b9' s)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.267687925952487,
    "entry_failed": false
  },
  "21813": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/PartialSups.lean",
    "full_name": "iSup_le_iSup_of_partialSups_le_partialSups",
    "start": [
      188,
      1
    ],
    "end": [
      191,
      20
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 iSup_partialSups_eq f, \u2190 iSup_partialSups_eq g]",
        "annotated_tactic": [
          "rw [\u2190 <a>iSup_partialSups_eq</a> f, \u2190 <a>iSup_partialSups_eq</a> g]",
          [
            {
              "full_name": "iSup_partialSups_eq",
              "def_path": "Mathlib/Order/PartialSups.lean",
              "def_pos": [
                184,
                9
              ],
              "def_end_pos": [
                184,
                28
              ]
            },
            {
              "full_name": "iSup_partialSups_eq",
              "def_path": "Mathlib/Order/PartialSups.lean",
              "def_pos": [
                184,
                9
              ],
              "def_end_pos": [
                184,
                28
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\nf g : \u2115 \u2192 \u03b1\nh : partialSups f \u2264 partialSups g\n\u22a2 \u2a06 n, f n \u2264 \u2a06 n, g n",
        "state_after": "\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\nf g : \u2115 \u2192 \u03b1\nh : partialSups f \u2264 partialSups g\n\u22a2 \u2a06 n, (partialSups f) n \u2264 \u2a06 n, (partialSups g) n"
      },
      {
        "tactic": "exact iSup_mono h",
        "annotated_tactic": [
          "exact <a>iSup_mono</a> h",
          [
            {
              "full_name": "iSup_mono",
              "def_path": "Mathlib/Order/CompleteLattice.lean",
              "def_pos": [
                785,
                9
              ],
              "def_end_pos": [
                785,
                18
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\nf g : \u2115 \u2192 \u03b1\nh : partialSups f \u2264 partialSups g\n\u22a2 \u2a06 n, (partialSups f) n \u2264 \u2a06 n, (partialSups g) n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.827387310913764,
    "entry_failed": false
  },
  "15396": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Ordinal/FixedPoint.lean",
    "full_name": "Ordinal.fp_unbounded",
    "start": [
      497,
      1
    ],
    "end": [
      499,
      34
    ],
    "traced_tactics": [
      {
        "tactic": "convert fp_family_unbounded fun _ : Unit => H",
        "annotated_tactic": [
          "convert <a>fp_family_unbounded</a> fun _ : <a>Unit</a> => H",
          [
            {
              "full_name": "Ordinal.fp_family_unbounded",
              "def_path": "Mathlib/SetTheory/Ordinal/FixedPoint.lean",
              "def_pos": [
                145,
                9
              ],
              "def_end_pos": [
                145,
                28
              ]
            },
            {
              "full_name": "Unit",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                142,
                8
              ],
              "def_end_pos": [
                142,
                12
              ]
            }
          ]
        ],
        "state_before": "f : Ordinal.{u} \u2192 Ordinal.{u}\nH : IsNormal f\n\u22a2 Set.Unbounded (fun x x_1 => x < x_1) (fixedPoints f)",
        "state_after": "case h.e'_3\nf : Ordinal.{u} \u2192 Ordinal.{u}\nH : IsNormal f\n\u22a2 fixedPoints f = \u22c2 i, fixedPoints f"
      },
      {
        "tactic": "exact (Set.iInter_const _).symm",
        "annotated_tactic": [
          "exact (<a>Set.iInter_const</a> _).<a>symm</a>",
          [
            {
              "full_name": "Set.iInter_const",
              "def_path": "Mathlib/Data/Set/Lattice.lean",
              "def_pos": [
                437,
                7
              ],
              "def_end_pos": [
                437,
                19
              ]
            },
            {
              "full_name": "Eq.symm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                323,
                9
              ],
              "def_end_pos": [
                323,
                16
              ]
            }
          ]
        ],
        "state_before": "case h.e'_3\nf : Ordinal.{u} \u2192 Ordinal.{u}\nH : IsNormal f\n\u22a2 fixedPoints f = \u22c2 i, fixedPoints f",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.023266989039257,
    "entry_failed": false
  },
  "858": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/PNat/Prime.lean",
    "full_name": "PNat.gcd_eq_right_iff_dvd",
    "start": [
      217,
      1
    ],
    "end": [
      219,
      28
    ],
    "traced_tactics": [
      {
        "tactic": "rw [gcd_comm]",
        "annotated_tactic": [
          "rw [<a>gcd_comm</a>]",
          [
            {
              "full_name": "PNat.gcd_comm",
              "def_path": "Mathlib/Data/PNat/Prime.lean",
              "def_pos": [
                204,
                9
              ],
              "def_end_pos": [
                204,
                17
              ]
            }
          ]
        ],
        "state_before": "m n : \u2115+\n\u22a2 m \u2223 n \u2194 n.gcd m = m",
        "state_after": "m n : \u2115+\n\u22a2 m \u2223 n \u2194 m.gcd n = m"
      },
      {
        "tactic": "apply gcd_eq_left_iff_dvd",
        "annotated_tactic": [
          "apply <a>gcd_eq_left_iff_dvd</a>",
          [
            {
              "full_name": "PNat.gcd_eq_left_iff_dvd",
              "def_path": "Mathlib/Data/PNat/Prime.lean",
              "def_pos": [
                210,
                9
              ],
              "def_end_pos": [
                210,
                28
              ]
            }
          ]
        ],
        "state_before": "m n : \u2115+\n\u22a2 m \u2223 n \u2194 m.gcd n = m",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7219949099235237,
    "entry_failed": false
  },
  "18694": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/Subobject/Limits.lean",
    "full_name": "CategoryTheory.Limits.imageSubobject_zero_arrow",
    "start": [
      369,
      1
    ],
    "end": [
      371,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 imageSubobject_arrow]",
        "annotated_tactic": [
          "rw [\u2190 <a>imageSubobject_arrow</a>]",
          [
            {
              "full_name": "CategoryTheory.Limits.imageSubobject_arrow",
              "def_path": "Mathlib/CategoryTheory/Subobject/Limits.lean",
              "def_pos": [
                309,
                9
              ],
              "def_end_pos": [
                309,
                29
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nX Y Z : C\nf : X \u27f6 Y\ninst\u271d\u00b2 : HasImage f\ninst\u271d\u00b9 : HasZeroMorphisms C\ninst\u271d : HasZeroObject C\n\u22a2 (imageSubobject 0).arrow = 0",
        "state_after": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nX Y Z : C\nf : X \u27f6 Y\ninst\u271d\u00b2 : HasImage f\ninst\u271d\u00b9 : HasZeroMorphisms C\ninst\u271d : HasZeroObject C\n\u22a2 (imageSubobjectIso 0).hom \u226b image.\u03b9 0 = 0"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nX Y Z : C\nf : X \u27f6 Y\ninst\u271d\u00b2 : HasImage f\ninst\u271d\u00b9 : HasZeroMorphisms C\ninst\u271d : HasZeroObject C\n\u22a2 (imageSubobjectIso 0).hom \u226b image.\u03b9 0 = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.6215042809490114,
    "entry_failed": false
  },
  "12147": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Base.lean",
    "full_name": "Real.rpow_logb",
    "start": [
      147,
      1
    ],
    "end": [
      149,
      22
    ],
    "traced_tactics": [
      {
        "tactic": "rw [rpow_logb_eq_abs b_pos b_ne_one hx.ne']",
        "annotated_tactic": [
          "rw [<a>rpow_logb_eq_abs</a> b_pos b_ne_one hx.ne']",
          [
            {
              "full_name": "Real.rpow_logb_eq_abs",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Log/Base.lean",
              "def_pos": [
                137,
                9
              ],
              "def_end_pos": [
                137,
                25
              ]
            }
          ]
        ],
        "state_before": "b x y : \u211d\nb_pos : 0 < b\nb_ne_one : b \u2260 1\nhx : 0 < x\n\u22a2 b ^ logb b x = x",
        "state_after": "b x y : \u211d\nb_pos : 0 < b\nb_ne_one : b \u2260 1\nhx : 0 < x\n\u22a2 |x| = x"
      },
      {
        "tactic": "exact abs_of_pos hx",
        "annotated_tactic": [
          "exact <a>abs_of_pos</a> hx",
          [
            {
              "full_name": "abs_of_pos",
              "def_path": "Mathlib/Algebra/Order/Group/Abs.lean",
              "def_pos": [
                101,
                3
              ],
              "def_end_pos": [
                101,
                14
              ]
            }
          ]
        ],
        "state_before": "b x y : \u211d\nb_pos : 0 < b\nb_ne_one : b \u2260 1\nhx : 0 < x\n\u22a2 |x| = x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.5570293680066243,
    "entry_failed": false
  },
  "23929": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/FieldTheory/Separable.lean",
    "full_name": "Polynomial.Separable.of_dvd",
    "start": [
      97,
      1
    ],
    "end": [
      99,
      33
    ],
    "traced_tactics": [
      {
        "tactic": "rcases hfg with \u27e8f', rfl\u27e9",
        "annotated_tactic": [
          "rcases hfg with \u27e8f', rfl\u27e9",
          []
        ],
        "state_before": "R : Type u\ninst\u271d\u00b9 : CommSemiring R\nS : Type v\ninst\u271d : CommSemiring S\nf g : R[X]\nhf : f.Separable\nhfg : g \u2223 f\n\u22a2 g.Separable",
        "state_after": "case intro\nR : Type u\ninst\u271d\u00b9 : CommSemiring R\nS : Type v\ninst\u271d : CommSemiring S\ng f' : R[X]\nhf : (g * f').Separable\n\u22a2 g.Separable"
      },
      {
        "tactic": "exact Separable.of_mul_left hf",
        "annotated_tactic": [
          "exact <a>Separable.of_mul_left</a> hf",
          [
            {
              "full_name": "Polynomial.Separable.of_mul_left",
              "def_path": "Mathlib/FieldTheory/Separable.lean",
              "def_pos": [
                87,
                9
              ],
              "def_end_pos": [
                87,
                30
              ]
            }
          ]
        ],
        "state_before": "case intro\nR : Type u\ninst\u271d\u00b9 : CommSemiring R\nS : Type v\ninst\u271d : CommSemiring S\ng f' : R[X]\nhf : (g * f').Separable\n\u22a2 g.Separable",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.3194210359361023,
    "entry_failed": false
  },
  "7366": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": ".lake/packages/batteries/Batteries/WF.lean",
    "full_name": "WellFounded.fixF_eq_fixFC",
    "start": [
      115,
      18
    ],
    "end": [
      117,
      36
    ],
    "traced_tactics": [
      {
        "tactic": "funext \u03b1 r C F x a",
        "annotated_tactic": [
          "funext \u03b1 r C F x a",
          []
        ],
        "state_before": "\u22a2 @fixF = @WellFounded.fixFC",
        "state_after": "case h.h.h.h.h.h\n\u03b1 : Sort u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nC : \u03b1 \u2192 Sort u_2\nF : (x : \u03b1) \u2192 ((y : \u03b1) \u2192 r y x \u2192 C y) \u2192 C x\nx : \u03b1\na : Acc r x\n\u22a2 fixF F x a = WellFounded.fixFC F x a"
      },
      {
        "tactic": "rw [fixF, Acc.rec_eq_recC, fixFC]",
        "annotated_tactic": [
          "rw [<a>fixF</a>, <a>Acc.rec_eq_recC</a>, <a>fixFC</a>]",
          [
            {
              "full_name": "WellFounded.fixF",
              "def_path": ".lake/packages/lean4/src/lean/Init/WF.lean",
              "def_pos": [
                77,
                19
              ],
              "def_end_pos": [
                77,
                23
              ]
            },
            {
              "full_name": "_private.\u00ab.lake\u00bb.packages.batteries.Batteries.WF.0.Acc.rec_eq_recC",
              "def_path": ".lake/packages/batteries/Batteries/WF.lean",
              "def_pos": [
                65,
                26
              ],
              "def_end_pos": [
                65,
                37
              ]
            },
            {
              "full_name": "_private.\u00ab.lake\u00bb.packages.batteries.Batteries.WF.0.WellFounded.fixFC",
              "def_path": ".lake/packages/batteries/Batteries/WF.lean",
              "def_pos": [
                110,
                23
              ],
              "def_end_pos": [
                110,
                28
              ]
            }
          ]
        ],
        "state_before": "case h.h.h.h.h.h\n\u03b1 : Sort u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nC : \u03b1 \u2192 Sort u_2\nF : (x : \u03b1) \u2192 ((y : \u03b1) \u2192 r y x \u2192 C y) \u2192 C x\nx : \u03b1\na : Acc r x\n\u22a2 fixF F x a = WellFounded.fixFC F x a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 0.7815558790462092,
    "entry_failed": false
  },
  "12756": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Finset/Option.lean",
    "full_name": "Finset.eraseNone_none",
    "start": [
      148,
      1
    ],
    "end": [
      150,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u22a2 eraseNone {none} = \u2205",
        "state_after": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 eraseNone {none} \u2194 a\u271d \u2208 \u2205"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 eraseNone {none} \u2194 a\u271d \u2208 \u2205",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9040475509827957,
    "entry_failed": false
  },
  "8175": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/SimpleGraph/Basic.lean",
    "full_name": "SimpleGraph.fromEdgeSet_univ",
    "start": [
      656,
      1
    ],
    "end": [
      658,
      67
    ],
    "traced_tactics": [
      {
        "tactic": "ext v w",
        "annotated_tactic": [
          "ext v w",
          []
        ],
        "state_before": "\u03b9 : Sort u_1\nV : Type u\nG : SimpleGraph V\na b c u v w : V\ne : Sym2 V\ns : Set (Sym2 V)\n\u22a2 fromEdgeSet Set.univ = \u22a4",
        "state_after": "case Adj.h.h.a\n\u03b9 : Sort u_1\nV : Type u\nG : SimpleGraph V\na b c u v\u271d w\u271d : V\ne : Sym2 V\ns : Set (Sym2 V)\nv w : V\n\u22a2 (fromEdgeSet Set.univ).Adj v w \u2194 \u22a4.Adj v w"
      },
      {
        "tactic": "simp only [fromEdgeSet_adj, Set.mem_univ, true_and_iff, top_adj]",
        "annotated_tactic": [
          "simp only [<a>fromEdgeSet_adj</a>, <a>Set.mem_univ</a>, <a>true_and_iff</a>, <a>top_adj</a>]",
          [
            {
              "full_name": "SimpleGraph.fromEdgeSet_adj",
              "def_path": "Mathlib/Combinatorics/SimpleGraph/Basic.lean",
              "def_pos": [
                631,
                9
              ],
              "def_end_pos": [
                631,
                24
              ]
            },
            {
              "full_name": "Set.mem_univ",
              "def_path": "Mathlib/Data/Set/Defs.lean",
              "def_pos": [
                82,
                29
              ],
              "def_end_pos": [
                82,
                37
              ]
            },
            {
              "full_name": "true_and_iff",
              "def_path": "Mathlib/Init/Logic.lean",
              "def_pos": [
                118,
                9
              ],
              "def_end_pos": [
                118,
                21
              ]
            },
            {
              "full_name": "SimpleGraph.top_adj",
              "def_path": "Mathlib/Combinatorics/SimpleGraph/Basic.lean",
              "def_pos": [
                361,
                9
              ],
              "def_end_pos": [
                361,
                16
              ]
            }
          ]
        ],
        "state_before": "case Adj.h.h.a\n\u03b9 : Sort u_1\nV : Type u\nG : SimpleGraph V\na b c u v\u271d w\u271d : V\ne : Sym2 V\ns : Set (Sym2 V)\nv w : V\n\u22a2 (fromEdgeSet Set.univ).Adj v w \u2194 \u22a4.Adj v w",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.646799492067657,
    "entry_failed": false
  },
  "8573": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/MvPolynomial/Degrees.lean",
    "full_name": "MvPolynomial.totalDegree_zero",
    "start": [
      387,
      1
    ],
    "end": [
      388,
      42
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 C_0]",
        "annotated_tactic": [
          "rw [\u2190 <a>C_0</a>]",
          [
            {
              "full_name": "MvPolynomial.C_0",
              "def_path": "Mathlib/Algebra/MvPolynomial/Basic.lean",
              "def_pos": [
                209,
                9
              ],
              "def_end_pos": [
                209,
                12
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\n\u22a2 totalDegree 0 = 0",
        "state_after": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\n\u22a2 (C 0).totalDegree = 0"
      },
      {
        "tactic": "exact totalDegree_C (0 : R)",
        "annotated_tactic": [
          "exact <a>totalDegree_C</a> (0 : R)",
          [
            {
              "full_name": "MvPolynomial.totalDegree_C",
              "def_path": "Mathlib/Algebra/MvPolynomial/Degrees.lean",
              "def_pos": [
                381,
                9
              ],
              "def_end_pos": [
                381,
                22
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\n\u22a2 (C 0).totalDegree = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.114792506908998,
    "entry_failed": false
  },
  "21071": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Coprime/Basic.lean",
    "full_name": "IsCoprime.of_mul_add_left_left",
    "start": [
      217,
      1
    ],
    "end": [
      219,
      31
    ],
    "traced_tactics": [
      {
        "tactic": "rw [add_comm] at h",
        "annotated_tactic": [
          "rw [<a>add_comm</a>] at h",
          [
            {
              "full_name": "add_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                331,
                3
              ],
              "def_end_pos": [
                331,
                14
              ]
            }
          ]
        ],
        "state_before": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nh : IsCoprime (y * z + x) y\n\u22a2 IsCoprime x y",
        "state_after": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nh : IsCoprime (x + y * z) y\n\u22a2 IsCoprime x y"
      },
      {
        "tactic": "exact h.of_add_mul_left_left",
        "annotated_tactic": [
          "exact h.of_add_mul_left_left",
          []
        ],
        "state_before": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nh : IsCoprime (x + y * z) y\n\u22a2 IsCoprime x y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.3139010629383847,
    "entry_failed": false
  },
  "17511": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": ".lake/packages/batteries/Batteries/Data/List/Perm.lean",
    "full_name": "List.Perm.filter",
    "start": [
      173,
      1
    ],
    "end": [
      174,
      82
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 filterMap_eq_filter]",
        "annotated_tactic": [
          "rw [\u2190 <a>filterMap_eq_filter</a>]",
          [
            {
              "full_name": "List.filterMap_eq_filter",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean",
              "def_pos": [
                972,
                9
              ],
              "def_end_pos": [
                972,
                28
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl\u2081 l\u2082 : List \u03b1\ns : l\u2081 ~ l\u2082\n\u22a2 List.filter p l\u2081 ~ List.filter p l\u2082",
        "state_after": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl\u2081 l\u2082 : List \u03b1\ns : l\u2081 ~ l\u2082\n\u22a2 List.filterMap (Option.guard fun x => p x = true) l\u2081 ~ List.filterMap (Option.guard fun x => p x = true) l\u2082"
      },
      {
        "tactic": "apply s.filterMap",
        "annotated_tactic": [
          "apply s.filterMap",
          []
        ],
        "state_before": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl\u2081 l\u2082 : List \u03b1\ns : l\u2081 ~ l\u2082\n\u22a2 List.filterMap (Option.guard fun x => p x = true) l\u2081 ~ List.filterMap (Option.guard fun x => p x = true) l\u2082",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7852146559162065,
    "entry_failed": false
  },
  "25993": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Heyting/Boundary.lean",
    "full_name": "Coheyting.boundary_le_boundary_sup_sup_boundary_inf_right",
    "start": [
      120,
      1
    ],
    "end": [
      122,
      55
    ],
    "traced_tactics": [
      {
        "tactic": "rw [sup_comm a, inf_comm]",
        "annotated_tactic": [
          "rw [<a>sup_comm</a> a, <a>inf_comm</a>]",
          [
            {
              "full_name": "sup_comm",
              "def_path": "Mathlib/Order/Lattice.lean",
              "def_pos": [
                224,
                9
              ],
              "def_end_pos": [
                224,
                17
              ]
            },
            {
              "full_name": "inf_comm",
              "def_path": "Mathlib/Order/Lattice.lean",
              "def_pos": [
                461,
                9
              ],
              "def_end_pos": [
                461,
                17
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : CoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 \u2202 b \u2264 \u2202 (a \u2294 b) \u2294 \u2202 (a \u2293 b)",
        "state_after": "\u03b1 : Type u_1\ninst\u271d : CoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 \u2202 b \u2264 \u2202 (b \u2294 a) \u2294 \u2202 (b \u2293 a)"
      },
      {
        "tactic": "exact boundary_le_boundary_sup_sup_boundary_inf_left",
        "annotated_tactic": [
          "exact <a>boundary_le_boundary_sup_sup_boundary_inf_left</a>",
          [
            {
              "full_name": "Coheyting.boundary_le_boundary_sup_sup_boundary_inf_left",
              "def_path": "Mathlib/Order/Heyting/Boundary.lean",
              "def_pos": [
                105,
                9
              ],
              "def_end_pos": [
                105,
                55
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : CoheytingAlgebra \u03b1\na b : \u03b1\n\u22a2 \u2202 b \u2264 \u2202 (b \u2294 a) \u2294 \u2202 (b \u2293 a)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.3180561729241163,
    "entry_failed": false
  },
  "9269": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/OfFn.lean",
    "full_name": "List.getElem_ofFn",
    "start": [
      61,
      1
    ],
    "end": [
      63,
      31
    ],
    "traced_tactics": [
      {
        "tactic": "simp_all",
        "annotated_tactic": [
          "simp_all",
          []
        ],
        "state_before": "\u03b1 : Type u\nn : \u2115\nf : Fin n \u2192 \u03b1\ni : \u2115\nh : i < (ofFn f).length\n\u22a2 i < n",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [ofFn, getElem_ofFn_go]",
        "annotated_tactic": [
          "simp [<a>ofFn</a>, <a>getElem_ofFn_go</a>]",
          [
            {
              "full_name": "List.ofFn",
              "def_path": ".lake/packages/batteries/Batteries/Data/List/Basic.lean",
              "def_pos": [
                745,
                5
              ],
              "def_end_pos": [
                745,
                9
              ]
            },
            {
              "full_name": "List.getElem_ofFn_go",
              "def_path": "Mathlib/Data/List/OfFn.lean",
              "def_pos": [
                50,
                9
              ],
              "def_end_pos": [
                50,
                24
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\nn : \u2115\nf : Fin n \u2192 \u03b1\ni : \u2115\nh : i < (ofFn f).length\n\u22a2 (ofFn f)[i] = f \u27e8i, \u22ef\u27e9",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6922911889851093,
    "entry_failed": false
  },
  "14951": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Filter.lean",
    "full_name": "Filter.nhds_iInf",
    "start": [
      139,
      1
    ],
    "end": [
      141,
      40
    ],
    "traced_tactics": [
      {
        "tactic": "simp only [nhds_eq]",
        "annotated_tactic": [
          "simp only [<a>nhds_eq</a>]",
          [
            {
              "full_name": "Filter.nhds_eq",
              "def_path": "Mathlib/Topology/Filter.lean",
              "def_pos": [
                74,
                9
              ],
              "def_end_pos": [
                74,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nX : Type u_4\nY : Type u_5\nf : \u03b9 \u2192 Filter \u03b1\n\u22a2 \ud835\udcdd (\u2a05 i, f i) = \u2a05 i, \ud835\udcdd (f i)",
        "state_after": "\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nX : Type u_4\nY : Type u_5\nf : \u03b9 \u2192 Filter \u03b1\n\u22a2 (\u2a05 i, f i).lift' (Iic \u2218 \ud835\udcdf) = \u2a05 i, (f i).lift' (Iic \u2218 \ud835\udcdf)"
      },
      {
        "tactic": "apply lift'_iInf_of_map_univ <;> simp",
        "annotated_tactic": [
          "apply <a>lift'_iInf_of_map_univ</a> <;> simp",
          [
            {
              "full_name": "Filter.lift'_iInf_of_map_univ",
              "def_path": "Mathlib/Order/Filter/Lift.lean",
              "def_pos": [
                393,
                9
              ],
              "def_end_pos": [
                393,
                31
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nX : Type u_4\nY : Type u_5\nf : \u03b9 \u2192 Filter \u03b1\n\u22a2 (\u2a05 i, f i).lift' (Iic \u2218 \ud835\udcdf) = \u2a05 i, (f i).lift' (Iic \u2218 \ud835\udcdf)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7921011339640245,
    "entry_failed": false
  },
  "1053": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Int/Lemmas.lean",
    "full_name": "Int.natAbs_lt_iff_sq_lt",
    "start": [
      50,
      1
    ],
    "end": [
      52,
      34
    ],
    "traced_tactics": [
      {
        "tactic": "rw [sq, sq]",
        "annotated_tactic": [
          "rw [<a>sq</a>, <a>sq</a>]",
          [
            {
              "full_name": "sq",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                684,
                41
              ],
              "def_end_pos": [
                684,
                43
              ]
            },
            {
              "full_name": "sq",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                684,
                41
              ],
              "def_end_pos": [
                684,
                43
              ]
            }
          ]
        ],
        "state_before": "a\u271d b\u271d : \u2124\nn : \u2115\na b : \u2124\n\u22a2 a.natAbs < b.natAbs \u2194 a ^ 2 < b ^ 2",
        "state_after": "a\u271d b\u271d : \u2124\nn : \u2115\na b : \u2124\n\u22a2 a.natAbs < b.natAbs \u2194 a * a < b * b"
      },
      {
        "tactic": "exact natAbs_lt_iff_mul_self_lt",
        "annotated_tactic": [
          "exact <a>natAbs_lt_iff_mul_self_lt</a>",
          [
            {
              "full_name": "Int.natAbs_lt_iff_mul_self_lt",
              "def_path": "Mathlib/Data/Int/Order/Lemmas.lean",
              "def_pos": [
                35,
                9
              ],
              "def_end_pos": [
                35,
                34
              ]
            }
          ]
        ],
        "state_before": "a\u271d b\u271d : \u2124\nn : \u2115\na b : \u2124\n\u22a2 a.natAbs < b.natAbs \u2194 a * a < b * b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2801956300390884,
    "entry_failed": false
  },
  "6747": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Ring/Canonical.lean",
    "full_name": "Odd.pos",
    "start": [
      47,
      1
    ],
    "end": [
      47,
      91
    ],
    "traced_tactics": [
      {
        "tactic": "rintro \u27e8k, rfl\u27e9",
        "annotated_tactic": [
          "rintro \u27e8k, rfl\u27e9",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d\u00b9 : CanonicallyOrderedCommSemiring \u03b1\na b c d : \u03b1\ninst\u271d : Nontrivial \u03b1\n\u22a2 Odd a \u2192 0 < a",
        "state_after": "case intro\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d\u00b9 : CanonicallyOrderedCommSemiring \u03b1\nb c d : \u03b1\ninst\u271d : Nontrivial \u03b1\nk : \u03b1\n\u22a2 0 < 2 * k + 1"
      },
      {
        "tactic": "simp [pos_iff_ne_zero]",
        "annotated_tactic": [
          "simp [<a>pos_iff_ne_zero</a>]",
          [
            {
              "full_name": "pos_iff_ne_zero",
              "def_path": "Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean",
              "def_pos": [
                230,
                3
              ],
              "def_end_pos": [
                230,
                14
              ]
            }
          ]
        ],
        "state_before": "case intro\n\u03b1 : Type u\n\u03b2 : Type u_1\ninst\u271d\u00b9 : CanonicallyOrderedCommSemiring \u03b1\nb c d : \u03b1\ninst\u271d : Nontrivial \u03b1\nk : \u03b1\n\u22a2 0 < 2 * k + 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.0356798040447757,
    "entry_failed": false
  },
  "2819": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Ring/Abs.lean",
    "full_name": "abs_lt_iff_mul_self_lt",
    "start": [
      95,
      1
    ],
    "end": [
      97,
      63
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 abs_mul_abs_self, \u2190 abs_mul_abs_self b]",
        "annotated_tactic": [
          "rw [\u2190 <a>abs_mul_abs_self</a>, \u2190 <a>abs_mul_abs_self</a> b]",
          [
            {
              "full_name": "abs_mul_abs_self",
              "def_path": "Mathlib/Algebra/Order/Ring/Abs.lean",
              "def_pos": [
                82,
                15
              ],
              "def_end_pos": [
                82,
                31
              ]
            },
            {
              "full_name": "abs_mul_abs_self",
              "def_path": "Mathlib/Algebra/Order/Ring/Abs.lean",
              "def_pos": [
                82,
                15
              ],
              "def_end_pos": [
                82,
                31
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedRing \u03b1\nn : \u2115\na b c : \u03b1\n\u22a2 |a| < |b| \u2194 a * a < b * b",
        "state_after": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedRing \u03b1\nn : \u2115\na b c : \u03b1\n\u22a2 |a| < |b| \u2194 |a| * |a| < |b| * |b|"
      },
      {
        "tactic": "exact mul_self_lt_mul_self_iff (abs_nonneg a) (abs_nonneg b)",
        "annotated_tactic": [
          "exact <a>mul_self_lt_mul_self_iff</a> (<a>abs_nonneg</a> a) (<a>abs_nonneg</a> b)",
          [
            {
              "full_name": "mul_self_lt_mul_self_iff",
              "def_path": "Mathlib/Algebra/Order/Ring/Defs.lean",
              "def_pos": [
                1009,
                9
              ],
              "def_end_pos": [
                1009,
                33
              ]
            },
            {
              "full_name": "abs_nonneg",
              "def_path": "Mathlib/Algebra/Order/Group/Abs.lean",
              "def_pos": [
                122,
                30
              ],
              "def_end_pos": [
                122,
                40
              ]
            },
            {
              "full_name": "abs_nonneg",
              "def_path": "Mathlib/Algebra/Order/Group/Abs.lean",
              "def_pos": [
                122,
                30
              ],
              "def_end_pos": [
                122,
                40
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedRing \u03b1\nn : \u2115\na b c : \u03b1\n\u22a2 |a| < |b| \u2194 |a| * |a| < |b| * |b|",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.1567169789923355,
    "entry_failed": false
  },
  "22785": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Interval/Set/OrderEmbedding.lean",
    "full_name": "OrderEmbedding.preimage_Ico",
    "start": [
      34,
      9
    ],
    "end": [
      34,
      79
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ne : \u03b1 \u21aao \u03b2\nx y : \u03b1\n\u22a2 \u21d1e \u207b\u00b9' Ico (e x) (e y) = Ico x y",
        "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ne : \u03b1 \u21aao \u03b2\nx y x\u271d : \u03b1\n\u22a2 x\u271d \u2208 \u21d1e \u207b\u00b9' Ico (e x) (e y) \u2194 x\u271d \u2208 Ico x y"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ne : \u03b1 \u21aao \u03b2\nx y x\u271d : \u03b1\n\u22a2 x\u271d \u2208 \u21d1e \u207b\u00b9' Ico (e x) (e y) \u2194 x\u271d \u2208 Ico x y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.125324086053297,
    "entry_failed": false
  },
  "8993": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Interval/Finset.lean",
    "full_name": "Finset.map_add_left_Ioc",
    "start": [
      48,
      1
    ],
    "end": [
      51,
      38
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 coe_inj, coe_map, coe_Ioc, coe_Ioc]",
        "annotated_tactic": [
          "rw [\u2190 <a>coe_inj</a>, <a>coe_map</a>, <a>coe_Ioc</a>, <a>coe_Ioc</a>]",
          [
            {
              "full_name": "Finset.coe_inj",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                244,
                9
              ],
              "def_end_pos": [
                244,
                16
              ]
            },
            {
              "full_name": "Finset.coe_map",
              "def_path": "Mathlib/Data/Finset/Image.lean",
              "def_pos": [
                114,
                9
              ],
              "def_end_pos": [
                114,
                16
              ]
            },
            {
              "full_name": "Finset.coe_Ioc",
              "def_path": "Mathlib/Order/Interval/Finset/Defs.lean",
              "def_pos": [
                343,
                9
              ],
              "def_end_pos": [
                343,
                16
              ]
            },
            {
              "full_name": "Finset.coe_Ioc",
              "def_path": "Mathlib/Order/Interval/Finset/Defs.lean",
              "def_pos": [
                343,
                9
              ],
              "def_end_pos": [
                343,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : OrderedCancelAddCommMonoid \u03b1\ninst\u271d\u00b9 : ExistsAddOfLE \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\na b c : \u03b1\n\u22a2 map (addLeftEmbedding c) (Ioc a b) = Ioc (c + a) (c + b)",
        "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : OrderedCancelAddCommMonoid \u03b1\ninst\u271d\u00b9 : ExistsAddOfLE \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\na b c : \u03b1\n\u22a2 \u21d1(addLeftEmbedding c) '' Set.Ioc a b = Set.Ioc (c + a) (c + b)"
      },
      {
        "tactic": "exact Set.image_const_add_Ioc _ _ _",
        "annotated_tactic": [
          "exact <a>Set.image_const_add_Ioc</a> _ _ _",
          [
            {
              "full_name": "Set.image_const_add_Ioc",
              "def_path": "Mathlib/Algebra/Order/Interval/Set/Monoid.lean",
              "def_pos": [
                133,
                9
              ],
              "def_end_pos": [
                133,
                28
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : OrderedCancelAddCommMonoid \u03b1\ninst\u271d\u00b9 : ExistsAddOfLE \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\na b c : \u03b1\n\u22a2 \u21d1(addLeftEmbedding c) '' Set.Ioc a b = Set.Ioc (c + a) (c + b)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.443966427934356,
    "entry_failed": false
  },
  "28432": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Setoid/Partition.lean",
    "full_name": "IndexedPartition.iUnion",
    "start": [
      382,
      1
    ],
    "end": [
      384,
      25
    ],
    "traced_tactics": [
      {
        "tactic": "ext x",
        "annotated_tactic": [
          "ext x",
          []
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ns : \u03b9 \u2192 Set \u03b1\nhs : IndexedPartition s\n\u22a2 \u22c3 i, s i = univ",
        "state_after": "case h\n\u03b9 : Type u_1\n\u03b1 : Type u_2\ns : \u03b9 \u2192 Set \u03b1\nhs : IndexedPartition s\nx : \u03b1\n\u22a2 x \u2208 \u22c3 i, s i \u2194 x \u2208 univ"
      },
      {
        "tactic": "simp [hs.exists_mem x]",
        "annotated_tactic": [
          "simp [hs.exists_mem x]",
          []
        ],
        "state_before": "case h\n\u03b9 : Type u_1\n\u03b1 : Type u_2\ns : \u03b9 \u2192 Set \u03b1\nhs : IndexedPartition s\nx : \u03b1\n\u22a2 x \u2208 \u22c3 i, s i \u2194 x \u2208 univ",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.3178343470208347,
    "entry_failed": false
  },
  "14535": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Matroid/Restrict.lean",
    "full_name": "Matroid.Restriction.eq_restrict",
    "start": [
      281,
      1
    ],
    "end": [
      282,
      51
    ],
    "traced_tactics": [
      {
        "tactic": "obtain \u27e8R, -, rfl\u27e9 := h",
        "annotated_tactic": [
          "obtain \u27e8R, -, rfl\u27e9 := h",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nM : Matroid \u03b1\nR I J X Y : Set \u03b1\nN : Matroid \u03b1\nh : N \u2264r M\n\u22a2 M \u21be N.E = N",
        "state_after": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nR\u271d I J X Y R : Set \u03b1\n\u22a2 M \u21be (M \u21be R).E = M \u21be R"
      },
      {
        "tactic": "rw [restrict_ground_eq]",
        "annotated_tactic": [
          "rw [<a>restrict_ground_eq</a>]",
          [
            {
              "full_name": "Matroid.restrict_ground_eq",
              "def_path": "Mathlib/Data/Matroid/Restrict.lean",
              "def_pos": [
                131,
                17
              ],
              "def_end_pos": [
                131,
                35
              ]
            }
          ]
        ],
        "state_before": "case intro.intro\n\u03b1 : Type u_1\nM : Matroid \u03b1\nR\u271d I J X Y R : Set \u03b1\n\u22a2 M \u21be (M \u21be R).E = M \u21be R",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.542826269054785,
    "entry_failed": false
  },
  "9077": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Pairing.lean",
    "full_name": "Nat.right_le_pair",
    "start": [
      115,
      1
    ],
    "end": [
      117,
      56
    ],
    "traced_tactics": [
      {
        "tactic": "by_cases h : a < b <;> simp [pair, h]",
        "annotated_tactic": [
          "by_cases h : a < b <;> simp [<a>pair</a>, h]",
          [
            {
              "full_name": "Nat.pair",
              "def_path": "Mathlib/Data/Nat/Pairing.lean",
              "def_pos": [
                35,
                5
              ],
              "def_end_pos": [
                35,
                9
              ]
            }
          ]
        ],
        "state_before": "a b : \u2115\n\u22a2 b \u2264 pair a b",
        "state_after": "case pos\na b : \u2115\nh : a < b\n\u22a2 b \u2264 b * b + a"
      },
      {
        "tactic": "exact le_trans (le_mul_self _) (Nat.le_add_right _ _)",
        "annotated_tactic": [
          "exact <a>le_trans</a> (<a>le_mul_self</a> _) (<a>Nat.le_add_right</a> _ _)",
          [
            {
              "full_name": "le_trans",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                56,
                9
              ],
              "def_end_pos": [
                56,
                17
              ]
            },
            {
              "full_name": "Nat.le_mul_self",
              "def_path": "Mathlib/Data/Nat/Defs.lean",
              "def_pos": [
                486,
                7
              ],
              "def_end_pos": [
                486,
                18
              ]
            },
            {
              "full_name": "Nat.le_add_right",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean",
              "def_pos": [
                395,
                9
              ],
              "def_end_pos": [
                395,
                21
              ]
            }
          ]
        ],
        "state_before": "case pos\na b : \u2115\nh : a < b\n\u22a2 b \u2264 b * b + a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6740534979617223,
    "entry_failed": false
  },
  "24427": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RepresentationTheory/Action/Basic.lean",
    "full_name": "Action.\u03c1_one",
    "start": [
      50,
      1
    ],
    "end": [
      50,
      98
    ],
    "traced_tactics": [
      {
        "tactic": "rw [MonoidHom.map_one]",
        "annotated_tactic": [
          "rw [<a>MonoidHom.map_one</a>]",
          [
            {
              "full_name": "MonoidHom.map_one",
              "def_path": "Mathlib/Algebra/Group/Hom/Defs.lean",
              "def_pos": [
                758,
                19
              ],
              "def_end_pos": [
                758,
                36
              ]
            }
          ]
        ],
        "state_before": "V : Type (u + 1)\ninst\u271d : LargeCategory V\nG : MonCat\nA : Action V G\n\u22a2 A.\u03c1 1 = \ud835\udfd9 A.V",
        "state_after": "V : Type (u + 1)\ninst\u271d : LargeCategory V\nG : MonCat\nA : Action V G\n\u22a2 1 = \ud835\udfd9 A.V"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "V : Type (u + 1)\ninst\u271d : LargeCategory V\nG : MonCat\nA : Action V G\n\u22a2 1 = \ud835\udfd9 A.V",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.275108629022725,
    "entry_failed": false
  },
  "1949": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Count.lean",
    "full_name": "Nat.count_of_forall",
    "start": [
      149,
      1
    ],
    "end": [
      151,
      34
    ],
    "traced_tactics": [
      {
        "tactic": "rw [count_eq_card_filter_range, filter_true_of_mem, card_range]",
        "annotated_tactic": [
          "rw [<a>count_eq_card_filter_range</a>, <a>filter_true_of_mem</a>, <a>card_range</a>]",
          [
            {
              "full_name": "Nat.count_eq_card_filter_range",
              "def_path": "Mathlib/Data/Nat/Count.lean",
              "def_pos": [
                54,
                9
              ],
              "def_end_pos": [
                54,
                35
              ]
            },
            {
              "full_name": "Finset.filter_true_of_mem",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                2646,
                9
              ],
              "def_end_pos": [
                2646,
                27
              ]
            },
            {
              "full_name": "Finset.card_range",
              "def_path": "Mathlib/Data/Finset/Card.lean",
              "def_pos": [
                206,
                9
              ],
              "def_end_pos": [
                206,
                19
              ]
            }
          ]
        ],
        "state_before": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\nhp : \u2200 n' < n, p n'\n\u22a2 count p n = n",
        "state_after": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\nhp : \u2200 n' < n, p n'\n\u22a2 \u2200 x \u2208 range n, p x"
      },
      {
        "tactic": "simpa only [Finset.mem_range]",
        "annotated_tactic": [
          "simpa only [<a>Finset.mem_range</a>]",
          [
            {
              "full_name": "Finset.mem_range",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                2935,
                9
              ],
              "def_end_pos": [
                2935,
                18
              ]
            }
          ]
        ],
        "state_before": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\nhp : \u2200 n' < n, p n'\n\u22a2 \u2200 x \u2208 range n, p x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8287703319219872,
    "entry_failed": false
  },
  "15736": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/WittVector/Truncated.lean",
    "full_name": "TruncatedWittVector.coeff_zero",
    "start": [
      211,
      1
    ],
    "end": [
      213,
      48
    ],
    "traced_tactics": [
      {
        "tactic": "show coeff i (truncateFun _ 0 : TruncatedWittVector p n R) = 0",
        "annotated_tactic": [
          "show <a>coeff</a> i (<a>truncateFun</a> _ 0 : <a>TruncatedWittVector</a> p n R) = 0",
          [
            {
              "full_name": "TruncatedWittVector.coeff",
              "def_path": "Mathlib/RingTheory/WittVector/Truncated.lean",
              "def_pos": [
                81,
                5
              ],
              "def_end_pos": [
                81,
                10
              ]
            },
            {
              "full_name": "WittVector.truncateFun",
              "def_path": "Mathlib/RingTheory/WittVector/Truncated.lean",
              "def_pos": [
                136,
                5
              ],
              "def_end_pos": [
                136,
                16
              ]
            },
            {
              "full_name": "TruncatedWittVector",
              "def_path": "Mathlib/RingTheory/WittVector/Truncated.lean",
              "def_pos": [
                60,
                5
              ],
              "def_end_pos": [
                60,
                24
              ]
            }
          ]
        ],
        "state_before": "p : \u2115\nhp : Fact (Nat.Prime p)\nn : \u2115\nR : Type u_1\ninst\u271d : CommRing R\ni : Fin n\n\u22a2 coeff i 0 = 0",
        "state_after": "p : \u2115\nhp : Fact (Nat.Prime p)\nn : \u2115\nR : Type u_1\ninst\u271d : CommRing R\ni : Fin n\n\u22a2 coeff i (truncateFun n 0) = 0"
      },
      {
        "tactic": "rw [coeff_truncateFun, WittVector.zero_coeff]",
        "annotated_tactic": [
          "rw [<a>coeff_truncateFun</a>, <a>WittVector.zero_coeff</a>]",
          [
            {
              "full_name": "WittVector.coeff_truncateFun",
              "def_path": "Mathlib/RingTheory/WittVector/Truncated.lean",
              "def_pos": [
                145,
                9
              ],
              "def_end_pos": [
                145,
                26
              ]
            },
            {
              "full_name": "WittVector.zero_coeff",
              "def_path": "Mathlib/RingTheory/WittVector/Defs.lean",
              "def_pos": [
                328,
                9
              ],
              "def_end_pos": [
                328,
                19
              ]
            }
          ]
        ],
        "state_before": "p : \u2115\nhp : Fact (Nat.Prime p)\nn : \u2115\nR : Type u_1\ninst\u271d : CommRing R\ni : Fin n\n\u22a2 coeff i (truncateFun n 0) = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.194345828029327,
    "entry_failed": false
  },
  "11179": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Ordinal/Exponential.lean",
    "full_name": "Ordinal.opow_limit",
    "start": [
      63,
      1
    ],
    "end": [
      65,
      67
    ],
    "traced_tactics": [
      {
        "tactic": "simp only [opow_def, if_neg a0]",
        "annotated_tactic": [
          "simp only [<a>opow_def</a>, <a>if_neg</a> a0]",
          [
            {
              "full_name": "Ordinal.opow_def",
              "def_path": "Mathlib/SetTheory/Ordinal/Exponential.lean",
              "def_pos": [
                36,
                9
              ],
              "def_end_pos": [
                36,
                17
              ]
            },
            {
              "full_name": "if_neg",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                937,
                9
              ],
              "def_end_pos": [
                937,
                15
              ]
            }
          ]
        ],
        "state_before": "a b : Ordinal.{u}\na0 : a \u2260 0\nh : b.IsLimit\n\u22a2 a ^ b = b.bsup fun c x => a ^ c",
        "state_after": "a b : Ordinal.{u}\na0 : a \u2260 0\nh : b.IsLimit\n\u22a2 (b.limitRecOn 1 (fun x IH => IH * a) fun b x => b.bsup) =\n    b.bsup fun c x => c.limitRecOn 1 (fun x IH => IH * a) fun b x => b.bsup"
      },
      {
        "tactic": "rw [limitRecOn_limit _ _ _ _ h]",
        "annotated_tactic": [
          "rw [<a>limitRecOn_limit</a> _ _ _ _ h]",
          [
            {
              "full_name": "Ordinal.limitRecOn_limit",
              "def_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean",
              "def_pos": [
                334,
                9
              ],
              "def_end_pos": [
                334,
                25
              ]
            }
          ]
        ],
        "state_before": "a b : Ordinal.{u}\na0 : a \u2260 0\nh : b.IsLimit\n\u22a2 (b.limitRecOn 1 (fun x IH => IH * a) fun b x => b.bsup) =\n    b.bsup fun c x => c.limitRecOn 1 (fun x IH => IH * a) fun b x => b.bsup",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7158244089223444,
    "entry_failed": false
  },
  "19522": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/ContinuousFunction/UniqueCFC.lean",
    "full_name": "ContinuousMap.toNNReal_algebraMap",
    "start": [
      78,
      1
    ],
    "end": [
      81,
      12
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "X : Type u_1\ninst\u271d : TopologicalSpace X\nr : \u211d\u22650\n\u22a2 ((algebraMap \u211d C(X, \u211d)) \u2191r).toNNReal = (algebraMap \u211d\u22650 C(X, \u211d\u22650)) r",
        "state_after": "case h.a\nX : Type u_1\ninst\u271d : TopologicalSpace X\nr : \u211d\u22650\na\u271d : X\n\u22a2 \u2191(((algebraMap \u211d C(X, \u211d)) \u2191r).toNNReal a\u271d) = \u2191(((algebraMap \u211d\u22650 C(X, \u211d\u22650)) r) a\u271d)"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case h.a\nX : Type u_1\ninst\u271d : TopologicalSpace X\nr : \u211d\u22650\na\u271d : X\n\u22a2 \u2191(((algebraMap \u211d C(X, \u211d)) \u2191r).toNNReal a\u271d) = \u2191(((algebraMap \u211d\u22650 C(X, \u211d\u22650)) r) a\u271d)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.428824869915843,
    "entry_failed": false
  },
  "25771": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/PartENat.lean",
    "full_name": "PartENat.toWithTop_natCast",
    "start": [
      622,
      1
    ],
    "end": [
      624,
      8
    ],
    "traced_tactics": [
      {
        "tactic": "simp only [\u2190 toWithTop_some]",
        "annotated_tactic": [
          "simp only [\u2190 <a>toWithTop_some</a>]",
          [
            {
              "full_name": "PartENat.toWithTop_some",
              "def_path": "Mathlib/Data/Nat/PartENat.lean",
              "def_pos": [
                618,
                9
              ],
              "def_end_pos": [
                618,
                23
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\nx\u271d : Decidable (\u2191n).Dom\n\u22a2 (\u2191n).toWithTop = \u2191n",
        "state_after": "n : \u2115\nx\u271d : Decidable (\u2191n).Dom\n\u22a2 (\u2191n).toWithTop = (\u2191n).toWithTop"
      },
      {
        "tactic": "congr",
        "annotated_tactic": [
          "congr",
          []
        ],
        "state_before": "n : \u2115\nx\u271d : Decidable (\u2191n).Dom\n\u22a2 (\u2191n).toWithTop = (\u2191n).toWithTop",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.465257265022956,
    "entry_failed": false
  },
  "10467": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/GeomSum.lean",
    "full_name": "sub_one_dvd_pow_sub_one",
    "start": [
      206,
      1
    ],
    "end": [
      209,
      52
    ],
    "traced_tactics": [
      {
        "tactic": "conv_rhs => rw [\u2190 one_pow n]",
        "annotated_tactic": [
          "conv_rhs => rw [\u2190 <a>one_pow</a> n]",
          [
            {
              "full_name": "one_pow",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                696,
                39
              ],
              "def_end_pos": [
                696,
                46
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\ninst\u271d : Ring \u03b1\nx : \u03b1\nn : \u2115\n\u22a2 x - 1 \u2223 x ^ n - 1",
        "state_after": "\u03b1 : Type u\ninst\u271d : Ring \u03b1\nx : \u03b1\nn : \u2115\n\u22a2 x - 1 \u2223 x ^ n - 1 ^ n"
      },
      {
        "tactic": "exact (Commute.one_right x).sub_dvd_pow_sub_pow n",
        "annotated_tactic": [
          "exact (<a>Commute.one_right</a> x).<a>sub_dvd_pow_sub_pow</a> n",
          [
            {
              "full_name": "Commute.one_right",
              "def_path": "Mathlib/Algebra/Group/Commute/Defs.lean",
              "def_pos": [
                156,
                9
              ],
              "def_end_pos": [
                156,
                18
              ]
            },
            {
              "full_name": "Commute.sub_dvd_pow_sub_pow",
              "def_path": "Mathlib/Algebra/GeomSum.lean",
              "def_pos": [
                193,
                9
              ],
              "def_end_pos": [
                193,
                36
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\ninst\u271d : Ring \u03b1\nx : \u03b1\nn : \u2115\n\u22a2 x - 1 \u2223 x ^ n - 1 ^ n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.9663430739892647,
    "entry_failed": false
  },
  "15299": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/MvPolynomial/Variables.lean",
    "full_name": "MvPolynomial.vars_C",
    "start": [
      87,
      1
    ],
    "end": [
      88,
      61
    ],
    "traced_tactics": [
      {
        "tactic": "classical rw [vars_def, degrees_C, Multiset.toFinset_zero]",
        "annotated_tactic": [
          "classical rw [<a>vars_def</a>, <a>degrees_C</a>, <a>Multiset.toFinset_zero</a>]",
          [
            {
              "full_name": "MvPolynomial.vars_def",
              "def_path": "Mathlib/Algebra/MvPolynomial/Variables.lean",
              "def_pos": [
                71,
                9
              ],
              "def_end_pos": [
                71,
                17
              ]
            },
            {
              "full_name": "MvPolynomial.degrees_C",
              "def_path": "Mathlib/Algebra/MvPolynomial/Degrees.lean",
              "def_pos": [
                101,
                9
              ],
              "def_end_pos": [
                101,
                18
              ]
            },
            {
              "full_name": "Multiset.toFinset_zero",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                3105,
                9
              ],
              "def_end_pos": [
                3105,
                22
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\n\u22a2 (C r).vars = \u2205",
        "state_after": "no goals"
      },
      {
        "tactic": "rw [vars_def, degrees_C, Multiset.toFinset_zero]",
        "annotated_tactic": [
          "rw [<a>vars_def</a>, <a>degrees_C</a>, <a>Multiset.toFinset_zero</a>]",
          [
            {
              "full_name": "MvPolynomial.vars_def",
              "def_path": "Mathlib/Algebra/MvPolynomial/Variables.lean",
              "def_pos": [
                71,
                9
              ],
              "def_end_pos": [
                71,
                17
              ]
            },
            {
              "full_name": "MvPolynomial.degrees_C",
              "def_path": "Mathlib/Algebra/MvPolynomial/Degrees.lean",
              "def_pos": [
                101,
                9
              ],
              "def_end_pos": [
                101,
                18
              ]
            },
            {
              "full_name": "Multiset.toFinset_zero",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                3105,
                9
              ],
              "def_end_pos": [
                3105,
                22
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nr : R\ne : \u2115\nn m : \u03c3\ns : \u03c3 \u2192\u2080 \u2115\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\n\u22a2 (C r).vars = \u2205",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5784757710061967,
    "entry_failed": false
  },
  "8857": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/FieldTheory/Separable.lean",
    "full_name": "Polynomial.not_separable_zero",
    "start": [
      52,
      1
    ],
    "end": [
      54,
      68
    ],
    "traced_tactics": [
      {
        "tactic": "rintro \u27e8x, y, h\u27e9",
        "annotated_tactic": [
          "rintro \u27e8x, y, h\u27e9",
          []
        ],
        "state_before": "R : Type u\ninst\u271d\u00b2 : CommSemiring R\nS : Type v\ninst\u271d\u00b9 : CommSemiring S\ninst\u271d : Nontrivial R\n\u22a2 \u00acSeparable 0",
        "state_after": "case intro.intro\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nS : Type v\ninst\u271d\u00b9 : CommSemiring S\ninst\u271d : Nontrivial R\nx y : R[X]\nh : x * 0 + y * derivative 0 = 1\n\u22a2 False"
      },
      {
        "tactic": "simp only [derivative_zero, mul_zero, add_zero, zero_ne_one] at h",
        "annotated_tactic": [
          "simp only [<a>derivative_zero</a>, <a>mul_zero</a>, <a>add_zero</a>, <a>zero_ne_one</a>] at h",
          [
            {
              "full_name": "Polynomial.derivative_zero",
              "def_path": "Mathlib/Algebra/Polynomial/Derivative.lean",
              "def_pos": [
                77,
                9
              ],
              "def_end_pos": [
                77,
                24
              ]
            },
            {
              "full_name": "MulZeroClass.mul_zero",
              "def_path": "Mathlib/Algebra/GroupWithZero/Defs.lean",
              "def_pos": [
                39,
                3
              ],
              "def_end_pos": [
                39,
                11
              ]
            },
            {
              "full_name": "add_zero",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                482,
                3
              ],
              "def_end_pos": [
                482,
                14
              ]
            },
            {
              "full_name": "zero_ne_one",
              "def_path": "Mathlib/Algebra/NeZero.lean",
              "def_pos": [
                55,
                15
              ],
              "def_end_pos": [
                55,
                26
              ]
            }
          ]
        ],
        "state_before": "case intro.intro\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nS : Type v\ninst\u271d\u00b9 : CommSemiring S\ninst\u271d : Nontrivial R\nx y : R[X]\nh : x * 0 + y * derivative 0 = 1\n\u22a2 False",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.1743642759975046,
    "entry_failed": false
  },
  "11320": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Surreal/Dyadic.lean",
    "full_name": "Surreal.double_powHalf_succ_eq_powHalf",
    "start": [
      182,
      1
    ],
    "end": [
      183,
      80
    ],
    "traced_tactics": [
      {
        "tactic": "rw [two_mul]",
        "annotated_tactic": [
          "rw [<a>two_mul</a>]",
          [
            {
              "full_name": "two_mul",
              "def_path": "Mathlib/Algebra/Ring/Defs.lean",
              "def_pos": [
                179,
                9
              ],
              "def_end_pos": [
                179,
                16
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\n\u22a2 2 * powHalf (n + 1) = powHalf n",
        "state_after": "n : \u2115\n\u22a2 powHalf (n + 1) + powHalf (n + 1) = powHalf n"
      },
      {
        "tactic": "exact Quotient.sound (PGame.add_powHalf_succ_self_eq_powHalf n)",
        "annotated_tactic": [
          "exact <a>Quotient.sound</a> (<a>PGame.add_powHalf_succ_self_eq_powHalf</a> n)",
          [
            {
              "full_name": "Quotient.sound",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1606,
                9
              ],
              "def_end_pos": [
                1606,
                14
              ]
            },
            {
              "full_name": "SetTheory.PGame.add_powHalf_succ_self_eq_powHalf",
              "def_path": "Mathlib/SetTheory/Surreal/Dyadic.lean",
              "def_pos": [
                124,
                9
              ],
              "def_end_pos": [
                124,
                41
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\n\u22a2 powHalf (n + 1) + powHalf (n + 1) = powHalf n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9896270369645208,
    "entry_failed": false
  },
  "10550": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Field/Basic.lean",
    "full_name": "inv_pos_lt_iff_one_lt_mul'",
    "start": [
      146,
      1
    ],
    "end": [
      148,
      23
    ],
    "traced_tactics": [
      {
        "tactic": "rw [inv_eq_one_div]",
        "annotated_tactic": [
          "rw [<a>inv_eq_one_div</a>]",
          [
            {
              "full_name": "inv_eq_one_div",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                445,
                9
              ],
              "def_end_pos": [
                445,
                23
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nha : 0 < a\n\u22a2 a\u207b\u00b9 < b \u2194 1 < a * b",
        "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nha : 0 < a\n\u22a2 1 / a < b \u2194 1 < a * b"
      },
      {
        "tactic": "exact div_lt_iff' ha",
        "annotated_tactic": [
          "exact <a>div_lt_iff'</a> ha",
          [
            {
              "full_name": "div_lt_iff'",
              "def_path": "Mathlib/Algebra/Order/Field/Basic.lean",
              "def_pos": [
                93,
                9
              ],
              "def_end_pos": [
                93,
                20
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : LinearOrderedSemifield \u03b1\na b c d e : \u03b1\nm n : \u2124\nha : 0 < a\n\u22a2 1 / a < b \u2194 1 < a * b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.989148707012646,
    "entry_failed": false
  },
  "22382": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Matroid/Map.lean",
    "full_name": "Matroid.map_emptyOn",
    "start": [
      451,
      1
    ],
    "end": [
      452,
      31
    ],
    "traced_tactics": [
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf\u271d : \u03b1 \u2192 \u03b2\nE I s : Set \u03b1\nM : Matroid \u03b1\nN : Matroid \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 InjOn f (emptyOn \u03b1).E",
        "state_after": "no goals"
      },
      {
        "tactic": "simp [\u2190 ground_eq_empty_iff]",
        "annotated_tactic": [
          "simp [\u2190 <a>ground_eq_empty_iff</a>]",
          [
            {
              "full_name": "Matroid.ground_eq_empty_iff",
              "def_path": "Mathlib/Data/Matroid/Constructions.lean",
              "def_pos": [
                57,
                9
              ],
              "def_end_pos": [
                57,
                28
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf\u271d : \u03b1 \u2192 \u03b2\nE I s : Set \u03b1\nM : Matroid \u03b1\nN : Matroid \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 (emptyOn \u03b1).map f \u22ef = emptyOn \u03b2",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.545388384955004,
    "entry_failed": false
  },
  "11344": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/PNat/Factors.lean",
    "full_name": "PrimeMultiset.prod_ofPNatMultiset",
    "start": [
      184,
      1
    ],
    "end": [
      186,
      25
    ],
    "traced_tactics": [
      {
        "tactic": "dsimp [prod]",
        "annotated_tactic": [
          "dsimp [<a>prod</a>]",
          [
            {
              "full_name": "PrimeMultiset.prod",
              "def_path": "Mathlib/Data/PNat/Factors.lean",
              "def_pos": [
                137,
                5
              ],
              "def_end_pos": [
                137,
                9
              ]
            }
          ]
        ],
        "state_before": "v : Multiset \u2115+\nh : \u2200 p \u2208 v, p.Prime\n\u22a2 (ofPNatMultiset v h).prod = v.prod",
        "state_after": "v : Multiset \u2115+\nh : \u2200 p \u2208 v, p.Prime\n\u22a2 (ofPNatMultiset v h).toPNatMultiset.prod = v.prod"
      },
      {
        "tactic": "rw [to_ofPNatMultiset]",
        "annotated_tactic": [
          "rw [<a>to_ofPNatMultiset</a>]",
          [
            {
              "full_name": "PrimeMultiset.to_ofPNatMultiset",
              "def_path": "Mathlib/Data/PNat/Factors.lean",
              "def_pos": [
                175,
                9
              ],
              "def_end_pos": [
                175,
                26
              ]
            }
          ]
        ],
        "state_before": "v : Multiset \u2115+\nh : \u2200 p \u2208 v, p.Prime\n\u22a2 (ofPNatMultiset v h).toPNatMultiset.prod = v.prod",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8506659819977358,
    "entry_failed": false
  },
  "19714": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Ring/Parity.lean",
    "full_name": "Even.neg_pow",
    "start": [
      41,
      1
    ],
    "end": [
      43,
      39
    ],
    "traced_tactics": [
      {
        "tactic": "rintro \u27e8c, rfl\u27e9 a",
        "annotated_tactic": [
          "rintro \u27e8c, rfl\u27e9 a",
          []
        ],
        "state_before": "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : HasDistribNeg \u03b1\nn : \u2115\na : \u03b1\n\u22a2 Even n \u2192 \u2200 (a : \u03b1), (-a) ^ n = a ^ n",
        "state_after": "case intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : HasDistribNeg \u03b1\na\u271d : \u03b1\nc : \u2115\na : \u03b1\n\u22a2 (-a) ^ (c + c) = a ^ (c + c)"
      },
      {
        "tactic": "simp_rw [\u2190 two_mul, pow_mul, neg_sq]",
        "annotated_tactic": [
          "simp_rw [\u2190 <a>two_mul</a>, <a>pow_mul</a>, <a>neg_sq</a>]",
          [
            {
              "full_name": "two_mul",
              "def_path": "Mathlib/Algebra/Ring/Defs.lean",
              "def_pos": [
                179,
                9
              ],
              "def_end_pos": [
                179,
                16
              ]
            },
            {
              "full_name": "pow_mul",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                713,
                32
              ],
              "def_end_pos": [
                713,
                39
              ]
            },
            {
              "full_name": "neg_sq",
              "def_path": "Mathlib/Algebra/Ring/Commute.lean",
              "def_pos": [
                196,
                7
              ],
              "def_end_pos": [
                196,
                13
              ]
            }
          ]
        ],
        "state_before": "case intro\nF : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : HasDistribNeg \u03b1\na\u271d : \u03b1\nc : \u2115\na : \u03b1\n\u22a2 (-a) ^ (c + c) = a ^ (c + c)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.3673140549799427,
    "entry_failed": false
  },
  "20277": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Filter/Archimedean.lean",
    "full_name": "tendsto_intCast_atTop_iff",
    "start": [
      69,
      1
    ],
    "end": [
      71,
      57
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 @Int.comap_cast_atTop R, tendsto_comap_iff]",
        "annotated_tactic": [
          "rw [\u2190 @<a>Int.comap_cast_atTop</a> R, <a>tendsto_comap_iff</a>]",
          [
            {
              "full_name": "Int.comap_cast_atTop",
              "def_path": "Mathlib/Order/Filter/Archimedean.lean",
              "def_pos": [
                55,
                17
              ],
              "def_end_pos": [
                55,
                37
              ]
            },
            {
              "full_name": "Filter.tendsto_comap_iff",
              "def_path": "Mathlib/Order/Filter/Basic.lean",
              "def_pos": [
                3140,
                9
              ],
              "def_end_pos": [
                3140,
                26
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : StrictOrderedRing R\ninst\u271d : Archimedean R\nf : \u03b1 \u2192 \u2124\nl : Filter \u03b1\n\u22a2 Tendsto (fun n => \u2191(f n)) l atTop \u2194 Tendsto f l atTop",
        "state_after": "\u03b1 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : StrictOrderedRing R\ninst\u271d : Archimedean R\nf : \u03b1 \u2192 \u2124\nl : Filter \u03b1\n\u22a2 Tendsto (fun n => \u2191(f n)) l atTop \u2194 Tendsto (Int.cast \u2218 f) l atTop"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : StrictOrderedRing R\ninst\u271d : Archimedean R\nf : \u03b1 \u2192 \u2124\nl : Filter \u03b1\n\u22a2 Tendsto (fun n => \u2191(f n)) l atTop \u2194 Tendsto (Int.cast \u2218 f) l atTop",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8714675899827853,
    "entry_failed": false
  },
  "24164": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/Opposites.lean",
    "full_name": "CategoryTheory.op_inv",
    "start": [
      162,
      1
    ],
    "end": [
      164,
      42
    ],
    "traced_tactics": [
      {
        "tactic": "apply IsIso.eq_inv_of_hom_inv_id",
        "annotated_tactic": [
          "apply <a>IsIso.eq_inv_of_hom_inv_id</a>",
          [
            {
              "full_name": "CategoryTheory.IsIso.eq_inv_of_hom_inv_id",
              "def_path": "Mathlib/CategoryTheory/Iso.lean",
              "def_pos": [
                380,
                9
              ],
              "def_end_pos": [
                380,
                29
              ]
            }
          ]
        ],
        "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nX Y : C\nf : X \u27f6 Y\ninst\u271d : IsIso f\n\u22a2 (inv f).op = inv f.op",
        "state_after": "case hom_inv_id\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nX Y : C\nf : X \u27f6 Y\ninst\u271d : IsIso f\n\u22a2 f.op \u226b (inv f).op = \ud835\udfd9 { unop := Y }"
      },
      {
        "tactic": "rw [\u2190 op_comp, IsIso.inv_hom_id, op_id]",
        "annotated_tactic": [
          "rw [\u2190 <a>op_comp</a>, <a>IsIso.inv_hom_id</a>, <a>op_id</a>]",
          [
            {
              "full_name": "CategoryTheory.op_comp",
              "def_path": "Mathlib/CategoryTheory/Opposites.lean",
              "def_pos": [
                79,
                9
              ],
              "def_end_pos": [
                79,
                16
              ]
            },
            {
              "full_name": "CategoryTheory.IsIso.inv_hom_id",
              "def_path": "Mathlib/CategoryTheory/Iso.lean",
              "def_pos": [
                291,
                9
              ],
              "def_end_pos": [
                291,
                19
              ]
            },
            {
              "full_name": "CategoryTheory.op_id",
              "def_path": "Mathlib/CategoryTheory/Opposites.lean",
              "def_pos": [
                84,
                9
              ],
              "def_end_pos": [
                84,
                14
              ]
            }
          ]
        ],
        "state_before": "case hom_inv_id\nC : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\nX Y : C\nf : X \u27f6 Y\ninst\u271d : IsIso f\n\u22a2 f.op \u226b (inv f).op = \ud835\udfd9 { unop := Y }",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8995381969725713,
    "entry_failed": false
  },
  "18818": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/Measure/Lebesgue/EqHaar.lean",
    "full_name": "MeasureTheory.addHaarMeasure_eq_volume",
    "start": [
      115,
      1
    ],
    "end": [
      116,
      66
    ],
    "traced_tactics": [
      {
        "tactic": "convert (addHaarMeasure_unique volume Icc01).symm",
        "annotated_tactic": [
          "convert (<a>addHaarMeasure_unique</a> <a>volume</a> <a>Icc01</a>).<a>symm</a>",
          [
            {
              "full_name": "MeasureTheory.Measure.addHaarMeasure_unique",
              "def_path": "Mathlib/MeasureTheory/Measure/Haar/Basic.lean",
              "def_pos": [
                755,
                3
              ],
              "def_end_pos": [
                755,
                14
              ]
            },
            {
              "full_name": "MeasureTheory.MeasureSpace.volume",
              "def_path": "Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean",
              "def_pos": [
                367,
                3
              ],
              "def_end_pos": [
                367,
                9
              ]
            },
            {
              "full_name": "TopologicalSpace.PositiveCompacts.Icc01",
              "def_path": "Mathlib/MeasureTheory/Measure/Lebesgue/EqHaar.lean",
              "def_pos": [
                56,
                5
              ],
              "def_end_pos": [
                56,
                44
              ]
            },
            {
              "full_name": "Eq.symm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                323,
                9
              ],
              "def_end_pos": [
                323,
                16
              ]
            }
          ]
        ],
        "state_before": "\u22a2 addHaarMeasure Icc01 = volume",
        "state_after": "case h.e'_2\n\n\u22a2 addHaarMeasure Icc01 = volume \u2191Icc01 \u2022 addHaarMeasure Icc01"
      },
      {
        "tactic": "simp [Icc01]",
        "annotated_tactic": [
          "simp [<a>Icc01</a>]",
          [
            {
              "full_name": "TopologicalSpace.PositiveCompacts.Icc01",
              "def_path": "Mathlib/MeasureTheory/Measure/Lebesgue/EqHaar.lean",
              "def_pos": [
                56,
                5
              ],
              "def_end_pos": [
                56,
                44
              ]
            }
          ]
        ],
        "state_before": "case h.e'_2\n\n\u22a2 addHaarMeasure Icc01 = volume \u2191Icc01 \u2022 addHaarMeasure Icc01",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.655971382977441,
    "entry_failed": false
  },
  "2381": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Stream/Init.lean",
    "full_name": "Stream'.interleave_tail_tail",
    "start": [
      426,
      1
    ],
    "end": [
      427,
      32
    ],
    "traced_tactics": [
      {
        "tactic": "rw [interleave_eq s\u2081 s\u2082]",
        "annotated_tactic": [
          "rw [<a>interleave_eq</a> s\u2081 s\u2082]",
          [
            {
              "full_name": "Stream'.interleave_eq",
              "def_path": "Mathlib/Data/Stream/Init.lean",
              "def_pos": [
                416,
                9
              ],
              "def_end_pos": [
                416,
                22
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\ns\u2081 s\u2082 : Stream' \u03b1\n\u22a2 s\u2081.tail \u22c8 s\u2082.tail = (s\u2081 \u22c8 s\u2082).tail.tail",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\ns\u2081 s\u2082 : Stream' \u03b1\n\u22a2 s\u2081.tail \u22c8 s\u2082.tail = (s\u2081.head :: s\u2082.head :: (s\u2081.tail \u22c8 s\u2082.tail)).tail.tail"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b4 : Type w\ns\u2081 s\u2082 : Stream' \u03b1\n\u22a2 s\u2081.tail \u22c8 s\u2082.tail = (s\u2081.head :: s\u2082.head :: (s\u2081.tail \u22c8 s\u2082.tail)).tail.tail",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.5196516449796036,
    "entry_failed": false
  },
  "21670": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Int/Basic.lean",
    "full_name": "Int.span_natAbs",
    "start": [
      139,
      1
    ],
    "end": [
      141,
      35
    ],
    "traced_tactics": [
      {
        "tactic": "rw [Ideal.span_singleton_eq_span_singleton]",
        "annotated_tactic": [
          "rw [<a>Ideal.span_singleton_eq_span_singleton</a>]",
          [
            {
              "full_name": "Ideal.span_singleton_eq_span_singleton",
              "def_path": "Mathlib/RingTheory/Ideal/Basic.lean",
              "def_pos": [
                516,
                9
              ],
              "def_end_pos": [
                516,
                41
              ]
            }
          ]
        ],
        "state_before": "a : \u2124\n\u22a2 Ideal.span {\u2191a.natAbs} = Ideal.span {a}",
        "state_after": "a : \u2124\n\u22a2 Associated (\u2191a.natAbs) a"
      },
      {
        "tactic": "exact (associated_natAbs _).symm",
        "annotated_tactic": [
          "exact (<a>associated_natAbs</a> _).<a>symm</a>",
          [
            {
              "full_name": "Int.associated_natAbs",
              "def_path": "Mathlib/Algebra/GCDMonoid/Nat.lean",
              "def_pos": [
                163,
                9
              ],
              "def_end_pos": [
                163,
                30
              ]
            },
            {
              "full_name": "Associated.symm",
              "def_path": "Mathlib/Algebra/Associated.lean",
              "def_pos": [
                419,
                19
              ],
              "def_end_pos": [
                419,
                23
              ]
            }
          ]
        ],
        "state_before": "a : \u2124\n\u22a2 Associated (\u2191a.natAbs) a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.0616210740990937,
    "entry_failed": false
  },
  "4735": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/DiscreteQuotient.lean",
    "full_name": "DiscreteQuotient.isClopen_setOf_rel",
    "start": [
      149,
      1
    ],
    "end": [
      151,
      26
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 fiber_eq]",
        "annotated_tactic": [
          "rw [\u2190 <a>fiber_eq</a>]",
          [
            {
              "full_name": "DiscreteQuotient.fiber_eq",
              "def_path": "Mathlib/Topology/DiscreteQuotient.lean",
              "def_pos": [
                112,
                9
              ],
              "def_end_pos": [
                112,
                17
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nX : Type u_2\nY : Type u_3\nZ : Type u_4\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nS : DiscreteQuotient X\nx : X\n\u22a2 IsClopen (setOf (S.Rel x))",
        "state_after": "\u03b1 : Type u_1\nX : Type u_2\nY : Type u_3\nZ : Type u_4\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nS : DiscreteQuotient X\nx : X\n\u22a2 IsClopen (S.proj \u207b\u00b9' {S.proj x})"
      },
      {
        "tactic": "apply isClopen_preimage",
        "annotated_tactic": [
          "apply <a>isClopen_preimage</a>",
          [
            {
              "full_name": "DiscreteQuotient.isClopen_preimage",
              "def_path": "Mathlib/Topology/DiscreteQuotient.lean",
              "def_pos": [
                137,
                9
              ],
              "def_end_pos": [
                137,
                26
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nX : Type u_2\nY : Type u_3\nZ : Type u_4\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nS : DiscreteQuotient X\nx : X\n\u22a2 IsClopen (S.proj \u207b\u00b9' {S.proj x})",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7261454199906439,
    "entry_failed": false
  },
  "1217": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Group/AddChar.lean",
    "full_name": "AddChar.mulShift_zero",
    "start": [
      388,
      1
    ],
    "end": [
      389,
      65
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : Ring R\ninst\u271d : CommMonoid M\n\u03c8 : AddChar R M\n\u22a2 \u03c8.mulShift 0 = 1",
        "state_after": "case h\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : Ring R\ninst\u271d : CommMonoid M\n\u03c8 : AddChar R M\nx\u271d : R\n\u22a2 (\u03c8.mulShift 0) x\u271d = 1 x\u271d"
      },
      {
        "tactic": "rw [mulShift_apply, zero_mul, map_zero_eq_one, one_apply]",
        "annotated_tactic": [
          "rw [<a>mulShift_apply</a>, <a>zero_mul</a>, <a>map_zero_eq_one</a>, <a>one_apply</a>]",
          [
            {
              "full_name": "AddChar.mulShift_apply",
              "def_path": "Mathlib/Algebra/Group/AddChar.lean",
              "def_pos": [
                353,
                15
              ],
              "def_end_pos": [
                353,
                29
              ]
            },
            {
              "full_name": "MulZeroClass.zero_mul",
              "def_path": "Mathlib/Algebra/GroupWithZero/Defs.lean",
              "def_pos": [
                37,
                3
              ],
              "def_end_pos": [
                37,
                11
              ]
            },
            {
              "full_name": "AddChar.map_zero_eq_one",
              "def_path": "Mathlib/Algebra/Group/AddChar.lean",
              "def_pos": [
                96,
                15
              ],
              "def_end_pos": [
                96,
                30
              ]
            },
            {
              "full_name": "AddChar.one_apply",
              "def_path": "Mathlib/Algebra/Group/AddChar.lean",
              "def_pos": [
                190,
                15
              ],
              "def_end_pos": [
                190,
                24
              ]
            }
          ]
        ],
        "state_before": "case h\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b9 : Ring R\ninst\u271d : CommMonoid M\n\u03c8 : AddChar R M\nx\u271d : R\n\u22a2 (\u03c8.mulShift 0) x\u271d = 1 x\u271d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.36176774604246,
    "entry_failed": false
  },
  "8411": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Finset/Option.lean",
    "full_name": "Finset.eraseNone_insertNone",
    "start": [
      170,
      1
    ],
    "end": [
      172,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Finset \u03b1\n\u22a2 eraseNone (insertNone s) = s",
        "state_after": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Finset \u03b1\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 eraseNone (insertNone s) \u2194 a\u271d \u2208 s"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Finset \u03b1\na\u271d : \u03b1\n\u22a2 a\u271d \u2208 eraseNone (insertNone s) \u2194 a\u271d \u2208 s",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.028508128016256,
    "entry_failed": false
  },
  "2215": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Group/Semiconj/Defs.lean",
    "full_name": "SemiconjBy.conj_mk",
    "start": [
      141,
      1
    ],
    "end": [
      142,
      59
    ],
    "traced_tactics": [
      {
        "tactic": "unfold SemiconjBy",
        "annotated_tactic": [
          "unfold <a>SemiconjBy</a>",
          [
            {
              "full_name": "SemiconjBy",
              "def_path": "Mathlib/Algebra/Group/Semiconj/Defs.lean",
              "def_pos": [
                40,
                5
              ],
              "def_end_pos": [
                40,
                15
              ]
            }
          ]
        ],
        "state_before": "S : Type u_1\nM : Type u_2\nG : Type u_3\ninst\u271d : Group G\na\u271d x\u271d y a x : G\n\u22a2 SemiconjBy a x (a * x * a\u207b\u00b9)",
        "state_after": "S : Type u_1\nM : Type u_2\nG : Type u_3\ninst\u271d : Group G\na\u271d x\u271d y a x : G\n\u22a2 a * x = a * x * a\u207b\u00b9 * a"
      },
      {
        "tactic": "rw [mul_assoc, inv_mul_self, mul_one]",
        "annotated_tactic": [
          "rw [<a>mul_assoc</a>, <a>inv_mul_self</a>, <a>mul_one</a>]",
          [
            {
              "full_name": "mul_assoc",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                289,
                9
              ],
              "def_end_pos": [
                289,
                18
              ]
            },
            {
              "full_name": "inv_mul_self",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                1228,
                9
              ],
              "def_end_pos": [
                1228,
                21
              ]
            },
            {
              "full_name": "mul_one",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                483,
                9
              ],
              "def_end_pos": [
                483,
                16
              ]
            }
          ]
        ],
        "state_before": "S : Type u_1\nM : Type u_2\nG : Type u_3\ninst\u271d : Group G\na\u271d x\u271d y a x : G\n\u22a2 a * x = a * x * a\u207b\u00b9 * a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 0.9705307030817494,
    "entry_failed": false
  },
  "13092": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Perm/Fin.lean",
    "full_name": "Fin.cycleRange_last",
    "start": [
      239,
      1
    ],
    "end": [
      241,
      55
    ],
    "traced_tactics": [
      {
        "tactic": "ext i",
        "annotated_tactic": [
          "ext i",
          []
        ],
        "state_before": "n : \u2115\n\u22a2 (last n).cycleRange = finRotate (n + 1)",
        "state_after": "case H.h\nn : \u2115\ni : Fin (n + 1)\n\u22a2 \u2191((last n).cycleRange i) = \u2191((finRotate (n + 1)) i)"
      },
      {
        "tactic": "rw [coe_cycleRange_of_le (le_last _), coe_finRotate]",
        "annotated_tactic": [
          "rw [<a>coe_cycleRange_of_le</a> (<a>le_last</a> _), <a>coe_finRotate</a>]",
          [
            {
              "full_name": "Fin.coe_cycleRange_of_le",
              "def_path": "Mathlib/GroupTheory/Perm/Fin.lean",
              "def_pos": [
                193,
                9
              ],
              "def_end_pos": [
                193,
                29
              ]
            },
            {
              "full_name": "Fin.le_last",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Fin/Lemmas.lean",
              "def_pos": [
                169,
                9
              ],
              "def_end_pos": [
                169,
                16
              ]
            },
            {
              "full_name": "coe_finRotate",
              "def_path": "Mathlib/Logic/Equiv/Fin.lean",
              "def_pos": [
                452,
                9
              ],
              "def_end_pos": [
                452,
                22
              ]
            }
          ]
        ],
        "state_before": "case H.h\nn : \u2115\ni : Fin (n + 1)\n\u22a2 \u2191((last n).cycleRange i) = \u2191((finRotate (n + 1)) i)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.8844597989227623,
    "entry_failed": false
  },
  "12033": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Rat/Defs.lean",
    "full_name": "Rat.nonneg_total",
    "start": [
      507,
      1
    ],
    "end": [
      508,
      85
    ],
    "traced_tactics": [
      {
        "tactic": "simp_rw [\u2190 num_nonneg, num_neg_eq_neg_num, Int.neg_nonneg]",
        "annotated_tactic": [
          "simp_rw [\u2190 <a>num_nonneg</a>, <a>num_neg_eq_neg_num</a>, <a>Int.neg_nonneg</a>]",
          [
            {
              "full_name": "Rat.num_nonneg",
              "def_path": "Mathlib/Data/Rat/Defs.lean",
              "def_pos": [
                122,
                15
              ],
              "def_end_pos": [
                122,
                25
              ]
            },
            {
              "full_name": "Rat.num_neg_eq_neg_num",
              "def_path": "Mathlib/Data/Rat/Defs.lean",
              "def_pos": [
                459,
                9
              ],
              "def_end_pos": [
                459,
                27
              ]
            },
            {
              "full_name": "Int.neg_nonneg",
              "def_path": "Mathlib/Data/Int/Defs.lean",
              "def_pos": [
                89,
                17
              ],
              "def_end_pos": [
                89,
                27
              ]
            }
          ]
        ],
        "state_before": "q a\u271d b c a : \u211a\n\u22a2 0 \u2264 a \u2228 0 \u2264 -a",
        "state_after": "q a\u271d b c a : \u211a\n\u22a2 0 \u2264 a.num \u2228 a.num \u2264 0"
      },
      {
        "tactic": "exact Int.le_total _ _",
        "annotated_tactic": [
          "exact <a>Int.le_total</a> _ _",
          [
            {
              "full_name": "Int.le_total",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean",
              "def_pos": [
                47,
                19
              ],
              "def_end_pos": [
                47,
                27
              ]
            }
          ]
        ],
        "state_before": "q a\u271d b c a : \u211a\n\u22a2 0 \u2264 a.num \u2228 a.num \u2264 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.8249557270901278,
    "entry_failed": false
  },
  "16595": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/AddTorsor.lean",
    "full_name": "vsub_right_cancel",
    "start": [
      225,
      1
    ],
    "end": [
      227,
      33
    ],
    "traced_tactics": [
      {
        "tactic": "refine vadd_left_cancel (p -\u1d65 p\u2082) ?_",
        "annotated_tactic": [
          "refine <a>vadd_left_cancel</a> (p -\u1d65 p\u2082) ?_",
          [
            {
              "full_name": "vadd_left_cancel",
              "def_path": "Mathlib/GroupTheory/GroupAction/Group.lean",
              "def_pos": [
                155,
                3
              ],
              "def_end_pos": [
                155,
                14
              ]
            }
          ]
        ],
        "state_before": "G : Type u_1\nP : Type u_2\ninst\u271d : AddGroup G\nT : AddTorsor G P\np\u2081 p\u2082 p : P\nh : p -\u1d65 p\u2081 = p -\u1d65 p\u2082\n\u22a2 p\u2081 = p\u2082",
        "state_after": "G : Type u_1\nP : Type u_2\ninst\u271d : AddGroup G\nT : AddTorsor G P\np\u2081 p\u2082 p : P\nh : p -\u1d65 p\u2081 = p -\u1d65 p\u2082\n\u22a2 p -\u1d65 p\u2082 +\u1d65 p\u2081 = p -\u1d65 p\u2082 +\u1d65 p\u2082"
      },
      {
        "tactic": "rw [vsub_vadd, \u2190 h, vsub_vadd]",
        "annotated_tactic": [
          "rw [<a>vsub_vadd</a>, \u2190 h, <a>vsub_vadd</a>]",
          [
            {
              "full_name": "vsub_vadd",
              "def_path": "Mathlib/Algebra/AddTorsor.lean",
              "def_pos": [
                85,
                9
              ],
              "def_end_pos": [
                85,
                18
              ]
            },
            {
              "full_name": "vsub_vadd",
              "def_path": "Mathlib/Algebra/AddTorsor.lean",
              "def_pos": [
                85,
                9
              ],
              "def_end_pos": [
                85,
                18
              ]
            }
          ]
        ],
        "state_before": "G : Type u_1\nP : Type u_2\ninst\u271d : AddGroup G\nT : AddTorsor G P\np\u2081 p\u2082 p : P\nh : p -\u1d65 p\u2081 = p -\u1d65 p\u2082\n\u22a2 p -\u1d65 p\u2082 +\u1d65 p\u2081 = p -\u1d65 p\u2082 +\u1d65 p\u2082",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.1743325130082667,
    "entry_failed": false
  },
  "8454": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Interval/Set/OrderEmbedding.lean",
    "full_name": "OrderEmbedding.preimage_Ioo",
    "start": [
      36,
      9
    ],
    "end": [
      36,
      79
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ne : \u03b1 \u21aao \u03b2\nx y : \u03b1\n\u22a2 \u21d1e \u207b\u00b9' Ioo (e x) (e y) = Ioo x y",
        "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ne : \u03b1 \u21aao \u03b2\nx y x\u271d : \u03b1\n\u22a2 x\u271d \u2208 \u21d1e \u207b\u00b9' Ioo (e x) (e y) \u2194 x\u271d \u2208 Ioo x y"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\ne : \u03b1 \u21aao \u03b2\nx y x\u271d : \u03b1\n\u22a2 x\u271d \u2208 \u21d1e \u207b\u00b9' Ioo (e x) (e y) \u2194 x\u271d \u2208 Ioo x y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2354733609827235,
    "entry_failed": false
  },
  "1178": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Filter.lean",
    "full_name": "Filter.closure_singleton",
    "start": [
      178,
      11
    ],
    "end": [
      180,
      43
    ],
    "traced_tactics": [
      {
        "tactic": "ext l'",
        "annotated_tactic": [
          "ext l'",
          []
        ],
        "state_before": "\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nX : Type u_4\nY : Type u_5\nl : Filter \u03b1\n\u22a2 closure {l} = Ici l",
        "state_after": "case h\n\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nX : Type u_4\nY : Type u_5\nl l' : Filter \u03b1\n\u22a2 l' \u2208 closure {l} \u2194 l' \u2208 Ici l"
      },
      {
        "tactic": "simp [Filter.mem_closure, Filter.le_def]",
        "annotated_tactic": [
          "simp [<a>Filter.mem_closure</a>, <a>Filter.le_def</a>]",
          [
            {
              "full_name": "Filter.mem_closure",
              "def_path": "Mathlib/Topology/Filter.lean",
              "def_pos": [
                170,
                19
              ],
              "def_end_pos": [
                170,
                30
              ]
            },
            {
              "full_name": "Filter.le_def",
              "def_path": "Mathlib/Order/Filter/Basic.lean",
              "def_pos": [
                344,
                9
              ],
              "def_end_pos": [
                344,
                15
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b9 : Sort u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nX : Type u_4\nY : Type u_5\nl l' : Filter \u03b1\n\u22a2 l' \u2208 closure {l} \u2194 l' \u2208 Ici l",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.971037634066306,
    "entry_failed": false
  },
  "13555": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/LegendreSymbol/ZModChar.lean",
    "full_name": "ZMod.\u03c7\u2084_nat_one_mod_four",
    "start": [
      94,
      1
    ],
    "end": [
      96,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u03c7\u2084_nat_mod_four, hn]",
        "annotated_tactic": [
          "rw [<a>\u03c7\u2084_nat_mod_four</a>, hn]",
          [
            {
              "full_name": "ZMod.\u03c7\u2084_nat_mod_four",
              "def_path": "Mathlib/NumberTheory/LegendreSymbol/ZModChar.lean",
              "def_pos": [
                58,
                9
              ],
              "def_end_pos": [
                58,
                24
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\nhn : n % 4 = 1\n\u22a2 \u03c7\u2084 \u2191n = 1",
        "state_after": "n : \u2115\nhn : n % 4 = 1\n\u22a2 \u03c7\u2084 \u21911 = 1"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "n : \u2115\nhn : n % 4 = 1\n\u22a2 \u03c7\u2084 \u21911 = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9761029629735276,
    "entry_failed": false
  },
  "20632": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Complex/Cardinality.lean",
    "full_name": "not_countable_complex",
    "start": [
      35,
      1
    ],
    "end": [
      37,
      15
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 le_aleph0_iff_set_countable, not_le, mk_univ_complex]",
        "annotated_tactic": [
          "rw [\u2190 <a>le_aleph0_iff_set_countable</a>, <a>not_le</a>, <a>mk_univ_complex</a>]",
          [
            {
              "full_name": "Cardinal.le_aleph0_iff_set_countable",
              "def_path": "Mathlib/SetTheory/Cardinal/Basic.lean",
              "def_pos": [
                1634,
                9
              ],
              "def_end_pos": [
                1634,
                36
              ]
            },
            {
              "full_name": "not_le",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                375,
                9
              ],
              "def_end_pos": [
                375,
                15
              ]
            },
            {
              "full_name": "mk_univ_complex",
              "def_path": "Mathlib/Data/Complex/Cardinality.lean",
              "def_pos": [
                31,
                9
              ],
              "def_end_pos": [
                31,
                24
              ]
            }
          ]
        ],
        "state_before": "\u22a2 \u00acSet.univ.Countable",
        "state_after": "\u22a2 \u2135\u2080 < \ud835\udd20"
      },
      {
        "tactic": "apply cantor",
        "annotated_tactic": [
          "apply <a>cantor</a>",
          [
            {
              "full_name": "Cardinal.cantor",
              "def_path": "Mathlib/SetTheory/Cardinal/Basic.lean",
              "def_pos": [
                736,
                9
              ],
              "def_end_pos": [
                736,
                15
              ]
            }
          ]
        ],
        "state_before": "\u22a2 \u2135\u2080 < \ud835\udd20",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5526289010886103,
    "entry_failed": false
  },
  "24029": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Combinatorics/SetFamily/Compression/Down.lean",
    "full_name": "Finset.nonMemberSubfamily_nonMemberSubfamily",
    "start": [
      133,
      1
    ],
    "end": [
      136,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c \u212c : Finset (Finset \u03b1)\ns : Finset \u03b1\na : \u03b1\n\u22a2 nonMemberSubfamily a (nonMemberSubfamily a \ud835\udc9c) = nonMemberSubfamily a \ud835\udc9c",
        "state_after": "case a\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c \u212c : Finset (Finset \u03b1)\ns : Finset \u03b1\na : \u03b1\na\u271d : Finset \u03b1\n\u22a2 a\u271d \u2208 nonMemberSubfamily a (nonMemberSubfamily a \ud835\udc9c) \u2194 a\u271d \u2208 nonMemberSubfamily a \ud835\udc9c"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case a\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\ud835\udc9c \u212c : Finset (Finset \u03b1)\ns : Finset \u03b1\na : \u03b1\na\u271d : Finset \u03b1\n\u22a2 a\u271d \u2208 nonMemberSubfamily a (nonMemberSubfamily a \ud835\udc9c) \u2194 a\u271d \u2208 nonMemberSubfamily a \ud835\udc9c",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5837416889844462,
    "entry_failed": false
  },
  "9236": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Interval/Set/Instances.lean",
    "full_name": "Set.Icc.coe_eq_zero",
    "start": [
      79,
      1
    ],
    "end": [
      81,
      24
    ],
    "traced_tactics": [
      {
        "tactic": "symm",
        "annotated_tactic": [
          "symm",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : OrderedSemiring \u03b1\nx : \u2191(Icc 0 1)\n\u22a2 \u2191x = 0 \u2194 x = 0",
        "state_after": "\u03b1 : Type u_1\ninst\u271d : OrderedSemiring \u03b1\nx : \u2191(Icc 0 1)\n\u22a2 x = 0 \u2194 \u2191x = 0"
      },
      {
        "tactic": "exact Subtype.ext_iff",
        "annotated_tactic": [
          "exact <a>Subtype.ext_iff</a>",
          [
            {
              "full_name": "Subtype.ext_iff",
              "def_path": "Mathlib/Data/Subtype.lean",
              "def_pos": [
                78,
                9
              ],
              "def_end_pos": [
                78,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : OrderedSemiring \u03b1\nx : \u2191(Icc 0 1)\n\u22a2 x = 0 \u2194 \u2191x = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.3264796199509874,
    "entry_failed": false
  },
  "25263": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Array/ExtractLemmas.lean",
    "full_name": "Array.extract_eq_nil_of_start_eq_end",
    "start": [
      16,
      1
    ],
    "end": [
      19,
      22
    ],
    "traced_tactics": [
      {
        "tactic": "refine extract_empty_of_stop_le_start a ?h",
        "annotated_tactic": [
          "refine <a>extract_empty_of_stop_le_start</a> a ?h",
          [
            {
              "full_name": "Array.extract_empty_of_stop_le_start",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Array/Lemmas.lean",
              "def_pos": [
                919,
                9
              ],
              "def_end_pos": [
                919,
                39
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ni : Nat\na : Array \u03b1\n\u22a2 a.extract i i = #[]",
        "state_after": "case h\n\u03b1 : Type u_1\ni : Nat\na : Array \u03b1\n\u22a2 i \u2264 i"
      },
      {
        "tactic": "exact Nat.le_refl i",
        "annotated_tactic": [
          "exact <a>Nat.le_refl</a> i",
          [
            {
              "full_name": "Nat.le_refl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                1690,
                19
              ],
              "def_end_pos": [
                1690,
                30
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u_1\ni : Nat\na : Array \u03b1\n\u22a2 i \u2264 i",
        "state_after": "no goals"
      }
    ],
    "entry_time": 0.5424963010009378,
    "entry_failed": false
  },
  "936": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Ring/Ext.lean",
    "full_name": "Ring.toSemiring_injective",
    "start": [
      387,
      1
    ],
    "end": [
      392,
      39
    ],
    "traced_tactics": [
      {
        "tactic": "intro _ _ h",
        "annotated_tactic": [
          "intro _ _ h",
          []
        ],
        "state_before": "R : Type u\n\u22a2 Function.Injective (@toSemiring R)",
        "state_after": "R : Type u\na\u2081\u271d a\u2082\u271d : Ring R\nh : toSemiring = toSemiring\n\u22a2 a\u2081\u271d = a\u2082\u271d"
      },
      {
        "tactic": "ext x y",
        "annotated_tactic": [
          "ext x y",
          []
        ],
        "state_before": "R : Type u\na\u2081\u271d a\u2082\u271d : Ring R\nh : toSemiring = toSemiring\n\u22a2 a\u2081\u271d = a\u2082\u271d",
        "state_after": "case h_add.h.h\nR : Type u\na\u2081\u271d a\u2082\u271d : Ring R\nh : toSemiring = toSemiring\nx y : R\n\u22a2 x + y = x + y\n\ncase h_mul.h.h\nR : Type u\na\u2081\u271d a\u2082\u271d : Ring R\nh : toSemiring = toSemiring\nx y : R\n\u22a2 x * y = x * y"
      }
    ],
    "entry_time": 2.4135632920078933,
    "entry_failed": false
  },
  "19794": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Category/CompHaus/Limits.lean",
    "full_name": "CompHaus.finiteCoproduct.\u03b9_injective",
    "start": [
      216,
      1
    ],
    "end": [
      218,
      43
    ],
    "traced_tactics": [
      {
        "tactic": "intro x y hxy",
        "annotated_tactic": [
          "intro x y hxy",
          []
        ],
        "state_before": "\u03b1 : Type w\ninst\u271d : Finite \u03b1\nX : \u03b1 \u2192 CompHaus\na : \u03b1\n\u22a2 Function.Injective \u21d1(\u03b9 X a)",
        "state_after": "\u03b1 : Type w\ninst\u271d : Finite \u03b1\nX : \u03b1 \u2192 CompHaus\na : \u03b1\nx y : (forget CompHaus).obj (X a)\nhxy : (\u03b9 X a) x = (\u03b9 X a) y\n\u22a2 x = y"
      },
      {
        "tactic": "exact eq_of_heq (Sigma.ext_iff.mp hxy).2",
        "annotated_tactic": [
          "exact <a>eq_of_heq</a> (Sigma.ext_iff.mp hxy).2",
          [
            {
              "full_name": "eq_of_heq",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                464,
                9
              ],
              "def_end_pos": [
                464,
                18
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type w\ninst\u271d : Finite \u03b1\nX : \u03b1 \u2192 CompHaus\na : \u03b1\nx y : (forget CompHaus).obj (X a)\nhxy : (\u03b9 X a) x = (\u03b9 X a) y\n\u22a2 x = y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.095666302018799,
    "entry_failed": false
  },
  "27291": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Matroid/Constructions.lean",
    "full_name": "Matroid.eq_emptyOn",
    "start": [
      71,
      1
    ],
    "end": [
      73,
      32
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 ground_eq_empty_iff]",
        "annotated_tactic": [
          "rw [\u2190 <a>ground_eq_empty_iff</a>]",
          [
            {
              "full_name": "Matroid.ground_eq_empty_iff",
              "def_path": "Mathlib/Data/Matroid/Constructions.lean",
              "def_pos": [
                57,
                9
              ],
              "def_end_pos": [
                57,
                28
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nM\u271d : Matroid \u03b1\nE B I X R J : Set \u03b1\ninst\u271d : IsEmpty \u03b1\nM : Matroid \u03b1\n\u22a2 M = emptyOn \u03b1",
        "state_after": "\u03b1 : Type u_1\nM\u271d : Matroid \u03b1\nE B I X R J : Set \u03b1\ninst\u271d : IsEmpty \u03b1\nM : Matroid \u03b1\n\u22a2 M.E = \u2205"
      },
      {
        "tactic": "exact M.E.eq_empty_of_isEmpty",
        "annotated_tactic": [
          "exact M.E.eq_empty_of_isEmpty",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nM\u271d : Matroid \u03b1\nE B I X R J : Set \u03b1\ninst\u271d : IsEmpty \u03b1\nM : Matroid \u03b1\n\u22a2 M.E = \u2205",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5061457760166377,
    "entry_failed": false
  },
  "5068": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/SuccPred/Limit.lean",
    "full_name": "Order.IsPredLimit.isMin",
    "start": [
      322,
      11
    ],
    "end": [
      324,
      40
    ],
    "traced_tactics": [
      {
        "tactic": "by_contra H",
        "annotated_tactic": [
          "by_contra H",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\na : \u03b1\ninst\u271d : PredOrder \u03b1\nh : IsPredLimit (pred a)\n\u22a2 IsMin a",
        "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\na : \u03b1\ninst\u271d : PredOrder \u03b1\nh : IsPredLimit (pred a)\nH : \u00acIsMin a\n\u22a2 False"
      },
      {
        "tactic": "exact h a (pred_covBy_of_not_isMin H)",
        "annotated_tactic": [
          "exact h a (<a>pred_covBy_of_not_isMin</a> H)",
          [
            {
              "full_name": "Order.pred_covBy_of_not_isMin",
              "def_path": "Mathlib/Order/SuccPred/Basic.lean",
              "def_pos": [
                652,
                9
              ],
              "def_end_pos": [
                652,
                32
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\na : \u03b1\ninst\u271d : PredOrder \u03b1\nh : IsPredLimit (pred a)\nH : \u00acIsMin a\n\u22a2 False",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9091740199364722,
    "entry_failed": false
  },
  "7620": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Ordinal/FixedPoint.lean",
    "full_name": "Ordinal.nfp_le_iff",
    "start": [
      449,
      1
    ],
    "end": [
      451,
      19
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 sup_iterate_eq_nfp]",
        "annotated_tactic": [
          "rw [\u2190 <a>sup_iterate_eq_nfp</a>]",
          [
            {
              "full_name": "Ordinal.sup_iterate_eq_nfp",
              "def_path": "Mathlib/SetTheory/Ordinal/FixedPoint.lean",
              "def_pos": [
                424,
                9
              ],
              "def_end_pos": [
                424,
                27
              ]
            }
          ]
        ],
        "state_before": "f : Ordinal.{u} \u2192 Ordinal.{u}\na b : Ordinal.{u}\n\u22a2 nfp f a \u2264 b \u2194 \u2200 (n : \u2115), f^[n] a \u2264 b",
        "state_after": "f : Ordinal.{u} \u2192 Ordinal.{u}\na b : Ordinal.{u}\n\u22a2 (fun a => sup fun n => f^[n] a) a \u2264 b \u2194 \u2200 (n : \u2115), f^[n] a \u2264 b"
      },
      {
        "tactic": "exact sup_le_iff",
        "annotated_tactic": [
          "exact <a>sup_le_iff</a>",
          [
            {
              "full_name": "Ordinal.sup_le_iff",
              "def_path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean",
              "def_pos": [
                1263,
                9
              ],
              "def_end_pos": [
                1263,
                19
              ]
            }
          ]
        ],
        "state_before": "f : Ordinal.{u} \u2192 Ordinal.{u}\na b : Ordinal.{u}\n\u22a2 (fun a => sup fun n => f^[n] a) a \u2264 b \u2194 \u2200 (n : \u2115), f^[n] a \u2264 b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.947105811093934,
    "entry_failed": false
  },
  "25947": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/GCDMonoid/Multiset.lean",
    "full_name": "Multiset.lcm_union",
    "start": [
      110,
      1
    ],
    "end": [
      112,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 lcm_dedup, dedup_ext.2, lcm_dedup, lcm_add]",
        "annotated_tactic": [
          "rw [\u2190 <a>lcm_dedup</a>, <a>dedup_ext</a>.2, <a>lcm_dedup</a>, <a>lcm_add</a>]",
          [
            {
              "full_name": "Multiset.lcm_dedup",
              "def_path": "Mathlib/Algebra/GCDMonoid/Multiset.lean",
              "def_pos": [
                95,
                9
              ],
              "def_end_pos": [
                95,
                18
              ]
            },
            {
              "full_name": "Multiset.dedup_ext",
              "def_path": "Mathlib/Data/Multiset/Dedup.lean",
              "def_pos": [
                116,
                9
              ],
              "def_end_pos": [
                116,
                18
              ]
            },
            {
              "full_name": "Multiset.lcm_dedup",
              "def_path": "Mathlib/Algebra/GCDMonoid/Multiset.lean",
              "def_pos": [
                95,
                9
              ],
              "def_end_pos": [
                95,
                18
              ]
            },
            {
              "full_name": "Multiset.lcm_add",
              "def_path": "Mathlib/Algebra/GCDMonoid/Multiset.lean",
              "def_pos": [
                59,
                9
              ],
              "def_end_pos": [
                59,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b9 : NormalizedGCDMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\ns\u2081 s\u2082 : Multiset \u03b1\n\u22a2 (s\u2081 \u222a s\u2082).lcm = GCDMonoid.lcm s\u2081.lcm s\u2082.lcm",
        "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b9 : NormalizedGCDMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\ns\u2081 s\u2082 : Multiset \u03b1\n\u22a2 \u2200 (a : \u03b1), a \u2208 s\u2081 \u222a s\u2082 \u2194 a \u2208 s\u2081 + s\u2082"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b9 : NormalizedGCDMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\ns\u2081 s\u2082 : Multiset \u03b1\n\u22a2 \u2200 (a : \u03b1), a \u2208 s\u2081 \u222a s\u2082 \u2194 a \u2208 s\u2081 + s\u2082",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6377487479476258,
    "entry_failed": false
  },
  "7508": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/Normed/Group/Pointwise.lean",
    "full_name": "inv_cthickening",
    "start": [
      102,
      1
    ],
    "end": [
      104,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "simp_rw [cthickening, \u2190 infEdist_inv]",
        "annotated_tactic": [
          "simp_rw [<a>cthickening</a>, \u2190 <a>infEdist_inv</a>]",
          [
            {
              "full_name": "Metric.cthickening",
              "def_path": "Mathlib/Topology/MetricSpace/Thickening.lean",
              "def_pos": [
                195,
                5
              ],
              "def_end_pos": [
                195,
                16
              ]
            },
            {
              "full_name": "infEdist_inv",
              "def_path": "Mathlib/Analysis/Normed/Group/Pointwise.lean",
              "def_pos": [
                76,
                9
              ],
              "def_end_pos": [
                76,
                21
              ]
            }
          ]
        ],
        "state_before": "E : Type u_1\ninst\u271d : SeminormedCommGroup E\n\u03b5 \u03b4 : \u211d\ns t : Set E\nx y : E\n\u22a2 (cthickening \u03b4 s)\u207b\u00b9 = cthickening \u03b4 s\u207b\u00b9",
        "state_after": "E : Type u_1\ninst\u271d : SeminormedCommGroup E\n\u03b5 \u03b4 : \u211d\ns t : Set E\nx y : E\n\u22a2 {x | EMetric.infEdist x s \u2264 ENNReal.ofReal \u03b4}\u207b\u00b9 = {x | EMetric.infEdist x\u207b\u00b9 s \u2264 ENNReal.ofReal \u03b4}"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "E : Type u_1\ninst\u271d : SeminormedCommGroup E\n\u03b5 \u03b4 : \u211d\ns t : Set E\nx y : E\n\u22a2 {x | EMetric.infEdist x s \u2264 ENNReal.ofReal \u03b4}\u207b\u00b9 = {x | EMetric.infEdist x\u207b\u00b9 s \u2264 ENNReal.ofReal \u03b4}",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.193708510021679,
    "entry_failed": false
  },
  "27224": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean",
    "full_name": "Mathlib.Meta.Positivity.log_nonneg_of_isNegNat",
    "start": [
      506,
      1
    ],
    "end": [
      509,
      38
    ],
    "traced_tactics": [
      {
        "tactic": "rw [NormNum.IsInt.neg_to_eq h rfl]",
        "annotated_tactic": [
          "rw [<a>NormNum.IsInt.neg_to_eq</a> h <a>rfl</a>]",
          [
            {
              "full_name": "Mathlib.Meta.NormNum.IsInt.neg_to_eq",
              "def_path": "Mathlib/Tactic/NormNum/Result.lean",
              "def_pos": [
                176,
                9
              ],
              "def_end_pos": [
                176,
                24
              ]
            },
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "e : \u211d\nd n : \u2115\nh : NormNum.IsInt e (Int.negOfNat n)\n\u22a2 0 \u2264 Real.log e",
        "state_after": "e : \u211d\nd n : \u2115\nh : NormNum.IsInt e (Int.negOfNat n)\n\u22a2 0 \u2264 Real.log (-\u2191n)"
      },
      {
        "tactic": "exact Real.log_neg_natCast_nonneg _",
        "annotated_tactic": [
          "exact <a>Real.log_neg_natCast_nonneg</a> _",
          [
            {
              "full_name": "Real.log_neg_natCast_nonneg",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean",
              "def_pos": [
                230,
                9
              ],
              "def_end_pos": [
                230,
                31
              ]
            }
          ]
        ],
        "state_before": "e : \u211d\nd n : \u2115\nh : NormNum.IsInt e (Int.negOfNat n)\n\u22a2 0 \u2264 Real.log (-\u2191n)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.810860686004162,
    "entry_failed": false
  },
  "16802": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Int/Bitwise.lean",
    "full_name": "Int.bit_negSucc",
    "start": [
      257,
      1
    ],
    "end": [
      259,
      18
    ],
    "traced_tactics": [
      {
        "tactic": "rw [bit_val, Nat.bit_val]",
        "annotated_tactic": [
          "rw [<a>bit_val</a>, <a>Nat.bit_val</a>]",
          [
            {
              "full_name": "Int.bit_val",
              "def_path": "Mathlib/Data/Int/Bitwise.lean",
              "def_pos": [
                228,
                9
              ],
              "def_end_pos": [
                228,
                16
              ]
            },
            {
              "full_name": "Nat.bit_val",
              "def_path": "Mathlib/Data/Nat/Bits.lean",
              "def_pos": [
                151,
                7
              ],
              "def_end_pos": [
                151,
                14
              ]
            }
          ]
        ],
        "state_before": "b : Bool\nn : \u2115\n\u22a2 bit b -[n+1] = -[Nat.bit (!b) n+1]",
        "state_after": "b : Bool\nn : \u2115\n\u22a2 (2 * -[n+1] + bif b then 1 else 0) = -[2 * n + bif !b then 1 else 0+1]"
      },
      {
        "tactic": "cases b <;> rfl",
        "annotated_tactic": [
          "cases b <;> rfl",
          []
        ],
        "state_before": "b : Bool\nn : \u2115\n\u22a2 (2 * -[n+1] + bif b then 1 else 0) = -[2 * n + bif !b then 1 else 0+1]",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9204548370325938,
    "entry_failed": false
  },
  "16074": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/AlgebraicGeometry/AffineScheme.lean",
    "full_name": "AlgebraicGeometry.isAffine_of_isIso",
    "start": [
      109,
      1
    ],
    "end": [
      110,
      81
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 mem_Spec_essImage] at h \u22a2",
        "annotated_tactic": [
          "rw [\u2190 <a>mem_Spec_essImage</a>] at h \u22a2",
          [
            {
              "full_name": "AlgebraicGeometry.mem_Spec_essImage",
              "def_path": "Mathlib/AlgebraicGeometry/AffineScheme.lean",
              "def_pos": [
                93,
                9
              ],
              "def_end_pos": [
                93,
                26
              ]
            }
          ]
        ],
        "state_before": "X Y : Scheme\nf : X \u27f6 Y\ninst\u271d : IsIso f\nh : IsAffine Y\n\u22a2 IsAffine X",
        "state_after": "X Y : Scheme\nf : X \u27f6 Y\ninst\u271d : IsIso f\nh : Y \u2208 Scheme.Spec.essImage\n\u22a2 X \u2208 Scheme.Spec.essImage"
      },
      {
        "tactic": "exact Functor.essImage.ofIso (asIso f).symm h",
        "annotated_tactic": [
          "exact <a>Functor.essImage.ofIso</a> (<a>asIso</a> f).<a>symm</a> h",
          [
            {
              "full_name": "CategoryTheory.Functor.essImage.ofIso",
              "def_path": "Mathlib/CategoryTheory/EssentialImage.lean",
              "def_pos": [
                57,
                9
              ],
              "def_end_pos": [
                57,
                23
              ]
            },
            {
              "full_name": "CategoryTheory.asIso",
              "def_path": "Mathlib/CategoryTheory/Iso.lean",
              "def_pos": [
                329,
                19
              ],
              "def_end_pos": [
                329,
                24
              ]
            },
            {
              "full_name": "CategoryTheory.Iso.symm",
              "def_path": "Mathlib/CategoryTheory/Iso.lean",
              "def_pos": [
                94,
                5
              ],
              "def_end_pos": [
                94,
                9
              ]
            }
          ]
        ],
        "state_before": "X Y : Scheme\nf : X \u27f6 Y\ninst\u271d : IsIso f\nh : Y \u2208 Scheme.Spec.essImage\n\u22a2 X \u2208 Scheme.Spec.essImage",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.5000683090183884,
    "entry_failed": false
  },
  "26952": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Algebra/InfiniteSum/Group.lean",
    "full_name": "multipliable_iff_cauchySeq_finset",
    "start": [
      192,
      1
    ],
    "end": [
      194,
      53
    ],
    "traced_tactics": [
      {
        "tactic": "classical exact cauchy_map_iff_exists_tendsto.symm",
        "annotated_tactic": [
          "classical exact cauchy_map_iff_exists_tendsto.symm",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : CommGroup \u03b1\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : CompleteSpace \u03b1\nf : \u03b2 \u2192 \u03b1\n\u22a2 Multipliable f \u2194 CauchySeq fun s => \u220f b \u2208 s, f b",
        "state_after": "no goals"
      },
      {
        "tactic": "exact cauchy_map_iff_exists_tendsto.symm",
        "annotated_tactic": [
          "exact cauchy_map_iff_exists_tendsto.symm",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b2 : CommGroup \u03b1\ninst\u271d\u00b9 : UniformSpace \u03b1\ninst\u271d : CompleteSpace \u03b1\nf : \u03b2 \u2192 \u03b1\n\u22a2 Multipliable f \u2194 CauchySeq fun s => \u220f b \u2208 s, f b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.14172343199607,
    "entry_failed": false
  },
  "16273": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": ".lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "full_name": "List.modifyNth_eq_modifyNthTR",
    "start": [
      267,
      10
    ],
    "end": [
      268,
      56
    ],
    "traced_tactics": [
      {
        "tactic": "funext \u03b1 f n l",
        "annotated_tactic": [
          "funext \u03b1 f n l",
          []
        ],
        "state_before": "\u22a2 @modifyNth = @modifyNthTR",
        "state_after": "case h.h.h.h\n\u03b1 : Type u_1\nf : \u03b1 \u2192 \u03b1\nn : Nat\nl : List \u03b1\n\u22a2 modifyNth f n l = modifyNthTR f n l"
      },
      {
        "tactic": "simp [modifyNthTR, modifyNthTR_go_eq]",
        "annotated_tactic": [
          "simp [<a>modifyNthTR</a>, <a>modifyNthTR_go_eq</a>]",
          [
            {
              "full_name": "List.modifyNthTR",
              "def_path": ".lake/packages/batteries/Batteries/Data/List/Basic.lean",
              "def_pos": [
                255,
                5
              ],
              "def_end_pos": [
                255,
                16
              ]
            },
            {
              "full_name": "List.modifyNthTR_go_eq",
              "def_path": ".lake/packages/batteries/Batteries/Data/List/Basic.lean",
              "def_pos": [
                262,
                9
              ],
              "def_end_pos": [
                262,
                26
              ]
            }
          ]
        ],
        "state_before": "case h.h.h.h\n\u03b1 : Type u_1\nf : \u03b1 \u2192 \u03b1\nn : Nat\nl : List \u03b1\n\u22a2 modifyNth f n l = modifyNthTR f n l",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.8307296029524878,
    "entry_failed": false
  },
  "13515": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/ContinuedFractions/Computation/Basic.lean",
    "full_name": "GeneralizedContinuedFraction.IntFractPair.stream_isSeq",
    "start": [
      159,
      1
    ],
    "end": [
      161,
      34
    ],
    "traced_tactics": [
      {
        "tactic": "intro _ hyp",
        "annotated_tactic": [
          "intro _ hyp",
          []
        ],
        "state_before": "K : Type u_1\ninst\u271d\u00b9 : LinearOrderedField K\ninst\u271d : FloorRing K\nv : K\n\u22a2 (IntFractPair.stream v).IsSeq",
        "state_after": "K : Type u_1\ninst\u271d\u00b9 : LinearOrderedField K\ninst\u271d : FloorRing K\nv : K\nn\u271d : \u2115\nhyp : IntFractPair.stream v n\u271d = none\n\u22a2 IntFractPair.stream v (n\u271d + 1) = none"
      },
      {
        "tactic": "simp [IntFractPair.stream, hyp]",
        "annotated_tactic": [
          "simp [<a>IntFractPair.stream</a>, hyp]",
          [
            {
              "full_name": "GeneralizedContinuedFraction.IntFractPair.stream",
              "def_path": "Mathlib/Algebra/ContinuedFractions/Computation/Basic.lean",
              "def_pos": [
                149,
                15
              ],
              "def_end_pos": [
                149,
                21
              ]
            }
          ]
        ],
        "state_before": "K : Type u_1\ninst\u271d\u00b9 : LinearOrderedField K\ninst\u271d : FloorRing K\nv : K\nn\u271d : \u2115\nhyp : IntFractPair.stream v n\u271d = none\n\u22a2 IntFractPair.stream v (n\u271d + 1) = none",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.3075574060203508,
    "entry_failed": false
  },
  "21091": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Finset/Sym.lean",
    "full_name": "Finset.mem_sym2_iff",
    "start": [
      51,
      1
    ],
    "end": [
      53,
      22
    ],
    "traced_tactics": [
      {
        "tactic": "rw [mem_mk, sym2_val, Multiset.mem_sym2_iff]",
        "annotated_tactic": [
          "rw [<a>mem_mk</a>, <a>sym2_val</a>, <a>Multiset.mem_sym2_iff</a>]",
          [
            {
              "full_name": "Finset.mem_mk",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                185,
                9
              ],
              "def_end_pos": [
                185,
                15
              ]
            },
            {
              "full_name": "Finset.sym2_val",
              "def_path": "Mathlib/Data/Finset/Sym.lean",
              "def_pos": [
                39,
                3
              ],
              "def_end_pos": [
                39,
                8
              ]
            },
            {
              "full_name": "Multiset.mem_sym2_iff",
              "def_path": "Mathlib/Data/Multiset/Sym.lean",
              "def_pos": [
                54,
                9
              ],
              "def_end_pos": [
                54,
                21
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ns t : Finset \u03b1\na b : \u03b1\nm : Sym2 \u03b1\n\u22a2 m \u2208 s.sym2 \u2194 \u2200 a \u2208 m, a \u2208 s",
        "state_after": "\u03b1 : Type u_1\ns t : Finset \u03b1\na b : \u03b1\nm : Sym2 \u03b1\n\u22a2 (\u2200 y \u2208 m, y \u2208 s.val) \u2194 \u2200 a \u2208 m, a \u2208 s"
      },
      {
        "tactic": "simp only [mem_val]",
        "annotated_tactic": [
          "simp only [<a>mem_val</a>]",
          [
            {
              "full_name": "Finset.mem_val",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                180,
                9
              ],
              "def_end_pos": [
                180,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ns t : Finset \u03b1\na b : \u03b1\nm : Sym2 \u03b1\n\u22a2 (\u2200 y \u2208 m, y \u2208 s.val) \u2194 \u2200 a \u2208 m, a \u2208 s",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2918941939715296,
    "entry_failed": false
  },
  "24604": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Interval/Finset.lean",
    "full_name": "Finset.map_add_left_Ico",
    "start": [
      36,
      1
    ],
    "end": [
      39,
      38
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 coe_inj, coe_map, coe_Ico, coe_Ico]",
        "annotated_tactic": [
          "rw [\u2190 <a>coe_inj</a>, <a>coe_map</a>, <a>coe_Ico</a>, <a>coe_Ico</a>]",
          [
            {
              "full_name": "Finset.coe_inj",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                244,
                9
              ],
              "def_end_pos": [
                244,
                16
              ]
            },
            {
              "full_name": "Finset.coe_map",
              "def_path": "Mathlib/Data/Finset/Image.lean",
              "def_pos": [
                114,
                9
              ],
              "def_end_pos": [
                114,
                16
              ]
            },
            {
              "full_name": "Finset.coe_Ico",
              "def_path": "Mathlib/Order/Interval/Finset/Defs.lean",
              "def_pos": [
                338,
                9
              ],
              "def_end_pos": [
                338,
                16
              ]
            },
            {
              "full_name": "Finset.coe_Ico",
              "def_path": "Mathlib/Order/Interval/Finset/Defs.lean",
              "def_pos": [
                338,
                9
              ],
              "def_end_pos": [
                338,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : OrderedCancelAddCommMonoid \u03b1\ninst\u271d\u00b9 : ExistsAddOfLE \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\na b c : \u03b1\n\u22a2 map (addLeftEmbedding c) (Ico a b) = Ico (c + a) (c + b)",
        "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : OrderedCancelAddCommMonoid \u03b1\ninst\u271d\u00b9 : ExistsAddOfLE \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\na b c : \u03b1\n\u22a2 \u21d1(addLeftEmbedding c) '' Set.Ico a b = Set.Ico (c + a) (c + b)"
      },
      {
        "tactic": "exact Set.image_const_add_Ico _ _ _",
        "annotated_tactic": [
          "exact <a>Set.image_const_add_Ico</a> _ _ _",
          [
            {
              "full_name": "Set.image_const_add_Ico",
              "def_path": "Mathlib/Algebra/Order/Interval/Set/Monoid.lean",
              "def_pos": [
                128,
                9
              ],
              "def_end_pos": [
                128,
                28
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : OrderedCancelAddCommMonoid \u03b1\ninst\u271d\u00b9 : ExistsAddOfLE \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\na b c : \u03b1\n\u22a2 \u21d1(addLeftEmbedding c) '' Set.Ico a b = Set.Ico (c + a) (c + b)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2993626580573618,
    "entry_failed": false
  },
  "28413": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Int/Basic.lean",
    "full_name": "Int.Prime.dvd_mul'",
    "start": [
      93,
      1
    ],
    "end": [
      96,
      31
    ],
    "traced_tactics": [
      {
        "tactic": "rw [Int.natCast_dvd, Int.natCast_dvd]",
        "annotated_tactic": [
          "rw [<a>Int.natCast_dvd</a>, <a>Int.natCast_dvd</a>]",
          [
            {
              "full_name": "Int.natCast_dvd",
              "def_path": "Mathlib/Data/Int/Defs.lean",
              "def_pos": [
                668,
                7
              ],
              "def_end_pos": [
                668,
                18
              ]
            },
            {
              "full_name": "Int.natCast_dvd",
              "def_path": "Mathlib/Data/Int/Defs.lean",
              "def_pos": [
                668,
                7
              ],
              "def_end_pos": [
                668,
                18
              ]
            }
          ]
        ],
        "state_before": "m n : \u2124\np : \u2115\nhp : Nat.Prime p\nh : \u2191p \u2223 m * n\n\u22a2 \u2191p \u2223 m \u2228 \u2191p \u2223 n",
        "state_after": "m n : \u2124\np : \u2115\nhp : Nat.Prime p\nh : \u2191p \u2223 m * n\n\u22a2 p \u2223 m.natAbs \u2228 p \u2223 n.natAbs"
      },
      {
        "tactic": "exact Int.Prime.dvd_mul hp h",
        "annotated_tactic": [
          "exact <a>Int.Prime.dvd_mul</a> hp h",
          [
            {
              "full_name": "Int.Prime.dvd_mul",
              "def_path": "Mathlib/RingTheory/Int/Basic.lean",
              "def_pos": [
                88,
                9
              ],
              "def_end_pos": [
                88,
                26
              ]
            }
          ]
        ],
        "state_before": "m n : \u2124\np : \u2115\nhp : Nat.Prime p\nh : \u2191p \u2223 m * n\n\u22a2 p \u2223 m.natAbs \u2228 p \u2223 n.natAbs",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.835213917074725,
    "entry_failed": false
  },
  "1557": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Circular.lean",
    "full_name": "sbtw_iff_not_btw",
    "start": [
      315,
      1
    ],
    "end": [
      317,
      60
    ],
    "traced_tactics": [
      {
        "tactic": "rw [sbtw_iff_btw_not_btw]",
        "annotated_tactic": [
          "rw [<a>sbtw_iff_btw_not_btw</a>]",
          [
            {
              "full_name": "sbtw_iff_btw_not_btw",
              "def_path": "Mathlib/Order/Circular.lean",
              "def_pos": [
                183,
                9
              ],
              "def_end_pos": [
                183,
                29
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : CircularOrder \u03b1\na b c : \u03b1\n\u22a2 sbtw a b c \u2194 \u00acbtw c b a",
        "state_after": "\u03b1 : Type u_1\ninst\u271d : CircularOrder \u03b1\na b c : \u03b1\n\u22a2 btw a b c \u2227 \u00acbtw c b a \u2194 \u00acbtw c b a"
      },
      {
        "tactic": "exact and_iff_right_of_imp (btw_total _ _ _).resolve_left",
        "annotated_tactic": [
          "exact <a>and_iff_right_of_imp</a> (<a>btw_total</a> _ _ _).<a>resolve_left</a>",
          [
            {
              "full_name": "and_iff_right_of_imp",
              "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean",
              "def_pos": [
                162,
                9
              ],
              "def_end_pos": [
                162,
                29
              ]
            },
            {
              "full_name": "CircularOrder.btw_total",
              "def_path": "Mathlib/Order/Circular.lean",
              "def_pos": [
                148,
                3
              ],
              "def_end_pos": [
                148,
                12
              ]
            },
            {
              "full_name": "Or.resolve_left",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                555,
                9
              ],
              "def_end_pos": [
                555,
                24
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : CircularOrder \u03b1\na b c : \u03b1\n\u22a2 btw a b c \u2227 \u00acbtw c b a \u2194 \u00acbtw c b a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.3836089950054884,
    "entry_failed": false
  },
  "7635": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean",
    "full_name": "CategoryTheory.Limits.IsZero.of_mono_eq_zero",
    "start": [
      205,
      1
    ],
    "end": [
      207,
      25
    ],
    "traced_tactics": [
      {
        "tactic": "subst h",
        "annotated_tactic": [
          "subst h",
          []
        ],
        "state_before": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nD : Type u'\ninst\u271d\u00b2 : Category.{v', u'} D\ninst\u271d\u00b9 : HasZeroMorphisms C\nX Y : C\nf : X \u27f6 Y\ninst\u271d : Mono f\nh : f = 0\n\u22a2 IsZero X",
        "state_after": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nD : Type u'\ninst\u271d\u00b2 : Category.{v', u'} D\ninst\u271d\u00b9 : HasZeroMorphisms C\nX Y : C\ninst\u271d : Mono 0\n\u22a2 IsZero X"
      },
      {
        "tactic": "apply of_mono_zero X Y",
        "annotated_tactic": [
          "apply <a>of_mono_zero</a> X Y",
          [
            {
              "full_name": "CategoryTheory.Limits.IsZero.of_mono_zero",
              "def_path": "Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean",
              "def_pos": [
                197,
                9
              ],
              "def_end_pos": [
                197,
                21
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nD : Type u'\ninst\u271d\u00b2 : Category.{v', u'} D\ninst\u271d\u00b9 : HasZeroMorphisms C\nX Y : C\ninst\u271d : Mono 0\n\u22a2 IsZero X",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.2267817079555243,
    "entry_failed": false
  },
  "26340": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Fintype/Powerset.lean",
    "full_name": "Finset.univ_filter_card_eq",
    "start": [
      49,
      1
    ],
    "end": [
      50,
      97
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : Fintype \u03b1\ns : Finset \u03b1\nk\u271d k : \u2115\n\u22a2 filter (fun s => s.card = k) univ = powersetCard k univ",
        "state_after": "case a\n\u03b1 : Type u_1\ninst\u271d : Fintype \u03b1\ns : Finset \u03b1\nk\u271d k : \u2115\na\u271d : Finset \u03b1\n\u22a2 a\u271d \u2208 filter (fun s => s.card = k) univ \u2194 a\u271d \u2208 powersetCard k univ"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case a\n\u03b1 : Type u_1\ninst\u271d : Fintype \u03b1\ns : Finset \u03b1\nk\u271d k : \u2115\na\u271d : Finset \u03b1\n\u22a2 a\u271d \u2208 filter (fun s => s.card = k) univ \u2194 a\u271d \u2208 powersetCard k univ",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2410690720425919,
    "entry_failed": false
  },
  "3012": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Chain.lean",
    "full_name": "List.Chain.rel",
    "start": [
      139,
      11
    ],
    "end": [
      141,
      35
    ],
    "traced_tactics": [
      {
        "tactic": "rw [chain_iff_pairwise] at hl",
        "annotated_tactic": [
          "rw [<a>chain_iff_pairwise</a>] at hl",
          [
            {
              "full_name": "List.chain_iff_pairwise",
              "def_path": "Mathlib/Data/List/Chain.lean",
              "def_pos": [
                129,
                9
              ],
              "def_end_pos": [
                129,
                27
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na b : \u03b1\ninst\u271d : IsTrans \u03b1 R\nhl : Chain R a l\nhb : b \u2208 l\n\u22a2 R a b",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na b : \u03b1\ninst\u271d : IsTrans \u03b1 R\nhl : Pairwise R (a :: l)\nhb : b \u2208 l\n\u22a2 R a b"
      },
      {
        "tactic": "exact rel_of_pairwise_cons hl hb",
        "annotated_tactic": [
          "exact <a>rel_of_pairwise_cons</a> hl hb",
          [
            {
              "full_name": "List.rel_of_pairwise_cons",
              "def_path": ".lake/packages/batteries/Batteries/Data/List/Pairwise.lean",
              "def_pos": [
                33,
                9
              ],
              "def_end_pos": [
                33,
                29
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na b : \u03b1\ninst\u271d : IsTrans \u03b1 R\nhl : Pairwise R (a :: l)\nhb : b \u2208 l\n\u22a2 R a b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7181466679321602,
    "entry_failed": false
  },
  "25579": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Nonneg/Field.lean",
    "full_name": "NNRat.cast_nonneg",
    "start": [
      34,
      1
    ],
    "end": [
      35,
      70
    ],
    "traced_tactics": [
      {
        "tactic": "rw [cast_def]",
        "annotated_tactic": [
          "rw [<a>cast_def</a>]",
          [
            {
              "full_name": "NNRat.cast_def",
              "def_path": "Mathlib/Algebra/Field/Defs.lean",
              "def_pos": [
                198,
                7
              ],
              "def_end_pos": [
                198,
                15
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedSemifield \u03b1\na : \u03b1\nq : \u211a\u22650\n\u22a2 0 \u2264 \u2191q",
        "state_after": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedSemifield \u03b1\na : \u03b1\nq : \u211a\u22650\n\u22a2 0 \u2264 \u2191q.num / \u2191q.den"
      },
      {
        "tactic": "exact div_nonneg q.num.cast_nonneg q.den.cast_nonneg",
        "annotated_tactic": [
          "exact <a>div_nonneg</a> q.num.cast_nonneg q.den.cast_nonneg",
          [
            {
              "full_name": "div_nonneg",
              "def_path": "Mathlib/Algebra/Order/Field/Defs.lean",
              "def_pos": [
                83,
                7
              ],
              "def_end_pos": [
                83,
                17
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedSemifield \u03b1\na : \u03b1\nq : \u211a\u22650\n\u22a2 0 \u2264 \u2191q.num / \u2191q.den",
        "state_after": "no goals"
      }
    ],
    "entry_time": 0.9977083880221471,
    "entry_failed": false
  },
  "13377": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Category/TopCat/Basic.lean",
    "full_name": "TopCat.openEmbedding_iff_isIso_comp'",
    "start": [
      217,
      1
    ],
    "end": [
      220,
      41
    ],
    "traced_tactics": [
      {
        "tactic": "simp only [\u2190 Functor.map_comp]",
        "annotated_tactic": [
          "simp only [\u2190 <a>Functor.map_comp</a>]",
          [
            {
              "full_name": "CategoryTheory.Functor.map_comp",
              "def_path": "Mathlib/CategoryTheory/Functor/Basic.lean",
              "def_pos": [
                43,
                3
              ],
              "def_end_pos": [
                43,
                11
              ]
            }
          ]
        ],
        "state_before": "X Y Z : TopCat\nf : X \u27f6 Y\ng : Y \u27f6 Z\ninst\u271d : IsIso f\n\u22a2 OpenEmbedding ((forget TopCat).map f \u226b (forget TopCat).map g) \u2194 OpenEmbedding \u21d1g",
        "state_after": "X Y Z : TopCat\nf : X \u27f6 Y\ng : Y \u27f6 Z\ninst\u271d : IsIso f\n\u22a2 OpenEmbedding ((forget TopCat).map (f \u226b g)) \u2194 OpenEmbedding \u21d1g"
      },
      {
        "tactic": "exact openEmbedding_iff_isIso_comp f g",
        "annotated_tactic": [
          "exact <a>openEmbedding_iff_isIso_comp</a> f g",
          [
            {
              "full_name": "TopCat.openEmbedding_iff_isIso_comp",
              "def_path": "Mathlib/Topology/Category/TopCat/Basic.lean",
              "def_pos": [
                206,
                9
              ],
              "def_end_pos": [
                206,
                37
              ]
            }
          ]
        ],
        "state_before": "X Y Z : TopCat\nf : X \u27f6 Y\ng : Y \u27f6 Z\ninst\u271d : IsIso f\n\u22a2 OpenEmbedding ((forget TopCat).map (f \u226b g)) \u2194 OpenEmbedding \u21d1g",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.2868153899908066,
    "entry_failed": false
  },
  "20925": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Semiquot.lean",
    "full_name": "Semiquot.mem_bind",
    "start": [
      136,
      1
    ],
    "end": [
      137,
      89
    ],
    "traced_tactics": [
      {
        "tactic": "simp_rw [\u2190 exists_prop]",
        "annotated_tactic": [
          "simp_rw [\u2190 <a>exists_prop</a>]",
          [
            {
              "full_name": "exists_prop",
              "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean",
              "def_pos": [
                307,
                17
              ],
              "def_end_pos": [
                307,
                28
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nq : Semiquot \u03b1\nf : \u03b1 \u2192 Semiquot \u03b2\nb : \u03b2\n\u22a2 b \u2208 q.bind f \u2194 \u2203 a \u2208 q, b \u2208 f a",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nq : Semiquot \u03b1\nf : \u03b1 \u2192 Semiquot \u03b2\nb : \u03b2\n\u22a2 b \u2208 q.bind f \u2194 \u2203 a, \u2203 (_ : a \u2208 q), b \u2208 f a"
      },
      {
        "tactic": "exact Set.mem_iUnion\u2082",
        "annotated_tactic": [
          "exact <a>Set.mem_iUnion\u2082</a>",
          [
            {
              "full_name": "Set.mem_iUnion\u2082",
              "def_path": "Mathlib/Data/Set/Lattice.lean",
              "def_pos": [
                67,
                9
              ],
              "def_end_pos": [
                67,
                20
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nq : Semiquot \u03b1\nf : \u03b1 \u2192 Semiquot \u03b2\nb : \u03b2\n\u22a2 b \u2208 q.bind f \u2194 \u2203 a, \u2203 (_ : a \u2208 q), b \u2208 f a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.3413372430950403,
    "entry_failed": false
  },
  "18968": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/RingQuot.lean",
    "full_name": "RingQuot.Rel.add_right",
    "start": [
      64,
      1
    ],
    "end": [
      66,
      23
    ],
    "traced_tactics": [
      {
        "tactic": "rw [add_comm a b, add_comm a c]",
        "annotated_tactic": [
          "rw [<a>add_comm</a> a b, <a>add_comm</a> a c]",
          [
            {
              "full_name": "add_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                331,
                3
              ],
              "def_end_pos": [
                331,
                14
              ]
            },
            {
              "full_name": "add_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                331,
                3
              ],
              "def_end_pos": [
                331,
                14
              ]
            }
          ]
        ],
        "state_before": "R : Type uR\ninst\u271d\u00b3 : Semiring R\nS : Type uS\ninst\u271d\u00b2 : CommSemiring S\nT : Type uT\nA : Type uA\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra S A\nr : R \u2192 R \u2192 Prop\na b c : R\nh : Rel r b c\n\u22a2 Rel r (a + b) (a + c)",
        "state_after": "R : Type uR\ninst\u271d\u00b3 : Semiring R\nS : Type uS\ninst\u271d\u00b2 : CommSemiring S\nT : Type uT\nA : Type uA\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra S A\nr : R \u2192 R \u2192 Prop\na b c : R\nh : Rel r b c\n\u22a2 Rel r (b + a) (c + a)"
      },
      {
        "tactic": "exact Rel.add_left h",
        "annotated_tactic": [
          "exact <a>Rel.add_left</a> h",
          [
            {
              "full_name": "RingQuot.Rel.add_left",
              "def_path": "Mathlib/Algebra/RingQuot.lean",
              "def_pos": [
                59,
                5
              ],
              "def_end_pos": [
                59,
                13
              ]
            }
          ]
        ],
        "state_before": "R : Type uR\ninst\u271d\u00b3 : Semiring R\nS : Type uS\ninst\u271d\u00b2 : CommSemiring S\nT : Type uT\nA : Type uA\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra S A\nr : R \u2192 R \u2192 Prop\na b c : R\nh : Rel r b c\n\u22a2 Rel r (b + a) (c + a)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9331331819994375,
    "entry_failed": false
  },
  "9904": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Matroid/Basic.lean",
    "full_name": "Matroid.setOf_base_eq_maximals_setOf_indep",
    "start": [
      564,
      1
    ],
    "end": [
      565,
      72
    ],
    "traced_tactics": [
      {
        "tactic": "ext B",
        "annotated_tactic": [
          "ext B",
          []
        ],
        "state_before": "\u03b1 : Type u_1\nM : Matroid \u03b1\n\u22a2 {B | M.Base B} = maximals (fun x x_1 => x \u2286 x_1) {I | M.Indep I}",
        "state_after": "case h\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB : Set \u03b1\n\u22a2 B \u2208 {B | M.Base B} \u2194 B \u2208 maximals (fun x x_1 => x \u2286 x_1) {I | M.Indep I}"
      },
      {
        "tactic": "rw [mem_maximals_setOf_iff, mem_setOf, base_iff_maximal_indep]",
        "annotated_tactic": [
          "rw [<a>mem_maximals_setOf_iff</a>, <a>mem_setOf</a>, <a>base_iff_maximal_indep</a>]",
          [
            {
              "full_name": "mem_maximals_setOf_iff",
              "def_path": "Mathlib/Order/Minimal.lean",
              "def_pos": [
                99,
                9
              ],
              "def_end_pos": [
                99,
                31
              ]
            },
            {
              "full_name": "Set.mem_setOf",
              "def_path": "Mathlib/Data/Set/Basic.lean",
              "def_pos": [
                230,
                9
              ],
              "def_end_pos": [
                230,
                18
              ]
            },
            {
              "full_name": "Matroid.base_iff_maximal_indep",
              "def_path": "Mathlib/Data/Matroid/Basic.lean",
              "def_pos": [
                559,
                9
              ],
              "def_end_pos": [
                559,
                31
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u_1\nM : Matroid \u03b1\nB : Set \u03b1\n\u22a2 B \u2208 {B | M.Base B} \u2194 B \u2208 maximals (fun x x_1 => x \u2286 x_1) {I | M.Indep I}",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.6659355550073087,
    "entry_failed": false
  },
  "17131": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Rel.lean",
    "full_name": "Rel.image_empty",
    "start": [
      210,
      1
    ],
    "end": [
      212,
      19
    ],
    "traced_tactics": [
      {
        "tactic": "ext x",
        "annotated_tactic": [
          "ext x",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : Rel \u03b1 \u03b2\n\u22a2 r.image \u2205 = \u2205",
        "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : Rel \u03b1 \u03b2\nx : \u03b2\n\u22a2 x \u2208 r.image \u2205 \u2194 x \u2208 \u2205"
      },
      {
        "tactic": "simp [mem_image]",
        "annotated_tactic": [
          "simp [<a>mem_image</a>]",
          [
            {
              "full_name": "Rel.mem_image",
              "def_path": "Mathlib/Data/Rel.lean",
              "def_pos": [
                169,
                9
              ],
              "def_end_pos": [
                169,
                18
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr : Rel \u03b1 \u03b2\nx : \u03b2\n\u22a2 x \u2208 r.image \u2205 \u2194 x \u2208 \u2205",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9981233859434724,
    "entry_failed": false
  },
  "7902": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Set/Card.lean",
    "full_name": "Set.encard_coe_eq_coe_finsetCard",
    "start": [
      82,
      1
    ],
    "end": [
      83,
      72
    ],
    "traced_tactics": [
      {
        "tactic": "rw [Finite.encard_eq_coe_toFinset_card (Finset.finite_toSet s)]",
        "annotated_tactic": [
          "rw [<a>Finite.encard_eq_coe_toFinset_card</a> (<a>Finset.finite_toSet</a> s)]",
          [
            {
              "full_name": "Set.Finite.encard_eq_coe_toFinset_card",
              "def_path": "Mathlib/Data/Set/Card.lean",
              "def_pos": [
                73,
                9
              ],
              "def_end_pos": [
                73,
                43
              ]
            },
            {
              "full_name": "Finset.finite_toSet",
              "def_path": "Mathlib/Data/Set/Finite.lean",
              "def_pos": [
                550,
                9
              ],
              "def_end_pos": [
                550,
                21
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns\u271d t : Set \u03b1\ns : Finset \u03b1\n\u22a2 (\u2191s).encard = \u2191s.card",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns\u271d t : Set \u03b1\ns : Finset \u03b1\n\u22a2 \u2191\u22ef.toFinset.card = \u2191s.card"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns\u271d t : Set \u03b1\ns : Finset \u03b1\n\u22a2 \u2191\u22ef.toFinset.card = \u2191s.card",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.696495376061648,
    "entry_failed": false
  },
  "4101": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/LinearAlgebra/UnitaryGroup.lean",
    "full_name": "Matrix.mem_unitaryGroup_iff",
    "start": [
      66,
      1
    ],
    "end": [
      68,
      40
    ],
    "traced_tactics": [
      {
        "tactic": "refine \u27e8And.right, fun hA => \u27e8?_, hA\u27e9\u27e9",
        "annotated_tactic": [
          "refine \u27e8<a>And.right</a>, fun hA => \u27e8?_, hA\u27e9\u27e9",
          [
            {
              "full_name": "And.right",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                524,
                3
              ],
              "def_end_pos": [
                524,
                8
              ]
            }
          ]
        ],
        "state_before": "n : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\n\u03b1 : Type v\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : StarRing \u03b1\nA : Matrix n n \u03b1\n\u22a2 A \u2208 unitaryGroup n \u03b1 \u2194 A * star A = 1",
        "state_after": "n : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\n\u03b1 : Type v\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : StarRing \u03b1\nA : Matrix n n \u03b1\nhA : A * star A = 1\n\u22a2 star A * A = 1"
      },
      {
        "tactic": "simpa only [mul_eq_one_comm] using hA",
        "annotated_tactic": [
          "simpa only [<a>mul_eq_one_comm</a>] using hA",
          [
            {
              "full_name": "Matrix.mul_eq_one_comm",
              "def_path": "Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean",
              "def_pos": [
                120,
                9
              ],
              "def_end_pos": [
                120,
                24
              ]
            }
          ]
        ],
        "state_before": "n : Type u\ninst\u271d\u00b3 : DecidableEq n\ninst\u271d\u00b2 : Fintype n\n\u03b1 : Type v\ninst\u271d\u00b9 : CommRing \u03b1\ninst\u271d : StarRing \u03b1\nA : Matrix n n \u03b1\nhA : A * star A = 1\n\u22a2 star A * A = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7221453200327232,
    "entry_failed": false
  },
  "9144": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Homology/Augment.lean",
    "full_name": "ChainComplex.chainComplex_d_succ_succ_zero",
    "start": [
      132,
      1
    ],
    "end": [
      134,
      32
    ],
    "traced_tactics": [
      {
        "tactic": "rw [C.shape]",
        "annotated_tactic": [
          "rw [C.shape]",
          []
        ],
        "state_before": "V : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nC : ChainComplex V \u2115\ni : \u2115\n\u22a2 C.d (i + 2) 0 = 0",
        "state_after": "case a\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nC : ChainComplex V \u2115\ni : \u2115\n\u22a2 \u00ac(ComplexShape.down \u2115).Rel (i + 2) 0"
      },
      {
        "tactic": "exact i.succ_succ_ne_one.symm",
        "annotated_tactic": [
          "exact i.succ_succ_ne_one.symm",
          []
        ],
        "state_before": "case a\nV : Type u\ninst\u271d\u00b9 : Category.{v, u} V\ninst\u271d : HasZeroMorphisms V\nC : ChainComplex V \u2115\ni : \u2115\n\u22a2 \u00ac(ComplexShape.down \u2115).Rel (i + 2) 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.567346056108363,
    "entry_failed": false
  },
  "3527": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/GroupWithZero/NonZeroDivisors.lean",
    "full_name": "nonZeroDivisorsLeft_eq_right",
    "start": [
      64,
      1
    ],
    "end": [
      66,
      27
    ],
    "traced_tactics": [
      {
        "tactic": "ext x",
        "annotated_tactic": [
          "ext x",
          []
        ],
        "state_before": "M\u2080\u271d : Type u_1\ninst\u271d\u00b9 : MonoidWithZero M\u2080\u271d\nM\u2080 : Type u_2\ninst\u271d : CommMonoidWithZero M\u2080\n\u22a2 nonZeroDivisorsLeft M\u2080 = nonZeroDivisorsRight M\u2080",
        "state_after": "case h\nM\u2080\u271d : Type u_1\ninst\u271d\u00b9 : MonoidWithZero M\u2080\u271d\nM\u2080 : Type u_2\ninst\u271d : CommMonoidWithZero M\u2080\nx : M\u2080\n\u22a2 x \u2208 nonZeroDivisorsLeft M\u2080 \u2194 x \u2208 nonZeroDivisorsRight M\u2080"
      },
      {
        "tactic": "simp [mul_comm x]",
        "annotated_tactic": [
          "simp [<a>mul_comm</a> x]",
          [
            {
              "full_name": "mul_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                332,
                9
              ],
              "def_end_pos": [
                332,
                17
              ]
            }
          ]
        ],
        "state_before": "case h\nM\u2080\u271d : Type u_1\ninst\u271d\u00b9 : MonoidWithZero M\u2080\u271d\nM\u2080 : Type u_2\ninst\u271d : CommMonoidWithZero M\u2080\nx : M\u2080\n\u22a2 x \u2208 nonZeroDivisorsLeft M\u2080 \u2194 x \u2208 nonZeroDivisorsRight M\u2080",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.019871386932209,
    "entry_failed": false
  },
  "24956": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/Fourier/AddCircle.lean",
    "full_name": "fourier_add'",
    "start": [
      172,
      1
    ],
    "end": [
      174,
      42
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 fourier_apply]",
        "annotated_tactic": [
          "rw [\u2190 <a>fourier_apply</a>]",
          [
            {
              "full_name": "fourier_apply",
              "def_path": "Mathlib/Analysis/Fourier/AddCircle.lean",
              "def_pos": [
                112,
                9
              ],
              "def_end_pos": [
                112,
                22
              ]
            }
          ]
        ],
        "state_before": "T : \u211d\nm n : \u2124\nx : AddCircle T\n\u22a2 \u2191((m + n) \u2022 x).toCircle = (fourier m) x * (fourier n) x",
        "state_after": "T : \u211d\nm n : \u2124\nx : AddCircle T\n\u22a2 (fourier (m + n)) x = (fourier m) x * (fourier n) x"
      },
      {
        "tactic": "exact fourier_add",
        "annotated_tactic": [
          "exact <a>fourier_add</a>",
          [
            {
              "full_name": "fourier_add",
              "def_path": "Mathlib/Analysis/Fourier/AddCircle.lean",
              "def_pos": [
                167,
                9
              ],
              "def_end_pos": [
                167,
                20
              ]
            }
          ]
        ],
        "state_before": "T : \u211d\nm n : \u2124\nx : AddCircle T\n\u22a2 (fourier (m + n)) x = (fourier m) x * (fourier n) x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.955596847925335,
    "entry_failed": false
  },
  "15488": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Probability/Variance.lean",
    "full_name": "MeasureTheory.Mem\u2112p.ofReal_variance_eq",
    "start": [
      97,
      1
    ],
    "end": [
      100,
      31
    ],
    "traced_tactics": [
      {
        "tactic": "rw [variance, ENNReal.ofReal_toReal]",
        "annotated_tactic": [
          "rw [<a>variance</a>, <a>ENNReal.ofReal_toReal</a>]",
          [
            {
              "full_name": "ProbabilityTheory.variance",
              "def_path": "Mathlib/Probability/Variance.lean",
              "def_pos": [
                56,
                5
              ],
              "def_end_pos": [
                56,
                13
              ]
            },
            {
              "full_name": "ENNReal.ofReal_toReal",
              "def_path": "Mathlib/Data/ENNReal/Basic.lean",
              "def_pos": [
                212,
                9
              ],
              "def_end_pos": [
                212,
                22
              ]
            }
          ]
        ],
        "state_before": "\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\ninst\u271d : IsFiniteMeasure \u03bc\nhX : Mem\u2112p X 2 \u03bc\n\u22a2 ENNReal.ofReal (variance X \u03bc) = evariance X \u03bc",
        "state_after": "\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\ninst\u271d : IsFiniteMeasure \u03bc\nhX : Mem\u2112p X 2 \u03bc\n\u22a2 evariance X \u03bc \u2260 \u22a4"
      },
      {
        "tactic": "exact hX.evariance_lt_top.ne",
        "annotated_tactic": [
          "exact hX.evariance_lt_top.ne",
          []
        ],
        "state_before": "\u03a9 : Type u_1\nm : MeasurableSpace \u03a9\nX : \u03a9 \u2192 \u211d\n\u03bc : Measure \u03a9\ninst\u271d : IsFiniteMeasure \u03bc\nhX : Mem\u2112p X 2 \u03bc\n\u22a2 evariance X \u03bc \u2260 \u22a4",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.630130797973834,
    "entry_failed": false
  },
  "23538": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Tactic/Positivity/Core.lean",
    "full_name": "Mathlib.Meta.Positivity.nonneg_of_isNat",
    "start": [
      131,
      1
    ],
    "end": [
      134,
      26
    ],
    "traced_tactics": [
      {
        "tactic": "rw [NormNum.IsNat.to_eq h rfl]",
        "annotated_tactic": [
          "rw [<a>NormNum.IsNat.to_eq</a> h <a>rfl</a>]",
          [
            {
              "full_name": "Mathlib.Meta.NormNum.IsNat.to_eq",
              "def_path": "Mathlib/Tactic/NormNum/Result.lean",
              "def_pos": [
                136,
                9
              ],
              "def_end_pos": [
                136,
                20
              ]
            },
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "u : Level\n\u03b1 : Q(Type u)\nz\u03b1 : Q(Zero \u00ab$\u03b1\u00bb)\np\u03b1 : Q(PartialOrder \u00ab$\u03b1\u00bb)\nA : Type u_1\ne : A\nn : \u2115\ninst\u271d : OrderedSemiring A\nh : NormNum.IsNat e n\n\u22a2 0 \u2264 e",
        "state_after": "u : Level\n\u03b1 : Q(Type u)\nz\u03b1 : Q(Zero \u00ab$\u03b1\u00bb)\np\u03b1 : Q(PartialOrder \u00ab$\u03b1\u00bb)\nA : Type u_1\ne : A\nn : \u2115\ninst\u271d : OrderedSemiring A\nh : NormNum.IsNat e n\n\u22a2 0 \u2264 \u2191n"
      },
      {
        "tactic": "exact Nat.cast_nonneg n",
        "annotated_tactic": [
          "exact <a>Nat.cast_nonneg</a> n",
          [
            {
              "full_name": "Nat.cast_nonneg",
              "def_path": "Mathlib/Data/Nat/Cast/Order.lean",
              "def_pos": [
                50,
                9
              ],
              "def_end_pos": [
                50,
                20
              ]
            }
          ]
        ],
        "state_before": "u : Level\n\u03b1 : Q(Type u)\nz\u03b1 : Q(Zero \u00ab$\u03b1\u00bb)\np\u03b1 : Q(PartialOrder \u00ab$\u03b1\u00bb)\nA : Type u_1\ne : A\nn : \u2115\ninst\u271d : OrderedSemiring A\nh : NormNum.IsNat e n\n\u22a2 0 \u2264 \u2191n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8072834180202335,
    "entry_failed": false
  },
  "14163": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/CharP/Quotient.lean",
    "full_name": "CharP.quotient_iff",
    "start": [
      47,
      1
    ],
    "end": [
      51,
      49
    ],
    "traced_tactics": [
      {
        "tactic": "refine \u27e8fun _ x hx => ?_, CharP.quotient' n I\u27e9",
        "annotated_tactic": [
          "refine \u27e8fun _ x hx => ?_, <a>CharP.quotient'</a> n I\u27e9",
          [
            {
              "full_name": "CharP.quotient'",
              "def_path": "Mathlib/Algebra/CharP/Quotient.lean",
              "def_pos": [
                37,
                9
              ],
              "def_end_pos": [
                37,
                18
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\nn : \u2115\ninst\u271d : CharP R n\nI : Ideal R\n\u22a2 CharP (R \u29f8 I) n \u2194 \u2200 (x : \u2115), \u2191x \u2208 I \u2192 \u2191x = 0",
        "state_after": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\nn : \u2115\ninst\u271d : CharP R n\nI : Ideal R\nx\u271d : CharP (R \u29f8 I) n\nx : \u2115\nhx : \u2191x \u2208 I\n\u22a2 \u2191x = 0"
      },
      {
        "tactic": "exact (Submodule.Quotient.mk_eq_zero I).mpr hx",
        "annotated_tactic": [
          "exact (<a>Submodule.Quotient.mk_eq_zero</a> I).<a>mpr</a> hx",
          [
            {
              "full_name": "Submodule.Quotient.mk_eq_zero",
              "def_path": "Mathlib/LinearAlgebra/Quotient.lean",
              "def_pos": [
                100,
                9
              ],
              "def_end_pos": [
                100,
                19
              ]
            },
            {
              "full_name": "Iff.mpr",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                120,
                3
              ],
              "def_end_pos": [
                120,
                6
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\nn : \u2115\ninst\u271d : CharP R n\nI : Ideal R\nx\u271d : CharP (R \u29f8 I) n\nx : \u2115\nhx : \u2191x \u2208 I\n\u22a2 \u2191x = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7085369949927554,
    "entry_failed": false
  },
  "10418": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Ring/Cast.lean",
    "full_name": "Int.cast_le_neg_one_of_neg",
    "start": [
      89,
      1
    ],
    "end": [
      91,
      31
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 Int.cast_one, \u2190 Int.cast_neg, cast_le]",
        "annotated_tactic": [
          "rw [\u2190 <a>Int.cast_one</a>, \u2190 <a>Int.cast_neg</a>, <a>cast_le</a>]",
          [
            {
              "full_name": "Int.cast_one",
              "def_path": "Mathlib/Data/Int/Cast/Basic.lean",
              "def_pos": [
                79,
                9
              ],
              "def_end_pos": [
                79,
                17
              ]
            },
            {
              "full_name": "Int.cast_neg",
              "def_path": "Mathlib/Data/Int/Cast/Basic.lean",
              "def_pos": [
                85,
                9
              ],
              "def_end_pos": [
                85,
                17
              ]
            },
            {
              "full_name": "Int.cast_le",
              "def_path": "Mathlib/Algebra/Order/Ring/Cast.lean",
              "def_pos": [
                49,
                26
              ],
              "def_end_pos": [
                49,
                33
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d : LinearOrderedRing R\na b n : \u2124\nx : R\nh : a < 0\n\u22a2 \u2191a \u2264 -1",
        "state_after": "R : Type u_1\ninst\u271d : LinearOrderedRing R\na b n : \u2124\nx : R\nh : a < 0\n\u22a2 a \u2264 -1"
      },
      {
        "tactic": "exact Int.le_sub_one_of_lt h",
        "annotated_tactic": [
          "exact <a>Int.le_sub_one_of_lt</a> h",
          [
            {
              "full_name": "Int.le_sub_one_of_lt",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Order.lean",
              "def_pos": [
                869,
                9
              ],
              "def_end_pos": [
                869,
                25
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d : LinearOrderedRing R\na b n : \u2124\nx : R\nh : a < 0\n\u22a2 a \u2264 -1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9177895350148901,
    "entry_failed": false
  },
  "11662": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/BoxIntegral/Box/SubboxInduction.lean",
    "full_name": "BoxIntegral.Box.iUnion_coe_splitCenterBox",
    "start": [
      95,
      1
    ],
    "end": [
      97,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "ext x",
        "annotated_tactic": [
          "ext x",
          []
        ],
        "state_before": "\u03b9 : Type u_1\nI\u271d J I : Box \u03b9\n\u22a2 \u22c3 s, \u2191(I.splitCenterBox s) = \u2191I",
        "state_after": "case h\n\u03b9 : Type u_1\nI\u271d J I : Box \u03b9\nx : \u03b9 \u2192 \u211d\n\u22a2 x \u2208 \u22c3 s, \u2191(I.splitCenterBox s) \u2194 x \u2208 \u2191I"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case h\n\u03b9 : Type u_1\nI\u271d J I : Box \u03b9\nx : \u03b9 \u2192 \u211d\n\u22a2 x \u2208 \u22c3 s, \u2191(I.splitCenterBox s) \u2194 x \u2208 \u2191I",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8929913160391152,
    "entry_failed": false
  },
  "26409": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": ".lake/packages/batteries/Batteries/Data/RBMap/Lemmas.lean",
    "full_name": "Batteries.RBNode.lowerBound?_of_some",
    "start": [
      467,
      1
    ],
    "end": [
      468,
      75
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 reverse_reverse t, lowerBound?_reverse]",
        "annotated_tactic": [
          "rw [\u2190 <a>reverse_reverse</a> t, <a>lowerBound?_reverse</a>]",
          [
            {
              "full_name": "Batteries.RBNode.reverse_reverse",
              "def_path": ".lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
              "def_pos": [
                48,
                17
              ],
              "def_end_pos": [
                48,
                32
              ]
            },
            {
              "full_name": "Batteries.RBNode.lowerBound?_reverse",
              "def_path": ".lake/packages/batteries/Batteries/Data/RBMap/Lemmas.lean",
              "def_pos": [
                386,
                17
              ],
              "def_end_pos": [
                386,
                36
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\ny : \u03b1\nt : RBNode \u03b1\n\u22a2 \u2203 x, lowerBound? cut t (some y) = some x",
        "state_after": "\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\ny : \u03b1\nt : RBNode \u03b1\n\u22a2 \u2203 x, upperBound? (fun x => (cut x).swap) t.reverse (some y) = some x"
      },
      {
        "tactic": "exact upperBound?_of_some",
        "annotated_tactic": [
          "exact <a>upperBound?_of_some</a>",
          [
            {
              "full_name": "Batteries.RBNode.upperBound?_of_some",
              "def_path": ".lake/packages/batteries/Batteries/Data/RBMap/Lemmas.lean",
              "def_pos": [
                464,
                9
              ],
              "def_end_pos": [
                464,
                28
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ncut : \u03b1 \u2192 Ordering\ny : \u03b1\nt : RBNode \u03b1\n\u22a2 \u2203 x, upperBound? (fun x => (cut x).swap) t.reverse (some y) = some x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.772876841947436,
    "entry_failed": false
  },
  "5899": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/Iso.lean",
    "full_name": "CategoryTheory.IsIso.Iso.inv_inv",
    "start": [
      429,
      1
    ],
    "end": [
      431,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "apply inv_eq_of_hom_inv_id",
        "annotated_tactic": [
          "apply <a>inv_eq_of_hom_inv_id</a>",
          [
            {
              "full_name": "CategoryTheory.IsIso.inv_eq_of_hom_inv_id",
              "def_path": "Mathlib/CategoryTheory/Iso.lean",
              "def_pos": [
                366,
                9
              ],
              "def_end_pos": [
                366,
                29
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : C\nf\u271d g : X \u27f6 Y\nh : Y \u27f6 Z\nf : X \u2245 Y\n\u22a2 inv f.inv = f.hom",
        "state_after": "case hom_inv_id\nC : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : C\nf\u271d g : X \u27f6 Y\nh : Y \u27f6 Z\nf : X \u2245 Y\n\u22a2 f.inv \u226b f.hom = \ud835\udfd9 Y"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case hom_inv_id\nC : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : C\nf\u271d g : X \u27f6 Y\nh : Y \u27f6 Z\nf : X \u2245 Y\n\u22a2 f.inv \u226b f.hom = \ud835\udfd9 Y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.721257505007088,
    "entry_failed": false
  },
  "7155": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Fin/VecNotation.lean",
    "full_name": "Matrix.neg_cons",
    "start": [
      579,
      1
    ],
    "end": [
      581,
      36
    ],
    "traced_tactics": [
      {
        "tactic": "ext i",
        "annotated_tactic": [
          "ext i",
          []
        ],
        "state_before": "\u03b1 : Type u\nm n o : \u2115\nm' : Type u_1\nn' : Type u_2\no' : Type u_3\ninst\u271d : Neg \u03b1\nx : \u03b1\nv : Fin n \u2192 \u03b1\n\u22a2 -vecCons x v = vecCons (-x) (-v)",
        "state_after": "case h\n\u03b1 : Type u\nm n o : \u2115\nm' : Type u_1\nn' : Type u_2\no' : Type u_3\ninst\u271d : Neg \u03b1\nx : \u03b1\nv : Fin n \u2192 \u03b1\ni : Fin n.succ\n\u22a2 (-vecCons x v) i = vecCons (-x) (-v) i"
      },
      {
        "tactic": "refine Fin.cases ?_ ?_ i <;> simp",
        "annotated_tactic": [
          "refine <a>Fin.cases</a> ?_ ?_ i <;> simp",
          [
            {
              "full_name": "Fin.cases",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Fin/Lemmas.lean",
              "def_pos": [
                654,
                21
              ],
              "def_end_pos": [
                654,
                26
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u\nm n o : \u2115\nm' : Type u_1\nn' : Type u_2\no' : Type u_3\ninst\u271d : Neg \u03b1\nx : \u03b1\nv : Fin n \u2192 \u03b1\ni : Fin n.succ\n\u22a2 (-vecCons x v) i = vecCons (-x) (-v) i",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.143387563992292,
    "entry_failed": false
  },
  "16759": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/Abelian/Exact.lean",
    "full_name": "CategoryTheory.Abelian.exact_cokernel",
    "start": [
      162,
      1
    ],
    "end": [
      164,
      12
    ],
    "traced_tactics": [
      {
        "tactic": "rw [exact_iff]",
        "annotated_tactic": [
          "rw [<a>exact_iff</a>]",
          [
            {
              "full_name": "CategoryTheory.Abelian.exact_iff",
              "def_path": "Mathlib/CategoryTheory/Abelian/Exact.lean",
              "def_pos": [
                66,
                9
              ],
              "def_end_pos": [
                66,
                18
              ]
            }
          ]
        ],
        "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\ninst\u271d : Abelian C\nX Y Z : C\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 Exact f (cokernel.\u03c0 f)",
        "state_after": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\ninst\u271d : Abelian C\nX Y Z : C\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 f \u226b cokernel.\u03c0 f = 0 \u2227 kernel.\u03b9 (cokernel.\u03c0 f) \u226b cokernel.\u03c0 f = 0"
      },
      {
        "tactic": "aesop_cat",
        "annotated_tactic": [
          "aesop_cat",
          []
        ],
        "state_before": "C : Type u\u2081\ninst\u271d\u00b9 : Category.{v\u2081, u\u2081} C\ninst\u271d : Abelian C\nX Y Z : C\nf : X \u27f6 Y\ng : Y \u27f6 Z\n\u22a2 f \u226b cokernel.\u03c0 f = 0 \u2227 kernel.\u03b9 (cokernel.\u03c0 f) \u226b cokernel.\u03c0 f = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.823150046984665,
    "entry_failed": false
  },
  "10753": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
    "full_name": "Polynomial.natDegree_eq_of_degree_eq",
    "start": [
      171,
      1
    ],
    "end": [
      172,
      61
    ],
    "traced_tactics": [
      {
        "tactic": "unfold natDegree",
        "annotated_tactic": [
          "unfold <a>natDegree</a>",
          [
            {
              "full_name": "Polynomial.natDegree",
              "def_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
              "def_pos": [
                67,
                5
              ],
              "def_end_pos": [
                67,
                14
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d\u00b9 : Semiring R\np q\u271d r : R[X]\ninst\u271d : Semiring S\nq : S[X]\nh : p.degree = q.degree\n\u22a2 p.natDegree = q.natDegree",
        "state_after": "R : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d\u00b9 : Semiring R\np q\u271d r : R[X]\ninst\u271d : Semiring S\nq : S[X]\nh : p.degree = q.degree\n\u22a2 WithBot.unbot' 0 p.degree = WithBot.unbot' 0 q.degree"
      },
      {
        "tactic": "rw [h]",
        "annotated_tactic": [
          "rw [h]",
          []
        ],
        "state_before": "R : Type u\nS : Type v\na b c d : R\nn m : \u2115\ninst\u271d\u00b9 : Semiring R\np q\u271d r : R[X]\ninst\u271d : Semiring S\nq : S[X]\nh : p.degree = q.degree\n\u22a2 WithBot.unbot' 0 p.degree = WithBot.unbot' 0 q.degree",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.075746594928205,
    "entry_failed": false
  },
  "10548": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/Bernoulli.lean",
    "full_name": "bernoulli'_three",
    "start": [
      122,
      1
    ],
    "end": [
      124,
      60
    ],
    "traced_tactics": [
      {
        "tactic": "rw [bernoulli'_def]",
        "annotated_tactic": [
          "rw [<a>bernoulli'_def</a>]",
          [
            {
              "full_name": "bernoulli'_def",
              "def_path": "Mathlib/NumberTheory/Bernoulli.lean",
              "def_pos": [
                78,
                9
              ],
              "def_end_pos": [
                78,
                23
              ]
            }
          ]
        ],
        "state_before": "A : Type u_1\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra \u211a A\n\u22a2 bernoulli' 3 = 0",
        "state_after": "A : Type u_1\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra \u211a A\n\u22a2 1 - \u2211 k \u2208 range 3, \u2191(Nat.choose 3 k) / (\u21913 - \u2191k + 1) * bernoulli' k = 0"
      },
      {
        "tactic": "norm_num [sum_range_succ, sum_range_succ, sum_range_zero]",
        "annotated_tactic": [
          "norm_num [<a>sum_range_succ</a>, <a>sum_range_succ</a>, <a>sum_range_zero</a>]",
          [
            {
              "full_name": "Finset.sum_range_succ",
              "def_path": "Mathlib/Algebra/BigOperators/Group/Finset.lean",
              "def_pos": [
                1519,
                3
              ],
              "def_end_pos": [
                1519,
                14
              ]
            },
            {
              "full_name": "Finset.sum_range_succ",
              "def_path": "Mathlib/Algebra/BigOperators/Group/Finset.lean",
              "def_pos": [
                1519,
                3
              ],
              "def_end_pos": [
                1519,
                14
              ]
            },
            {
              "full_name": "Finset.sum_range_zero",
              "def_path": "Mathlib/Algebra/BigOperators/Group/Finset.lean",
              "def_pos": [
                1561,
                3
              ],
              "def_end_pos": [
                1561,
                14
              ]
            }
          ]
        ],
        "state_before": "A : Type u_1\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra \u211a A\n\u22a2 1 - \u2211 k \u2208 range 3, \u2191(Nat.choose 3 k) / (\u21913 - \u2191k + 1) * bernoulli' k = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.5521076848963276,
    "entry_failed": false
  },
  "11090": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Factorization/Root.lean",
    "full_name": "Nat.ceilRoot_one_left",
    "start": [
      122,
      1
    ],
    "end": [
      123,
      42
    ],
    "traced_tactics": [
      {
        "tactic": "simp [ceilRoot]",
        "annotated_tactic": [
          "simp [<a>ceilRoot</a>]",
          [
            {
              "full_name": "Nat.ceilRoot",
              "def_path": "Mathlib/Data/Nat/Factorization/Root.lean",
              "def_pos": [
                109,
                5
              ],
              "def_end_pos": [
                109,
                13
              ]
            }
          ]
        ],
        "state_before": "a\u271d b n a : \u2115\n\u22a2 ceilRoot 1 a = a",
        "state_after": "a\u271d b n a : \u2115\n\u22a2 (if a = 0 then 0 else a.factorization.prod fun p k => p ^ k) = a"
      },
      {
        "tactic": "split_ifs <;> simp [*]",
        "annotated_tactic": [
          "split_ifs <;> simp [*]",
          []
        ],
        "state_before": "a\u271d b n a : \u2115\n\u22a2 (if a = 0 then 0 else a.factorization.prod fun p k => p ^ k) = a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.3507951840292662,
    "entry_failed": false
  },
  "9876": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": ".lake/packages/batteries/Batteries/Data/List/Perm.lean",
    "full_name": "List.Perm.countP_eq",
    "start": [
      271,
      1
    ],
    "end": [
      274,
      31
    ],
    "traced_tactics": [
      {
        "tactic": "simp only [countP_eq_length_filter]",
        "annotated_tactic": [
          "simp only [<a>countP_eq_length_filter</a>]",
          [
            {
              "full_name": "List.countP_eq_length_filter",
              "def_path": ".lake/packages/batteries/Batteries/Data/List/Count.lean",
              "def_pos": [
                60,
                9
              ],
              "def_end_pos": [
                60,
                32
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl\u2081 l\u2082 : List \u03b1\ns : l\u2081 ~ l\u2082\n\u22a2 countP p l\u2081 = countP p l\u2082",
        "state_after": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl\u2081 l\u2082 : List \u03b1\ns : l\u2081 ~ l\u2082\n\u22a2 (List.filter p l\u2081).length = (List.filter p l\u2082).length"
      },
      {
        "tactic": "exact (s.filter _).length_eq",
        "annotated_tactic": [
          "exact (s.filter _).<a>length_eq</a>",
          [
            {
              "full_name": "List.Perm.length_eq",
              "def_path": ".lake/packages/batteries/Batteries/Data/List/Perm.lean",
              "def_pos": [
                108,
                9
              ],
              "def_end_pos": [
                108,
                23
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl\u2081 l\u2082 : List \u03b1\ns : l\u2081 ~ l\u2082\n\u22a2 (List.filter p l\u2081).length = (List.filter p l\u2082).length",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.158522635931149,
    "entry_failed": false
  },
  "25962": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Probability/Distributions/Poisson.lean",
    "full_name": "ProbabilityTheory.poissonPMFReal_nonneg",
    "start": [
      54,
      1
    ],
    "end": [
      56,
      13
    ],
    "traced_tactics": [
      {
        "tactic": "unfold poissonPMFReal",
        "annotated_tactic": [
          "unfold <a>poissonPMFReal</a>",
          [
            {
              "full_name": "ProbabilityTheory.poissonPMFReal",
              "def_path": "Mathlib/Probability/Distributions/Poisson.lean",
              "def_pos": [
                35,
                5
              ],
              "def_end_pos": [
                35,
                19
              ]
            }
          ]
        ],
        "state_before": "r : \u211d\u22650\nn : \u2115\n\u22a2 0 \u2264 poissonPMFReal r n",
        "state_after": "r : \u211d\u22650\nn : \u2115\n\u22a2 0 \u2264 rexp (-\u2191r) * \u2191r ^ n / \u2191n !"
      },
      {
        "tactic": "positivity",
        "annotated_tactic": [
          "positivity",
          []
        ],
        "state_before": "r : \u211d\u22650\nn : \u2115\n\u22a2 0 \u2264 rexp (-\u2191r) * \u2191r ^ n / \u2191n !",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6855685730697587,
    "entry_failed": false
  },
  "26411": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Homotopy/Path.lean",
    "full_name": "Path.Homotopy.eval_zero",
    "start": [
      83,
      1
    ],
    "end": [
      85,
      14
    ],
    "traced_tactics": [
      {
        "tactic": "ext t",
        "annotated_tactic": [
          "ext t",
          []
        ],
        "state_before": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx\u2080 x\u2081 x\u2082 x\u2083 : X\np\u2080 p\u2081 : Path x\u2080 x\u2081\nF : p\u2080.Homotopy p\u2081\n\u22a2 F.eval 0 = p\u2080",
        "state_after": "case a.h\nX : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx\u2080 x\u2081 x\u2082 x\u2083 : X\np\u2080 p\u2081 : Path x\u2080 x\u2081\nF : p\u2080.Homotopy p\u2081\nt : \u2191I\n\u22a2 (F.eval 0) t = p\u2080 t"
      },
      {
        "tactic": "simp [eval]",
        "annotated_tactic": [
          "simp [<a>eval</a>]",
          [
            {
              "full_name": "Path.Homotopy.eval",
              "def_path": "Mathlib/Topology/Homotopy/Path.lean",
              "def_pos": [
                76,
                5
              ],
              "def_end_pos": [
                76,
                9
              ]
            }
          ]
        ],
        "state_before": "case a.h\nX : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx\u2080 x\u2081 x\u2082 x\u2083 : X\np\u2080 p\u2081 : Path x\u2080 x\u2081\nF : p\u2080.Homotopy p\u2081\nt : \u2191I\n\u22a2 (F.eval 0) t = p\u2080 t",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.4841757339891046,
    "entry_failed": false
  },
  "4482": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/PNat/Prime.lean",
    "full_name": "PNat.Coprime.factor_eq_gcd_right",
    "start": [
      288,
      1
    ],
    "end": [
      289,
      86
    ],
    "traced_tactics": [
      {
        "tactic": "rw [mul_comm]",
        "annotated_tactic": [
          "rw [<a>mul_comm</a>]",
          [
            {
              "full_name": "mul_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                332,
                9
              ],
              "def_end_pos": [
                332,
                17
              ]
            }
          ]
        ],
        "state_before": "a b m n : \u2115+\ncop : m.Coprime n\nam : a \u2223 m\nbn : b \u2223 n\n\u22a2 a = (b * a).gcd m",
        "state_after": "a b m n : \u2115+\ncop : m.Coprime n\nam : a \u2223 m\nbn : b \u2223 n\n\u22a2 a = (a * b).gcd m"
      },
      {
        "tactic": "apply Coprime.factor_eq_gcd_left cop am bn",
        "annotated_tactic": [
          "apply <a>Coprime.factor_eq_gcd_left</a> cop am bn",
          [
            {
              "full_name": "PNat.Coprime.factor_eq_gcd_left",
              "def_path": "Mathlib/Data/PNat/Prime.lean",
              "def_pos": [
                279,
                9
              ],
              "def_end_pos": [
                279,
                35
              ]
            }
          ]
        ],
        "state_before": "a b m n : \u2115+\ncop : m.Coprime n\nam : a \u2223 m\nbn : b \u2223 n\n\u22a2 a = (a * b).gcd m",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9007067530183122,
    "entry_failed": false
  },
  "3235": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Logic/Equiv/Functor.lean",
    "full_name": "Bifunctor.mapEquiv_refl_refl",
    "start": [
      90,
      1
    ],
    "end": [
      92,
      18
    ],
    "traced_tactics": [
      {
        "tactic": "ext x",
        "annotated_tactic": [
          "ext x",
          []
        ],
        "state_before": "\u03b1 \u03b2 : Type u\n\u03b1' \u03b2' : Type v\nF : Type u \u2192 Type v \u2192 Type w\ninst\u271d\u00b9 : Bifunctor F\ninst\u271d : LawfulBifunctor F\n\u22a2 mapEquiv F (Equiv.refl \u03b1) (Equiv.refl \u03b1') = Equiv.refl (F \u03b1 \u03b1')",
        "state_after": "case H\n\u03b1 \u03b2 : Type u\n\u03b1' \u03b2' : Type v\nF : Type u \u2192 Type v \u2192 Type w\ninst\u271d\u00b9 : Bifunctor F\ninst\u271d : LawfulBifunctor F\nx : F \u03b1 \u03b1'\n\u22a2 (mapEquiv F (Equiv.refl \u03b1) (Equiv.refl \u03b1')) x = (Equiv.refl (F \u03b1 \u03b1')) x"
      },
      {
        "tactic": "simp [id_bimap]",
        "annotated_tactic": [
          "simp [<a>id_bimap</a>]",
          [
            {
              "full_name": "LawfulBifunctor.id_bimap",
              "def_path": "Mathlib/Control/Bifunctor.lean",
              "def_pos": [
                41,
                3
              ],
              "def_end_pos": [
                41,
                11
              ]
            }
          ]
        ],
        "state_before": "case H\n\u03b1 \u03b2 : Type u\n\u03b1' \u03b2' : Type v\nF : Type u \u2192 Type v \u2192 Type w\ninst\u271d\u00b9 : Bifunctor F\ninst\u271d : LawfulBifunctor F\nx : F \u03b1 \u03b1'\n\u22a2 (mapEquiv F (Equiv.refl \u03b1) (Equiv.refl \u03b1')) x = (Equiv.refl (F \u03b1 \u03b1')) x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.104781404021196,
    "entry_failed": false
  },
  "20244": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Divisibility/Units.lean",
    "full_name": "IsUnit.dvd_mul_left",
    "start": [
      110,
      1
    ],
    "end": [
      112,
      27
    ],
    "traced_tactics": [
      {
        "tactic": "rcases hu with \u27e8u, rfl\u27e9",
        "annotated_tactic": [
          "rcases hu with \u27e8u, rfl\u27e9",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : CommMonoid \u03b1\na b u : \u03b1\nhu : IsUnit u\n\u22a2 a \u2223 u * b \u2194 a \u2223 b",
        "state_after": "case intro\n\u03b1 : Type u_1\ninst\u271d : CommMonoid \u03b1\na b : \u03b1\nu : \u03b1\u02e3\n\u22a2 a \u2223 \u2191u * b \u2194 a \u2223 b"
      },
      {
        "tactic": "apply Units.dvd_mul_left",
        "annotated_tactic": [
          "apply <a>Units.dvd_mul_left</a>",
          [
            {
              "full_name": "Units.dvd_mul_left",
              "def_path": "Mathlib/Algebra/Divisibility/Units.lean",
              "def_pos": [
                57,
                9
              ],
              "def_end_pos": [
                57,
                21
              ]
            }
          ]
        ],
        "state_before": "case intro\n\u03b1 : Type u_1\ninst\u271d : CommMonoid \u03b1\na b : \u03b1\nu : \u03b1\u02e3\n\u22a2 a \u2223 \u2191u * b \u2194 a \u2223 b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.3466282709268853,
    "entry_failed": false
  },
  "11728": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Rel.lean",
    "full_name": "Rel.inv_comp",
    "start": [
      150,
      1
    ],
    "end": [
      152,
      35
    ],
    "traced_tactics": [
      {
        "tactic": "ext x z",
        "annotated_tactic": [
          "ext x z",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr\u271d r : Rel \u03b1 \u03b2\ns : Rel \u03b2 \u03b3\n\u22a2 (r \u2022 s).inv = s.inv \u2022 r.inv",
        "state_after": "case a.h.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr\u271d r : Rel \u03b1 \u03b2\ns : Rel \u03b2 \u03b3\nx : \u03b3\nz : \u03b1\n\u22a2 (r \u2022 s).inv x z \u2194 (s.inv \u2022 r.inv) x z"
      },
      {
        "tactic": "simp [comp, inv, flip, and_comm]",
        "annotated_tactic": [
          "simp [<a>comp</a>, <a>inv</a>, <a>flip</a>, <a>and_comm</a>]",
          [
            {
              "full_name": "Rel.comp",
              "def_path": "Mathlib/Data/Rel.lean",
              "def_pos": [
                97,
                5
              ],
              "def_end_pos": [
                97,
                9
              ]
            },
            {
              "full_name": "Rel.inv",
              "def_path": "Mathlib/Data/Rel.lean",
              "def_pos": [
                62,
                5
              ],
              "def_end_pos": [
                62,
                8
              ]
            },
            {
              "full_name": "flip",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                30,
                15
              ],
              "def_end_pos": [
                30,
                19
              ]
            },
            {
              "full_name": "and_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                819,
                9
              ],
              "def_end_pos": [
                819,
                17
              ]
            }
          ]
        ],
        "state_before": "case a.h.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr\u271d r : Rel \u03b1 \u03b2\ns : Rel \u03b2 \u03b3\nx : \u03b3\nz : \u03b1\n\u22a2 (r \u2022 s).inv x z \u2194 (s.inv \u2022 r.inv) x z",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6592446659924462,
    "entry_failed": false
  },
  "24292": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Game/Ordinal.lean",
    "full_name": "Ordinal.toPGame_equiv_iff",
    "start": [
      164,
      1
    ],
    "end": [
      167,
      55
    ],
    "traced_tactics": [
      {
        "tactic": "change _ \u2264_ \u2227 _ \u2264 _ \u2194 _",
        "annotated_tactic": [
          "change _ \u2264_ \u2227 _ \u2264 _ \u2194 _",
          []
        ],
        "state_before": "a b : Ordinal.{u_1}\n\u22a2 a.toPGame \u2248 b.toPGame \u2194 a = b",
        "state_after": "a b : Ordinal.{u_1}\n\u22a2 a.toPGame \u2264 b.toPGame \u2227 b.toPGame \u2264 a.toPGame \u2194 a = b"
      },
      {
        "tactic": "rw [le_antisymm_iff, toPGame_le_iff, toPGame_le_iff]",
        "annotated_tactic": [
          "rw [<a>le_antisymm_iff</a>, <a>toPGame_le_iff</a>, <a>toPGame_le_iff</a>]",
          [
            {
              "full_name": "le_antisymm_iff",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                194,
                9
              ],
              "def_end_pos": [
                194,
                24
              ]
            },
            {
              "full_name": "Ordinal.toPGame_le_iff",
              "def_path": "Mathlib/SetTheory/Game/Ordinal.lean",
              "def_pos": [
                154,
                9
              ],
              "def_end_pos": [
                154,
                23
              ]
            },
            {
              "full_name": "Ordinal.toPGame_le_iff",
              "def_path": "Mathlib/SetTheory/Game/Ordinal.lean",
              "def_pos": [
                154,
                9
              ],
              "def_end_pos": [
                154,
                23
              ]
            }
          ]
        ],
        "state_before": "a b : Ordinal.{u_1}\n\u22a2 a.toPGame \u2264 b.toPGame \u2227 b.toPGame \u2264 a.toPGame \u2194 a = b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8558794560376555,
    "entry_failed": false
  },
  "831": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Finset/Prod.lean",
    "full_name": "Finset.diag_union",
    "start": [
      398,
      1
    ],
    "end": [
      400,
      48
    ],
    "traced_tactics": [
      {
        "tactic": "ext \u27e8i, j\u27e9",
        "annotated_tactic": [
          "ext \u27e8i, j\u27e9",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\nx : \u03b1 \u00d7 \u03b1\n\u22a2 (s \u222a t).diag = s.diag \u222a t.diag",
        "state_after": "case a.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\nx : \u03b1 \u00d7 \u03b1\ni j : \u03b1\n\u22a2 (i, j) \u2208 (s \u222a t).diag \u2194 (i, j) \u2208 s.diag \u222a t.diag"
      },
      {
        "tactic": "simp only [mem_diag, mem_union, or_and_right]",
        "annotated_tactic": [
          "simp only [<a>mem_diag</a>, <a>mem_union</a>, <a>or_and_right</a>]",
          [
            {
              "full_name": "Finset.mem_diag",
              "def_path": "Mathlib/Data/Finset/Prod.lean",
              "def_pos": [
                308,
                9
              ],
              "def_end_pos": [
                308,
                17
              ]
            },
            {
              "full_name": "Finset.mem_union",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                1404,
                9
              ],
              "def_end_pos": [
                1404,
                18
              ]
            },
            {
              "full_name": "or_and_right",
              "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean",
              "def_pos": [
                110,
                9
              ],
              "def_end_pos": [
                110,
                21
              ]
            }
          ]
        ],
        "state_before": "case a.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\nx : \u03b1 \u00d7 \u03b1\ni j : \u03b1\n\u22a2 (i, j) \u2208 (s \u222a t).diag \u2194 (i, j) \u2208 s.diag \u222a t.diag",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.3752410530578345,
    "entry_failed": false
  },
  "5154": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/UniformSpace/AbstractCompletion.lean",
    "full_name": "AbstractCompletion.extend_coe",
    "start": [
      136,
      1
    ],
    "end": [
      138,
      52
    ],
    "traced_tactics": [
      {
        "tactic": "rw [pkg.extend_def hf]",
        "annotated_tactic": [
          "rw [pkg.extend_def hf]",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : UniformSpace \u03b1\npkg : AbstractCompletion \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : UniformSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ninst\u271d : T2Space \u03b2\nhf : UniformContinuous f\na : \u03b1\n\u22a2 pkg.extend f (pkg.coe a) = f a",
        "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b2 : UniformSpace \u03b1\npkg : AbstractCompletion \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : UniformSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ninst\u271d : T2Space \u03b2\nhf : UniformContinuous f\na : \u03b1\n\u22a2 \u22ef.extend f (pkg.coe a) = f a"
      },
      {
        "tactic": "exact pkg.denseInducing.extend_eq hf.continuous a",
        "annotated_tactic": [
          "exact pkg.denseInducing.extend_eq hf.continuous a",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : UniformSpace \u03b1\npkg : AbstractCompletion \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : UniformSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ninst\u271d : T2Space \u03b2\nhf : UniformContinuous f\na : \u03b1\n\u22a2 \u22ef.extend f (pkg.coe a) = f a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.558463120018132,
    "entry_failed": false
  },
  "10980": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Vector/Basic.lean",
    "full_name": "Vector.reverse_reverse",
    "start": [
      253,
      1
    ],
    "end": [
      255,
      24
    ],
    "traced_tactics": [
      {
        "tactic": "cases v",
        "annotated_tactic": [
          "cases v",
          []
        ],
        "state_before": "n : \u2115\n\u03b1 : Type u_1\nv : Vector \u03b1 n\n\u22a2 v.reverse.reverse = v",
        "state_after": "case mk\nn : \u2115\n\u03b1 : Type u_1\nval\u271d : List \u03b1\nproperty\u271d : val\u271d.length = n\n\u22a2 (reverse \u27e8val\u271d, property\u271d\u27e9).reverse = \u27e8val\u271d, property\u271d\u27e9"
      },
      {
        "tactic": "simp [Vector.reverse]",
        "annotated_tactic": [
          "simp [<a>Vector.reverse</a>]",
          [
            {
              "full_name": "Vector.reverse",
              "def_path": "Mathlib/Data/Vector/Basic.lean",
              "def_pos": [
                242,
                5
              ],
              "def_end_pos": [
                242,
                12
              ]
            }
          ]
        ],
        "state_before": "case mk\nn : \u2115\n\u03b1 : Type u_1\nval\u271d : List \u03b1\nproperty\u271d : val\u271d.length = n\n\u22a2 (reverse \u27e8val\u271d, property\u271d\u27e9).reverse = \u27e8val\u271d, property\u271d\u27e9",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.472364548011683,
    "entry_failed": false
  },
  "28677": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Part.lean",
    "full_name": "Part.bind_map",
    "start": [
      548,
      1
    ],
    "end": [
      549,
      95
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 bind_some_eq_map, bind_assoc]",
        "annotated_tactic": [
          "rw [\u2190 <a>bind_some_eq_map</a>, <a>bind_assoc</a>]",
          [
            {
              "full_name": "Part.bind_some_eq_map",
              "def_path": "Mathlib/Data/Part.lean",
              "def_pos": [
                525,
                9
              ],
              "def_end_pos": [
                525,
                25
              ]
            },
            {
              "full_name": "Part.bind_assoc",
              "def_path": "Mathlib/Data/Part.lean",
              "def_pos": [
                539,
                9
              ],
              "def_end_pos": [
                539,
                19
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2\nx : Part \u03b1\ng : \u03b2 \u2192 Part \u03b3\n\u22a2 (map f x).bind g = x.bind fun y => g (f y)",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2\nx : Part \u03b1\ng : \u03b2 \u2192 Part \u03b3\n\u22a2 (x.bind fun x => ((some \u2218 f) x).bind g) = x.bind fun y => g (f y)"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3\u271d : Type u_3\n\u03b3 : Type u_4\nf : \u03b1 \u2192 \u03b2\nx : Part \u03b1\ng : \u03b2 \u2192 Part \u03b3\n\u22a2 (x.bind fun x => ((some \u2218 f) x).bind g) = x.bind fun y => g (f y)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.7874074690043926,
    "entry_failed": false
  },
  "23466": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/Bernoulli.lean",
    "full_name": "bernoulli'_two",
    "start": [
      116,
      1
    ],
    "end": [
      118,
      60
    ],
    "traced_tactics": [
      {
        "tactic": "rw [bernoulli'_def]",
        "annotated_tactic": [
          "rw [<a>bernoulli'_def</a>]",
          [
            {
              "full_name": "bernoulli'_def",
              "def_path": "Mathlib/NumberTheory/Bernoulli.lean",
              "def_pos": [
                78,
                9
              ],
              "def_end_pos": [
                78,
                23
              ]
            }
          ]
        ],
        "state_before": "A : Type u_1\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra \u211a A\n\u22a2 bernoulli' 2 = 1 / 6",
        "state_after": "A : Type u_1\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra \u211a A\n\u22a2 1 - \u2211 k \u2208 range 2, \u2191(Nat.choose 2 k) / (\u21912 - \u2191k + 1) * bernoulli' k = 1 / 6"
      },
      {
        "tactic": "norm_num [sum_range_succ, sum_range_succ, sum_range_zero]",
        "annotated_tactic": [
          "norm_num [<a>sum_range_succ</a>, <a>sum_range_succ</a>, <a>sum_range_zero</a>]",
          [
            {
              "full_name": "Finset.sum_range_succ",
              "def_path": "Mathlib/Algebra/BigOperators/Group/Finset.lean",
              "def_pos": [
                1519,
                3
              ],
              "def_end_pos": [
                1519,
                14
              ]
            },
            {
              "full_name": "Finset.sum_range_succ",
              "def_path": "Mathlib/Algebra/BigOperators/Group/Finset.lean",
              "def_pos": [
                1519,
                3
              ],
              "def_end_pos": [
                1519,
                14
              ]
            },
            {
              "full_name": "Finset.sum_range_zero",
              "def_path": "Mathlib/Algebra/BigOperators/Group/Finset.lean",
              "def_pos": [
                1561,
                3
              ],
              "def_end_pos": [
                1561,
                14
              ]
            }
          ]
        ],
        "state_before": "A : Type u_1\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Algebra \u211a A\n\u22a2 1 - \u2211 k \u2208 range 2, \u2191(Nat.choose 2 k) / (\u21912 - \u2191k + 1) * bernoulli' k = 1 / 6",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.30736206099391,
    "entry_failed": false
  },
  "15224": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Regular/Pow.lean",
    "full_name": "IsRightRegular.pow",
    "start": [
      36,
      1
    ],
    "end": [
      38,
      22
    ],
    "traced_tactics": [
      {
        "tactic": "rw [IsRightRegular, \u2190 mul_right_iterate]",
        "annotated_tactic": [
          "rw [<a>IsRightRegular</a>, \u2190 <a>mul_right_iterate</a>]",
          [
            {
              "full_name": "IsRightRegular",
              "def_path": "Mathlib/Algebra/Regular/Basic.lean",
              "def_pos": [
                52,
                5
              ],
              "def_end_pos": [
                52,
                19
              ]
            },
            {
              "full_name": "mul_right_iterate",
              "def_path": "Mathlib/Algebra/GroupPower/IterateHom.lean",
              "def_pos": [
                105,
                9
              ],
              "def_end_pos": [
                105,
                26
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\na b : R\ninst\u271d : Monoid R\nn : \u2115\nrra : IsRightRegular a\n\u22a2 IsRightRegular (a ^ n)",
        "state_after": "R : Type u_1\na b : R\ninst\u271d : Monoid R\nn : \u2115\nrra : IsRightRegular a\n\u22a2 Function.Injective (fun x => x * a)^[n]"
      },
      {
        "tactic": "exact rra.iterate n",
        "annotated_tactic": [
          "exact rra.iterate n",
          []
        ],
        "state_before": "R : Type u_1\na b : R\ninst\u271d : Monoid R\nn : \u2115\nrra : IsRightRegular a\n\u22a2 Function.Injective (fun x => x * a)^[n]",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.180977037991397,
    "entry_failed": false
  },
  "22555": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Ring/Ext.lean",
    "full_name": "Ring.toNonAssocRing_injective",
    "start": [
      382,
      1
    ],
    "end": [
      385,
      16
    ],
    "traced_tactics": [
      {
        "tactic": "intro _ _ _",
        "annotated_tactic": [
          "intro _ _ _",
          []
        ],
        "state_before": "R : Type u\n\u22a2 Function.Injective (@toNonAssocRing R)",
        "state_after": "R : Type u\na\u2081\u271d a\u2082\u271d : Ring R\na\u271d : toNonAssocRing = toNonAssocRing\n\u22a2 a\u2081\u271d = a\u2082\u271d"
      },
      {
        "tactic": "ext <;> congr",
        "annotated_tactic": [
          "ext <;> congr",
          []
        ],
        "state_before": "R : Type u\na\u2081\u271d a\u2082\u271d : Ring R\na\u271d : toNonAssocRing = toNonAssocRing\n\u22a2 a\u2081\u271d = a\u2082\u271d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.287808007095009,
    "entry_failed": false
  },
  "12897": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/DropRight.lean",
    "full_name": "List.rtakeWhile_concat",
    "start": [
      198,
      1
    ],
    "end": [
      201,
      32
    ],
    "traced_tactics": [
      {
        "tactic": "simp only [rtakeWhile, takeWhile, reverse_append, reverse_singleton, singleton_append]",
        "annotated_tactic": [
          "simp only [<a>rtakeWhile</a>, <a>takeWhile</a>, <a>reverse_append</a>, <a>reverse_singleton</a>, <a>singleton_append</a>]",
          [
            {
              "full_name": "List.rtakeWhile",
              "def_path": "Mathlib/Data/List/DropRight.lean",
              "def_pos": [
                190,
                5
              ],
              "def_end_pos": [
                190,
                15
              ]
            },
            {
              "full_name": "List.takeWhile",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Basic.lean",
              "def_pos": [
                755,
                5
              ],
              "def_end_pos": [
                755,
                14
              ]
            },
            {
              "full_name": "List.reverse_append",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean",
              "def_pos": [
                1477,
                17
              ],
              "def_end_pos": [
                1477,
                31
              ]
            },
            {
              "full_name": "List.reverse_singleton",
              "def_path": "Mathlib/Data/List/Basic.lean",
              "def_pos": [
                526,
                9
              ],
              "def_end_pos": [
                526,
                26
              ]
            },
            {
              "full_name": "List.singleton_append",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/List/Lemmas.lean",
              "def_pos": [
                1069,
                22
              ],
              "def_end_pos": [
                1069,
                38
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl : List \u03b1\nn : \u2115\nx : \u03b1\n\u22a2 rtakeWhile p (l ++ [x]) = if p x = true then rtakeWhile p l ++ [x] else []",
        "state_after": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl : List \u03b1\nn : \u2115\nx : \u03b1\n\u22a2 (match p x with\n      | true => x :: takeWhile p l.reverse\n      | false => []).reverse =\n    if p x = true then (takeWhile p l.reverse).reverse ++ [x] else []"
      },
      {
        "tactic": "split_ifs with h <;> simp [h]",
        "annotated_tactic": [
          "split_ifs with h <;> simp [h]",
          []
        ],
        "state_before": "\u03b1 : Type u_1\np : \u03b1 \u2192 Bool\nl : List \u03b1\nn : \u2115\nx : \u03b1\n\u22a2 (match p x with\n      | true => x :: takeWhile p l.reverse\n      | false => []).reverse =\n    if p x = true then (takeWhile p l.reverse).reverse ++ [x] else []",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5410115380072966,
    "entry_failed": false
  },
  "24120": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/Iso.lean",
    "full_name": "CategoryTheory.Iso.hom_eq_inv",
    "start": [
      248,
      1
    ],
    "end": [
      250,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "erw [inv_eq_inv \u03b1.symm \u03b2, eq_comm]",
        "annotated_tactic": [
          "erw [<a>inv_eq_inv</a> \u03b1.symm \u03b2, <a>eq_comm</a>]",
          [
            {
              "full_name": "CategoryTheory.Iso.inv_eq_inv",
              "def_path": "Mathlib/CategoryTheory/Iso.lean",
              "def_pos": [
                227,
                9
              ],
              "def_end_pos": [
                227,
                19
              ]
            },
            {
              "full_name": "eq_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                811,
                9
              ],
              "def_end_pos": [
                811,
                16
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : C\n\u03b1 : X \u2245 Y\n\u03b2 : Y \u2245 X\n\u22a2 \u03b1.hom = \u03b2.inv \u2194 \u03b2.hom = \u03b1.inv",
        "state_after": "C : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : C\n\u03b1 : X \u2245 Y\n\u03b2 : Y \u2245 X\n\u22a2 \u03b2.hom = \u03b1.symm.hom \u2194 \u03b2.hom = \u03b1.inv"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "C : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : C\n\u03b1 : X \u2245 Y\n\u03b2 : Y \u2245 X\n\u22a2 \u03b2.hom = \u03b1.symm.hom \u2194 \u03b2.hom = \u03b1.inv",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.2561226199613884,
    "entry_failed": false
  },
  "3723": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Dist.lean",
    "full_name": "Nat.dist_tri_right",
    "start": [
      57,
      1
    ],
    "end": [
      57,
      93
    ],
    "traced_tactics": [
      {
        "tactic": "rw [add_comm]",
        "annotated_tactic": [
          "rw [<a>add_comm</a>]",
          [
            {
              "full_name": "add_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                331,
                3
              ],
              "def_end_pos": [
                331,
                14
              ]
            }
          ]
        ],
        "state_before": "n m : \u2115\n\u22a2 m \u2264 n + n.dist m",
        "state_after": "n m : \u2115\n\u22a2 m \u2264 n.dist m + n"
      },
      {
        "tactic": "apply dist_tri_left",
        "annotated_tactic": [
          "apply <a>dist_tri_left</a>",
          [
            {
              "full_name": "Nat.dist_tri_left",
              "def_path": "Mathlib/Data/Nat/Dist.lean",
              "def_pos": [
                53,
                9
              ],
              "def_end_pos": [
                53,
                22
              ]
            }
          ]
        ],
        "state_before": "n m : \u2115\n\u22a2 m \u2264 n.dist m + n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2559627279406413,
    "entry_failed": false
  },
  "8042": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Choose/Multinomial.lean",
    "full_name": "Nat.multinomial_singleton",
    "start": [
      75,
      1
    ],
    "end": [
      76,
      44
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 cons_empty, multinomial_cons]",
        "annotated_tactic": [
          "rw [\u2190 <a>cons_empty</a>, <a>multinomial_cons</a>]",
          [
            {
              "full_name": "Finset.cons_empty",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                908,
                9
              ],
              "def_end_pos": [
                908,
                19
              ]
            },
            {
              "full_name": "Nat.multinomial_cons",
              "def_path": "Mathlib/Data/Nat/Choose/Multinomial.lean",
              "def_pos": [
                62,
                7
              ],
              "def_end_pos": [
                62,
                23
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ns : Finset \u03b1\nf\u271d : \u03b1 \u2192 \u2115\na\u271d b : \u03b1\nn : \u2115\na : \u03b1\nf : \u03b1 \u2192 \u2115\n\u22a2 multinomial {a} f = 1",
        "state_after": "\u03b1 : Type u_1\ns : Finset \u03b1\nf\u271d : \u03b1 \u2192 \u2115\na\u271d b : \u03b1\nn : \u2115\na : \u03b1\nf : \u03b1 \u2192 \u2115\n\u22a2 (f a + \u2211 i \u2208 \u2205, f i).choose (f a) * multinomial \u2205 f = 1"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ns : Finset \u03b1\nf\u271d : \u03b1 \u2192 \u2115\na\u271d b : \u03b1\nn : \u2115\na : \u03b1\nf : \u03b1 \u2192 \u2115\n\u22a2 (f a + \u2211 i \u2208 \u2205, f i).choose (f a) * multinomial \u2205 f = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4900837679160759,
    "entry_failed": false
  },
  "23941": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Game/PGame.lean",
    "full_name": "SetTheory.PGame.le_or_gf",
    "start": [
      464,
      1
    ],
    "end": [
      466,
      11
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 PGame.not_le]",
        "annotated_tactic": [
          "rw [\u2190 <a>PGame.not_le</a>]",
          [
            {
              "full_name": "SetTheory.PGame.not_le",
              "def_path": "Mathlib/SetTheory/Game/PGame.lean",
              "def_pos": [
                406,
                19
              ],
              "def_end_pos": [
                406,
                25
              ]
            }
          ]
        ],
        "state_before": "xl xr : Type u\nx y : PGame\n\u22a2 x \u2264 y \u2228 y \u29cf x",
        "state_after": "xl xr : Type u\nx y : PGame\n\u22a2 x \u2264 y \u2228 \u00acx \u2264 y"
      },
      {
        "tactic": "apply em",
        "annotated_tactic": [
          "apply <a>em</a>",
          [
            {
              "full_name": "em",
              "def_path": "Mathlib/Logic/Basic.lean",
              "def_pos": [
                195,
                7
              ],
              "def_end_pos": [
                195,
                9
              ]
            }
          ]
        ],
        "state_before": "xl xr : Type u\nx y : PGame\n\u22a2 x \u2264 y \u2228 \u00acx \u2264 y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.659392821951769,
    "entry_failed": false
  },
  "27946": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/ConcreteCategory/EpiMono.lean",
    "full_name": "CategoryTheory.ConcreteCategory.bijective_of_isIso",
    "start": [
      168,
      1
    ],
    "end": [
      171,
      17
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 isIso_iff_bijective]",
        "annotated_tactic": [
          "rw [\u2190 <a>isIso_iff_bijective</a>]",
          [
            {
              "full_name": "CategoryTheory.isIso_iff_bijective",
              "def_path": "Mathlib/CategoryTheory/Types.lean",
              "def_pos": [
                391,
                9
              ],
              "def_end_pos": [
                391,
                28
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : ConcreteCategory C\nX Y : C\nf : X \u27f6 Y\ninst\u271d : IsIso f\n\u22a2 Function.Bijective ((forget C).map f)",
        "state_after": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : ConcreteCategory C\nX Y : C\nf : X \u27f6 Y\ninst\u271d : IsIso f\n\u22a2 IsIso ((forget C).map f)"
      },
      {
        "tactic": "infer_instance",
        "annotated_tactic": [
          "infer_instance",
          []
        ],
        "state_before": "C : Type u\ninst\u271d\u00b2 : Category.{v, u} C\ninst\u271d\u00b9 : ConcreteCategory C\nX Y : C\nf : X \u27f6 Y\ninst\u271d : IsIso f\n\u22a2 IsIso ((forget C).map f)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5337567869573832,
    "entry_failed": false
  },
  "19207": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/CategoryTheory/Iso.lean",
    "full_name": "CategoryTheory.IsIso.inv_id",
    "start": [
      411,
      1
    ],
    "end": [
      413,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "apply inv_eq_of_hom_inv_id",
        "annotated_tactic": [
          "apply <a>inv_eq_of_hom_inv_id</a>",
          [
            {
              "full_name": "CategoryTheory.IsIso.inv_eq_of_hom_inv_id",
              "def_path": "Mathlib/CategoryTheory/Iso.lean",
              "def_pos": [
                366,
                9
              ],
              "def_end_pos": [
                366,
                29
              ]
            }
          ]
        ],
        "state_before": "C : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : C\nf g : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 inv (\ud835\udfd9 X) = \ud835\udfd9 X",
        "state_after": "case hom_inv_id\nC : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : C\nf g : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 \ud835\udfd9 X \u226b \ud835\udfd9 X = \ud835\udfd9 X"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case hom_inv_id\nC : Type u\ninst\u271d : Category.{v, u} C\nX Y Z : C\nf g : X \u27f6 Y\nh : Y \u27f6 Z\n\u22a2 \ud835\udfd9 X \u226b \ud835\udfd9 X = \ud835\udfd9 X",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.6433028100291267,
    "entry_failed": false
  },
  "24492": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/PowerSeries/Basic.lean",
    "full_name": "PowerSeries.coeff_zero_eq_constantCoeff",
    "start": [
      229,
      1
    ],
    "end": [
      231,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "rw [coeff, Finsupp.single_zero]",
        "annotated_tactic": [
          "rw [<a>coeff</a>, <a>Finsupp.single_zero</a>]",
          [
            {
              "full_name": "PowerSeries.coeff",
              "def_path": "Mathlib/RingTheory/PowerSeries/Basic.lean",
              "def_pos": [
                139,
                5
              ],
              "def_end_pos": [
                139,
                10
              ]
            },
            {
              "full_name": "Finsupp.single_zero",
              "def_path": "Mathlib/Data/Finsupp/Defs.lean",
              "def_pos": [
                323,
                9
              ],
              "def_end_pos": [
                323,
                20
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d : Semiring R\n\u22a2 \u21d1(coeff R 0) = \u21d1(constantCoeff R)",
        "state_after": "R : Type u_1\ninst\u271d : Semiring R\n\u22a2 \u21d1(MvPowerSeries.coeff R 0) = \u21d1(constantCoeff R)"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d : Semiring R\n\u22a2 \u21d1(MvPowerSeries.coeff R 0) = \u21d1(constantCoeff R)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.8499314130749553,
    "entry_failed": false
  },
  "16741": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Count.lean",
    "full_name": "Nat.count_eq_card_filter_range",
    "start": [
      54,
      1
    ],
    "end": [
      56,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "rw [count, List.countP_eq_length_filter]",
        "annotated_tactic": [
          "rw [<a>count</a>, <a>List.countP_eq_length_filter</a>]",
          [
            {
              "full_name": "Nat.count",
              "def_path": "Mathlib/Data/Nat/Count.lean",
              "def_pos": [
                33,
                5
              ],
              "def_end_pos": [
                33,
                10
              ]
            },
            {
              "full_name": "List.countP_eq_length_filter",
              "def_path": ".lake/packages/batteries/Batteries/Data/List/Count.lean",
              "def_pos": [
                60,
                9
              ],
              "def_end_pos": [
                60,
                32
              ]
            }
          ]
        ],
        "state_before": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\n\u22a2 count p n = (filter p (range n)).card",
        "state_after": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\n\u22a2 (List.filter (fun b => decide (p b)) (List.range n)).length = (filter p (range n)).card"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nn : \u2115\n\u22a2 (List.filter (fun b => decide (p b)) (List.range n)).length = (filter p (range n)).card",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.3464922450948507,
    "entry_failed": false
  },
  "9844": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Cardinal/Continuum.lean",
    "full_name": "Cardinal.aleph_one_le_continuum",
    "start": [
      97,
      1
    ],
    "end": [
      99,
      48
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 succ_aleph0]",
        "annotated_tactic": [
          "rw [\u2190 <a>succ_aleph0</a>]",
          [
            {
              "full_name": "Cardinal.succ_aleph0",
              "def_path": "Mathlib/SetTheory/Cardinal/Ordinal.lean",
              "def_pos": [
                344,
                9
              ],
              "def_end_pos": [
                344,
                20
              ]
            }
          ]
        ],
        "state_before": "\u22a2 aleph 1 \u2264 \ud835\udd20",
        "state_after": "\u22a2 Order.succ \u2135\u2080 \u2264 \ud835\udd20"
      },
      {
        "tactic": "exact Order.succ_le_of_lt aleph0_lt_continuum",
        "annotated_tactic": [
          "exact <a>Order.succ_le_of_lt</a> <a>aleph0_lt_continuum</a>",
          [
            {
              "full_name": "Order.succ_le_of_lt",
              "def_path": "Mathlib/Order/SuccPred/Basic.lean",
              "def_pos": [
                239,
                9
              ],
              "def_end_pos": [
                239,
                22
              ]
            },
            {
              "full_name": "Cardinal.aleph0_lt_continuum",
              "def_path": "Mathlib/SetTheory/Cardinal/Continuum.lean",
              "def_pos": [
                70,
                9
              ],
              "def_end_pos": [
                70,
                28
              ]
            }
          ]
        ],
        "state_before": "\u22a2 Order.succ \u2135\u2080 \u2264 \ud835\udd20",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5097953119548038,
    "entry_failed": false
  },
  "10932": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Fintype/Lattice.lean",
    "full_name": "Finite.exists_min",
    "start": [
      68,
      1
    ],
    "end": [
      71,
      52
    ],
    "traced_tactics": [
      {
        "tactic": "cases nonempty_fintype \u03b1",
        "annotated_tactic": [
          "cases <a>nonempty_fintype</a> \u03b1",
          [
            {
              "full_name": "nonempty_fintype",
              "def_path": "Mathlib/Data/Fintype/Card.lean",
              "def_pos": [
                443,
                9
              ],
              "def_end_pos": [
                443,
                25
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : Finite \u03b1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u2203 x\u2080, \u2200 (x : \u03b1), f x\u2080 \u2264 f x",
        "state_after": "case intro\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : Finite \u03b1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\nval\u271d : Fintype \u03b1\n\u22a2 \u2203 x\u2080, \u2200 (x : \u03b1), f x\u2080 \u2264 f x"
      },
      {
        "tactic": "simpa using exists_min_image univ f univ_nonempty",
        "annotated_tactic": [
          "simpa using <a>exists_min_image</a> <a>univ</a> f <a>univ_nonempty</a>",
          [
            {
              "full_name": "Finset.exists_min_image",
              "def_path": "Mathlib/Data/Finset/Lattice.lean",
              "def_pos": [
                1942,
                9
              ],
              "def_end_pos": [
                1942,
                25
              ]
            },
            {
              "full_name": "Finset.univ",
              "def_path": "Mathlib/Data/Fintype/Basic.lean",
              "def_pos": [
                70,
                5
              ],
              "def_end_pos": [
                70,
                9
              ]
            },
            {
              "full_name": "Finset.univ_nonempty",
              "def_path": "Mathlib/Data/Fintype/Basic.lean",
              "def_pos": [
                109,
                9
              ],
              "def_end_pos": [
                109,
                22
              ]
            }
          ]
        ],
        "state_before": "case intro\n\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : Finite \u03b1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\nval\u271d : Fintype \u03b1\n\u22a2 \u2203 x\u2080, \u2200 (x : \u03b1), f x\u2080 \u2264 f x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.426333307987079,
    "entry_failed": false
  },
  "24993": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Group/OrderIso.lean",
    "full_name": "OrderIso.mulLeft_symm",
    "start": [
      137,
      1
    ],
    "end": [
      139,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "ext x",
        "annotated_tactic": [
          "ext x",
          []
        ],
        "state_before": "\u03b1 : Type u\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x * x_1) fun x x_1 => x \u2264 x_1\na : \u03b1\n\u22a2 (mulLeft a).symm = mulLeft a\u207b\u00b9",
        "state_after": "case h.h\n\u03b1 : Type u\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x * x_1) fun x x_1 => x \u2264 x_1\na x : \u03b1\n\u22a2 (mulLeft a).symm x = (mulLeft a\u207b\u00b9) x"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case h.h\n\u03b1 : Type u\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x * x_1) fun x x_1 => x \u2264 x_1\na x : \u03b1\n\u22a2 (mulLeft a).symm x = (mulLeft a\u207b\u00b9) x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5590504390420392,
    "entry_failed": false
  },
  "3883": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Rel.lean",
    "full_name": "Rel.comp_right_bot",
    "start": [
      126,
      1
    ],
    "end": [
      128,
      23
    ],
    "traced_tactics": [
      {
        "tactic": "ext x y",
        "annotated_tactic": [
          "ext x y",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr\u271d r : Rel \u03b1 \u03b2\n\u22a2 r \u2022 \u22a5 = \u22a5",
        "state_after": "case a.h.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr\u271d r : Rel \u03b1 \u03b2\nx : \u03b1\ny : \u03b3\n\u22a2 (r \u2022 \u22a5) x y \u2194 \u22a5 x y"
      },
      {
        "tactic": "simp [comp, Bot.bot]",
        "annotated_tactic": [
          "simp [<a>comp</a>, <a>Bot.bot</a>]",
          [
            {
              "full_name": "Rel.comp",
              "def_path": "Mathlib/Data/Rel.lean",
              "def_pos": [
                97,
                5
              ],
              "def_end_pos": [
                97,
                9
              ]
            },
            {
              "full_name": "Bot.bot",
              "def_path": "Mathlib/Order/Notation.lean",
              "def_pos": [
                107,
                3
              ],
              "def_end_pos": [
                107,
                6
              ]
            }
          ]
        ],
        "state_before": "case a.h.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nr\u271d r : Rel \u03b1 \u03b2\nx : \u03b1\ny : \u03b3\n\u22a2 (r \u2022 \u22a5) x y \u2194 \u22a5 x y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.456767515046522,
    "entry_failed": false
  },
  "28174": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/AlgebraicGeometry/EllipticCurve/DivisionPolynomial/Basic.lean",
    "full_name": "WeierstrassCurve.\u03a8_four",
    "start": [
      321,
      1
    ],
    "end": [
      323,
      49
    ],
    "traced_tactics": [
      {
        "tactic": "erw [\u03a8_ofNat, pre\u03a8'_four, if_pos <| by decide]",
        "annotated_tactic": [
          "erw [<a>\u03a8_ofNat</a>, <a>pre\u03a8'_four</a>, <a>if_pos</a> <| by decide]",
          [
            {
              "full_name": "WeierstrassCurve.\u03a8_ofNat",
              "def_path": "Mathlib/AlgebraicGeometry/EllipticCurve/DivisionPolynomial/Basic.lean",
              "def_pos": [
                302,
                7
              ],
              "def_end_pos": [
                302,
                14
              ]
            },
            {
              "full_name": "WeierstrassCurve.pre\u03a8'_four",
              "def_path": "Mathlib/AlgebraicGeometry/EllipticCurve/DivisionPolynomial/Basic.lean",
              "def_pos": [
                179,
                7
              ],
              "def_end_pos": [
                179,
                17
              ]
            },
            {
              "full_name": "if_pos",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                932,
                9
              ],
              "def_end_pos": [
                932,
                15
              ]
            }
          ]
        ],
        "state_before": "R : Type r\nS : Type s\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nW : WeierstrassCurve R\n\u22a2 W.\u03a8 4 = C W.pre\u03a8\u2084 * W.\u03c8\u2082",
        "state_after": "no goals"
      },
      {
        "tactic": "decide",
        "annotated_tactic": [
          "decide",
          []
        ],
        "state_before": "R : Type r\nS : Type s\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nW : WeierstrassCurve R\n\u22a2 Even 4",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.194138803053647,
    "entry_failed": false
  },
  "570": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Perm/ClosureSwap.lean",
    "full_name": "Equiv.Perm.IsSwap.finite_compl_fixedBy",
    "start": [
      41,
      1
    ],
    "end": [
      44,
      34
    ],
    "traced_tactics": [
      {
        "tactic": "obtain \u27e8x, y, -, rfl\u27e9 := h",
        "annotated_tactic": [
          "obtain \u27e8x, y, -, rfl\u27e9 := h",
          []
        ],
        "state_before": "G : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : DecidableEq \u03b1\n\u03c3 : Perm \u03b1\nh : \u03c3.IsSwap\n\u22a2 (fixedBy \u03b1 \u03c3)\u1d9c.Finite",
        "state_after": "case intro.intro.intro\nG : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : DecidableEq \u03b1\nx y : \u03b1\n\u22a2 (fixedBy \u03b1 (swap x y))\u1d9c.Finite"
      },
      {
        "tactic": "exact finite_compl_fixedBy_swap",
        "annotated_tactic": [
          "exact <a>finite_compl_fixedBy_swap</a>",
          [
            {
              "full_name": "finite_compl_fixedBy_swap",
              "def_path": "Mathlib/GroupTheory/Perm/ClosureSwap.lean",
              "def_pos": [
                37,
                9
              ],
              "def_end_pos": [
                37,
                34
              ]
            }
          ]
        ],
        "state_before": "case intro.intro.intro\nG : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : DecidableEq \u03b1\nx y : \u03b1\n\u22a2 (fixedBy \u03b1 (swap x y))\u1d9c.Finite",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.3435106070246547,
    "entry_failed": false
  },
  "15895": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Probability/Distributions/Poisson.lean",
    "full_name": "ProbabilityTheory.poissonPMFReal_pos",
    "start": [
      49,
      1
    ],
    "end": [
      52,
      13
    ],
    "traced_tactics": [
      {
        "tactic": "rw [poissonPMFReal]",
        "annotated_tactic": [
          "rw [<a>poissonPMFReal</a>]",
          [
            {
              "full_name": "ProbabilityTheory.poissonPMFReal",
              "def_path": "Mathlib/Probability/Distributions/Poisson.lean",
              "def_pos": [
                35,
                5
              ],
              "def_end_pos": [
                35,
                19
              ]
            }
          ]
        ],
        "state_before": "r : \u211d\u22650\nn : \u2115\nhr : 0 < r\n\u22a2 0 < poissonPMFReal r n",
        "state_after": "r : \u211d\u22650\nn : \u2115\nhr : 0 < r\n\u22a2 0 < rexp (-\u2191r) * \u2191r ^ n / \u2191n !"
      },
      {
        "tactic": "positivity",
        "annotated_tactic": [
          "positivity",
          []
        ],
        "state_before": "r : \u211d\u22650\nn : \u2115\nhr : 0 < r\n\u22a2 0 < rexp (-\u2191r) * \u2191r ^ n / \u2191n !",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.873526332899928,
    "entry_failed": false
  },
  "7758": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Ring/Ext.lean",
    "full_name": "Semiring.toNonUnitalSemiring_injective",
    "start": [
      332,
      1
    ],
    "end": [
      337,
      39
    ],
    "traced_tactics": [
      {
        "tactic": "intro _ _ h",
        "annotated_tactic": [
          "intro _ _ h",
          []
        ],
        "state_before": "R : Type u\n\u22a2 Function.Injective (@toNonUnitalSemiring R)",
        "state_after": "R : Type u\na\u2081\u271d a\u2082\u271d : Semiring R\nh : toNonUnitalSemiring = toNonUnitalSemiring\n\u22a2 a\u2081\u271d = a\u2082\u271d"
      },
      {
        "tactic": "ext x y",
        "annotated_tactic": [
          "ext x y",
          []
        ],
        "state_before": "R : Type u\na\u2081\u271d a\u2082\u271d : Semiring R\nh : toNonUnitalSemiring = toNonUnitalSemiring\n\u22a2 a\u2081\u271d = a\u2082\u271d",
        "state_after": "case h_add.h.h\nR : Type u\na\u2081\u271d a\u2082\u271d : Semiring R\nh : toNonUnitalSemiring = toNonUnitalSemiring\nx y : R\n\u22a2 x + y = x + y\n\ncase h_mul.h.h\nR : Type u\na\u2081\u271d a\u2082\u271d : Semiring R\nh : toNonUnitalSemiring = toNonUnitalSemiring\nx y : R\n\u22a2 x * y = x * y"
      }
    ],
    "entry_time": 2.0778539850143716,
    "entry_failed": false
  },
  "5331": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Defs.lean",
    "full_name": "List.iterate_eq_iterateTR",
    "start": [
      574,
      1
    ],
    "end": [
      576,
      46
    ],
    "traced_tactics": [
      {
        "tactic": "funext \u03b1 f a n",
        "annotated_tactic": [
          "funext \u03b1 f a n",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b5 : Type u_5\n\u03b6 : Type u_6\n\u22a2 @iterate = @iterateTR",
        "state_after": "case h.h.h.h\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b5 : Type u_5\n\u03b6 : Type u_6\n\u03b1 : Type u_7\nf : \u03b1 \u2192 \u03b1\na : \u03b1\nn : \u2115\n\u22a2 iterate f a n = iterateTR f a n"
      },
      {
        "tactic": "exact Eq.symm <| iterateTR_loop_eq f a n []",
        "annotated_tactic": [
          "exact <a>Eq.symm</a> <| <a>iterateTR_loop_eq</a> f a n []",
          [
            {
              "full_name": "Eq.symm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                323,
                9
              ],
              "def_end_pos": [
                323,
                16
              ]
            },
            {
              "full_name": "List.iterateTR_loop_eq",
              "def_path": "Mathlib/Data/List/Defs.lean",
              "def_pos": [
                569,
                9
              ],
              "def_end_pos": [
                569,
                26
              ]
            }
          ]
        ],
        "state_before": "case h.h.h.h\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\n\u03b5 : Type u_5\n\u03b6 : Type u_6\n\u03b1 : Type u_7\nf : \u03b1 \u2192 \u03b1\na : \u03b1\nn : \u2115\n\u22a2 iterate f a n = iterateTR f a n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8931422430323437,
    "entry_failed": false
  },
  "18873": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Finsupp/Multiset.lean",
    "full_name": "Finsupp.toMultiset_single",
    "start": [
      52,
      1
    ],
    "end": [
      53,
      60
    ],
    "traced_tactics": [
      {
        "tactic": "rw [toMultiset_apply, sum_single_index]",
        "annotated_tactic": [
          "rw [<a>toMultiset_apply</a>, <a>sum_single_index</a>]",
          [
            {
              "full_name": "Finsupp.toMultiset_apply",
              "def_path": "Mathlib/Data/Finsupp/Multiset.lean",
              "def_pos": [
                47,
                9
              ],
              "def_end_pos": [
                47,
                25
              ]
            },
            {
              "full_name": "Finsupp.sum_single_index",
              "def_path": "Mathlib/Algebra/BigOperators/Finsupp.lean",
              "def_pos": [
                68,
                3
              ],
              "def_end_pos": [
                68,
                14
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\na : \u03b1\nn : \u2115\n\u22a2 toMultiset (single a n) = n \u2022 {a}",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\na : \u03b1\nn : \u2115\n\u22a2 0 \u2022 {a} = 0"
      },
      {
        "tactic": "apply zero_nsmul",
        "annotated_tactic": [
          "apply <a>zero_nsmul</a>",
          [
            {
              "full_name": "zero_nsmul",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                650,
                15
              ],
              "def_end_pos": [
                650,
                25
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\na : \u03b1\nn : \u2115\n\u22a2 0 \u2022 {a} = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6810332169989124,
    "entry_failed": false
  },
  "8410": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/WittVector/Teichmuller.lean",
    "full_name": "WittVector.teichmuller_zero",
    "start": [
      116,
      1
    ],
    "end": [
      117,
      36
    ],
    "traced_tactics": [
      {
        "tactic": "rw [zero_coeff]",
        "annotated_tactic": [
          "rw [<a>zero_coeff</a>]",
          [
            {
              "full_name": "WittVector.zero_coeff",
              "def_path": "Mathlib/RingTheory/WittVector/Defs.lean",
              "def_pos": [
                328,
                9
              ],
              "def_end_pos": [
                328,
                19
              ]
            }
          ]
        ],
        "state_before": "case h.succ\np : \u2115\nR : Type u_1\nS : Type u_2\nhp : Fact (Nat.Prime p)\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nn\u271d : \u2115\n\u22a2 ((teichmuller p) 0).coeff (n\u271d + 1) = coeff 0 (n\u271d + 1)",
        "state_after": "case h.succ\np : \u2115\nR : Type u_1\nS : Type u_2\nhp : Fact (Nat.Prime p)\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nn\u271d : \u2115\n\u22a2 ((teichmuller p) 0).coeff (n\u271d + 1) = 0"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case h.succ\np : \u2115\nR : Type u_1\nS : Type u_2\nhp : Fact (Nat.Prime p)\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nn\u271d : \u2115\n\u22a2 ((teichmuller p) 0).coeff (n\u271d + 1) = 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.6951946929330006,
    "entry_failed": false
  },
  "19229": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/HahnSeries/Addition.lean",
    "full_name": "HahnSeries.sub_coeff'",
    "start": [
      167,
      1
    ],
    "end": [
      169,
      24
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : AddGroup R\nx y : HahnSeries \u0393 R\n\u22a2 (x - y).coeff = x.coeff - y.coeff",
        "state_after": "case h\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : AddGroup R\nx y : HahnSeries \u0393 R\nx\u271d : \u0393\n\u22a2 (x - y).coeff x\u271d = (x.coeff - y.coeff) x\u271d"
      },
      {
        "tactic": "simp [sub_eq_add_neg]",
        "annotated_tactic": [
          "simp [<a>sub_eq_add_neg</a>]",
          [
            {
              "full_name": "sub_eq_add_neg",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                1057,
                3
              ],
              "def_end_pos": [
                1057,
                14
              ]
            }
          ]
        ],
        "state_before": "case h\n\u0393 : Type u_1\nR : Type u_2\ninst\u271d\u00b9 : PartialOrder \u0393\ninst\u271d : AddGroup R\nx y : HahnSeries \u0393 R\nx\u271d : \u0393\n\u22a2 (x - y).coeff x\u271d = (x.coeff - y.coeff) x\u271d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.4604004400316626,
    "entry_failed": false
  },
  "11032": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Init/Order/Defs.lean",
    "full_name": "compare_lt_iff_lt",
    "start": [
      421,
      1
    ],
    "end": [
      423,
      41
    ],
    "traced_tactics": [
      {
        "tactic": "rw [LinearOrder.compare_eq_compareOfLessAndEq, compareOfLessAndEq]",
        "annotated_tactic": [
          "rw [<a>LinearOrder.compare_eq_compareOfLessAndEq</a>, <a>compareOfLessAndEq</a>]",
          [
            {
              "full_name": "LinearOrder.compare_eq_compareOfLessAndEq",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                289,
                3
              ],
              "def_end_pos": [
                289,
                32
              ]
            },
            {
              "full_name": "compareOfLessAndEq",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Ord.lean",
              "def_pos": [
                95,
                15
              ],
              "def_end_pos": [
                95,
                33
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\n\u22a2 compare a b = Ordering.lt \u2194 a < b",
        "state_after": "\u03b1 : Type u\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\n\u22a2 (if a < b then Ordering.lt else if a = b then Ordering.eq else Ordering.gt) = Ordering.lt \u2194 a < b"
      },
      {
        "tactic": "split_ifs <;> simp only [*, lt_irrefl]",
        "annotated_tactic": [
          "split_ifs <;> simp only [*, <a>lt_irrefl</a>]",
          [
            {
              "full_name": "lt_irrefl",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                79,
                9
              ],
              "def_end_pos": [
                79,
                18
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\ninst\u271d : LinearOrder \u03b1\na b : \u03b1\n\u22a2 (if a < b then Ordering.lt else if a = b then Ordering.eq else Ordering.gt) = Ordering.lt \u2194 a < b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.535237786010839,
    "entry_failed": false
  },
  "23788": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Choose/Central.lean",
    "full_name": "Nat.two_dvd_centralBinom_of_one_le",
    "start": [
      124,
      1
    ],
    "end": [
      126,
      41
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 Nat.succ_pred_eq_of_pos h]",
        "annotated_tactic": [
          "rw [\u2190 <a>Nat.succ_pred_eq_of_pos</a> h]",
          [
            {
              "full_name": "Nat.succ_pred_eq_of_pos",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean",
              "def_pos": [
                830,
                9
              ],
              "def_end_pos": [
                830,
                28
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\nh : 0 < n\n\u22a2 2 \u2223 n.centralBinom",
        "state_after": "n : \u2115\nh : 0 < n\n\u22a2 2 \u2223 n.pred.succ.centralBinom"
      },
      {
        "tactic": "exact two_dvd_centralBinom_succ n.pred",
        "annotated_tactic": [
          "exact <a>two_dvd_centralBinom_succ</a> n.pred",
          [
            {
              "full_name": "Nat.two_dvd_centralBinom_succ",
              "def_path": "Mathlib/Data/Nat/Choose/Central.lean",
              "def_pos": [
                118,
                9
              ],
              "def_end_pos": [
                118,
                34
              ]
            }
          ]
        ],
        "state_before": "n : \u2115\nh : 0 < n\n\u22a2 2 \u2223 n.pred.succ.centralBinom",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.938463418977335,
    "entry_failed": false
  },
  "5948": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": ".lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "full_name": "List.get?_inj",
    "start": [
      276,
      1
    ],
    "end": [
      279,
      11
    ],
    "traced_tactics": [
      {
        "tactic": "apply getElem?_inj h\u2080 h\u2081",
        "annotated_tactic": [
          "apply <a>getElem?_inj</a> h\u2080 h\u2081",
          [
            {
              "full_name": "List.getElem?_inj",
              "def_path": ".lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
              "def_pos": [
                254,
                9
              ],
              "def_end_pos": [
                254,
                21
              ]
            }
          ]
        ],
        "state_before": "i : Nat\n\u03b1\u271d : Type u_1\nxs : List \u03b1\u271d\nj : Nat\nh\u2080 : i < xs.length\nh\u2081 : xs.Nodup\nh\u2082 : xs.get? i = xs.get? j\n\u22a2 i = j",
        "state_after": "i : Nat\n\u03b1\u271d : Type u_1\nxs : List \u03b1\u271d\nj : Nat\nh\u2080 : i < xs.length\nh\u2081 : xs.Nodup\nh\u2082 : xs.get? i = xs.get? j\n\u22a2 xs[i]? = xs[j]?"
      },
      {
        "tactic": "simp_all",
        "annotated_tactic": [
          "simp_all",
          []
        ],
        "state_before": "i : Nat\n\u03b1\u271d : Type u_1\nxs : List \u03b1\u271d\nj : Nat\nh\u2080 : i < xs.length\nh\u2081 : xs.Nodup\nh\u2082 : xs.get? i = xs.get? j\n\u22a2 xs[i]? = xs[j]?",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.526078402996063,
    "entry_failed": false
  },
  "11134": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Int/GCD.lean",
    "full_name": "Int.lcm_one_right",
    "start": [
      430,
      1
    ],
    "end": [
      432,
      26
    ],
    "traced_tactics": [
      {
        "tactic": "rw [Int.lcm]",
        "annotated_tactic": [
          "rw [<a>Int.lcm</a>]",
          [
            {
              "full_name": "Int.lcm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Int/Gcd.lean",
              "def_pos": [
                41,
                5
              ],
              "def_end_pos": [
                41,
                8
              ]
            }
          ]
        ],
        "state_before": "i : \u2124\n\u22a2 i.lcm 1 = i.natAbs",
        "state_after": "i : \u2124\n\u22a2 i.natAbs.lcm (natAbs 1) = i.natAbs"
      },
      {
        "tactic": "apply Nat.lcm_one_right",
        "annotated_tactic": [
          "apply <a>Nat.lcm_one_right</a>",
          [
            {
              "full_name": "Nat.lcm_one_right",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Lcm.lean",
              "def_pos": [
                25,
                17
              ],
              "def_end_pos": [
                25,
                30
              ]
            }
          ]
        ],
        "state_before": "i : \u2124\n\u22a2 i.natAbs.lcm (natAbs 1) = i.natAbs",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.7508870910387486,
    "entry_failed": false
  },
  "1299": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/MeasureTheory/OuterMeasure/AE.lean",
    "full_name": "MeasureTheory.inter_ae_eq_empty_of_ae_eq_empty_right",
    "start": [
      242,
      1
    ],
    "end": [
      245,
      19
    ],
    "traced_tactics": [
      {
        "tactic": "convert ae_eq_set_inter (ae_eq_refl s) h",
        "annotated_tactic": [
          "convert <a>ae_eq_set_inter</a> (<a>ae_eq_refl</a> s) h",
          [
            {
              "full_name": "MeasureTheory.ae_eq_set_inter",
              "def_path": "Mathlib/MeasureTheory/OuterMeasure/AE.lean",
              "def_pos": [
                197,
                9
              ],
              "def_end_pos": [
                197,
                24
              ]
            },
            {
              "full_name": "MeasureTheory.ae_eq_refl",
              "def_path": "Mathlib/MeasureTheory/OuterMeasure/AE.lean",
              "def_pos": [
                120,
                9
              ],
              "def_end_pos": [
                120,
                19
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nF : Type u_3\ninst\u271d\u00b9 : FunLike F (Set \u03b1) \u211d\u22650\u221e\ninst\u271d : OuterMeasureClass F \u03b1\n\u03bc : F\ns t : Set \u03b1\nh : t =\u1da0[ae \u03bc] \u2205\n\u22a2 s \u2229 t =\u1da0[ae \u03bc] \u2205",
        "state_after": "case h.e'_5\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nF : Type u_3\ninst\u271d\u00b9 : FunLike F (Set \u03b1) \u211d\u22650\u221e\ninst\u271d : OuterMeasureClass F \u03b1\n\u03bc : F\ns t : Set \u03b1\nh : t =\u1da0[ae \u03bc] \u2205\n\u22a2 \u2205 = s \u2229 \u2205"
      },
      {
        "tactic": "rw [inter_empty]",
        "annotated_tactic": [
          "rw [<a>inter_empty</a>]",
          [
            {
              "full_name": "Set.inter_empty",
              "def_path": "Mathlib/Data/Set/Basic.lean",
              "def_pos": [
                896,
                9
              ],
              "def_end_pos": [
                896,
                20
              ]
            }
          ]
        ],
        "state_before": "case h.e'_5\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nF : Type u_3\ninst\u271d\u00b9 : FunLike F (Set \u03b1) \u211d\u22650\u221e\ninst\u271d : OuterMeasureClass F \u03b1\n\u03bc : F\ns t : Set \u03b1\nh : t =\u1da0[ae \u03bc] \u2205\n\u22a2 \u2205 = s \u2229 \u2205",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.4353667399846017,
    "entry_failed": false
  },
  "927": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Geometry/Euclidean/Sphere/Basic.lean",
    "full_name": "EuclideanGeometry.Cospherical.subset",
    "start": [
      175,
      1
    ],
    "end": [
      178,
      42
    ],
    "traced_tactics": [
      {
        "tactic": "rcases hc with \u27e8c, r, hcr\u27e9",
        "annotated_tactic": [
          "rcases hc with \u27e8c, r, hcr\u27e9",
          []
        ],
        "state_before": "V : Type u_1\nP : Type u_2\ninst\u271d : MetricSpace P\nps\u2081 ps\u2082 : Set P\nhs : ps\u2081 \u2286 ps\u2082\nhc : Cospherical ps\u2082\n\u22a2 Cospherical ps\u2081",
        "state_after": "case intro.intro\nV : Type u_1\nP : Type u_2\ninst\u271d : MetricSpace P\nps\u2081 ps\u2082 : Set P\nhs : ps\u2081 \u2286 ps\u2082\nc : P\nr : \u211d\nhcr : \u2200 p \u2208 ps\u2082, dist p c = r\n\u22a2 Cospherical ps\u2081"
      },
      {
        "tactic": "exact \u27e8c, r, fun p hp => hcr p (hs hp)\u27e9",
        "annotated_tactic": [
          "exact \u27e8c, r, fun p hp => hcr p (hs hp)\u27e9",
          []
        ],
        "state_before": "case intro.intro\nV : Type u_1\nP : Type u_2\ninst\u271d : MetricSpace P\nps\u2081 ps\u2082 : Set P\nhs : ps\u2081 \u2286 ps\u2082\nc : P\nr : \u211d\nhcr : \u2200 p \u2208 ps\u2082, dist p c = r\n\u22a2 Cospherical ps\u2081",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.4421968000242487,
    "entry_failed": false
  },
  "733": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/Zsqrtd/GaussianInt.lean",
    "full_name": "GaussianInt.toComplex_star",
    "start": [
      135,
      1
    ],
    "end": [
      137,
      42
    ],
    "traced_tactics": [
      {
        "tactic": "rw [toComplex_def\u2082, toComplex_def\u2082]",
        "annotated_tactic": [
          "rw [<a>toComplex_def\u2082</a>, <a>toComplex_def\u2082</a>]",
          [
            {
              "full_name": "GaussianInt.toComplex_def\u2082",
              "def_path": "Mathlib/NumberTheory/Zsqrtd/GaussianInt.lean",
              "def_pos": [
                84,
                9
              ],
              "def_end_pos": [
                84,
                23
              ]
            },
            {
              "full_name": "GaussianInt.toComplex_def\u2082",
              "def_path": "Mathlib/NumberTheory/Zsqrtd/GaussianInt.lean",
              "def_pos": [
                84,
                9
              ],
              "def_end_pos": [
                84,
                23
              ]
            }
          ]
        ],
        "state_before": "x : \u2124[i]\n\u22a2 toComplex (star x) = (starRingEnd \u2102) (toComplex x)",
        "state_after": "x : \u2124[i]\n\u22a2 { re := \u2191(star x).re, im := \u2191(star x).im } = (starRingEnd \u2102) { re := \u2191x.re, im := \u2191x.im }"
      },
      {
        "tactic": "exact congr_arg\u2082 _ rfl (Int.cast_neg _)",
        "annotated_tactic": [
          "exact <a>congr_arg\u2082</a> _ <a>rfl</a> (<a>Int.cast_neg</a> _)",
          [
            {
              "full_name": "congr_arg\u2082",
              "def_path": ".lake/packages/batteries/Batteries/Logic.lean",
              "def_pos": [
                77,
                7
              ],
              "def_end_pos": [
                77,
                17
              ]
            },
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            },
            {
              "full_name": "Int.cast_neg",
              "def_path": "Mathlib/Data/Int/Cast/Basic.lean",
              "def_pos": [
                85,
                9
              ],
              "def_end_pos": [
                85,
                17
              ]
            }
          ]
        ],
        "state_before": "x : \u2124[i]\n\u22a2 { re := \u2191(star x).re, im := \u2191(star x).im } = (starRingEnd \u2102) { re := \u2191x.re, im := \u2191x.im }",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.160446990048513,
    "entry_failed": false
  },
  "25551": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/GroupWithZero/Canonical.lean",
    "full_name": "OrderIso.mulRight\u2080'_symm",
    "start": [
      277,
      1
    ],
    "end": [
      280,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : LinearOrderedCommGroupWithZero \u03b1\na\u271d b c d : \u03b1\nm n : \u2115\na : \u03b1\nha : a \u2260 0\n\u22a2 (mulRight\u2080' ha).symm = mulRight\u2080' \u22ef",
        "state_after": "case h.h\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedCommGroupWithZero \u03b1\na\u271d b c d : \u03b1\nm n : \u2115\na : \u03b1\nha : a \u2260 0\nx\u271d : \u03b1\n\u22a2 (mulRight\u2080' ha).symm x\u271d = (mulRight\u2080' \u22ef) x\u271d"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case h.h\n\u03b1 : Type u_1\ninst\u271d : LinearOrderedCommGroupWithZero \u03b1\na\u271d b c d : \u03b1\nm n : \u2115\na : \u03b1\nha : a \u2260 0\nx\u271d : \u03b1\n\u22a2 (mulRight\u2080' ha).symm x\u271d = (mulRight\u2080' \u22ef) x\u271d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.9678448560880497,
    "entry_failed": false
  },
  "26596": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Multiset/FinsetOps.lean",
    "full_name": "Multiset.ndinter_eq_zero_iff_disjoint",
    "start": [
      279,
      1
    ],
    "end": [
      280,
      50
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 subset_zero]",
        "annotated_tactic": [
          "rw [\u2190 <a>subset_zero</a>]",
          [
            {
              "full_name": "Multiset.subset_zero",
              "def_path": "Mathlib/Data/Multiset/Basic.lean",
              "def_pos": [
                449,
                15
              ],
              "def_end_pos": [
                449,
                26
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns\u271d s t : Multiset \u03b1\n\u22a2 s.ndinter t = 0 \u2194 s.Disjoint t",
        "state_after": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns\u271d s t : Multiset \u03b1\n\u22a2 s.ndinter t \u2286 0 \u2194 s.Disjoint t"
      },
      {
        "tactic": "simp [subset_iff, Disjoint]",
        "annotated_tactic": [
          "simp [<a>subset_iff</a>, <a>Disjoint</a>]",
          [
            {
              "full_name": "Multiset.subset_iff",
              "def_path": "Mathlib/Data/Multiset/Basic.lean",
              "def_pos": [
                417,
                9
              ],
              "def_end_pos": [
                417,
                19
              ]
            },
            {
              "full_name": "Multiset.Disjoint",
              "def_path": "Mathlib/Data/Multiset/Basic.lean",
              "def_pos": [
                3002,
                5
              ],
              "def_end_pos": [
                3002,
                13
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns\u271d s t : Multiset \u03b1\n\u22a2 s.ndinter t \u2286 0 \u2194 s.Disjoint t",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.283799577038735,
    "entry_failed": false
  },
  "7243": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Logic/Small/Group.lean",
    "full_name": "equivShrink_symm_neg",
    "start": [
      96,
      1
    ],
    "end": [
      100,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "rw [Equiv.neg_def]",
        "annotated_tactic": [
          "rw [<a>Equiv.neg_def</a>]",
          [
            {
              "full_name": "Equiv.neg_def",
              "def_path": "Mathlib/Logic/Equiv/TransferInstance.lean",
              "def_pos": [
                110,
                3
              ],
              "def_end_pos": [
                110,
                14
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Neg \u03b1\ninst\u271d : Small.{u_2, u_1} \u03b1\nx : Shrink.{u_2, u_1} \u03b1\n\u22a2 (equivShrink \u03b1).symm (-x) = -(equivShrink \u03b1).symm x",
        "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Neg \u03b1\ninst\u271d : Small.{u_2, u_1} \u03b1\nx : Shrink.{u_2, u_1} \u03b1\n\u22a2 (equivShrink \u03b1).symm ((equivShrink \u03b1).symm.symm (-(equivShrink \u03b1).symm x)) = -(equivShrink \u03b1).symm x"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Neg \u03b1\ninst\u271d : Small.{u_2, u_1} \u03b1\nx : Shrink.{u_2, u_1} \u03b1\n\u22a2 (equivShrink \u03b1).symm ((equivShrink \u03b1).symm.symm (-(equivShrink \u03b1).symm x)) = -(equivShrink \u03b1).symm x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.9354294650256634,
    "entry_failed": false
  },
  "11412": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/MetricSpace/Infsep.lean",
    "full_name": "Set.infsep_zero_iff_subsingleton_of_finite",
    "start": [
      532,
      1
    ],
    "end": [
      534,
      52
    ],
    "traced_tactics": [
      {
        "tactic": "rw [infsep_zero, einfsep_eq_top_iff, or_iff_right_iff_imp]",
        "annotated_tactic": [
          "rw [<a>infsep_zero</a>, <a>einfsep_eq_top_iff</a>, <a>or_iff_right_iff_imp</a>]",
          [
            {
              "full_name": "Set.infsep_zero",
              "def_path": "Mathlib/Topology/MetricSpace/Infsep.lean",
              "def_pos": [
                332,
                9
              ],
              "def_end_pos": [
                332,
                20
              ]
            },
            {
              "full_name": "Set.einfsep_eq_top_iff",
              "def_path": "Mathlib/Topology/MetricSpace/Infsep.lean",
              "def_pos": [
                253,
                9
              ],
              "def_end_pos": [
                253,
                27
              ]
            },
            {
              "full_name": "or_iff_right_iff_imp",
              "def_path": ".lake/packages/lean4/src/lean/Init/SimpLemmas.lean",
              "def_pos": [
                188,
                17
              ],
              "def_end_pos": [
                188,
                37
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : MetricSpace \u03b1\ns : Set \u03b1\ninst\u271d : Finite \u2191s\n\u22a2 s.infsep = 0 \u2194 s.Subsingleton",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : MetricSpace \u03b1\ns : Set \u03b1\ninst\u271d : Finite \u2191s\n\u22a2 s.einfsep = 0 \u2192 s.Subsingleton"
      },
      {
        "tactic": "exact fun H => (einfsep_pos_of_finite.ne' H).elim",
        "annotated_tactic": [
          "exact fun H => (einfsep_pos_of_finite.ne' H).<a>elim</a>",
          [
            {
              "full_name": "False.elim",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                236,
                21
              ],
              "def_end_pos": [
                236,
                31
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : MetricSpace \u03b1\ns : Set \u03b1\ninst\u271d : Finite \u2191s\n\u22a2 s.einfsep = 0 \u2192 s.Subsingleton",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.622706964961253,
    "entry_failed": false
  },
  "1774": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Interval/Finset/Basic.lean",
    "full_name": "Finset.Ioc_subset_Ioo_right",
    "start": [
      225,
      1
    ],
    "end": [
      227,
      35
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 coe_subset, coe_Ioc, coe_Ioo]",
        "annotated_tactic": [
          "rw [\u2190 <a>coe_subset</a>, <a>coe_Ioc</a>, <a>coe_Ioo</a>]",
          [
            {
              "full_name": "Finset.coe_subset",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                376,
                9
              ],
              "def_end_pos": [
                376,
                19
              ]
            },
            {
              "full_name": "Finset.coe_Ioc",
              "def_path": "Mathlib/Order/Interval/Finset/Defs.lean",
              "def_pos": [
                343,
                9
              ],
              "def_end_pos": [
                343,
                16
              ]
            },
            {
              "full_name": "Finset.coe_Ioo",
              "def_path": "Mathlib/Order/Interval/Finset/Defs.lean",
              "def_pos": [
                348,
                9
              ],
              "def_end_pos": [
                348,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1\nh : b\u2081 < b\u2082\n\u22a2 Ioc a b\u2081 \u2286 Ioo a b\u2082",
        "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1\nh : b\u2081 < b\u2082\n\u22a2 Set.Ioc a b\u2081 \u2286 Set.Ioo a b\u2082"
      },
      {
        "tactic": "exact Set.Ioc_subset_Ioo_right h",
        "annotated_tactic": [
          "exact <a>Set.Ioc_subset_Ioo_right</a> h",
          [
            {
              "full_name": "Set.Ioc_subset_Ioo_right",
              "def_path": "Mathlib/Order/Interval/Set/Basic.lean",
              "def_pos": [
                512,
                9
              ],
              "def_end_pos": [
                512,
                29
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1\nh : b\u2081 < b\u2082\n\u22a2 Set.Ioc a b\u2081 \u2286 Set.Ioo a b\u2082",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.8255724639166147,
    "entry_failed": false
  },
  "20523": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/ModelTheory/Definability.lean",
    "full_name": "Set.Definable.mono",
    "start": [
      86,
      1
    ],
    "end": [
      88,
      71
    ],
    "traced_tactics": [
      {
        "tactic": "rw [definable_iff_empty_definable_with_params] at *",
        "annotated_tactic": [
          "rw [<a>definable_iff_empty_definable_with_params</a>] at *",
          [
            {
              "full_name": "Set.definable_iff_empty_definable_with_params",
              "def_path": "Mathlib/ModelTheory/Definability.lean",
              "def_pos": [
                81,
                9
              ],
              "def_end_pos": [
                81,
                50
              ]
            }
          ]
        ],
        "state_before": "M : Type w\nA : Set M\nL : Language\ninst\u271d : L.Structure M\n\u03b1 : Type u\u2081\n\u03b2 : Type u_1\nB : Set M\ns : Set (\u03b1 \u2192 M)\nhAs : A.Definable L s\nhAB : A \u2286 B\n\u22a2 B.Definable L s",
        "state_after": "M : Type w\nA : Set M\nL : Language\ninst\u271d : L.Structure M\n\u03b1 : Type u\u2081\n\u03b2 : Type u_1\nB : Set M\ns : Set (\u03b1 \u2192 M)\nhAs : \u2205.Definable (L[[\u2191A]]) s\nhAB : A \u2286 B\n\u22a2 \u2205.Definable (L[[\u2191B]]) s"
      },
      {
        "tactic": "exact hAs.map_expansion (L.lhomWithConstantsMap (Set.inclusion hAB))",
        "annotated_tactic": [
          "exact hAs.map_expansion (L.lhomWithConstantsMap (<a>Set.inclusion</a> hAB))",
          [
            {
              "full_name": "Set.inclusion",
              "def_path": "Mathlib/Data/Set/Basic.lean",
              "def_pos": [
                2438,
                5
              ],
              "def_end_pos": [
                2438,
                14
              ]
            }
          ]
        ],
        "state_before": "M : Type w\nA : Set M\nL : Language\ninst\u271d : L.Structure M\n\u03b1 : Type u\u2081\n\u03b2 : Type u_1\nB : Set M\ns : Set (\u03b1 \u2192 M)\nhAs : \u2205.Definable (L[[\u2191A]]) s\nhAB : A \u2286 B\n\u22a2 \u2205.Definable (L[[\u2191B]]) s",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.621591690927744,
    "entry_failed": false
  },
  "22228": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Polynomial/Degree/Lemmas.lean",
    "full_name": "Polynomial.natDegree_sub_le_iff_left",
    "start": [
      331,
      1
    ],
    "end": [
      334,
      56
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 natDegree_neg] at qn",
        "annotated_tactic": [
          "rw [\u2190 <a>natDegree_neg</a>] at qn",
          [
            {
              "full_name": "Polynomial.natDegree_neg",
              "def_path": "Mathlib/Algebra/Polynomial/Degree/Definitions.lean",
              "def_pos": [
                549,
                9
              ],
              "def_end_pos": [
                549,
                22
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\n\u03b9 : Type w\na b : R\nm n : \u2115\ninst\u271d : Ring R\np q : R[X]\nqn : q.natDegree \u2264 n\n\u22a2 (p - q).natDegree \u2264 n \u2194 p.natDegree \u2264 n",
        "state_after": "R : Type u\nS : Type v\n\u03b9 : Type w\na b : R\nm n : \u2115\ninst\u271d : Ring R\np q : R[X]\nqn : (-q).natDegree \u2264 n\n\u22a2 (p - q).natDegree \u2264 n \u2194 p.natDegree \u2264 n"
      },
      {
        "tactic": "rw [sub_eq_add_neg, natDegree_add_le_iff_left _ _ qn]",
        "annotated_tactic": [
          "rw [<a>sub_eq_add_neg</a>, <a>natDegree_add_le_iff_left</a> _ _ qn]",
          [
            {
              "full_name": "sub_eq_add_neg",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                1057,
                3
              ],
              "def_end_pos": [
                1057,
                14
              ]
            },
            {
              "full_name": "Polynomial.natDegree_add_le_iff_left",
              "def_path": "Mathlib/Algebra/Polynomial/Degree/Lemmas.lean",
              "def_pos": [
                76,
                9
              ],
              "def_end_pos": [
                76,
                34
              ]
            }
          ]
        ],
        "state_before": "R : Type u\nS : Type v\n\u03b9 : Type w\na b : R\nm n : \u2115\ninst\u271d : Ring R\np q : R[X]\nqn : (-q).natDegree \u2264 n\n\u22a2 (p - q).natDegree \u2264 n \u2194 p.natDegree \u2264 n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.196289283921942,
    "entry_failed": false
  },
  "15710": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Group/Semiconj/Defs.lean",
    "full_name": "SemiconjBy.mul_right",
    "start": [
      62,
      1
    ],
    "end": [
      66,
      56
    ],
    "traced_tactics": [
      {
        "tactic": "unfold SemiconjBy",
        "annotated_tactic": [
          "unfold <a>SemiconjBy</a>",
          [
            {
              "full_name": "SemiconjBy",
              "def_path": "Mathlib/Algebra/Group/Semiconj/Defs.lean",
              "def_pos": [
                40,
                5
              ],
              "def_end_pos": [
                40,
                15
              ]
            }
          ]
        ],
        "state_before": "S : Type u_1\nM : Type u_2\nG : Type u_3\ninst\u271d : Semigroup S\na b x y z x' y' : S\nh : SemiconjBy a x y\nh' : SemiconjBy a x' y'\n\u22a2 SemiconjBy a (x * x') (y * y')",
        "state_after": "S : Type u_1\nM : Type u_2\nG : Type u_3\ninst\u271d : Semigroup S\na b x y z x' y' : S\nh : SemiconjBy a x y\nh' : SemiconjBy a x' y'\n\u22a2 a * (x * x') = y * y' * a"
      },
      {
        "tactic": "rw [\u2190 mul_assoc, h.eq, mul_assoc, h'.eq, \u2190 mul_assoc]",
        "annotated_tactic": [
          "rw [\u2190 <a>mul_assoc</a>, h.eq, <a>mul_assoc</a>, h'.eq, \u2190 <a>mul_assoc</a>]",
          [
            {
              "full_name": "mul_assoc",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                289,
                9
              ],
              "def_end_pos": [
                289,
                18
              ]
            },
            {
              "full_name": "mul_assoc",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                289,
                9
              ],
              "def_end_pos": [
                289,
                18
              ]
            },
            {
              "full_name": "mul_assoc",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                289,
                9
              ],
              "def_end_pos": [
                289,
                18
              ]
            }
          ]
        ],
        "state_before": "S : Type u_1\nM : Type u_2\nG : Type u_3\ninst\u271d : Semigroup S\na b x y z x' y' : S\nh : SemiconjBy a x y\nh' : SemiconjBy a x' y'\n\u22a2 a * (x * x') = y * y' * a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 0.8003093029838055,
    "entry_failed": false
  },
  "732": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/MetricSpace/Lipschitz.lean",
    "full_name": "LipschitzWith.dist",
    "start": [
      170,
      11
    ],
    "end": [
      172,
      79
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 one_add_one_eq_two]",
        "annotated_tactic": [
          "rw [\u2190 <a>one_add_one_eq_two</a>]",
          [
            {
              "full_name": "one_add_one_eq_two",
              "def_path": "Mathlib/Data/Nat/Cast/Defs.lean",
              "def_pos": [
                231,
                9
              ],
              "def_end_pos": [
                231,
                27
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\ninst\u271d\u00b9 : PseudoMetricSpace \u03b2\ninst\u271d : PseudoMetricSpace \u03b3\nK : \u211d\u22650\nf : \u03b1 \u2192 \u03b2\nx y : \u03b1\nr : \u211d\n\u22a2 LipschitzWith 2 (uncurry dist)",
        "state_after": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\ninst\u271d\u00b9 : PseudoMetricSpace \u03b2\ninst\u271d : PseudoMetricSpace \u03b3\nK : \u211d\u22650\nf : \u03b1 \u2192 \u03b2\nx y : \u03b1\nr : \u211d\n\u22a2 LipschitzWith (1 + 1) (uncurry dist)"
      },
      {
        "tactic": "exact LipschitzWith.uncurry LipschitzWith.dist_left LipschitzWith.dist_right",
        "annotated_tactic": [
          "exact <a>LipschitzWith.uncurry</a> <a>LipschitzWith.dist_left</a> <a>LipschitzWith.dist_right</a>",
          [
            {
              "full_name": "LipschitzWith.uncurry",
              "def_path": "Mathlib/Topology/EMetricSpace/Lipschitz.lean",
              "def_pos": [
                252,
                19
              ],
              "def_end_pos": [
                252,
                26
              ]
            },
            {
              "full_name": "LipschitzWith.dist_left",
              "def_path": "Mathlib/Topology/MetricSpace/Lipschitz.lean",
              "def_pos": [
                162,
                19
              ],
              "def_end_pos": [
                162,
                28
              ]
            },
            {
              "full_name": "LipschitzWith.dist_right",
              "def_path": "Mathlib/Topology/MetricSpace/Lipschitz.lean",
              "def_pos": [
                166,
                19
              ],
              "def_end_pos": [
                166,
                29
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\n\u03b9 : Type x\ninst\u271d\u00b2 : PseudoMetricSpace \u03b1\ninst\u271d\u00b9 : PseudoMetricSpace \u03b2\ninst\u271d : PseudoMetricSpace \u03b3\nK : \u211d\u22650\nf : \u03b1 \u2192 \u03b2\nx y : \u03b1\nr : \u211d\n\u22a2 LipschitzWith (1 + 1) (uncurry dist)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.457961748004891,
    "entry_failed": false
  },
  "15733": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Interval/Set/OrdConnected.lean",
    "full_name": "Set.ordConnected_range",
    "start": [
      265,
      1
    ],
    "end": [
      268,
      40
    ],
    "traced_tactics": [
      {
        "tactic": "simp_rw [\u2190 image_univ]",
        "annotated_tactic": [
          "simp_rw [\u2190 <a>image_univ</a>]",
          [
            {
              "full_name": "Set.image_univ",
              "def_path": "Mathlib/Data/Set/Image.lean",
              "def_pos": [
                701,
                9
              ],
              "def_end_pos": [
                701,
                19
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ns t : Set \u03b1\nE : Type u_3\ninst\u271d\u00b9 : EquivLike E \u03b1 \u03b2\ninst\u271d : OrderIsoClass E \u03b1 \u03b2\ne : E\n\u22a2 (range \u21d1e).OrdConnected",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ns t : Set \u03b1\nE : Type u_3\ninst\u271d\u00b9 : EquivLike E \u03b1 \u03b2\ninst\u271d : OrderIsoClass E \u03b1 \u03b2\ne : E\n\u22a2 (\u21d1e '' univ).OrdConnected"
      },
      {
        "tactic": "exact ordConnected_image (e : \u03b1 \u2243o \u03b2)",
        "annotated_tactic": [
          "exact <a>ordConnected_image</a> (e : \u03b1 \u2243o \u03b2)",
          [
            {
              "full_name": "Set.ordConnected_image",
              "def_path": "Mathlib/Order/Interval/Set/OrdConnected.lean",
              "def_pos": [
                257,
                9
              ],
              "def_end_pos": [
                257,
                27
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ns t : Set \u03b1\nE : Type u_3\ninst\u271d\u00b9 : EquivLike E \u03b1 \u03b2\ninst\u271d : OrderIsoClass E \u03b1 \u03b2\ne : E\n\u22a2 (\u21d1e '' univ).OrdConnected",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8213154620025307,
    "entry_failed": false
  },
  "2778": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/ModularForms/JacobiTheta/OneVariable.lean",
    "full_name": "differentiableAt_jacobiTheta",
    "start": [
      135,
      1
    ],
    "end": [
      138,
      47
    ],
    "traced_tactics": [
      {
        "tactic": "simp_rw [funext jacobiTheta_eq_jacobiTheta\u2082]",
        "annotated_tactic": [
          "simp_rw [<a>funext</a> <a>jacobiTheta_eq_jacobiTheta\u2082</a>]",
          [
            {
              "full_name": "funext",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                1817,
                9
              ],
              "def_end_pos": [
                1817,
                15
              ]
            },
            {
              "full_name": "jacobiTheta_eq_jacobiTheta\u2082",
              "def_path": "Mathlib/NumberTheory/ModularForms/JacobiTheta/OneVariable.lean",
              "def_pos": [
                30,
                7
              ],
              "def_end_pos": [
                30,
                34
              ]
            }
          ]
        ],
        "state_before": "\u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\n\u22a2 DifferentiableAt \u2102 jacobiTheta \u03c4",
        "state_after": "\u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\n\u22a2 DifferentiableAt \u2102 (jacobiTheta\u2082 0) \u03c4"
      },
      {
        "tactic": "exact differentiableAt_jacobiTheta\u2082_snd 0 h\u03c4",
        "annotated_tactic": [
          "exact <a>differentiableAt_jacobiTheta\u2082_snd</a> 0 h\u03c4",
          [
            {
              "full_name": "differentiableAt_jacobiTheta\u2082_snd",
              "def_path": "Mathlib/NumberTheory/ModularForms/JacobiTheta/TwoVariable.lean",
              "def_pos": [
                331,
                7
              ],
              "def_end_pos": [
                331,
                40
              ]
            }
          ]
        ],
        "state_before": "\u03c4 : \u2102\nh\u03c4 : 0 < \u03c4.im\n\u22a2 DifferentiableAt \u2102 (jacobiTheta\u2082 0) \u03c4",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.310514164972119,
    "entry_failed": false
  },
  "9402": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Polynomial/Smeval.lean",
    "full_name": "Polynomial.smeval_one",
    "start": [
      83,
      1
    ],
    "end": [
      85,
      37
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 C_1, smeval_C]",
        "annotated_tactic": [
          "rw [\u2190 <a>C_1</a>, <a>smeval_C</a>]",
          [
            {
              "full_name": "Polynomial.C_1",
              "def_path": "Mathlib/Algebra/Polynomial/Basic.lean",
              "def_pos": [
                521,
                9
              ],
              "def_end_pos": [
                521,
                12
              ]
            },
            {
              "full_name": "Polynomial.smeval_C",
              "def_path": "Mathlib/Algebra/Polynomial/Smeval.lean",
              "def_pos": [
                57,
                9
              ],
              "def_end_pos": [
                57,
                17
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d\u00b3 : Semiring R\nr : R\np : R[X]\nS : Type u_2\ninst\u271d\u00b2 : AddCommMonoid S\ninst\u271d\u00b9 : Pow S \u2115\ninst\u271d : MulActionWithZero R S\nx : S\n\u22a2 smeval 1 x = 1 \u2022 x ^ 0",
        "state_after": "R : Type u_1\ninst\u271d\u00b3 : Semiring R\nr : R\np : R[X]\nS : Type u_2\ninst\u271d\u00b2 : AddCommMonoid S\ninst\u271d\u00b9 : Pow S \u2115\ninst\u271d : MulActionWithZero R S\nx : S\n\u22a2 1 \u2022 x ^ 0 = 1 \u2022 x ^ 0"
      },
      {
        "tactic": "simp only [Nat.cast_one, one_smul]",
        "annotated_tactic": [
          "simp only [<a>Nat.cast_one</a>, <a>one_smul</a>]",
          [
            {
              "full_name": "Nat.cast_one",
              "def_path": "Mathlib/Data/Nat/Cast/Defs.lean",
              "def_pos": [
                154,
                9
              ],
              "def_end_pos": [
                154,
                17
              ]
            },
            {
              "full_name": "one_smul",
              "def_path": "Mathlib/Algebra/Group/Action/Defs.lean",
              "def_pos": [
                453,
                7
              ],
              "def_end_pos": [
                453,
                15
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d\u00b3 : Semiring R\nr : R\np : R[X]\nS : Type u_2\ninst\u271d\u00b2 : AddCommMonoid S\ninst\u271d\u00b9 : Pow S \u2115\ninst\u271d : MulActionWithZero R S\nx : S\n\u22a2 1 \u2022 x ^ 0 = 1 \u2022 x ^ 0",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.0427482929080725,
    "entry_failed": false
  },
  "17747": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Interval/Multiset.lean",
    "full_name": "Multiset.Ico_filter_le_left",
    "start": [
      310,
      1
    ],
    "end": [
      313,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "rw [Ico, \u2190 Finset.filter_val, Finset.Ico_filter_le_left hab]",
        "annotated_tactic": [
          "rw [<a>Ico</a>, \u2190 <a>Finset.filter_val</a>, <a>Finset.Ico_filter_le_left</a> hab]",
          [
            {
              "full_name": "Multiset.Ico",
              "def_path": "Mathlib/Order/Interval/Multiset.lean",
              "def_pos": [
                51,
                5
              ],
              "def_end_pos": [
                51,
                8
              ]
            },
            {
              "full_name": "Finset.filter_val",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                2581,
                9
              ],
              "def_end_pos": [
                2581,
                19
              ]
            },
            {
              "full_name": "Finset.Ico_filter_le_left",
              "def_path": "Mathlib/Order/Interval/Finset/Basic.lean",
              "def_pos": [
                644,
                9
              ],
              "def_end_pos": [
                644,
                27
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\na\u271d b\u271d a b : \u03b1\ninst\u271d : DecidablePred fun x => x \u2264 a\nhab : a < b\n\u22a2 filter (fun x => x \u2264 a) (Ico a b) = {a}",
        "state_after": "\u03b1 : Type u_1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\na\u271d b\u271d a b : \u03b1\ninst\u271d : DecidablePred fun x => x \u2264 a\nhab : a < b\n\u22a2 {a}.val = {a}"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\na\u271d b\u271d a b : \u03b1\ninst\u271d : DecidablePred fun x => x \u2264 a\nhab : a < b\n\u22a2 {a}.val = {a}",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8278724229894578,
    "entry_failed": false
  },
  "12362": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Nilpotent/Basic.lean",
    "full_name": "IsNilpotent.isUnit_one_sub",
    "start": [
      64,
      1
    ],
    "end": [
      66,
      28
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 IsUnit.neg_iff, neg_sub]",
        "annotated_tactic": [
          "rw [\u2190 <a>IsUnit.neg_iff</a>, <a>neg_sub</a>]",
          [
            {
              "full_name": "IsUnit.neg_iff",
              "def_path": "Mathlib/Algebra/Ring/Units.lean",
              "def_pos": [
                110,
                9
              ],
              "def_end_pos": [
                110,
                23
              ]
            },
            {
              "full_name": "neg_sub",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                553,
                3
              ],
              "def_end_pos": [
                553,
                14
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\nS : Type u_2\nx y : R\ninst\u271d : Ring R\nr : R\nhnil : IsNilpotent r\n\u22a2 IsUnit (1 - r)",
        "state_after": "R : Type u_1\nS : Type u_2\nx y : R\ninst\u271d : Ring R\nr : R\nhnil : IsNilpotent r\n\u22a2 IsUnit (r - 1)"
      },
      {
        "tactic": "exact isUnit_sub_one hnil",
        "annotated_tactic": [
          "exact <a>isUnit_sub_one</a> hnil",
          [
            {
              "full_name": "IsNilpotent.isUnit_sub_one",
              "def_path": "Mathlib/RingTheory/Nilpotent/Basic.lean",
              "def_pos": [
                58,
                9
              ],
              "def_end_pos": [
                58,
                35
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\nS : Type u_2\nx y : R\ninst\u271d : Ring R\nr : R\nhnil : IsNilpotent r\n\u22a2 IsUnit (r - 1)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.6767975270049646,
    "entry_failed": false
  },
  "26239": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/ModEq.lean",
    "full_name": "Nat.ModEq.add_right_cancel",
    "start": [
      173,
      11
    ],
    "end": [
      176,
      30
    ],
    "traced_tactics": [
      {
        "tactic": "rw [add_comm a, add_comm b] at h\u2082",
        "annotated_tactic": [
          "rw [<a>add_comm</a> a, <a>add_comm</a> b] at h\u2082",
          [
            {
              "full_name": "add_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                331,
                3
              ],
              "def_end_pos": [
                331,
                14
              ]
            },
            {
              "full_name": "add_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                331,
                3
              ],
              "def_end_pos": [
                331,
                14
              ]
            }
          ]
        ],
        "state_before": "m n a b c d : \u2115\nh\u2081 : c \u2261 d [MOD n]\nh\u2082 : a + c \u2261 b + d [MOD n]\n\u22a2 a \u2261 b [MOD n]",
        "state_after": "m n a b c d : \u2115\nh\u2081 : c \u2261 d [MOD n]\nh\u2082 : c + a \u2261 d + b [MOD n]\n\u22a2 a \u2261 b [MOD n]"
      },
      {
        "tactic": "exact h\u2081.add_left_cancel h\u2082",
        "annotated_tactic": [
          "exact h\u2081.add_left_cancel h\u2082",
          []
        ],
        "state_before": "m n a b c d : \u2115\nh\u2081 : c \u2261 d [MOD n]\nh\u2082 : c + a \u2261 d + b [MOD n]\n\u22a2 a \u2261 b [MOD n]",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.8980664809932932,
    "entry_failed": false
  },
  "15252": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Bits.lean",
    "full_name": "Nat.bit0_lt_bit0",
    "start": [
      479,
      1
    ],
    "end": [
      479,
      80
    ],
    "traced_tactics": [
      {
        "tactic": "unfold bit0",
        "annotated_tactic": [
          "unfold <a>bit0</a>",
          [
            {
              "full_name": "bit0",
              "def_path": "Mathlib/Init/ZeroOne.lean",
              "def_pos": [
                37,
                5
              ],
              "def_end_pos": [
                37,
                9
              ]
            }
          ]
        ],
        "state_before": "m n : \u2115\n\u22a2 bit0 m < bit0 n \u2194 m < n",
        "state_after": "m n : \u2115\n\u22a2 m + m < n + n \u2194 m < n"
      },
      {
        "tactic": "omega",
        "annotated_tactic": [
          "omega",
          []
        ],
        "state_before": "m n : \u2115\n\u22a2 m + m < n + n \u2194 m < n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.2161494790343568,
    "entry_failed": false
  },
  "7625": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Sym/Basic.lean",
    "full_name": "Sym.eq_replicate_iff",
    "start": [
      302,
      1
    ],
    "end": [
      304,
      26
    ],
    "traced_tactics": [
      {
        "tactic": "erw [Subtype.ext_iff, Multiset.eq_replicate]",
        "annotated_tactic": [
          "erw [<a>Subtype.ext_iff</a>, <a>Multiset.eq_replicate</a>]",
          [
            {
              "full_name": "Subtype.ext_iff",
              "def_path": "Mathlib/Data/Subtype.lean",
              "def_pos": [
                78,
                9
              ],
              "def_end_pos": [
                78,
                16
              ]
            },
            {
              "full_name": "Multiset.eq_replicate",
              "def_path": "Mathlib/Data/Multiset/Basic.lean",
              "def_pos": [
                977,
                9
              ],
              "def_end_pos": [
                977,
                21
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn n' m : \u2115\ns : Sym \u03b1 n\na b : \u03b1\n\u22a2 s = replicate n a \u2194 \u2200 b \u2208 s, b = a",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn n' m : \u2115\ns : Sym \u03b1 n\na b : \u03b1\n\u22a2 (Multiset.card \u2191s = n \u2227 \u2200 b \u2208 \u2191s, b = a) \u2194 \u2200 b \u2208 s, b = a"
      },
      {
        "tactic": "exact and_iff_right s.2",
        "annotated_tactic": [
          "exact <a>and_iff_right</a> s.2",
          [
            {
              "full_name": "and_iff_right",
              "def_path": ".lake/packages/lean4/src/lean/Init/PropLemmas.lean",
              "def_pos": [
                70,
                9
              ],
              "def_end_pos": [
                70,
                22
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn n' m : \u2115\ns : Sym \u03b1 n\na b : \u03b1\n\u22a2 (Multiset.card \u2191s = n \u2227 \u2200 b \u2208 \u2191s, b = a) \u2194 \u2200 b \u2208 s, b = a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.413212914019823,
    "entry_failed": false
  },
  "4792": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/SmoothNumbers.lean",
    "full_name": "Nat.mem_smoothNumbers_of_dvd",
    "start": [
      291,
      1
    ],
    "end": [
      295,
      40
    ],
    "traced_tactics": [
      {
        "tactic": "simp only [smoothNumbers_eq_factoredNumbers] at h \u22a2",
        "annotated_tactic": [
          "simp only [<a>smoothNumbers_eq_factoredNumbers</a>] at h \u22a2",
          [
            {
              "full_name": "Nat.smoothNumbers_eq_factoredNumbers",
              "def_path": "Mathlib/NumberTheory/SmoothNumbers.lean",
              "def_pos": [
                275,
                7
              ],
              "def_end_pos": [
                275,
                39
              ]
            }
          ]
        ],
        "state_before": "n m k : \u2115\nh : m \u2208 n.smoothNumbers\nh' : k \u2223 m\n\u22a2 k \u2208 n.smoothNumbers",
        "state_after": "n m k : \u2115\nh' : k \u2223 m\nh : m \u2208 factoredNumbers (Finset.range n)\n\u22a2 k \u2208 factoredNumbers (Finset.range n)"
      },
      {
        "tactic": "exact mem_factoredNumbers_of_dvd h h'",
        "annotated_tactic": [
          "exact <a>mem_factoredNumbers_of_dvd</a> h h'",
          [
            {
              "full_name": "Nat.mem_factoredNumbers_of_dvd",
              "def_path": "Mathlib/NumberTheory/SmoothNumbers.lean",
              "def_pos": [
                76,
                7
              ],
              "def_end_pos": [
                76,
                33
              ]
            }
          ]
        ],
        "state_before": "n m k : \u2115\nh' : k \u2223 m\nh : m \u2208 factoredNumbers (Finset.range n)\n\u22a2 k \u2208 factoredNumbers (Finset.range n)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.5733164299745113,
    "entry_failed": false
  },
  "9919": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Computability/Halting.lean",
    "full_name": "ComputablePred.computable_iff_re_compl_re'",
    "start": [
      269,
      1
    ],
    "end": [
      271,
      45
    ],
    "traced_tactics": [
      {
        "tactic": "classical exact computable_iff_re_compl_re",
        "annotated_tactic": [
          "classical exact <a>computable_iff_re_compl_re</a>",
          [
            {
              "full_name": "ComputablePred.computable_iff_re_compl_re",
              "def_path": "Mathlib/Computability/Halting.lean",
              "def_pos": [
                251,
                9
              ],
              "def_end_pos": [
                251,
                35
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03c3 : Type u_2\ninst\u271d\u00b9 : Primcodable \u03b1\ninst\u271d : Primcodable \u03c3\np : \u03b1 \u2192 Prop\n\u22a2 ComputablePred p \u2194 RePred p \u2227 RePred fun a => \u00acp a",
        "state_after": "no goals"
      },
      {
        "tactic": "exact computable_iff_re_compl_re",
        "annotated_tactic": [
          "exact <a>computable_iff_re_compl_re</a>",
          [
            {
              "full_name": "ComputablePred.computable_iff_re_compl_re",
              "def_path": "Mathlib/Computability/Halting.lean",
              "def_pos": [
                251,
                9
              ],
              "def_end_pos": [
                251,
                35
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03c3 : Type u_2\ninst\u271d\u00b9 : Primcodable \u03b1\ninst\u271d : Primcodable \u03c3\np : \u03b1 \u2192 Prop\n\u22a2 ComputablePred p \u2194 RePred p \u2227 RePred fun a => \u00acp a",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.4419507189886644,
    "entry_failed": false
  },
  "462": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Interval/Finset/Basic.lean",
    "full_name": "Finset.Ico_subset_Ioo_left",
    "start": [
      220,
      1
    ],
    "end": [
      222,
      34
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 coe_subset, coe_Ico, coe_Ioo]",
        "annotated_tactic": [
          "rw [\u2190 <a>coe_subset</a>, <a>coe_Ico</a>, <a>coe_Ioo</a>]",
          [
            {
              "full_name": "Finset.coe_subset",
              "def_path": "Mathlib/Data/Finset/Basic.lean",
              "def_pos": [
                376,
                9
              ],
              "def_end_pos": [
                376,
                19
              ]
            },
            {
              "full_name": "Finset.coe_Ico",
              "def_path": "Mathlib/Order/Interval/Finset/Defs.lean",
              "def_pos": [
                338,
                9
              ],
              "def_end_pos": [
                338,
                16
              ]
            },
            {
              "full_name": "Finset.coe_Ioo",
              "def_path": "Mathlib/Order/Interval/Finset/Defs.lean",
              "def_pos": [
                348,
                9
              ],
              "def_end_pos": [
                348,
                16
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1\nh : a\u2081 < a\u2082\n\u22a2 Ico a\u2082 b \u2286 Ioo a\u2081 b",
        "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1\nh : a\u2081 < a\u2082\n\u22a2 Set.Ico a\u2082 b \u2286 Set.Ioo a\u2081 b"
      },
      {
        "tactic": "exact Set.Ico_subset_Ioo_left h",
        "annotated_tactic": [
          "exact <a>Set.Ico_subset_Ioo_left</a> h",
          [
            {
              "full_name": "Set.Ico_subset_Ioo_left",
              "def_path": "Mathlib/Order/Interval/Set/Basic.lean",
              "def_pos": [
                508,
                9
              ],
              "def_end_pos": [
                508,
                28
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b1\na a\u2081 a\u2082 b b\u2081 b\u2082 c x : \u03b1\nh : a\u2081 < a\u2082\n\u22a2 Set.Ico a\u2082 b \u2286 Set.Ioo a\u2081 b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.9849704189691693,
    "entry_failed": false
  },
  "7374": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": ".lake/packages/batteries/Batteries/Data/List/Init/Attach.lean",
    "full_name": "List.pmap_eq_pmapImpl",
    "start": [
      38,
      18
    ],
    "end": [
      44,
      16
    ],
    "traced_tactics": [
      {
        "tactic": "funext \u03b1 \u03b2 p f L h'",
        "annotated_tactic": [
          "funext \u03b1 \u03b2 p f L h'",
          []
        ],
        "state_before": "\u22a2 @pmap = @List.pmapImpl",
        "state_after": "case h.h.h.h.h.h\n\u03b1 : Type u_2\n\u03b2 : Type u_1\np : \u03b1 \u2192 Prop\nf : (a : \u03b1) \u2192 p a \u2192 \u03b2\nL : List \u03b1\nh' : \u2200 (a : \u03b1), a \u2208 L \u2192 p a\n\u22a2 pmap f L h' = List.pmapImpl f L h'"
      },
      {
        "tactic": "exact go L h'",
        "annotated_tactic": [
          "exact go L h'",
          []
        ],
        "state_before": "case h.h.h.h.h.h\n\u03b1 : Type u_2\n\u03b2 : Type u_1\np : \u03b1 \u2192 Prop\nf : (a : \u03b1) \u2192 p a \u2192 \u03b2\nL : List \u03b1\nh' : \u2200 (a : \u03b1), a \u2208 L \u2192 p a\n\u22a2 pmap f L h' = List.pmapImpl f L h'",
        "state_after": "no goals"
      }
    ],
    "entry_time": 0.7059232869651169,
    "entry_failed": false
  },
  "28381": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Log/Deriv.lean",
    "full_name": "HasStrictDerivAt.log",
    "start": [
      111,
      1
    ],
    "end": [
      114,
      44
    ],
    "traced_tactics": [
      {
        "tactic": "rw [div_eq_inv_mul]",
        "annotated_tactic": [
          "rw [<a>div_eq_inv_mul</a>]",
          [
            {
              "full_name": "div_eq_inv_mul",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                736,
                9
              ],
              "def_end_pos": [
                736,
                23
              ]
            }
          ]
        ],
        "state_before": "f : \u211d \u2192 \u211d\nx f' : \u211d\ns : Set \u211d\nhf : HasStrictDerivAt f f' x\nhx : f x \u2260 0\n\u22a2 HasStrictDerivAt (fun y => Real.log (f y)) (f' / f x) x",
        "state_after": "f : \u211d \u2192 \u211d\nx f' : \u211d\ns : Set \u211d\nhf : HasStrictDerivAt f f' x\nhx : f x \u2260 0\n\u22a2 HasStrictDerivAt (fun y => Real.log (f y)) ((f x)\u207b\u00b9 * f') x"
      },
      {
        "tactic": "exact (hasStrictDerivAt_log hx).comp x hf",
        "annotated_tactic": [
          "exact (<a>hasStrictDerivAt_log</a> hx).<a>comp</a> x hf",
          [
            {
              "full_name": "Real.hasStrictDerivAt_log",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Log/Deriv.lean",
              "def_pos": [
                42,
                9
              ],
              "def_end_pos": [
                42,
                29
              ]
            },
            {
              "full_name": "HasStrictDerivAt.comp",
              "def_path": "Mathlib/Analysis/Calculus/Deriv/Comp.lean",
              "def_pos": [
                267,
                9
              ],
              "def_end_pos": [
                267,
                30
              ]
            }
          ]
        ],
        "state_before": "f : \u211d \u2192 \u211d\nx f' : \u211d\ns : Set \u211d\nhf : HasStrictDerivAt f f' x\nhx : f x \u2260 0\n\u22a2 HasStrictDerivAt (fun y => Real.log (f y)) ((f x)\u207b\u00b9 * f') x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.774402681970969,
    "entry_failed": false
  },
  "12435": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Factorization/Basic.lean",
    "full_name": "Nat.factorizationEquiv_apply",
    "start": [
      305,
      1
    ],
    "end": [
      307,
      6
    ],
    "traced_tactics": [
      {
        "tactic": "cases n",
        "annotated_tactic": [
          "cases n",
          []
        ],
        "state_before": "a b m n\u271d p : \u2115\nn : \u2115+\n\u22a2 \u2191(factorizationEquiv n) = (\u2191n).factorization",
        "state_after": "case mk\na b m n p val\u271d : \u2115\nproperty\u271d : 0 < val\u271d\n\u22a2 \u2191(factorizationEquiv \u27e8val\u271d, property\u271d\u27e9) = (\u2191\u27e8val\u271d, property\u271d\u27e9).factorization"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "case mk\na b m n p val\u271d : \u2115\nproperty\u271d : 0 < val\u271d\n\u22a2 \u2191(factorizationEquiv \u27e8val\u271d, property\u271d\u27e9) = (\u2191\u27e8val\u271d, property\u271d\u27e9).factorization",
        "state_after": "no goals"
      }
    ],
    "entry_time": 3.8426697630202398,
    "entry_failed": false
  },
  "6018": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Set.lean",
    "full_name": "Nat.zero_union_range_succ",
    "start": [
      21,
      1
    ],
    "end": [
      23,
      19
    ],
    "traced_tactics": [
      {
        "tactic": "ext n",
        "annotated_tactic": [
          "ext n",
          []
        ],
        "state_before": "\u22a2 {0} \u222a range succ = univ",
        "state_after": "case h\nn : \u2115\n\u22a2 n \u2208 {0} \u222a range succ \u2194 n \u2208 univ"
      },
      {
        "tactic": "cases n <;> simp",
        "annotated_tactic": [
          "cases n <;> simp",
          []
        ],
        "state_before": "case h\nn : \u2115\n\u22a2 n \u2208 {0} \u222a range succ \u2194 n \u2208 univ",
        "state_after": "no goals"
      }
    ],
    "entry_time": 0.9429546809988096,
    "entry_failed": false
  },
  "3786": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/Padics/PadicVal.lean",
    "full_name": "padicValNat_mul_pow_right",
    "start": [
      609,
      1
    ],
    "end": [
      612,
      41
    ],
    "traced_tactics": [
      {
        "tactic": "rw [mul_comm (p^n) (q^m)]",
        "annotated_tactic": [
          "rw [<a>mul_comm</a> (p^n) (q^m)]",
          [
            {
              "full_name": "mul_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                332,
                9
              ],
              "def_end_pos": [
                332,
                17
              ]
            }
          ]
        ],
        "state_before": "p q : \u2115\nhp : Fact (Nat.Prime p)\nhq : Fact (Nat.Prime q)\nn m : \u2115\nneq : q \u2260 p\n\u22a2 padicValNat q (p ^ n * q ^ m) = m",
        "state_after": "p q : \u2115\nhp : Fact (Nat.Prime p)\nhq : Fact (Nat.Prime q)\nn m : \u2115\nneq : q \u2260 p\n\u22a2 padicValNat q (q ^ m * p ^ n) = m"
      },
      {
        "tactic": "exact padicValNat_mul_pow_left m n neq",
        "annotated_tactic": [
          "exact <a>padicValNat_mul_pow_left</a> m n neq",
          [
            {
              "full_name": "padicValNat_mul_pow_left",
              "def_path": "Mathlib/NumberTheory/Padics/PadicVal.lean",
              "def_pos": [
                604,
                9
              ],
              "def_end_pos": [
                604,
                33
              ]
            }
          ]
        ],
        "state_before": "p q : \u2115\nhp : Fact (Nat.Prime p)\nhq : Fact (Nat.Prime q)\nn m : \u2115\nneq : q \u2260 p\n\u22a2 padicValNat q (q ^ m * p ^ n) = m",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.826195124071091,
    "entry_failed": false
  },
  "14141": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/LinearAlgebra/CliffordAlgebra/Equivs.lean",
    "full_name": "CliffordAlgebraRing.involute_eq_id",
    "start": [
      106,
      1
    ],
    "end": [
      107,
      100
    ],
    "traced_tactics": [
      {
        "tactic": "ext",
        "annotated_tactic": [
          "ext",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d : CommRing R\n\u22a2 involute = AlgHom.id R (CliffordAlgebra 0)",
        "state_after": "case a.h\nR : Type u_1\ninst\u271d : CommRing R\nx\u271d : Unit\n\u22a2 (involute.toLinearMap \u2218\u2097 \u03b9 0) x\u271d = ((AlgHom.id R (CliffordAlgebra 0)).toLinearMap \u2218\u2097 \u03b9 0) x\u271d"
      },
      {
        "tactic": "simp",
        "annotated_tactic": [
          "simp",
          []
        ],
        "state_before": "case a.h\nR : Type u_1\ninst\u271d : CommRing R\nx\u271d : Unit\n\u22a2 (involute.toLinearMap \u2218\u2097 \u03b9 0) x\u271d = ((AlgHom.id R (CliffordAlgebra 0)).toLinearMap \u2218\u2097 \u03b9 0) x\u271d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.7441826720023528,
    "entry_failed": false
  },
  "4156": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/InnerProductSpace/TwoDim.lean",
    "full_name": "Orientation.areaForm_neg_orientation",
    "start": [
      126,
      1
    ],
    "end": [
      128,
      32
    ],
    "traced_tactics": [
      {
        "tactic": "ext x y",
        "annotated_tactic": [
          "ext x y",
          []
        ],
        "state_before": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\no : Orientation \u211d E (Fin 2)\n\u22a2 (-o).areaForm = -o.areaForm",
        "state_after": "case h.h\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\no : Orientation \u211d E (Fin 2)\nx y : E\n\u22a2 ((-o).areaForm x) y = ((-o.areaForm) x) y"
      },
      {
        "tactic": "simp [areaForm_to_volumeForm]",
        "annotated_tactic": [
          "simp [<a>areaForm_to_volumeForm</a>]",
          [
            {
              "full_name": "Orientation.areaForm_to_volumeForm",
              "def_path": "Mathlib/Analysis/InnerProductSpace/TwoDim.lean",
              "def_pos": [
                106,
                9
              ],
              "def_end_pos": [
                106,
                31
              ]
            }
          ]
        ],
        "state_before": "case h.h\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\no : Orientation \u211d E (Fin 2)\nx y : E\n\u22a2 ((-o).areaForm x) y = ((-o.areaForm) x) y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.595125621999614,
    "entry_failed": false
  },
  "5050": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/LinearAlgebra/AffineSpace/Slope.lean",
    "full_name": "slope_neg_fun",
    "start": [
      99,
      1
    ],
    "end": [
      100,
      33
    ],
    "traced_tactics": [
      {
        "tactic": "ext x y",
        "annotated_tactic": [
          "ext x y",
          []
        ],
        "state_before": "k : Type u_1\nE : Type u_2\nPE : Type u_3\ninst\u271d\u00b3 : Field k\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module k E\ninst\u271d : AddTorsor E PE\nf : k \u2192 E\n\u22a2 slope (-f) = -slope f",
        "state_after": "case h.h\nk : Type u_1\nE : Type u_2\nPE : Type u_3\ninst\u271d\u00b3 : Field k\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module k E\ninst\u271d : AddTorsor E PE\nf : k \u2192 E\nx y : k\n\u22a2 slope (-f) x y = (-slope f) x y"
      },
      {
        "tactic": "exact slope_neg f x y",
        "annotated_tactic": [
          "exact <a>slope_neg</a> f x y",
          [
            {
              "full_name": "slope_neg",
              "def_path": "Mathlib/LinearAlgebra/AffineSpace/Slope.lean",
              "def_pos": [
                96,
                15
              ],
              "def_end_pos": [
                96,
                24
              ]
            }
          ]
        ],
        "state_before": "case h.h\nk : Type u_1\nE : Type u_2\nPE : Type u_3\ninst\u271d\u00b3 : Field k\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module k E\ninst\u271d : AddTorsor E PE\nf : k \u2192 E\nx y : k\n\u22a2 slope (-f) x y = (-slope f) x y",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.849076809012331,
    "entry_failed": false
  },
  "24807": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/MetricSpace/Isometry.lean",
    "full_name": "Isometry.diam_range",
    "start": [
      224,
      1
    ],
    "end": [
      226,
      27
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 image_univ]",
        "annotated_tactic": [
          "rw [\u2190 <a>image_univ</a>]",
          [
            {
              "full_name": "Set.image_univ",
              "def_path": "Mathlib/Data/Set/Image.lean",
              "def_pos": [
                701,
                9
              ],
              "def_end_pos": [
                701,
                19
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Isometry f\n\u22a2 Metric.diam (range f) = Metric.diam univ",
        "state_after": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Isometry f\n\u22a2 Metric.diam (f '' univ) = Metric.diam univ"
      },
      {
        "tactic": "exact hf.diam_image univ",
        "annotated_tactic": [
          "exact hf.diam_image <a>univ</a>",
          [
            {
              "full_name": "Set.univ",
              "def_path": "Mathlib/Init/Set.lean",
              "def_pos": [
                153,
                5
              ],
              "def_end_pos": [
                153,
                9
              ]
            }
          ]
        ],
        "state_before": "\u03b9 : Type u_1\n\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Isometry f\n\u22a2 Metric.diam (f '' univ) = Metric.diam univ",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.2366076050093397,
    "entry_failed": false
  },
  "19676": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Int/Cast/Basic.lean",
    "full_name": "Int.cast_bit1",
    "start": [
      137,
      1
    ],
    "end": [
      138,
      56
    ],
    "traced_tactics": [
      {
        "tactic": "rw [bit1, Int.cast_add, Int.cast_one, cast_bit0]",
        "annotated_tactic": [
          "rw [<a>bit1</a>, <a>Int.cast_add</a>, <a>Int.cast_one</a>, <a>cast_bit0</a>]",
          [
            {
              "full_name": "bit1",
              "def_path": "Mathlib/Init/ZeroOne.lean",
              "def_pos": [
                41,
                5
              ],
              "def_end_pos": [
                41,
                9
              ]
            },
            {
              "full_name": "Int.cast_add",
              "def_path": "Mathlib/Data/Int/Cast/Basic.lean",
              "def_pos": [
                109,
                9
              ],
              "def_end_pos": [
                109,
                17
              ]
            },
            {
              "full_name": "Int.cast_one",
              "def_path": "Mathlib/Data/Int/Cast/Basic.lean",
              "def_pos": [
                79,
                9
              ],
              "def_end_pos": [
                79,
                17
              ]
            },
            {
              "full_name": "Int.cast_bit0",
              "def_path": "Mathlib/Data/Int/Cast/Basic.lean",
              "def_pos": [
                132,
                9
              ],
              "def_end_pos": [
                132,
                18
              ]
            }
          ]
        ],
        "state_before": "R : Type u\ninst\u271d : AddGroupWithOne R\nn : \u2124\n\u22a2 \u2191(bit1 n) = bit1 \u2191n",
        "state_after": "R : Type u\ninst\u271d : AddGroupWithOne R\nn : \u2124\n\u22a2 bit0 \u2191n + 1 = bit1 \u2191n"
      },
      {
        "tactic": "rfl",
        "annotated_tactic": [
          "rfl",
          []
        ],
        "state_before": "R : Type u\ninst\u271d : AddGroupWithOne R\nn : \u2124\n\u22a2 bit0 \u2191n + 1 = bit1 \u2191n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.4157360339304432,
    "entry_failed": false
  },
  "6756": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Order/LeftRightNhds.lean",
    "full_name": "countable_setOf_isolated_right",
    "start": [
      99,
      1
    ],
    "end": [
      102,
      75
    ],
    "traced_tactics": [
      {
        "tactic": "simp only [nhdsWithin_Ioi_eq_bot_iff, setOf_or]",
        "annotated_tactic": [
          "simp only [<a>nhdsWithin_Ioi_eq_bot_iff</a>, <a>setOf_or</a>]",
          [
            {
              "full_name": "nhdsWithin_Ioi_eq_bot_iff",
              "def_path": "Mathlib/Topology/Order/LeftRightNhds.lean",
              "def_pos": [
                82,
                9
              ],
              "def_end_pos": [
                82,
                34
              ]
            },
            {
              "full_name": "Set.setOf_or",
              "def_path": "Mathlib/Data/Set/Basic.lean",
              "def_pos": [
                281,
                9
              ],
              "def_end_pos": [
                281,
                17
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : SecondCountableTopology \u03b1\n\u22a2 {x | \ud835\udcdd[>] x = \u22a5}.Countable",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : SecondCountableTopology \u03b1\n\u22a2 ({a | IsTop a} \u222a {a | \u2203 b, a \u22d6 b}).Countable"
      },
      {
        "tactic": "exact (subsingleton_isTop \u03b1).countable.union countable_setOf_covBy_right",
        "annotated_tactic": [
          "exact (<a>subsingleton_isTop</a> \u03b1).countable.union <a>countable_setOf_covBy_right</a>",
          [
            {
              "full_name": "Set.subsingleton_isTop",
              "def_path": "Mathlib/Data/Set/Subsingleton.lean",
              "def_pos": [
                91,
                9
              ],
              "def_end_pos": [
                91,
                27
              ]
            },
            {
              "full_name": "countable_setOf_covBy_right",
              "def_path": "Mathlib/Topology/Order/Basic.lean",
              "def_pos": [
                555,
                9
              ],
              "def_end_pos": [
                555,
                36
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : SecondCountableTopology \u03b1\n\u22a2 ({a | IsTop a} \u222a {a | \u2203 b, a \u22d6 b}).Countable",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.4837856258964166,
    "entry_failed": false
  },
  "23897": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Complex.lean",
    "full_name": "Complex.cos_eq_one_iff",
    "start": [
      110,
      1
    ],
    "end": [
      112,
      43
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 cos_zero, eq_comm, cos_eq_cos_iff]",
        "annotated_tactic": [
          "rw [\u2190 <a>cos_zero</a>, <a>eq_comm</a>, <a>cos_eq_cos_iff</a>]",
          [
            {
              "full_name": "Complex.cos_zero",
              "def_path": "Mathlib/Data/Complex/Exponential.lean",
              "def_pos": [
                543,
                9
              ],
              "def_end_pos": [
                543,
                17
              ]
            },
            {
              "full_name": "eq_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                811,
                9
              ],
              "def_end_pos": [
                811,
                16
              ]
            },
            {
              "full_name": "Complex.cos_eq_cos_iff",
              "def_path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Complex.lean",
              "def_pos": [
                90,
                9
              ],
              "def_end_pos": [
                90,
                23
              ]
            }
          ]
        ],
        "state_before": "x : \u2102\n\u22a2 cos x = 1 \u2194 \u2203 k, \u2191k * (2 * \u2191\u03c0) = x",
        "state_after": "x : \u2102\n\u22a2 (\u2203 k, x = 2 * \u2191k * \u2191\u03c0 + 0 \u2228 x = 2 * \u2191k * \u2191\u03c0 - 0) \u2194 \u2203 k, \u2191k * (2 * \u2191\u03c0) = x"
      },
      {
        "tactic": "simp [mul_assoc, mul_left_comm, eq_comm]",
        "annotated_tactic": [
          "simp [<a>mul_assoc</a>, <a>mul_left_comm</a>, <a>eq_comm</a>]",
          [
            {
              "full_name": "mul_assoc",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                289,
                9
              ],
              "def_end_pos": [
                289,
                18
              ]
            },
            {
              "full_name": "mul_left_comm",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                184,
                9
              ],
              "def_end_pos": [
                184,
                22
              ]
            },
            {
              "full_name": "eq_comm",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                811,
                9
              ],
              "def_end_pos": [
                811,
                16
              ]
            }
          ]
        ],
        "state_before": "x : \u2102\n\u22a2 (\u2203 k, x = 2 * \u2191k * \u2191\u03c0 + 0 \u2228 x = 2 * \u2191k * \u2191\u03c0 - 0) \u2194 \u2203 k, \u2191k * (2 * \u2191\u03c0) = x",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.741992588038556,
    "entry_failed": false
  },
  "25918": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/SetTheory/Cardinal/Cofinality.lean",
    "full_name": "Ordinal.cof_lsub_le",
    "start": [
      303,
      1
    ],
    "end": [
      305,
      35
    ],
    "traced_tactics": [
      {
        "tactic": "rw [cof_eq_sInf_lsub]",
        "annotated_tactic": [
          "rw [<a>cof_eq_sInf_lsub</a>]",
          [
            {
              "full_name": "Ordinal.cof_eq_sInf_lsub",
              "def_path": "Mathlib/SetTheory/Cardinal/Cofinality.lean",
              "def_pos": [
                228,
                9
              ],
              "def_end_pos": [
                228,
                25
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{u}\n\u22a2 (lsub f).cof \u2264 #\u03b9",
        "state_after": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{u}\n\u22a2 sInf {a | \u2203 \u03b9_1 f_1, lsub f_1 = lsub f \u2227 #\u03b9_1 = a} \u2264 #\u03b9"
      },
      {
        "tactic": "exact csInf_le' \u27e8\u03b9, f, rfl, rfl\u27e9",
        "annotated_tactic": [
          "exact <a>csInf_le'</a> \u27e8\u03b9, f, <a>rfl</a>, <a>rfl</a>\u27e9",
          [
            {
              "full_name": "csInf_le'",
              "def_path": "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean",
              "def_pos": [
                1239,
                9
              ],
              "def_end_pos": [
                1239,
                18
              ]
            },
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            },
            {
              "full_name": "rfl",
              "def_path": ".lake/packages/lean4/src/lean/Init/Prelude.lean",
              "def_pos": [
                294,
                22
              ],
              "def_end_pos": [
                294,
                25
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u03b9 : Type u\nf : \u03b9 \u2192 Ordinal.{u}\n\u22a2 sInf {a | \u2203 \u03b9_1 f_1, lsub f_1 = lsub f \u2227 #\u03b9_1 = a} \u2264 #\u03b9",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.1113074839813635,
    "entry_failed": false
  },
  "13659": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Nilpotent.lean",
    "full_name": "lowerCentralSeries_nilpotencyClass",
    "start": [
      427,
      1
    ],
    "end": [
      430,
      63
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 lowerCentralSeries_length_eq_nilpotencyClass]",
        "annotated_tactic": [
          "rw [\u2190 <a>lowerCentralSeries_length_eq_nilpotencyClass</a>]",
          [
            {
              "full_name": "lowerCentralSeries_length_eq_nilpotencyClass",
              "def_path": "Mathlib/GroupTheory/Nilpotent.lean",
              "def_pos": [
                415,
                9
              ],
              "def_end_pos": [
                415,
                53
              ]
            }
          ]
        ],
        "state_before": "G : Type u_1\ninst\u271d\u00b9 : Group G\nH : Subgroup G\ninst\u271d : H.Normal\nhG : Group.IsNilpotent G\n\u22a2 lowerCentralSeries G (Group.nilpotencyClass G) = \u22a5",
        "state_after": "G : Type u_1\ninst\u271d\u00b9 : Group G\nH : Subgroup G\ninst\u271d : H.Normal\nhG : Group.IsNilpotent G\n\u22a2 lowerCentralSeries G (Nat.find \u22ef) = \u22a5"
      },
      {
        "tactic": "exact Nat.find_spec (nilpotent_iff_lowerCentralSeries.mp hG)",
        "annotated_tactic": [
          "exact <a>Nat.find_spec</a> (nilpotent_iff_lowerCentralSeries.mp hG)",
          [
            {
              "full_name": "Nat.find_spec",
              "def_path": "Mathlib/Init/Data/Nat/Lemmas.lean",
              "def_pos": [
                707,
                19
              ],
              "def_end_pos": [
                707,
                28
              ]
            }
          ]
        ],
        "state_before": "G : Type u_1\ninst\u271d\u00b9 : Group G\nH : Subgroup G\ninst\u271d : H.Normal\nhG : Group.IsNilpotent G\n\u22a2 lowerCentralSeries G (Nat.find \u22ef) = \u22a5",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.686972383060493,
    "entry_failed": false
  },
  "21809": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/NumberTheory/Dioph.lean",
    "full_name": "IsPoly.neg",
    "start": [
      85,
      1
    ],
    "end": [
      86,
      46
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 zero_sub]",
        "annotated_tactic": [
          "rw [\u2190 <a>zero_sub</a>]",
          [
            {
              "full_name": "zero_sub",
              "def_path": "Mathlib/Algebra/Group/Basic.lean",
              "def_pos": [
                467,
                3
              ],
              "def_end_pos": [
                467,
                14
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : (\u03b1 \u2192 \u2115) \u2192 \u2124\n\u22a2 IsPoly f \u2192 IsPoly (-f)",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : (\u03b1 \u2192 \u2115) \u2192 \u2124\n\u22a2 IsPoly f \u2192 IsPoly (0 - f)"
      },
      {
        "tactic": "exact (IsPoly.const 0).sub",
        "annotated_tactic": [
          "exact (<a>IsPoly.const</a> 0).<a>sub</a>",
          [
            {
              "full_name": "IsPoly.const",
              "def_path": "Mathlib/NumberTheory/Dioph.lean",
              "def_pos": [
                80,
                5
              ],
              "def_end_pos": [
                80,
                10
              ]
            },
            {
              "full_name": "IsPoly.sub",
              "def_path": "Mathlib/NumberTheory/Dioph.lean",
              "def_pos": [
                81,
                5
              ],
              "def_end_pos": [
                81,
                8
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : (\u03b1 \u2192 \u2115) \u2192 \u2124\n\u22a2 IsPoly f \u2192 IsPoly (0 - f)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.5389801510609686,
    "entry_failed": false
  },
  "23288": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/Heyting/Boundary.lean",
    "full_name": "Coheyting.boundary_inf",
    "start": [
      80,
      1
    ],
    "end": [
      82,
      67
    ],
    "traced_tactics": [
      {
        "tactic": "unfold boundary",
        "annotated_tactic": [
          "unfold <a>boundary</a>",
          [
            {
              "full_name": "Coheyting.boundary",
              "def_path": "Mathlib/Order/Heyting/Boundary.lean",
              "def_pos": [
                36,
                5
              ],
              "def_end_pos": [
                36,
                13
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : CoheytingAlgebra \u03b1\na\u271d b\u271d a b : \u03b1\n\u22a2 \u2202 (a \u2293 b) = \u2202 a \u2293 b \u2294 a \u2293 \u2202 b",
        "state_after": "\u03b1 : Type u_1\ninst\u271d : CoheytingAlgebra \u03b1\na\u271d b\u271d a b : \u03b1\n\u22a2 a \u2293 b \u2293 \uffe2(a \u2293 b) = a \u2293 \uffe2a \u2293 b \u2294 a \u2293 (b \u2293 \uffe2b)"
      },
      {
        "tactic": "rw [hnot_inf_distrib, inf_sup_left, inf_right_comm, \u2190 inf_assoc]",
        "annotated_tactic": [
          "rw [<a>hnot_inf_distrib</a>, <a>inf_sup_left</a>, <a>inf_right_comm</a>, \u2190 <a>inf_assoc</a>]",
          [
            {
              "full_name": "hnot_inf_distrib",
              "def_path": "Mathlib/Order/Heyting/Basic.lean",
              "def_pos": [
                940,
                9
              ],
              "def_end_pos": [
                940,
                25
              ]
            },
            {
              "full_name": "inf_sup_left",
              "def_path": "Mathlib/Order/Lattice.lean",
              "def_pos": [
                726,
                9
              ],
              "def_end_pos": [
                726,
                21
              ]
            },
            {
              "full_name": "inf_right_comm",
              "def_path": "Mathlib/Order/Lattice.lean",
              "def_pos": [
                485,
                9
              ],
              "def_end_pos": [
                485,
                23
              ]
            },
            {
              "full_name": "inf_assoc",
              "def_path": "Mathlib/Order/Lattice.lean",
              "def_pos": [
                466,
                9
              ],
              "def_end_pos": [
                466,
                18
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d : CoheytingAlgebra \u03b1\na\u271d b\u271d a b : \u03b1\n\u22a2 a \u2293 b \u2293 \uffe2(a \u2293 b) = a \u2293 \uffe2a \u2293 b \u2294 a \u2293 (b \u2293 \uffe2b)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.1793432630365714,
    "entry_failed": false
  },
  "26168": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Order/SuccPred/Limit.lean",
    "full_name": "Order.mem_range_pred_of_not_isPredLimit",
    "start": [
      382,
      1
    ],
    "end": [
      384,
      18
    ],
    "traced_tactics": [
      {
        "tactic": "cases' not_isPredLimit_iff.1 h with b hb",
        "annotated_tactic": [
          "cases' <a>not_isPredLimit_iff</a>.1 h with b hb",
          [
            {
              "full_name": "Order.not_isPredLimit_iff",
              "def_path": "Mathlib/Order/SuccPred/Limit.lean",
              "def_pos": [
                375,
                9
              ],
              "def_end_pos": [
                375,
                28
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PredOrder \u03b1\na b : \u03b1\nC : \u03b1 \u2192 Sort u_2\nh : \u00acIsPredLimit a\n\u22a2 a \u2208 range pred",
        "state_after": "case intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PredOrder \u03b1\na b\u271d : \u03b1\nC : \u03b1 \u2192 Sort u_2\nh : \u00acIsPredLimit a\nb : \u03b1\nhb : \u00acIsMin b \u2227 pred b = a\n\u22a2 a \u2208 range pred"
      },
      {
        "tactic": "exact \u27e8b, hb.2\u27e9",
        "annotated_tactic": [
          "exact \u27e8b, hb.2\u27e9",
          []
        ],
        "state_before": "case intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : PredOrder \u03b1\na b\u271d : \u03b1\nC : \u03b1 \u2192 Sort u_2\nh : \u00acIsPredLimit a\nb : \u03b1\nhb : \u00acIsMin b \u2227 pred b = a\n\u22a2 a \u2208 range pred",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.1080758860334754,
    "entry_failed": false
  },
  "24595": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Topology/Compactification/OnePoint.lean",
    "full_name": "OnePoint.isClosed_infty",
    "start": [
      287,
      1
    ],
    "end": [
      289,
      25
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 compl_range_coe, isClosed_compl_iff]",
        "annotated_tactic": [
          "rw [\u2190 <a>compl_range_coe</a>, <a>isClosed_compl_iff</a>]",
          [
            {
              "full_name": "OnePoint.compl_range_coe",
              "def_path": "Mathlib/Topology/Compactification/OnePoint.lean",
              "def_pos": [
                140,
                9
              ],
              "def_end_pos": [
                140,
                24
              ]
            },
            {
              "full_name": "isClosed_compl_iff",
              "def_path": "Mathlib/Topology/Basic.lean",
              "def_pos": [
                197,
                9
              ],
              "def_end_pos": [
                197,
                27
              ]
            }
          ]
        ],
        "state_before": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set (OnePoint X)\nt : Set X\n\u22a2 IsClosed {\u221e}",
        "state_after": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set (OnePoint X)\nt : Set X\n\u22a2 IsOpen (range some)"
      },
      {
        "tactic": "exact isOpen_range_coe",
        "annotated_tactic": [
          "exact <a>isOpen_range_coe</a>",
          [
            {
              "full_name": "OnePoint.isOpen_range_coe",
              "def_path": "Mathlib/Topology/Compactification/OnePoint.lean",
              "def_pos": [
                283,
                9
              ],
              "def_end_pos": [
                283,
                25
              ]
            }
          ]
        ],
        "state_before": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set (OnePoint X)\nt : Set X\n\u22a2 IsOpen (range some)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.366596645093523,
    "entry_failed": false
  },
  "27173": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/GroupTheory/Coxeter/Length.lean",
    "full_name": "CoxeterSystem.exists_word_with_prod",
    "start": [
      61,
      9
    ],
    "end": [
      63,
      18
    ],
    "traced_tactics": [
      {
        "tactic": "rcases cs.wordProd_surjective w with \u27e8\u03c9, rfl\u27e9",
        "annotated_tactic": [
          "rcases cs.wordProd_surjective w with \u27e8\u03c9, rfl\u27e9",
          []
        ],
        "state_before": "B : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\n\u22a2 \u2203 n \u03c9, \u03c9.length = n \u2227 cs.wordProd \u03c9 = w",
        "state_after": "case intro\nB : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\n\u03c9 : List B\n\u22a2 \u2203 n \u03c9_1, \u03c9_1.length = n \u2227 cs.wordProd \u03c9_1 = cs.wordProd \u03c9"
      },
      {
        "tactic": "use \u03c9.length, \u03c9",
        "annotated_tactic": [
          "use \u03c9.length, \u03c9",
          []
        ],
        "state_before": "case intro\nB : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\n\u03c9 : List B\n\u22a2 \u2203 n \u03c9_1, \u03c9_1.length = n \u2227 cs.wordProd \u03c9_1 = cs.wordProd \u03c9",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.5684197199298069,
    "entry_failed": false
  },
  "14445": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Nat/Choose/Basic.lean",
    "full_name": "Nat.factorial_mul_factorial_dvd_factorial",
    "start": [
      181,
      1
    ],
    "end": [
      182,
      90
    ],
    "traced_tactics": [
      {
        "tactic": "rw [\u2190 choose_mul_factorial_mul_factorial hk, Nat.mul_assoc]",
        "annotated_tactic": [
          "rw [\u2190 <a>choose_mul_factorial_mul_factorial</a> hk, <a>Nat.mul_assoc</a>]",
          [
            {
              "full_name": "Nat.choose_mul_factorial_mul_factorial",
              "def_path": "Mathlib/Data/Nat/Choose/Basic.lean",
              "def_pos": [
                125,
                9
              ],
              "def_end_pos": [
                125,
                43
              ]
            },
            {
              "full_name": "Nat.mul_assoc",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Basic.lean",
              "def_pos": [
                245,
                19
              ],
              "def_end_pos": [
                245,
                28
              ]
            }
          ]
        ],
        "state_before": "n k : \u2115\nhk : k \u2264 n\n\u22a2 k ! * (n - k)! \u2223 n !",
        "state_after": "n k : \u2115\nhk : k \u2264 n\n\u22a2 k ! * (n - k)! \u2223 n.choose k * (k ! * (n - k)!)"
      },
      {
        "tactic": "exact Nat.dvd_mul_left _ _",
        "annotated_tactic": [
          "exact <a>Nat.dvd_mul_left</a> _ _",
          [
            {
              "full_name": "Nat.dvd_mul_left",
              "def_path": ".lake/packages/lean4/src/lean/Init/Data/Nat/Dvd.lean",
              "def_pos": [
                16,
                19
              ],
              "def_end_pos": [
                16,
                31
              ]
            }
          ]
        ],
        "state_before": "n k : \u2115\nhk : k \u2264 n\n\u22a2 k ! * (n - k)! \u2223 n.choose k * (k ! * (n - k)!)",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.7636792779667303,
    "entry_failed": false
  },
  "26488": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/PNat/Prime.lean",
    "full_name": "PNat.Coprime.gcd_mul_right_cancel_right",
    "start": [
      238,
      1
    ],
    "end": [
      241,
      42
    ],
    "traced_tactics": [
      {
        "tactic": "rw [mul_comm]",
        "annotated_tactic": [
          "rw [<a>mul_comm</a>]",
          [
            {
              "full_name": "mul_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                332,
                9
              ],
              "def_end_pos": [
                332,
                17
              ]
            }
          ]
        ],
        "state_before": "m n k : \u2115+\n\u22a2 k.Coprime m \u2192 m.gcd (n * k) = m.gcd n",
        "state_after": "m n k : \u2115+\n\u22a2 k.Coprime m \u2192 m.gcd (k * n) = m.gcd n"
      },
      {
        "tactic": "apply Coprime.gcd_mul_left_cancel_right",
        "annotated_tactic": [
          "apply <a>Coprime.gcd_mul_left_cancel_right</a>",
          [
            {
              "full_name": "PNat.Coprime.gcd_mul_left_cancel_right",
              "def_path": "Mathlib/Data/PNat/Prime.lean",
              "def_pos": [
                232,
                9
              ],
              "def_end_pos": [
                232,
                42
              ]
            }
          ]
        ],
        "state_before": "m n k : \u2115+\n\u22a2 k.Coprime m \u2192 m.gcd (k * n) = m.gcd n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.857440223917365,
    "entry_failed": false
  },
  "13994": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Computability/Encoding.lean",
    "full_name": "Computability.Encoding.encode_injective",
    "start": [
      43,
      1
    ],
    "end": [
      45,
      47
    ],
    "traced_tactics": [
      {
        "tactic": "refine fun _ _ h => Option.some_injective _ ?_",
        "annotated_tactic": [
          "refine fun _ _ h => <a>Option.some_injective</a> _ ?_",
          [
            {
              "full_name": "Option.some_injective",
              "def_path": "Mathlib/Data/Option/Basic.lean",
              "def_pos": [
                77,
                9
              ],
              "def_end_pos": [
                77,
                23
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u\ne : Encoding \u03b1\n\u22a2 Function.Injective e.encode",
        "state_after": "\u03b1 : Type u\ne : Encoding \u03b1\nx\u271d\u00b9 x\u271d : \u03b1\nh : e.encode x\u271d\u00b9 = e.encode x\u271d\n\u22a2 some x\u271d\u00b9 = some x\u271d"
      },
      {
        "tactic": "rw [\u2190 e.decode_encode, \u2190 e.decode_encode, h]",
        "annotated_tactic": [
          "rw [\u2190 e.decode_encode, \u2190 e.decode_encode, h]",
          []
        ],
        "state_before": "\u03b1 : Type u\ne : Encoding \u03b1\nx\u271d\u00b9 x\u271d : \u03b1\nh : e.encode x\u271d\u00b9 = e.encode x\u271d\n\u22a2 some x\u271d\u00b9 = some x\u271d",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2358015349600464,
    "entry_failed": false
  },
  "3742": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/MvPowerSeries/Basic.lean",
    "full_name": "MvPowerSeries.coeff_add_mul_monomial",
    "start": [
      243,
      1
    ],
    "end": [
      246,
      27
    ],
    "traced_tactics": [
      {
        "tactic": "rw [coeff_mul_monomial, if_pos, add_tsub_cancel_right]",
        "annotated_tactic": [
          "rw [<a>coeff_mul_monomial</a>, <a>if_pos</a>, <a>add_tsub_cancel_right</a>]",
          [
            {
              "full_name": "MvPowerSeries.coeff_mul_monomial",
              "def_path": "Mathlib/RingTheory/MvPowerSeries/Basic.lean",
              "def_pos": [
                225,
                9
              ],
              "def_end_pos": [
                225,
                27
              ]
            },
            {
              "full_name": "if_pos",
              "def_path": ".lake/packages/lean4/src/lean/Init/Core.lean",
              "def_pos": [
                932,
                9
              ],
              "def_end_pos": [
                932,
                15
              ]
            },
            {
              "full_name": "add_tsub_cancel_right",
              "def_path": "Mathlib/Algebra/Order/Sub/Defs.lean",
              "def_pos": [
                356,
                9
              ],
              "def_end_pos": [
                356,
                30
              ]
            }
          ]
        ],
        "state_before": "\u03c3 : Type u_1\nR : Type u_2\ninst\u271d : Semiring R\nm n : \u03c3 \u2192\u2080 \u2115\n\u03c6 \u03c8 : MvPowerSeries \u03c3 R\na : R\n\u22a2 (coeff R (m + n)) (\u03c6 * (monomial R n) a) = (coeff R m) \u03c6 * a",
        "state_after": "case hc\n\u03c3 : Type u_1\nR : Type u_2\ninst\u271d : Semiring R\nm n : \u03c3 \u2192\u2080 \u2115\n\u03c6 \u03c8 : MvPowerSeries \u03c3 R\na : R\n\u22a2 n \u2264 m + n"
      },
      {
        "tactic": "exact le_add_left le_rfl",
        "annotated_tactic": [
          "exact <a>le_add_left</a> <a>le_rfl</a>",
          [
            {
              "full_name": "le_add_left",
              "def_path": "Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean",
              "def_pos": [
                256,
                3
              ],
              "def_end_pos": [
                256,
                14
              ]
            },
            {
              "full_name": "le_rfl",
              "def_path": "Mathlib/Init/Order/Defs.lean",
              "def_pos": [
                50,
                9
              ],
              "def_end_pos": [
                50,
                15
              ]
            }
          ]
        ],
        "state_before": "case hc\n\u03c3 : Type u_1\nR : Type u_2\ninst\u271d : Semiring R\nm n : \u03c3 \u2192\u2080 \u2115\n\u03c6 \u03c8 : MvPowerSeries \u03c3 R\na : R\n\u22a2 n \u2264 m + n",
        "state_after": "no goals"
      }
    ],
    "entry_time": 4.676029216963798,
    "entry_failed": false
  },
  "12477": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/RingTheory/Coprime/Basic.lean",
    "full_name": "IsCoprime.of_mul_right_right",
    "start": [
      154,
      1
    ],
    "end": [
      156,
      28
    ],
    "traced_tactics": [
      {
        "tactic": "rw [mul_comm] at H",
        "annotated_tactic": [
          "rw [<a>mul_comm</a>] at H",
          [
            {
              "full_name": "mul_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                332,
                9
              ],
              "def_end_pos": [
                332,
                17
              ]
            }
          ]
        ],
        "state_before": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nH : IsCoprime x (y * z)\n\u22a2 IsCoprime x z",
        "state_after": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nH : IsCoprime x (z * y)\n\u22a2 IsCoprime x z"
      },
      {
        "tactic": "exact H.of_mul_right_left",
        "annotated_tactic": [
          "exact H.of_mul_right_left",
          []
        ],
        "state_before": "R : Type u\ninst\u271d : CommSemiring R\nx y z : R\nH : IsCoprime x (z * y)\n\u22a2 IsCoprime x z",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.698821994010359,
    "entry_failed": false
  },
  "10710": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Int/Lemmas.lean",
    "full_name": "Int.natAbs_eq_iff_sq_eq",
    "start": [
      45,
      1
    ],
    "end": [
      47,
      34
    ],
    "traced_tactics": [
      {
        "tactic": "rw [sq, sq]",
        "annotated_tactic": [
          "rw [<a>sq</a>, <a>sq</a>]",
          [
            {
              "full_name": "sq",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                684,
                41
              ],
              "def_end_pos": [
                684,
                43
              ]
            },
            {
              "full_name": "sq",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                684,
                41
              ],
              "def_end_pos": [
                684,
                43
              ]
            }
          ]
        ],
        "state_before": "a\u271d b\u271d : \u2124\nn : \u2115\na b : \u2124\n\u22a2 a.natAbs = b.natAbs \u2194 a ^ 2 = b ^ 2",
        "state_after": "a\u271d b\u271d : \u2124\nn : \u2115\na b : \u2124\n\u22a2 a.natAbs = b.natAbs \u2194 a * a = b * b"
      },
      {
        "tactic": "exact natAbs_eq_iff_mul_self_eq",
        "annotated_tactic": [
          "exact <a>natAbs_eq_iff_mul_self_eq</a>",
          [
            {
              "full_name": "Int.natAbs_eq_iff_mul_self_eq",
              "def_path": "Mathlib/Data/Int/Order/Lemmas.lean",
              "def_pos": [
                28,
                9
              ],
              "def_end_pos": [
                28,
                34
              ]
            }
          ]
        ],
        "state_before": "a\u271d b\u271d : \u2124\nn : \u2115\na b : \u2124\n\u22a2 a.natAbs = b.natAbs \u2194 a * a = b * b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.2006472509820014,
    "entry_failed": false
  },
  "6536": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Group/Basic.lean",
    "full_name": "comp_mul_left",
    "start": [
      117,
      1
    ],
    "end": [
      119,
      19
    ],
    "traced_tactics": [
      {
        "tactic": "ext z",
        "annotated_tactic": [
          "ext z",
          []
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : Type u_3\nM : Type u_4\ninst\u271d : Semigroup \u03b1\nx y : \u03b1\n\u22a2 ((fun x_1 => x * x_1) \u2218 fun x => y * x) = fun x_1 => x * y * x_1",
        "state_after": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : Type u_3\nM : Type u_4\ninst\u271d : Semigroup \u03b1\nx y z : \u03b1\n\u22a2 ((fun x_1 => x * x_1) \u2218 fun x => y * x) z = x * y * z"
      },
      {
        "tactic": "simp [mul_assoc]",
        "annotated_tactic": [
          "simp [<a>mul_assoc</a>]",
          [
            {
              "full_name": "mul_assoc",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                289,
                9
              ],
              "def_end_pos": [
                289,
                18
              ]
            }
          ]
        ],
        "state_before": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nG : Type u_3\nM : Type u_4\ninst\u271d : Semigroup \u03b1\nx y z : \u03b1\n\u22a2 ((fun x_1 => x * x_1) \u2218 fun x => y * x) z = x * y * z",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.72923144698143,
    "entry_failed": false
  },
  "17099": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Tactic/Positivity/Basic.lean",
    "full_name": "Mathlib.Meta.Positivity.max_ne",
    "start": [
      98,
      1
    ],
    "end": [
      99,
      41
    ],
    "traced_tactics": [
      {
        "tactic": "rw [max_def]",
        "annotated_tactic": [
          "rw [<a>max_def</a>]",
          [
            {
              "full_name": "max_def",
              "def_path": "Mathlib/Init/Order/LinearOrder.lean",
              "def_pos": [
                29,
                9
              ],
              "def_end_pos": [
                29,
                16
              ]
            }
          ]
        ],
        "state_before": "R : Type u_1\ninst\u271d : LinearOrder R\na b c : R\nha : a \u2260 c\nhb : b \u2260 c\n\u22a2 max a b \u2260 c",
        "state_after": "R : Type u_1\ninst\u271d : LinearOrder R\na b c : R\nha : a \u2260 c\nhb : b \u2260 c\n\u22a2 (if a \u2264 b then b else a) \u2260 c"
      },
      {
        "tactic": "split_ifs <;> assumption",
        "annotated_tactic": [
          "split_ifs <;> assumption",
          []
        ],
        "state_before": "R : Type u_1\ninst\u271d : LinearOrder R\na b c : R\nha : a \u2260 c\nhb : b \u2260 c\n\u22a2 (if a \u2264 b then b else a) \u2260 c",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.4692302210023627,
    "entry_failed": false
  },
  "18375": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Algebra/Order/Sub/Defs.lean",
    "full_name": "tsub_add_eq_tsub_tsub_swap",
    "start": [
      271,
      1
    ],
    "end": [
      273,
      30
    ],
    "traced_tactics": [
      {
        "tactic": "rw [add_comm]",
        "annotated_tactic": [
          "rw [<a>add_comm</a>]",
          [
            {
              "full_name": "add_comm",
              "def_path": "Mathlib/Algebra/Group/Defs.lean",
              "def_pos": [
                331,
                3
              ],
              "def_end_pos": [
                331,
                14
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : AddCommSemigroup \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na\u271d b\u271d c\u271d d a b c : \u03b1\n\u22a2 a - (b + c) = a - c - b",
        "state_after": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : AddCommSemigroup \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na\u271d b\u271d c\u271d d a b c : \u03b1\n\u22a2 a - (c + b) = a - c - b"
      },
      {
        "tactic": "apply tsub_add_eq_tsub_tsub",
        "annotated_tactic": [
          "apply <a>tsub_add_eq_tsub_tsub</a>",
          [
            {
              "full_name": "tsub_add_eq_tsub_tsub",
              "def_path": "Mathlib/Algebra/Order/Sub/Defs.lean",
              "def_pos": [
                267,
                9
              ],
              "def_end_pos": [
                267,
                30
              ]
            }
          ]
        ],
        "state_before": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : AddCommSemigroup \u03b1\ninst\u271d\u00b9 : Sub \u03b1\ninst\u271d : OrderedSub \u03b1\na\u271d b\u271d c\u271d d a b c : \u03b1\n\u22a2 a - (c + b) = a - c - b",
        "state_after": "no goals"
      }
    ],
    "entry_time": 1.732051811995916,
    "entry_failed": false
  },
  "23850": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/Real/GoldenRatio.lean",
    "full_name": "gold_add_goldConj",
    "start": [
      70,
      1
    ],
    "end": [
      72,
      7
    ],
    "traced_tactics": [
      {
        "tactic": "rw [goldenRatio, goldenConj]",
        "annotated_tactic": [
          "rw [<a>goldenRatio</a>, <a>goldenConj</a>]",
          [
            {
              "full_name": "goldenRatio",
              "def_path": "Mathlib/Data/Real/GoldenRatio.lean",
              "def_pos": [
                32,
                8
              ],
              "def_end_pos": [
                32,
                19
              ]
            },
            {
              "full_name": "goldenConj",
              "def_path": "Mathlib/Data/Real/GoldenRatio.lean",
              "def_pos": [
                36,
                8
              ],
              "def_end_pos": [
                36,
                18
              ]
            }
          ]
        ],
        "state_before": "\u22a2 \u03c6 + \u03c8 = 1",
        "state_after": "\u22a2 (1 + \u221a5) / 2 + (1 - \u221a5) / 2 = 1"
      },
      {
        "tactic": "ring",
        "annotated_tactic": [
          "ring",
          []
        ],
        "state_before": "\u22a2 (1 + \u221a5) / 2 + (1 - \u221a5) / 2 = 1",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.6032042029546574,
    "entry_failed": false
  },
  "22399": {
    "url": "https://github.com/leanprover-community/mathlib4",
    "commit": "29dcec074de168ac2bf835a77ef68bbe069194c5",
    "file_path": "Mathlib/Data/List/Chain.lean",
    "full_name": "List.Chain'.infix",
    "start": [
      303,
      1
    ],
    "end": [
      305,
      41
    ],
    "traced_tactics": [
      {
        "tactic": "rcases h' with \u27e8l\u2082, l\u2083, rfl\u27e9",
        "annotated_tactic": [
          "rcases h' with \u27e8l\u2082, l\u2083, rfl\u27e9",
          []
        ],
        "state_before": "\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl l\u2081 l\u2082 : List \u03b1\na b : \u03b1\nh : Chain' R l\nh' : l\u2081 <:+: l\n\u22a2 Chain' R l\u2081",
        "state_after": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl\u2081 l\u2082\u271d : List \u03b1\na b : \u03b1\nl\u2082 l\u2083 : List \u03b1\nh : Chain' R (l\u2082 ++ l\u2081 ++ l\u2083)\n\u22a2 Chain' R l\u2081"
      },
      {
        "tactic": "exact h.left_of_append.right_of_append",
        "annotated_tactic": [
          "exact h.left_of_append.right_of_append",
          []
        ],
        "state_before": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\nR r : \u03b1 \u2192 \u03b1 \u2192 Prop\nl\u2081 l\u2082\u271d : List \u03b1\na b : \u03b1\nl\u2082 l\u2083 : List \u03b1\nh : Chain' R (l\u2082 ++ l\u2081 ++ l\u2083)\n\u22a2 Chain' R l\u2081",
        "state_after": "no goals"
      }
    ],
    "entry_time": 2.8021007800707594,
    "entry_failed": false
  }
}