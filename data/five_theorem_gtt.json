{
  "https___github.com_leanprover-community_mathlib4@29dcec074de168ac2bf835a77ef68bbe069194c5:Mathlib_RingTheory_Ideal_Basic.lean:Ideal.isCompactElement_top": [
    0,
    "simpa only [\u2190 span_singleton_one] using Submodule.singleton_span_isCompactElement 1",
    [
      "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : Semiring \u03b1\nI : Ideal \u03b1\na b : \u03b1\n\u22a2 CompleteLattice.IsCompactElement \u22a4",
      "no goals"
    ]
  ],
  "https___github.com_leanprover-community_mathlib4@29dcec074de168ac2bf835a77ef68bbe069194c5:Mathlib_Algebra_Order_Monoid_NatCast.lean:zero_le_four": [
    0,
    "rw [\u2190 three_add_one_eq_four]\n<tactic_delimiter>\nexact add_nonneg zero_le_three zero_le_one",
    [
      "\u03b1 : Type u_1\ninst\u271d\u00b3 : AddMonoidWithOne \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : ZeroLEOneClass \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\n\u22a2 0 \u2264 4",
      "\u03b1 : Type u_1\ninst\u271d\u00b3 : AddMonoidWithOne \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : ZeroLEOneClass \u03b1\ninst\u271d : CovariantClass \u03b1 \u03b1 (fun x x_1 => x + x_1) fun x x_1 => x \u2264 x_1\n\u22a2 0 \u2264 3 + 1",
      "no goals"
    ]
  ],
  "https___github.com_leanprover-community_mathlib4@29dcec074de168ac2bf835a77ef68bbe069194c5:Mathlib_Algebra_Ring_Parity.lean:Even.sub_odd": [
    0,
    "rw [sub_eq_add_neg]\n<tactic_delimiter>\nexact ha.add_odd hb.neg",
    [
      "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d : Ring \u03b1\na b : \u03b1\nn : \u2115\nha : Even a\nhb : Odd b\n\u22a2 Odd (a - b)",
      "F : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nR : Type u_4\ninst\u271d : Ring \u03b1\na b : \u03b1\nn : \u2115\nha : Even a\nhb : Odd b\n\u22a2 Odd (a + -b)",
      "no goals"
    ]
  ],
  "https___github.com_leanprover-community_mathlib4@29dcec074de168ac2bf835a77ef68bbe069194c5:Mathlib_Combinatorics_SimpleGraph_Basic.lean:SimpleGraph.commonNeighbors_top_eq": [
    0,
    "ext u\n<tactic_delimiter>\nsimp [commonNeighbors, eq_comm, not_or]",
    [
      "\u03b9 : Sort u_1\nV : Type u\nG : SimpleGraph V\na b c u v\u271d w\u271d : V\ne : Sym2 V\nv w : V\n\u22a2 \u22a4.commonNeighbors v w = Set.univ \\ {v, w}",
      "case h\n\u03b9 : Sort u_1\nV : Type u\nG : SimpleGraph V\na b c u\u271d v\u271d w\u271d : V\ne : Sym2 V\nv w u : V\n\u22a2 u \u2208 \u22a4.commonNeighbors v w \u2194 u \u2208 Set.univ \\ {v, w}",
      "no goals"
    ]
  ],
  "https___github.com_leanprover-community_mathlib4@29dcec074de168ac2bf835a77ef68bbe069194c5:Mathlib_Data_List_Sigma.lean:List.lookupAll_length_le_one": [
    0,
    "have := Nodup.sublist ((lookupAll_sublist a l).map _) h\n<tactic_delimiter>\nrw [map_map] at this\n<tactic_delimiter>\nrwa [\u2190 nodup_replicate, \u2190 map_const]",
    [
      "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\nl\u271d l\u2081 l\u2082 : List (Sigma \u03b2)\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List (Sigma \u03b2)\nh : l.NodupKeys\n\u22a2 (lookupAll a l).length \u2264 1",
      "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\nl\u271d l\u2081 l\u2082 : List (Sigma \u03b2)\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List (Sigma \u03b2)\nh : l.NodupKeys\nthis : (map Sigma.fst (map (Sigma.mk a) (lookupAll a l))).Nodup\n\u22a2 (lookupAll a l).length \u2264 1",
      "\u03b1 : Type u\n\u03b2 : \u03b1 \u2192 Type v\nl\u271d l\u2081 l\u2082 : List (Sigma \u03b2)\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nl : List (Sigma \u03b2)\nh : l.NodupKeys\nthis : (map (Sigma.fst \u2218 Sigma.mk a) (lookupAll a l)).Nodup\n\u22a2 (lookupAll a l).length \u2264 1",
      "no goals"
    ]
  ]
}